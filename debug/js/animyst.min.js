/*! animyst 2015-10-30 */
"use strict";

var dat = dat || {};

dat.gui = dat.gui || {}, dat.utils = dat.utils || {}, dat.controllers = dat.controllers || {}, 
dat.dom = dat.dom || {}, dat.color = dat.color || {}, dat.utils.css = function() {
    return {
        load: function(a, b) {
            b = b || document;
            var c = b.createElement("link");
            c.type = "text/css", c.rel = "stylesheet", c.href = a, b.getElementsByTagName("head")[0].appendChild(c);
        },
        inject: function(a, b) {
            b = b || document;
            var c = document.createElement("style");
            c.type = "text/css", c.innerHTML = a, b.getElementsByTagName("head")[0].appendChild(c);
        }
    };
}(), dat.utils.common = function() {
    var a = Array.prototype.forEach, b = Array.prototype.slice;
    return {
        BREAK: {},
        extend: function(a) {
            return this.each(b.call(arguments, 1), function(b) {
                for (var c in b) this.isUndefined(b[c]) || (a[c] = b[c]);
            }, this), a;
        },
        defaults: function(a) {
            return this.each(b.call(arguments, 1), function(b) {
                for (var c in b) this.isUndefined(a[c]) && (a[c] = b[c]);
            }, this), a;
        },
        compose: function() {
            var a = b.call(arguments);
            return function() {
                for (var c = b.call(arguments), d = a.length - 1; d >= 0; d--) c = [ a[d].apply(this, c) ];
                return c[0];
            };
        },
        each: function(b, c, d) {
            if (a && b.forEach === a) b.forEach(c, d); else if (b.length === b.length + 0) for (var e = 0, f = b.length; f > e && !(e in b && c.call(d, b[e], e) === this.BREAK); e++) ; else for (e in b) if (c.call(d, b[e], e) === this.BREAK) break;
        },
        defer: function(a) {
            setTimeout(a, 0);
        },
        toArray: function(a) {
            return a.toArray ? a.toArray() : b.call(a);
        },
        isUndefined: function(a) {
            return void 0 === a;
        },
        isNull: function(a) {
            return null === a;
        },
        isNaN: function(a) {
            return a !== a;
        },
        isArray: Array.isArray || function(a) {
            return a.constructor === Array;
        },
        isObject: function(a) {
            return a === Object(a);
        },
        isNumber: function(a) {
            return a === a + 0;
        },
        isString: function(a) {
            return a === a + "";
        },
        isBoolean: function(a) {
            return !1 === a || !0 === a;
        },
        isFunction: function(a) {
            return "[object Function]" === Object.prototype.toString.call(a);
        }
    };
}(), dat.controllers.Controller = function(a) {
    var b = function(a, b) {
        this.initialValue = a[b], this.domElement = document.createElement("div"), this.object = a, 
        this.property = b, this.__onFinishChange = this.__onChange = void 0;
    };
    return a.extend(b.prototype, {
        onChange: function(a) {
            return this.__onChange = a, this;
        },
        onFinishChange: function(a) {
            return this.__onFinishChange = a, this;
        },
        setValue: function(a) {
            return this.object[this.property] = a, this.__onChange && this.__onChange.call(this, a), 
            this.updateDisplay(), this;
        },
        getValue: function() {
            return this.object[this.property];
        },
        updateDisplay: function() {
            return this;
        },
        isModified: function() {
            return this.initialValue !== this.getValue();
        }
    }), b;
}(dat.utils.common), dat.dom.dom = function(a) {
    function b(b) {
        return "0" === b || a.isUndefined(b) ? 0 : (b = b.match(d), a.isNull(b) ? 0 : parseFloat(b[1]));
    }
    var c = {};
    a.each({
        HTMLEvents: [ "change" ],
        MouseEvents: [ "click", "mousemove", "mousedown", "mouseup", "mouseover" ],
        KeyboardEvents: [ "keydown" ]
    }, function(b, d) {
        a.each(b, function(a) {
            c[a] = d;
        });
    });
    var d = /(\d+(\.\d+)?)px/, e = {
        makeSelectable: function(a, b) {
            void 0 !== a && void 0 !== a.style && (a.onselectstart = b ? function() {
                return !1;
            } : function() {}, a.style.MozUserSelect = b ? "auto" : "none", a.style.KhtmlUserSelect = b ? "auto" : "none", 
            a.unselectable = b ? "on" : "off");
        },
        makeFullscreen: function(b, c, d) {
            a.isUndefined(c) && (c = !0), a.isUndefined(d) && (d = !0), b.style.position = "absolute", 
            c && (b.style.left = 0, b.style.right = 0), d && (b.style.top = 0, b.style.bottom = 0);
        },
        fakeEvent: function(b, d, e, f) {
            e = e || {};
            var g = c[d];
            if (!g) throw Error("Event type " + d + " not supported.");
            var h = document.createEvent(g);
            switch (g) {
              case "MouseEvents":
                h.initMouseEvent(d, e.bubbles || !1, e.cancelable || !0, window, e.clickCount || 1, 0, 0, e.x || e.clientX || 0, e.y || e.clientY || 0, !1, !1, !1, !1, 0, null);
                break;

              case "KeyboardEvents":
                g = h.initKeyboardEvent || h.initKeyEvent, a.defaults(e, {
                    cancelable: !0,
                    ctrlKey: !1,
                    altKey: !1,
                    shiftKey: !1,
                    metaKey: !1,
                    keyCode: void 0,
                    charCode: void 0
                }), g(d, e.bubbles || !1, e.cancelable, window, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.keyCode, e.charCode);
                break;

              default:
                h.initEvent(d, e.bubbles || !1, e.cancelable || !0);
            }
            a.defaults(h, f), b.dispatchEvent(h);
        },
        bind: function(a, b, c, d) {
            return a.addEventListener ? a.addEventListener(b, c, d || !1) : a.attachEvent && a.attachEvent("on" + b, c), 
            e;
        },
        unbind: function(a, b, c, d) {
            return a.removeEventListener ? a.removeEventListener(b, c, d || !1) : a.detachEvent && a.detachEvent("on" + b, c), 
            e;
        },
        addClass: function(a, b) {
            if (void 0 === a.className) a.className = b; else if (a.className !== b) {
                var c = a.className.split(/ +/);
                -1 == c.indexOf(b) && (c.push(b), a.className = c.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
            }
            return e;
        },
        removeClass: function(a, b) {
            if (b) {
                if (void 0 !== a.className) if (a.className === b) a.removeAttribute("class"); else {
                    var c = a.className.split(/ +/), d = c.indexOf(b);
                    -1 != d && (c.splice(d, 1), a.className = c.join(" "));
                }
            } else a.className = void 0;
            return e;
        },
        hasClass: function(a, b) {
            return RegExp("(?:^|\\s+)" + b + "(?:\\s+|$)").test(a.className) || !1;
        },
        getWidth: function(a) {
            return a = getComputedStyle(a), b(a["border-left-width"]) + b(a["border-right-width"]) + b(a["padding-left"]) + b(a["padding-right"]) + b(a.width);
        },
        getHeight: function(a) {
            return a = getComputedStyle(a), b(a["border-top-width"]) + b(a["border-bottom-width"]) + b(a["padding-top"]) + b(a["padding-bottom"]) + b(a.height);
        },
        getOffset: function(a) {
            var b = {
                left: 0,
                top: 0
            };
            if (a.offsetParent) do b.left += a.offsetLeft, b.top += a.offsetTop; while (a = a.offsetParent);
            return b;
        },
        isActive: function(a) {
            return a === document.activeElement && (a.type || a.href);
        }
    };
    return e;
}(dat.utils.common), dat.controllers.OptionController = function(a, b, c) {
    var d = function(a, e, f) {
        d.superclass.call(this, a, e);
        var g = this;
        if (this.__select = document.createElement("select"), c.isArray(f)) {
            var h = {};
            c.each(f, function(a) {
                h[a] = a;
            }), f = h;
        }
        c.each(f, function(a, b) {
            var c = document.createElement("option");
            c.innerHTML = b, c.setAttribute("value", a), g.__select.appendChild(c);
        }), this.updateDisplay(), b.bind(this.__select, "change", function() {
            g.setValue(this.options[this.selectedIndex].value);
        }), this.domElement.appendChild(this.__select);
    };
    return d.superclass = a, c.extend(d.prototype, a.prototype, {
        setValue: function(a) {
            return a = d.superclass.prototype.setValue.call(this, a), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), 
            a;
        },
        updateDisplay: function() {
            return this.__select.value = this.getValue(), d.superclass.prototype.updateDisplay.call(this);
        }
    }), d;
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.NumberController = function(a, b) {
    var c = function(a, d, e) {
        c.superclass.call(this, a, d), e = e || {}, this.__min = e.min, this.__max = e.max, 
        this.__step = e.step, b.isUndefined(this.__step) ? this.__impliedStep = 0 == this.initialValue ? 1 : Math.pow(10, Math.floor(Math.log(this.initialValue) / Math.LN10)) / 10 : this.__impliedStep = this.__step, 
        a = this.__impliedStep, a = a.toString(), a = -1 < a.indexOf(".") ? a.length - a.indexOf(".") - 1 : 0, 
        this.__precision = a;
    };
    return c.superclass = a, b.extend(c.prototype, a.prototype, {
        setValue: function(a) {
            return void 0 !== this.__min && a < this.__min ? a = this.__min : void 0 !== this.__max && a > this.__max && (a = this.__max), 
            void 0 !== this.__step && 0 != a % this.__step && (a = Math.round(a / this.__step) * this.__step), 
            c.superclass.prototype.setValue.call(this, a);
        },
        min: function(a) {
            return this.__min = a, this;
        },
        max: function(a) {
            return this.__max = a, this;
        },
        step: function(a) {
            return this.__step = a, this;
        }
    }), c;
}(dat.controllers.Controller, dat.utils.common), dat.controllers.NumberControllerBox = function(a, b, c) {
    var d = function(a, e, f) {
        function g() {
            var a = parseFloat(k.__input.value);
            c.isNaN(a) || k.setValue(a);
        }
        function h(a) {
            var b = j - a.clientY;
            k.setValue(k.getValue() + b * k.__impliedStep), j = a.clientY;
        }
        function i() {
            b.unbind(window, "mousemove", h), b.unbind(window, "mouseup", i);
        }
        this.__truncationSuspended = !1, d.superclass.call(this, a, e, f);
        var j, k = this;
        this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), 
        b.bind(this.__input, "change", g), b.bind(this.__input, "blur", function() {
            g(), k.__onFinishChange && k.__onFinishChange.call(k, k.getValue());
        }), b.bind(this.__input, "mousedown", function(a) {
            b.bind(window, "mousemove", h), b.bind(window, "mouseup", i), j = a.clientY;
        }), b.bind(this.__input, "keydown", function(a) {
            13 === a.keyCode && (k.__truncationSuspended = !0, this.blur(), k.__truncationSuspended = !1);
        }), this.updateDisplay(), this.domElement.appendChild(this.__input);
    };
    return d.superclass = a, c.extend(d.prototype, a.prototype, {
        updateDisplay: function() {
            var a, b = this.__input;
            if (this.__truncationSuspended) a = this.getValue(); else {
                a = this.getValue();
                var c = Math.pow(10, this.__precision);
                a = Math.round(a * c) / c;
            }
            return b.value = a, d.superclass.prototype.updateDisplay.call(this);
        }
    }), d;
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.common), dat.controllers.NumberControllerSlider = function(a, b, c, d, e) {
    function f(a, b, c, d, e) {
        return d + (a - b) / (c - b) * (e - d);
    }
    var g = function(a, c, d, e, h) {
        function i(a) {
            a.preventDefault();
            var c = b.getOffset(k.__background), d = b.getWidth(k.__background);
            return k.setValue(f(a.clientX, c.left, c.left + d, k.__min, k.__max)), !1;
        }
        function j() {
            b.unbind(window, "mousemove", i), b.unbind(window, "mouseup", j), k.__onFinishChange && k.__onFinishChange.call(k, k.getValue());
        }
        g.superclass.call(this, a, c, {
            min: d,
            max: e,
            step: h
        });
        var k = this;
        this.__background = document.createElement("div"), this.__foreground = document.createElement("div"), 
        b.bind(this.__background, "mousedown", function(a) {
            b.bind(window, "mousemove", i), b.bind(window, "mouseup", j), i(a);
        }), b.addClass(this.__background, "slider"), b.addClass(this.__foreground, "slider-fg"), 
        this.updateDisplay(), this.__background.appendChild(this.__foreground), this.domElement.appendChild(this.__background);
    };
    return g.superclass = a, g.useDefaultStyles = function() {
        c.inject(e);
    }, d.extend(g.prototype, a.prototype, {
        updateDisplay: function() {
            var a = (this.getValue() - this.__min) / (this.__max - this.__min);
            return this.__foreground.style.width = 100 * a + "%", g.superclass.prototype.updateDisplay.call(this);
        }
    }), g;
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.css, dat.utils.common, "/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}"), 
dat.controllers.FunctionController = function(a, b, c) {
    var d = function(a, c, e) {
        d.superclass.call(this, a, c);
        var f = this;
        this.__button = document.createElement("div"), this.__button.innerHTML = void 0 === e ? "Fire" : e, 
        b.bind(this.__button, "click", function(a) {
            return a.preventDefault(), f.fire(), !1;
        }), b.addClass(this.__button, "button"), this.domElement.appendChild(this.__button);
    };
    return d.superclass = a, c.extend(d.prototype, a.prototype, {
        fire: function() {
            this.__onChange && this.__onChange.call(this), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), 
            this.getValue().call(this.object);
        }
    }), d;
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.BooleanController = function(a, b, c) {
    var d = function(a, c) {
        d.superclass.call(this, a, c);
        var e = this;
        this.__prev = this.getValue(), this.__checkbox = document.createElement("input"), 
        this.__checkbox.setAttribute("type", "checkbox"), b.bind(this.__checkbox, "change", function() {
            e.setValue(!e.__prev);
        }, !1), this.domElement.appendChild(this.__checkbox), this.updateDisplay();
    };
    return d.superclass = a, c.extend(d.prototype, a.prototype, {
        setValue: function(a) {
            return a = d.superclass.prototype.setValue.call(this, a), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), 
            this.__prev = this.getValue(), a;
        },
        updateDisplay: function() {
            return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), 
            this.__checkbox.checked = !0) : this.__checkbox.checked = !1, d.superclass.prototype.updateDisplay.call(this);
        }
    }), d;
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.color.toString = function(a) {
    return function(b) {
        if (1 == b.a || a.isUndefined(b.a)) {
            for (b = b.hex.toString(16); 6 > b.length; ) b = "0" + b;
            return "#" + b;
        }
        return "rgba(" + Math.round(b.r) + "," + Math.round(b.g) + "," + Math.round(b.b) + "," + b.a + ")";
    };
}(dat.utils.common), dat.color.interpret = function(a, b) {
    var c, d, e = [ {
        litmus: b.isString,
        conversions: {
            THREE_CHAR_HEX: {
                read: function(a) {
                    return a = a.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i), null === a ? !1 : {
                        space: "HEX",
                        hex: parseInt("0x" + a[1].toString() + a[1].toString() + a[2].toString() + a[2].toString() + a[3].toString() + a[3].toString())
                    };
                },
                write: a
            },
            SIX_CHAR_HEX: {
                read: function(a) {
                    return a = a.match(/^#([A-F0-9]{6})$/i), null === a ? !1 : {
                        space: "HEX",
                        hex: parseInt("0x" + a[1].toString())
                    };
                },
                write: a
            },
            CSS_RGB: {
                read: function(a) {
                    return a = a.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/), null === a ? !1 : {
                        space: "RGB",
                        r: parseFloat(a[1]),
                        g: parseFloat(a[2]),
                        b: parseFloat(a[3])
                    };
                },
                write: a
            },
            CSS_RGBA: {
                read: function(a) {
                    return a = a.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/), null === a ? !1 : {
                        space: "RGB",
                        r: parseFloat(a[1]),
                        g: parseFloat(a[2]),
                        b: parseFloat(a[3]),
                        a: parseFloat(a[4])
                    };
                },
                write: a
            }
        }
    }, {
        litmus: b.isNumber,
        conversions: {
            HEX: {
                read: function(a) {
                    return {
                        space: "HEX",
                        hex: a,
                        conversionName: "HEX"
                    };
                },
                write: function(a) {
                    return a.hex;
                }
            }
        }
    }, {
        litmus: b.isArray,
        conversions: {
            RGB_ARRAY: {
                read: function(a) {
                    return 3 != a.length ? !1 : {
                        space: "RGB",
                        r: a[0],
                        g: a[1],
                        b: a[2]
                    };
                },
                write: function(a) {
                    return [ a.r, a.g, a.b ];
                }
            },
            RGBA_ARRAY: {
                read: function(a) {
                    return 4 != a.length ? !1 : {
                        space: "RGB",
                        r: a[0],
                        g: a[1],
                        b: a[2],
                        a: a[3]
                    };
                },
                write: function(a) {
                    return [ a.r, a.g, a.b, a.a ];
                }
            }
        }
    }, {
        litmus: b.isObject,
        conversions: {
            RGBA_OBJ: {
                read: function(a) {
                    return b.isNumber(a.r) && b.isNumber(a.g) && b.isNumber(a.b) && b.isNumber(a.a) ? {
                        space: "RGB",
                        r: a.r,
                        g: a.g,
                        b: a.b,
                        a: a.a
                    } : !1;
                },
                write: function(a) {
                    return {
                        r: a.r,
                        g: a.g,
                        b: a.b,
                        a: a.a
                    };
                }
            },
            RGB_OBJ: {
                read: function(a) {
                    return b.isNumber(a.r) && b.isNumber(a.g) && b.isNumber(a.b) ? {
                        space: "RGB",
                        r: a.r,
                        g: a.g,
                        b: a.b
                    } : !1;
                },
                write: function(a) {
                    return {
                        r: a.r,
                        g: a.g,
                        b: a.b
                    };
                }
            },
            HSVA_OBJ: {
                read: function(a) {
                    return b.isNumber(a.h) && b.isNumber(a.s) && b.isNumber(a.v) && b.isNumber(a.a) ? {
                        space: "HSV",
                        h: a.h,
                        s: a.s,
                        v: a.v,
                        a: a.a
                    } : !1;
                },
                write: function(a) {
                    return {
                        h: a.h,
                        s: a.s,
                        v: a.v,
                        a: a.a
                    };
                }
            },
            HSV_OBJ: {
                read: function(a) {
                    return b.isNumber(a.h) && b.isNumber(a.s) && b.isNumber(a.v) ? {
                        space: "HSV",
                        h: a.h,
                        s: a.s,
                        v: a.v
                    } : !1;
                },
                write: function(a) {
                    return {
                        h: a.h,
                        s: a.s,
                        v: a.v
                    };
                }
            }
        }
    } ];
    return function() {
        d = !1;
        var a = 1 < arguments.length ? b.toArray(arguments) : arguments[0];
        return b.each(e, function(e) {
            return e.litmus(a) ? (b.each(e.conversions, function(e, f) {
                return c = e.read(a), !1 === d && !1 !== c ? (d = c, c.conversionName = f, c.conversion = e, 
                b.BREAK) : void 0;
            }), b.BREAK) : void 0;
        }), d;
    };
}(dat.color.toString, dat.utils.common), dat.GUI = dat.gui.GUI = function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
    function p(a, b, c, f) {
        if (void 0 === b[c]) throw Error("Object " + b + ' has no property "' + c + '"');
        f.color ? b = new k(b, c) : (b = [ b, c ].concat(f.factoryArgs), b = d.apply(a, b)), 
        f.before instanceof e && (f.before = f.before.__li), s(a, b), n.addClass(b.domElement, "c"), 
        c = document.createElement("span"), n.addClass(c, "property-name"), c.innerHTML = b.property;
        var g = document.createElement("div");
        return g.appendChild(c), g.appendChild(b.domElement), f = q(a, g, f.before), n.addClass(f, I.CLASS_CONTROLLER_ROW), 
        n.addClass(f, typeof b.getValue()), r(a, f, b), a.__controllers.push(b), b;
    }
    function q(a, b, c) {
        var d = document.createElement("li");
        return b && d.appendChild(b), c ? a.__ul.insertBefore(d, params.before) : a.__ul.appendChild(d), 
        a.onResize(), d;
    }
    function r(a, b, c) {
        if (c.__li = b, c.__gui = a, o.extend(c, {
            options: function(b) {
                return 1 < arguments.length ? (c.remove(), p(a, c.object, c.property, {
                    before: c.__li.nextElementSibling,
                    factoryArgs: [ o.toArray(arguments) ]
                })) : o.isArray(b) || o.isObject(b) ? (c.remove(), p(a, c.object, c.property, {
                    before: c.__li.nextElementSibling,
                    factoryArgs: [ b ]
                })) : void 0;
            },
            name: function(a) {
                return c.__li.firstElementChild.firstElementChild.innerHTML = a, c;
            },
            listen: function() {
                return c.__gui.listen(c), c;
            },
            remove: function() {
                return c.__gui.remove(c), c;
            }
        }), c instanceof i) {
            var d = new h(c.object, c.property, {
                min: c.__min,
                max: c.__max,
                step: c.__step
            });
            o.each([ "updateDisplay", "onChange", "onFinishChange" ], function(a) {
                var b = c[a], e = d[a];
                c[a] = d[a] = function() {
                    var a = Array.prototype.slice.call(arguments);
                    return b.apply(c, a), e.apply(d, a);
                };
            }), n.addClass(b, "has-slider"), c.domElement.insertBefore(d.domElement, c.domElement.firstElementChild);
        } else if (c instanceof h) {
            var e = function(b) {
                return o.isNumber(c.__min) && o.isNumber(c.__max) ? (c.remove(), p(a, c.object, c.property, {
                    before: c.__li.nextElementSibling,
                    factoryArgs: [ c.__min, c.__max, c.__step ]
                })) : b;
            };
            c.min = o.compose(e, c.min), c.max = o.compose(e, c.max);
        } else c instanceof f ? (n.bind(b, "click", function() {
            n.fakeEvent(c.__checkbox, "click");
        }), n.bind(c.__checkbox, "click", function(a) {
            a.stopPropagation();
        })) : c instanceof g ? (n.bind(b, "click", function() {
            n.fakeEvent(c.__button, "click");
        }), n.bind(b, "mouseover", function() {
            n.addClass(c.__button, "hover");
        }), n.bind(b, "mouseout", function() {
            n.removeClass(c.__button, "hover");
        })) : c instanceof k && (n.addClass(b, "color"), c.updateDisplay = o.compose(function(a) {
            return b.style.borderLeftColor = c.__color.toString(), a;
        }, c.updateDisplay), c.updateDisplay());
        c.setValue = o.compose(function(b) {
            return a.getRoot().__preset_select && c.isModified() && y(a.getRoot(), !0), b;
        }, c.setValue);
    }
    function s(a, b) {
        var c = a.getRoot(), d = c.__rememberedObjects.indexOf(b.object);
        if (-1 != d) {
            var e = c.__rememberedObjectIndecesToControllers[d];
            if (void 0 === e && (e = {}, c.__rememberedObjectIndecesToControllers[d] = e), e[b.property] = b, 
            c.load && c.load.remembered) {
                if (c = c.load.remembered, c[a.preset]) c = c[a.preset]; else {
                    if (!c[B]) return;
                    c = c[B];
                }
                c[d] && void 0 !== c[d][b.property] && (d = c[d][b.property], b.initialValue = d, 
                b.setValue(d));
            }
        }
    }
    function t(a) {
        var b = a.__save_row = document.createElement("li");
        n.addClass(a.domElement, "has-save"), a.__ul.insertBefore(b, a.__ul.firstChild), 
        n.addClass(b, "save-row");
        var c = document.createElement("span");
        c.innerHTML = "&nbsp;", n.addClass(c, "button gears");
        var d = document.createElement("span");
        d.innerHTML = "Save", n.addClass(d, "button"), n.addClass(d, "save");
        var e = document.createElement("span");
        e.innerHTML = "New", n.addClass(e, "button"), n.addClass(e, "save-as");
        var f = document.createElement("span");
        f.innerHTML = "Revert", n.addClass(f, "button"), n.addClass(f, "revert");
        var g = a.__preset_select = document.createElement("select");
        if (a.load && a.load.remembered ? o.each(a.load.remembered, function(b, c) {
            x(a, c, c == a.preset);
        }) : x(a, B, !1), n.bind(g, "change", function() {
            for (var b = 0; b < a.__preset_select.length; b++) a.__preset_select[b].innerHTML = a.__preset_select[b].value;
            a.preset = this.value;
        }), b.appendChild(g), b.appendChild(c), b.appendChild(d), b.appendChild(e), b.appendChild(f), 
        A) {
            var b = document.getElementById("dg-save-locally"), h = document.getElementById("dg-local-explain");
            b.style.display = "block", b = document.getElementById("dg-local-storage"), "true" === localStorage.getItem(document.location.href + ".isLocal") && b.setAttribute("checked", "checked");
            var i = function() {
                h.style.display = a.useLocalStorage ? "block" : "none";
            };
            i(), n.bind(b, "change", function() {
                a.useLocalStorage = !a.useLocalStorage, i();
            });
        }
        var j = document.getElementById("dg-new-constructor");
        n.bind(j, "keydown", function(a) {
            !a.metaKey || 67 !== a.which && 67 != a.keyCode || D.hide();
        }), n.bind(c, "click", function() {
            j.innerHTML = JSON.stringify(a.getSaveObject(), void 0, 2), D.show(), j.focus(), 
            j.select();
        }), n.bind(d, "click", function() {
            a.save();
        }), n.bind(e, "click", function() {
            var b = prompt("Enter a new preset name.");
            b && a.saveAs(b);
        }), n.bind(f, "click", function() {
            a.revert();
        });
    }
    function u(a) {
        function b(b) {
            return b.preventDefault(), e = b.clientX, n.addClass(a.__closeButton, I.CLASS_DRAG), 
            n.bind(window, "mousemove", c), n.bind(window, "mouseup", d), !1;
        }
        function c(b) {
            return b.preventDefault(), a.width += e - b.clientX, a.onResize(), e = b.clientX, 
            !1;
        }
        function d() {
            n.removeClass(a.__closeButton, I.CLASS_DRAG), n.unbind(window, "mousemove", c), 
            n.unbind(window, "mouseup", d);
        }
        a.__resize_handle = document.createElement("div"), o.extend(a.__resize_handle.style, {
            width: "6px",
            marginLeft: "-3px",
            height: "200px",
            cursor: "ew-resize",
            position: "absolute"
        });
        var e;
        n.bind(a.__resize_handle, "mousedown", b), n.bind(a.__closeButton, "mousedown", b), 
        a.domElement.insertBefore(a.__resize_handle, a.domElement.firstElementChild);
    }
    function v(a, b) {
        a.domElement.style.width = b + "px", a.__save_row && a.autoPlace && (a.__save_row.style.width = b + "px"), 
        a.__closeButton && (a.__closeButton.style.width = b + "px");
    }
    function w(a, b) {
        var c = {};
        return o.each(a.__rememberedObjects, function(d, e) {
            var f = {};
            o.each(a.__rememberedObjectIndecesToControllers[e], function(a, c) {
                f[c] = b ? a.initialValue : a.getValue();
            }), c[e] = f;
        }), c;
    }
    function x(a, b, c) {
        var d = document.createElement("option");
        d.innerHTML = b, d.value = b, a.__preset_select.appendChild(d), c && (a.__preset_select.selectedIndex = a.__preset_select.length - 1);
    }
    function y(a, b) {
        var c = a.__preset_select[a.__preset_select.selectedIndex];
        c.innerHTML = b ? c.value + "*" : c.value;
    }
    function z(a) {
        0 != a.length && l(function() {
            z(a);
        }), o.each(a, function(a) {
            a.updateDisplay();
        });
    }
    a.inject(c);
    var A, B = "Default";
    try {
        A = "localStorage" in window && null !== window.localStorage;
    } catch (C) {
        A = !1;
    }
    var D, E, F = !0, G = !1, H = [], I = function(a) {
        function b() {
            localStorage.setItem(document.location.href + ".gui", JSON.stringify(d.getSaveObject()));
        }
        function c() {
            var a = d.getRoot();
            a.width += 1, o.defer(function() {
                a.width -= 1;
            });
        }
        var d = this;
        this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), 
        this.domElement.appendChild(this.__ul), n.addClass(this.domElement, "dg"), this.__folders = {}, 
        this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], 
        this.__listening = [], a = a || {}, a = o.defaults(a, {
            autoPlace: !0,
            width: I.DEFAULT_WIDTH
        }), a = o.defaults(a, {
            resizable: a.autoPlace,
            hideable: a.autoPlace
        }), o.isUndefined(a.load) ? a.load = {
            preset: B
        } : a.preset && (a.load.preset = a.preset), o.isUndefined(a.parent) && a.hideable && H.push(this), 
        a.resizable = o.isUndefined(a.parent) && a.resizable, a.autoPlace && o.isUndefined(a.scrollable) && (a.scrollable = !0);
        var e = A && "true" === localStorage.getItem(document.location.href + ".isLocal");
        if (Object.defineProperties(this, {
            parent: {
                get: function() {
                    return a.parent;
                }
            },
            scrollable: {
                get: function() {
                    return a.scrollable;
                }
            },
            autoPlace: {
                get: function() {
                    return a.autoPlace;
                }
            },
            preset: {
                get: function() {
                    return d.parent ? d.getRoot().preset : a.load.preset;
                },
                set: function(b) {
                    for (d.parent ? d.getRoot().preset = b : a.load.preset = b, b = 0; b < this.__preset_select.length; b++) this.__preset_select[b].value == this.preset && (this.__preset_select.selectedIndex = b);
                    d.revert();
                }
            },
            width: {
                get: function() {
                    return a.width;
                },
                set: function(b) {
                    a.width = b, v(d, b);
                }
            },
            name: {
                get: function() {
                    return a.name;
                },
                set: function(b) {
                    a.name = b, g && (g.innerHTML = a.name);
                }
            },
            closed: {
                get: function() {
                    return a.closed;
                },
                set: function(b) {
                    a.closed = b, a.closed ? n.addClass(d.__ul, I.CLASS_CLOSED) : n.removeClass(d.__ul, I.CLASS_CLOSED), 
                    this.onResize(), d.__closeButton && (d.__closeButton.innerHTML = b ? I.TEXT_OPEN : I.TEXT_CLOSED);
                }
            },
            load: {
                get: function() {
                    return a.load;
                }
            },
            useLocalStorage: {
                get: function() {
                    return e;
                },
                set: function(a) {
                    A && ((e = a) ? n.bind(window, "unload", b) : n.unbind(window, "unload", b), localStorage.setItem(document.location.href + ".isLocal", a));
                }
            }
        }), o.isUndefined(a.parent)) {
            if (a.closed = !1, n.addClass(this.domElement, I.CLASS_MAIN), n.makeSelectable(this.domElement, !1), 
            A && e) {
                d.useLocalStorage = !0;
                var f = localStorage.getItem(document.location.href + ".gui");
                f && (a.load = JSON.parse(f));
            }
            this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = I.TEXT_CLOSED, 
            n.addClass(this.__closeButton, I.CLASS_CLOSE_BUTTON), this.domElement.appendChild(this.__closeButton), 
            n.bind(this.__closeButton, "click", function() {
                d.closed = !d.closed;
            });
        } else {
            void 0 === a.closed && (a.closed = !0);
            var g = document.createTextNode(a.name);
            n.addClass(g, "controller-name"), f = q(d, g), n.addClass(this.__ul, I.CLASS_CLOSED), 
            n.addClass(f, "title"), n.bind(f, "click", function(a) {
                return a.preventDefault(), d.closed = !d.closed, !1;
            }), a.closed || (this.closed = !1);
        }
        a.autoPlace && (o.isUndefined(a.parent) && (F && (E = document.createElement("div"), 
        n.addClass(E, "dg"), n.addClass(E, I.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(E), 
        F = !1), E.appendChild(this.domElement), n.addClass(this.domElement, I.CLASS_AUTO_PLACE)), 
        this.parent || v(d, a.width)), n.bind(window, "resize", function() {
            d.onResize();
        }), n.bind(this.__ul, "webkitTransitionEnd", function() {
            d.onResize();
        }), n.bind(this.__ul, "transitionend", function() {
            d.onResize();
        }), n.bind(this.__ul, "oTransitionEnd", function() {
            d.onResize();
        }), this.onResize(), a.resizable && u(this), d.getRoot(), a.parent || c();
    };
    return I.toggleHide = function() {
        G = !G, o.each(H, function(a) {
            a.domElement.style.zIndex = G ? -999 : 999, a.domElement.style.opacity = G ? 0 : 1;
        });
    }, I.CLASS_AUTO_PLACE = "a", I.CLASS_AUTO_PLACE_CONTAINER = "ac", I.CLASS_MAIN = "main", 
    I.CLASS_CONTROLLER_ROW = "cr", I.CLASS_TOO_TALL = "taller-than-window", I.CLASS_CLOSED = "closed", 
    I.CLASS_CLOSE_BUTTON = "close-button", I.CLASS_DRAG = "drag", I.DEFAULT_WIDTH = 245, 
    I.TEXT_CLOSED = "Close Controls", I.TEXT_OPEN = "Open Controls", n.bind(window, "keydown", function(a) {
        "text" === document.activeElement.type || 72 !== a.which && 72 != a.keyCode || I.toggleHide();
    }, !1), o.extend(I.prototype, {
        add: function(a, b) {
            return p(this, a, b, {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
            });
        },
        addColor: function(a, b) {
            return p(this, a, b, {
                color: !0
            });
        },
        remove: function(a) {
            this.__ul.removeChild(a.__li), this.__controllers.slice(this.__controllers.indexOf(a), 1);
            var b = this;
            o.defer(function() {
                b.onResize();
            });
        },
        destroy: function() {
            this.autoPlace && E.removeChild(this.domElement);
        },
        addFolder: function(a) {
            if (void 0 !== this.__folders[a]) throw Error('You already have a folder in this GUI by the name "' + a + '"');
            var b = {
                name: a,
                parent: this
            };
            return b.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[a] && (b.closed = this.load.folders[a].closed, 
            b.load = this.load.folders[a]), b = new I(b), this.__folders[a] = b, a = q(this, b.domElement), 
            n.addClass(a, "folder"), b;
        },
        open: function() {
            this.closed = !1;
        },
        close: function() {
            this.closed = !0;
        },
        onResize: function() {
            var a = this.getRoot();
            if (a.scrollable) {
                var b = n.getOffset(a.__ul).top, c = 0;
                o.each(a.__ul.childNodes, function(b) {
                    a.autoPlace && b === a.__save_row || (c += n.getHeight(b));
                }), window.innerHeight - b - 20 < c ? (n.addClass(a.domElement, I.CLASS_TOO_TALL), 
                a.__ul.style.height = window.innerHeight - b - 20 + "px") : (n.removeClass(a.domElement, I.CLASS_TOO_TALL), 
                a.__ul.style.height = "auto");
            }
            a.__resize_handle && o.defer(function() {
                a.__resize_handle.style.height = a.__ul.offsetHeight + "px";
            }), a.__closeButton && (a.__closeButton.style.width = a.width + "px");
        },
        remember: function() {
            if (o.isUndefined(D) && (D = new m(), D.domElement.innerHTML = b), this.parent) throw Error("You can only call remember on a top level GUI.");
            var a = this;
            o.each(Array.prototype.slice.call(arguments), function(b) {
                0 == a.__rememberedObjects.length && t(a), -1 == a.__rememberedObjects.indexOf(b) && a.__rememberedObjects.push(b);
            }), this.autoPlace && v(this, this.width);
        },
        getRoot: function() {
            for (var a = this; a.parent; ) a = a.parent;
            return a;
        },
        getSaveObject: function() {
            var a = this.load;
            return a.closed = this.closed, 0 < this.__rememberedObjects.length && (a.preset = this.preset, 
            a.remembered || (a.remembered = {}), a.remembered[this.preset] = w(this)), a.folders = {}, 
            o.each(this.__folders, function(b, c) {
                a.folders[c] = b.getSaveObject();
            }), a;
        },
        save: function() {
            this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = w(this), 
            y(this, !1);
        },
        saveAs: function(a) {
            this.load.remembered || (this.load.remembered = {}, this.load.remembered[B] = w(this, !0)), 
            this.load.remembered[a] = w(this), this.preset = a, x(this, a, !0);
        },
        revert: function(a) {
            o.each(this.__controllers, function(b) {
                this.getRoot().load.remembered ? s(a || this.getRoot(), b) : b.setValue(b.initialValue);
            }, this), o.each(this.__folders, function(a) {
                a.revert(a);
            }), a || y(this.getRoot(), !1);
        },
        listen: function(a) {
            var b = 0 == this.__listening.length;
            this.__listening.push(a), b && z(this.__listening);
        }
    }), I;
}(dat.utils.css, '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>', ".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid rgba(0, 0, 0, 0); }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2fa1d6; }\n    .dg .cr.number input[type=text] {\n      color: #2fa1d6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2fa1d6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n", dat.controllers.factory = function(a, b, c, d, e, f, g) {
    return function(h, i, j, k) {
        var l = h[i];
        return g.isArray(j) || g.isObject(j) ? new a(h, i, j) : g.isNumber(l) ? g.isNumber(j) && g.isNumber(k) ? new c(h, i, j, k) : new b(h, i, {
            min: j,
            max: k
        }) : g.isString(l) ? new d(h, i) : g.isFunction(l) ? new e(h, i, "") : g.isBoolean(l) ? new f(h, i) : void 0;
    };
}(dat.controllers.OptionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.StringController = function(a, b, c) {
    var d = function(a, c) {
        function e() {
            f.setValue(f.__input.value);
        }
        d.superclass.call(this, a, c);
        var f = this;
        this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), 
        b.bind(this.__input, "keyup", e), b.bind(this.__input, "change", e), b.bind(this.__input, "blur", function() {
            f.__onFinishChange && f.__onFinishChange.call(f, f.getValue());
        }), b.bind(this.__input, "keydown", function(a) {
            13 === a.keyCode && this.blur();
        }), this.updateDisplay(), this.domElement.appendChild(this.__input);
    };
    return d.superclass = a, c.extend(d.prototype, a.prototype, {
        updateDisplay: function() {
            return b.isActive(this.__input) || (this.__input.value = this.getValue()), d.superclass.prototype.updateDisplay.call(this);
        }
    }), d;
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.FunctionController, dat.controllers.BooleanController, dat.utils.common), dat.controllers.Controller, dat.controllers.BooleanController, dat.controllers.FunctionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.OptionController, dat.controllers.ColorController = function(a, b, c, d, e) {
    function f(a, b, c, d) {
        a.style.background = "", e.each(i, function(e) {
            a.style.cssText += "background: " + e + "linear-gradient(" + b + ", " + c + " 0%, " + d + " 100%); ";
        });
    }
    function g(a) {
        a.style.background = "", a.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", 
        a.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", 
        a.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", 
        a.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", 
        a.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
    }
    var h = function(a, i) {
        function j(a) {
            n(a), b.bind(window, "mousemove", n), b.bind(window, "mouseup", k);
        }
        function k() {
            b.unbind(window, "mousemove", n), b.unbind(window, "mouseup", k);
        }
        function l() {
            var a = d(this.value);
            !1 !== a ? (p.__color.__state = a, p.setValue(p.__color.toOriginal())) : this.value = p.__color.toString();
        }
        function m() {
            b.unbind(window, "mousemove", o), b.unbind(window, "mouseup", m);
        }
        function n(a) {
            a.preventDefault();
            var c = b.getWidth(p.__saturation_field), d = b.getOffset(p.__saturation_field), e = (a.clientX - d.left + document.body.scrollLeft) / c;
            return a = 1 - (a.clientY - d.top + document.body.scrollTop) / c, a > 1 ? a = 1 : 0 > a && (a = 0), 
            e > 1 ? e = 1 : 0 > e && (e = 0), p.__color.v = a, p.__color.s = e, p.setValue(p.__color.toOriginal()), 
            !1;
        }
        function o(a) {
            a.preventDefault();
            var c = b.getHeight(p.__hue_field), d = b.getOffset(p.__hue_field);
            return a = 1 - (a.clientY - d.top + document.body.scrollTop) / c, a > 1 ? a = 1 : 0 > a && (a = 0), 
            p.__color.h = 360 * a, p.setValue(p.__color.toOriginal()), !1;
        }
        h.superclass.call(this, a, i), this.__color = new c(this.getValue()), this.__temp = new c(0);
        var p = this;
        this.domElement = document.createElement("div"), b.makeSelectable(this.domElement, !1), 
        this.__selector = document.createElement("div"), this.__selector.className = "selector", 
        this.__saturation_field = document.createElement("div"), this.__saturation_field.className = "saturation-field", 
        this.__field_knob = document.createElement("div"), this.__field_knob.className = "field-knob", 
        this.__field_knob_border = "2px solid ", this.__hue_knob = document.createElement("div"), 
        this.__hue_knob.className = "hue-knob", this.__hue_field = document.createElement("div"), 
        this.__hue_field.className = "hue-field", this.__input = document.createElement("input"), 
        this.__input.type = "text", this.__input_textShadow = "0 1px 1px ", b.bind(this.__input, "keydown", function(a) {
            13 === a.keyCode && l.call(this);
        }), b.bind(this.__input, "blur", l), b.bind(this.__selector, "mousedown", function(a) {
            b.addClass(this, "drag").bind(window, "mouseup", function(a) {
                b.removeClass(p.__selector, "drag");
            });
        });
        var q = document.createElement("div");
        e.extend(this.__selector.style, {
            width: "122px",
            height: "102px",
            padding: "3px",
            backgroundColor: "#222",
            boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
        }), e.extend(this.__field_knob.style, {
            position: "absolute",
            width: "12px",
            height: "12px",
            border: this.__field_knob_border + (.5 > this.__color.v ? "#fff" : "#000"),
            boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
            borderRadius: "12px",
            zIndex: 1
        }), e.extend(this.__hue_knob.style, {
            position: "absolute",
            width: "15px",
            height: "2px",
            borderRight: "4px solid #fff",
            zIndex: 1
        }), e.extend(this.__saturation_field.style, {
            width: "100px",
            height: "100px",
            border: "1px solid #555",
            marginRight: "3px",
            display: "inline-block",
            cursor: "pointer"
        }), e.extend(q.style, {
            width: "100%",
            height: "100%",
            background: "none"
        }), f(q, "top", "rgba(0,0,0,0)", "#000"), e.extend(this.__hue_field.style, {
            width: "15px",
            height: "100px",
            display: "inline-block",
            border: "1px solid #555",
            cursor: "ns-resize"
        }), g(this.__hue_field), e.extend(this.__input.style, {
            outline: "none",
            textAlign: "center",
            color: "#fff",
            border: 0,
            fontWeight: "bold",
            textShadow: this.__input_textShadow + "rgba(0,0,0,0.7)"
        }), b.bind(this.__saturation_field, "mousedown", j), b.bind(this.__field_knob, "mousedown", j), 
        b.bind(this.__hue_field, "mousedown", function(a) {
            o(a), b.bind(window, "mousemove", o), b.bind(window, "mouseup", m);
        }), this.__saturation_field.appendChild(q), this.__selector.appendChild(this.__field_knob), 
        this.__selector.appendChild(this.__saturation_field), this.__selector.appendChild(this.__hue_field), 
        this.__hue_field.appendChild(this.__hue_knob), this.domElement.appendChild(this.__input), 
        this.domElement.appendChild(this.__selector), this.updateDisplay();
    };
    h.superclass = a, e.extend(h.prototype, a.prototype, {
        updateDisplay: function() {
            var a = d(this.getValue());
            if (!1 !== a) {
                var b = !1;
                e.each(c.COMPONENTS, function(c) {
                    return e.isUndefined(a[c]) || e.isUndefined(this.__color.__state[c]) || a[c] === this.__color.__state[c] ? void 0 : (b = !0, 
                    {});
                }, this), b && e.extend(this.__color.__state, a);
            }
            e.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
            var g = .5 > this.__color.v || .5 < this.__color.s ? 255 : 0, h = 255 - g;
            e.extend(this.__field_knob.style, {
                marginLeft: 100 * this.__color.s - 7 + "px",
                marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                backgroundColor: this.__temp.toString(),
                border: this.__field_knob_border + "rgb(" + g + "," + g + "," + g + ")"
            }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, 
            this.__temp.v = 1, f(this.__saturation_field, "left", "#fff", this.__temp.toString()), 
            e.extend(this.__input.style, {
                backgroundColor: this.__input.value = this.__color.toString(),
                color: "rgb(" + g + "," + g + "," + g + ")",
                textShadow: this.__input_textShadow + "rgba(" + h + "," + h + "," + h + ",.7)"
            });
        }
    });
    var i = [ "-moz-", "-o-", "-webkit-", "-ms-", "" ];
    return h;
}(dat.controllers.Controller, dat.dom.dom, dat.color.Color = function(a, b, c, d) {
    function e(a, b, c) {
        Object.defineProperty(a, b, {
            get: function() {
                return "RGB" === this.__state.space ? this.__state[b] : (g(this, b, c), this.__state[b]);
            },
            set: function(a) {
                "RGB" !== this.__state.space && (g(this, b, c), this.__state.space = "RGB"), this.__state[b] = a;
            }
        });
    }
    function f(a, b) {
        Object.defineProperty(a, b, {
            get: function() {
                return "HSV" === this.__state.space ? this.__state[b] : (h(this), this.__state[b]);
            },
            set: function(a) {
                "HSV" !== this.__state.space && (h(this), this.__state.space = "HSV"), this.__state[b] = a;
            }
        });
    }
    function g(a, c, e) {
        if ("HEX" === a.__state.space) a.__state[c] = b.component_from_hex(a.__state.hex, e); else {
            if ("HSV" !== a.__state.space) throw "Corrupted color state";
            d.extend(a.__state, b.hsv_to_rgb(a.__state.h, a.__state.s, a.__state.v));
        }
    }
    function h(a) {
        var c = b.rgb_to_hsv(a.r, a.g, a.b);
        d.extend(a.__state, {
            s: c.s,
            v: c.v
        }), d.isNaN(c.h) ? d.isUndefined(a.__state.h) && (a.__state.h = 0) : a.__state.h = c.h;
    }
    var i = function() {
        if (this.__state = a.apply(this, arguments), !1 === this.__state) throw "Failed to interpret color arguments";
        this.__state.a = this.__state.a || 1;
    };
    return i.COMPONENTS = "r g b h s v hex a".split(" "), d.extend(i.prototype, {
        toString: function() {
            return c(this);
        },
        toOriginal: function() {
            return this.__state.conversion.write(this);
        }
    }), e(i.prototype, "r", 2), e(i.prototype, "g", 1), e(i.prototype, "b", 0), f(i.prototype, "h"), 
    f(i.prototype, "s"), f(i.prototype, "v"), Object.defineProperty(i.prototype, "a", {
        get: function() {
            return this.__state.a;
        },
        set: function(a) {
            this.__state.a = a;
        }
    }), Object.defineProperty(i.prototype, "hex", {
        get: function() {
            return "HEX" !== !this.__state.space && (this.__state.hex = b.rgb_to_hex(this.r, this.g, this.b)), 
            this.__state.hex;
        },
        set: function(a) {
            this.__state.space = "HEX", this.__state.hex = a;
        }
    }), i;
}(dat.color.interpret, dat.color.math = function() {
    var a;
    return {
        hsv_to_rgb: function(a, b, c) {
            var d = a / 60 - Math.floor(a / 60), e = c * (1 - b), f = c * (1 - d * b);
            return b = c * (1 - (1 - d) * b), a = [ [ c, b, e ], [ f, c, e ], [ e, c, b ], [ e, f, c ], [ b, e, c ], [ c, e, f ] ][Math.floor(a / 60) % 6], 
            {
                r: 255 * a[0],
                g: 255 * a[1],
                b: 255 * a[2]
            };
        },
        rgb_to_hsv: function(a, b, c) {
            var d = Math.min(a, b, c), e = Math.max(a, b, c), d = e - d;
            return 0 == e ? {
                h: NaN,
                s: 0,
                v: 0
            } : (a = (a == e ? (b - c) / d : b == e ? 2 + (c - a) / d : 4 + (a - b) / d) / 6, 
            0 > a && (a += 1), {
                h: 360 * a,
                s: d / e,
                v: e / 255
            });
        },
        rgb_to_hex: function(a, b, c) {
            return a = this.hex_with_component(0, 2, a), a = this.hex_with_component(a, 1, b), 
            a = this.hex_with_component(a, 0, c);
        },
        component_from_hex: function(a, b) {
            return a >> 8 * b & 255;
        },
        hex_with_component: function(b, c, d) {
            return d << (a = 8 * c) | b & ~(255 << a);
        }
    };
}(), dat.color.toString, dat.utils.common), dat.color.interpret, dat.utils.common), dat.utils.requestAnimationFrame = function() {
    return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a, b) {
        window.setTimeout(a, 1e3 / 60);
    };
}(), dat.dom.CenteredDiv = function(a, b) {
    var c = function() {
        this.backgroundElement = document.createElement("div"), b.extend(this.backgroundElement.style, {
            backgroundColor: "rgba(0,0,0,0.8)",
            top: 0,
            left: 0,
            display: "none",
            zIndex: "1000",
            opacity: 0,
            WebkitTransition: "opacity 0.2s linear"
        }), a.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", 
        this.domElement = document.createElement("div"), b.extend(this.domElement.style, {
            position: "fixed",
            display: "none",
            zIndex: "1001",
            opacity: 0,
            WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear"
        }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
        var c = this;
        a.bind(this.backgroundElement, "click", function() {
            c.hide();
        });
    };
    return c.prototype.show = function() {
        var a = this;
        this.backgroundElement.style.display = "block", this.domElement.style.display = "block", 
        this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", 
        this.layout(), b.defer(function() {
            a.backgroundElement.style.opacity = 1, a.domElement.style.opacity = 1, a.domElement.style.webkitTransform = "scale(1)";
        });
    }, c.prototype.hide = function() {
        var b = this, c = function() {
            b.domElement.style.display = "none", b.backgroundElement.style.display = "none", 
            a.unbind(b.domElement, "webkitTransitionEnd", c), a.unbind(b.domElement, "transitionend", c), 
            a.unbind(b.domElement, "oTransitionEnd", c);
        };
        a.bind(this.domElement, "webkitTransitionEnd", c), a.bind(this.domElement, "transitionend", c), 
        a.bind(this.domElement, "oTransitionEnd", c), this.backgroundElement.style.opacity = 0, 
        this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
    }, c.prototype.layout = function() {
        this.domElement.style.left = window.innerWidth / 2 - a.getWidth(this.domElement) / 2 + "px", 
        this.domElement.style.top = window.innerHeight / 2 - a.getHeight(this.domElement) / 2 + "px";
    }, c;
}(dat.dom.dom, dat.utils.common), dat.dom.dom, dat.utils.common), !function() {
    var a = {}, b = null, c = !0, d = !1;
    try {
        "undefined" != typeof AudioContext ? b = new AudioContext() : "undefined" != typeof webkitAudioContext ? b = new webkitAudioContext() : c = !1;
    } catch (e) {
        c = !1;
    }
    if (!c) if ("undefined" != typeof Audio) try {
        new Audio();
    } catch (e) {
        d = !0;
    } else d = !0;
    if (c) {
        var f = void 0 === b.createGain ? b.createGainNode() : b.createGain();
        f.gain.value = 1, f.connect(b.destination);
    }
    var g = function(a) {
        this._volume = 1, this._muted = !1, this.usingWebAudio = c, this.ctx = b, this.noAudio = d, 
        this._howls = [], this._codecs = a, this.iOSAutoEnable = !0;
    };
    g.prototype = {
        volume: function(a) {
            var b = this;
            if (a = parseFloat(a), a >= 0 && 1 >= a) {
                b._volume = a, c && (f.gain.value = a);
                for (var d in b._howls) if (b._howls.hasOwnProperty(d) && b._howls[d]._webAudio === !1) for (var e = 0; e < b._howls[d]._audioNode.length; e++) b._howls[d]._audioNode[e].volume = b._howls[d]._volume * b._volume;
                return b;
            }
            return c ? f.gain.value : b._volume;
        },
        mute: function() {
            return this._setMuted(!0), this;
        },
        unmute: function() {
            return this._setMuted(!1), this;
        },
        _setMuted: function(a) {
            var b = this;
            b._muted = a, c && (f.gain.value = a ? 0 : b._volume);
            for (var d in b._howls) if (b._howls.hasOwnProperty(d) && b._howls[d]._webAudio === !1) for (var e = 0; e < b._howls[d]._audioNode.length; e++) b._howls[d]._audioNode[e].muted = a;
        },
        codecs: function(a) {
            return this._codecs[a];
        },
        _enableiOSAudio: function() {
            var a = this;
            if (!b || !a._iOSEnabled && /iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                a._iOSEnabled = !1;
                var c = function() {
                    var d = b.createBuffer(1, 1, 22050), e = b.createBufferSource();
                    e.buffer = d, e.connect(b.destination), void 0 === e.start ? e.noteOn(0) : e.start(0), 
                    setTimeout(function() {
                        (e.playbackState === e.PLAYING_STATE || e.playbackState === e.FINISHED_STATE) && (a._iOSEnabled = !0, 
                        a.iOSAutoEnable = !1, window.removeEventListener("touchstart", c, !1));
                    }, 0);
                };
                return window.addEventListener("touchstart", c, !1), a;
            }
        }
    };
    var h = null, i = {};
    d || (h = new Audio(), i = {
        mp3: !!h.canPlayType("audio/mpeg;").replace(/^no$/, ""),
        opus: !!h.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
        ogg: !!h.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
        wav: !!h.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
        aac: !!h.canPlayType("audio/aac;").replace(/^no$/, ""),
        m4a: !!(h.canPlayType("audio/x-m4a;") || h.canPlayType("audio/m4a;") || h.canPlayType("audio/aac;")).replace(/^no$/, ""),
        mp4: !!(h.canPlayType("audio/x-mp4;") || h.canPlayType("audio/mp4;") || h.canPlayType("audio/aac;")).replace(/^no$/, ""),
        weba: !!h.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
    });
    var j = new g(i), k = function(a) {
        var d = this;
        d._autoplay = a.autoplay || !1, d._buffer = a.buffer || !1, d._duration = a.duration || 0, 
        d._format = a.format || null, d._loop = a.loop || !1, d._loaded = !1, d._sprite = a.sprite || {}, 
        d._src = a.src || "", d._pos3d = a.pos3d || [ 0, 0, -.5 ], d._volume = void 0 !== a.volume ? a.volume : 1, 
        d._urls = a.urls || [], d._rate = a.rate || 1, d._model = a.model || null, d._onload = [ a.onload || function() {} ], 
        d._onloaderror = [ a.onloaderror || function() {} ], d._onend = [ a.onend || function() {} ], 
        d._onpause = [ a.onpause || function() {} ], d._onplay = [ a.onplay || function() {} ], 
        d._onendTimer = [], d._webAudio = c && !d._buffer, d._audioNode = [], d._webAudio && d._setupAudioNode(), 
        void 0 !== b && b && j.iOSAutoEnable && j._enableiOSAudio(), j._howls.push(d), d.load();
    };
    if (k.prototype = {
        load: function() {
            var a = this, b = null;
            if (d) return void a.on("loaderror");
            for (var c = 0; c < a._urls.length; c++) {
                var e, f;
                if (a._format) e = a._format; else {
                    if (f = a._urls[c], e = /^data:audio\/([^;,]+);/i.exec(f), e || (e = /\.([^.]+)$/.exec(f.split("?", 1)[0])), 
                    !e) return void a.on("loaderror");
                    e = e[1].toLowerCase();
                }
                if (i[e]) {
                    b = a._urls[c];
                    break;
                }
            }
            if (!b) return void a.on("loaderror");
            if (a._src = b, a._webAudio) l(a, b); else {
                var h = new Audio();
                h.addEventListener("error", function() {
                    h.error && 4 === h.error.code && (g.noAudio = !0), a.on("loaderror", {
                        type: h.error ? h.error.code : 0
                    });
                }, !1), a._audioNode.push(h), h.src = b, h._pos = 0, h.preload = "auto", h.volume = j._muted ? 0 : a._volume * j.volume();
                var k = function() {
                    a._duration = Math.ceil(10 * h.duration) / 10, 0 === Object.getOwnPropertyNames(a._sprite).length && (a._sprite = {
                        _default: [ 0, 1e3 * a._duration ]
                    }), a._loaded || (a._loaded = !0, a.on("load")), a._autoplay && a.play(), h.removeEventListener("canplaythrough", k, !1);
                };
                h.addEventListener("canplaythrough", k, !1), h.load();
            }
            return a;
        },
        urls: function(a) {
            var b = this;
            return a ? (b.stop(), b._urls = "string" == typeof a ? [ a ] : a, b._loaded = !1, 
            b.load(), b) : b._urls;
        },
        play: function(a, c) {
            var d = this;
            return "function" == typeof a && (c = a), a && "function" != typeof a || (a = "_default"), 
            d._loaded ? d._sprite[a] ? (d._inactiveNode(function(e) {
                e._sprite = a;
                var f = e._pos > 0 ? e._pos : d._sprite[a][0] / 1e3, g = 0;
                d._webAudio ? (g = d._sprite[a][1] / 1e3 - e._pos, e._pos > 0 && (f = d._sprite[a][0] / 1e3 + f)) : g = d._sprite[a][1] / 1e3 - (f - d._sprite[a][0] / 1e3);
                var h, i = !(!d._loop && !d._sprite[a][2]), k = "string" == typeof c ? c : Math.round(Date.now() * Math.random()) + "";
                if (function() {
                    var b = {
                        id: k,
                        sprite: a,
                        loop: i
                    };
                    h = setTimeout(function() {
                        !d._webAudio && i && d.stop(b.id).play(a, b.id), d._webAudio && !i && (d._nodeById(b.id).paused = !0, 
                        d._nodeById(b.id)._pos = 0, d._clearEndTimer(b.id)), d._webAudio || i || d.stop(b.id), 
                        d.on("end", k);
                    }, 1e3 * g), d._onendTimer.push({
                        timer: h,
                        id: b.id
                    });
                }(), d._webAudio) {
                    var l = d._sprite[a][0] / 1e3, m = d._sprite[a][1] / 1e3;
                    e.id = k, e.paused = !1, o(d, [ i, l, m ], k), d._playStart = b.currentTime, e.gain.value = d._volume, 
                    void 0 === e.bufferSource.start ? e.bufferSource.noteGrainOn(0, f, g) : e.bufferSource.start(0, f, g);
                } else {
                    if (4 !== e.readyState && (e.readyState || !navigator.isCocoonJS)) return d._clearEndTimer(k), 
                    function() {
                        var b = d, f = a, g = c, h = e, i = function() {
                            b.play(f, g), h.removeEventListener("canplaythrough", i, !1);
                        };
                        h.addEventListener("canplaythrough", i, !1);
                    }(), d;
                    e.readyState = 4, e.id = k, e.currentTime = f, e.muted = j._muted || e.muted, e.volume = d._volume * j.volume(), 
                    setTimeout(function() {
                        e.play();
                    }, 0);
                }
                return d.on("play"), "function" == typeof c && c(k), d;
            }), d) : ("function" == typeof c && c(), d) : (d.on("load", function() {
                d.play(a, c);
            }), d);
        },
        pause: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.pause(a);
            }), b;
            b._clearEndTimer(a);
            var c = a ? b._nodeById(a) : b._activeNode();
            if (c) if (c._pos = b.pos(null, a), b._webAudio) {
                if (!c.bufferSource || c.paused) return b;
                c.paused = !0, void 0 === c.bufferSource.stop ? c.bufferSource.noteOff(0) : c.bufferSource.stop(0);
            } else c.pause();
            return b.on("pause"), b;
        },
        stop: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.stop(a);
            }), b;
            b._clearEndTimer(a);
            var c = a ? b._nodeById(a) : b._activeNode();
            if (c) if (c._pos = 0, b._webAudio) {
                if (!c.bufferSource || c.paused) return b;
                c.paused = !0, void 0 === c.bufferSource.stop ? c.bufferSource.noteOff(0) : c.bufferSource.stop(0);
            } else isNaN(c.duration) || (c.pause(), c.currentTime = 0);
            return b;
        },
        mute: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.mute(a);
            }), b;
            var c = a ? b._nodeById(a) : b._activeNode();
            return c && (b._webAudio ? c.gain.value = 0 : c.muted = !0), b;
        },
        unmute: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.unmute(a);
            }), b;
            var c = a ? b._nodeById(a) : b._activeNode();
            return c && (b._webAudio ? c.gain.value = b._volume : c.muted = !1), b;
        },
        volume: function(a, b) {
            var c = this;
            if (a = parseFloat(a), a >= 0 && 1 >= a) {
                if (c._volume = a, !c._loaded) return c.on("play", function() {
                    c.volume(a, b);
                }), c;
                var d = b ? c._nodeById(b) : c._activeNode();
                return d && (c._webAudio ? d.gain.value = a : d.volume = a * j.volume()), c;
            }
            return c._volume;
        },
        loop: function(a) {
            var b = this;
            return "boolean" == typeof a ? (b._loop = a, b) : b._loop;
        },
        sprite: function(a) {
            var b = this;
            return "object" == typeof a ? (b._sprite = a, b) : b._sprite;
        },
        pos: function(a, c) {
            var d = this;
            if (!d._loaded) return d.on("load", function() {
                d.pos(a);
            }), "number" == typeof a ? d : d._pos || 0;
            a = parseFloat(a);
            var e = c ? d._nodeById(c) : d._activeNode();
            if (e) return a >= 0 ? (d.pause(c), e._pos = a, d.play(e._sprite, c), d) : d._webAudio ? e._pos + (b.currentTime - d._playStart) : e.currentTime;
            if (a >= 0) return d;
            for (var f = 0; f < d._audioNode.length; f++) if (d._audioNode[f].paused && 4 === d._audioNode[f].readyState) return d._webAudio ? d._audioNode[f]._pos : d._audioNode[f].currentTime;
        },
        pos3d: function(a, b, c, d) {
            var e = this;
            if (b = void 0 !== b && b ? b : 0, c = void 0 !== c && c ? c : -.5, !e._loaded) return e.on("play", function() {
                e.pos3d(a, b, c, d);
            }), e;
            if (!(a >= 0 || 0 > a)) return e._pos3d;
            if (e._webAudio) {
                var f = d ? e._nodeById(d) : e._activeNode();
                f && (e._pos3d = [ a, b, c ], f.panner.setPosition(a, b, c), f.panner.panningModel = e._model || "HRTF");
            }
            return e;
        },
        fade: function(a, b, c, d, e) {
            var f = this, g = Math.abs(a - b), h = a > b ? "down" : "up", i = g / .01, j = c / i;
            if (!f._loaded) return f.on("load", function() {
                f.fade(a, b, c, d, e);
            }), f;
            f.volume(a, e);
            for (var k = 1; i >= k; k++) !function() {
                var a = f._volume + ("up" === h ? .01 : -.01) * k, c = Math.round(1e3 * a) / 1e3, g = b;
                setTimeout(function() {
                    f.volume(c, e), c === g && d && d();
                }, j * k);
            }();
        },
        fadeIn: function(a, b, c) {
            return this.volume(0).play().fade(0, a, b, c);
        },
        fadeOut: function(a, b, c, d) {
            var e = this;
            return e.fade(e._volume, a, b, function() {
                c && c(), e.pause(d), e.on("end");
            }, d);
        },
        _nodeById: function(a) {
            for (var b = this, c = b._audioNode[0], d = 0; d < b._audioNode.length; d++) if (b._audioNode[d].id === a) {
                c = b._audioNode[d];
                break;
            }
            return c;
        },
        _activeNode: function() {
            for (var a = this, b = null, c = 0; c < a._audioNode.length; c++) if (!a._audioNode[c].paused) {
                b = a._audioNode[c];
                break;
            }
            return a._drainPool(), b;
        },
        _inactiveNode: function(a) {
            for (var b = this, c = null, d = 0; d < b._audioNode.length; d++) if (b._audioNode[d].paused && 4 === b._audioNode[d].readyState) {
                a(b._audioNode[d]), c = !0;
                break;
            }
            if (b._drainPool(), !c) {
                var e;
                if (b._webAudio) e = b._setupAudioNode(), a(e); else {
                    b.load(), e = b._audioNode[b._audioNode.length - 1];
                    var f = navigator.isCocoonJS ? "canplaythrough" : "loadedmetadata", g = function() {
                        e.removeEventListener(f, g, !1), a(e);
                    };
                    e.addEventListener(f, g, !1);
                }
            }
        },
        _drainPool: function() {
            var a, b = this, c = 0;
            for (a = 0; a < b._audioNode.length; a++) b._audioNode[a].paused && c++;
            for (a = b._audioNode.length - 1; a >= 0 && !(5 >= c); a--) b._audioNode[a].paused && (b._webAudio && b._audioNode[a].disconnect(0), 
            c--, b._audioNode.splice(a, 1));
        },
        _clearEndTimer: function(a) {
            for (var b = this, c = 0, d = 0; d < b._onendTimer.length; d++) if (b._onendTimer[d].id === a) {
                c = d;
                break;
            }
            var e = b._onendTimer[c];
            e && (clearTimeout(e.timer), b._onendTimer.splice(c, 1));
        },
        _setupAudioNode: function() {
            var a = this, c = a._audioNode, d = a._audioNode.length;
            return c[d] = void 0 === b.createGain ? b.createGainNode() : b.createGain(), c[d].gain.value = a._volume, 
            c[d].paused = !0, c[d]._pos = 0, c[d].readyState = 4, c[d].connect(f), c[d].panner = b.createPanner(), 
            c[d].panner.panningModel = a._model || "equalpower", c[d].panner.setPosition(a._pos3d[0], a._pos3d[1], a._pos3d[2]), 
            c[d].panner.connect(c[d]), c[d];
        },
        on: function(a, b) {
            var c = this, d = c["_on" + a];
            if ("function" == typeof b) d.push(b); else for (var e = 0; e < d.length; e++) b ? d[e].call(c, b) : d[e].call(c);
            return c;
        },
        off: function(a, b) {
            var c = this, d = c["_on" + a], e = b ? "" + b : null;
            if (e) {
                for (var f = 0; f < d.length; f++) if (e === "" + d[f]) {
                    d.splice(f, 1);
                    break;
                }
            } else c["_on" + a] = [];
            return c;
        },
        unload: function() {
            for (var b = this, c = b._audioNode, d = 0; d < b._audioNode.length; d++) c[d].paused || (b.stop(c[d].id), 
            b.on("end", c[d].id)), b._webAudio ? c[d].disconnect(0) : c[d].src = "";
            for (d = 0; d < b._onendTimer.length; d++) clearTimeout(b._onendTimer[d].timer);
            var e = j._howls.indexOf(b);
            null !== e && e >= 0 && j._howls.splice(e, 1), delete a[b._src], b = null;
        }
    }, c) var l = function(b, c) {
        if (c in a) return b._duration = a[c].duration, void n(b);
        if (/^data:[^;]+;base64,/.test(c)) {
            for (var d = atob(c.split(",")[1]), e = new Uint8Array(d.length), f = 0; f < d.length; ++f) e[f] = d.charCodeAt(f);
            m(e.buffer, b, c);
        } else {
            var g = new XMLHttpRequest();
            g.open("GET", c, !0), g.responseType = "arraybuffer", g.onload = function() {
                m(g.response, b, c);
            }, g.onerror = function() {
                b._webAudio && (b._buffer = !0, b._webAudio = !1, b._audioNode = [], delete b._gainNode, 
                delete a[c], b.load());
            };
            try {
                g.send();
            } catch (h) {
                g.onerror();
            }
        }
    }, m = function(c, d, e) {
        b.decodeAudioData(c, function(b) {
            b && (a[e] = b, n(d, b));
        }, function() {
            d.on("loaderror");
        });
    }, n = function(a, b) {
        a._duration = b ? b.duration : a._duration, 0 === Object.getOwnPropertyNames(a._sprite).length && (a._sprite = {
            _default: [ 0, 1e3 * a._duration ]
        }), a._loaded || (a._loaded = !0, a.on("load")), a._autoplay && a.play();
    }, o = function(c, d, e) {
        var f = c._nodeById(e);
        f.bufferSource = b.createBufferSource(), f.bufferSource.buffer = a[c._src], f.bufferSource.connect(f.panner), 
        f.bufferSource.loop = d[0], d[0] && (f.bufferSource.loopStart = d[1], f.bufferSource.loopEnd = d[1] + d[2]), 
        f.bufferSource.playbackRate.value = c._rate;
    };
    "function" == typeof define && define.amd && define(function() {
        return {
            Howler: j,
            Howl: k
        };
    }), "undefined" != typeof exports && (exports.Howler = j, exports.Howl = k), "undefined" != typeof window && (window.Howler = j, 
    window.Howl = k);
}();

var paper = new function(a) {
    var b = new function() {
        function c(a, c, d, e, g) {
            function h(f, h) {
                h = h || (h = j(c, f)) && (h.get ? h : h.value), "string" == typeof h && "#" === h[0] && (h = a[h.substring(1)] || h);
                var k, m = "function" == typeof h, n = h, o = g || m ? h && h.get ? f in a : a[f] : null;
                g && o || (m && o && (h.base = o), m && e !== !1 && (k = f.match(/^([gs]et|is)(([A-Z])(.*))$/)) && (i[k[3].toLowerCase() + k[4]] = k[2]), 
                n && !m && n.get && "function" == typeof n.get && b.isPlainObject(n) || (n = {
                    value: n,
                    writable: !0
                }), (j(a, f) || {
                    configurable: !0
                }).configurable && (n.configurable = !0, n.enumerable = d), l(a, f, n));
            }
            var i = {};
            if (c) {
                for (var k in c) c.hasOwnProperty(k) && !f.test(k) && h(k);
                for (var k in i) {
                    var m = i[k], n = a["set" + m], o = a["get" + m] || n && a["is" + m];
                    !o || e !== !0 && 0 !== o.length || h(k, {
                        get: o,
                        set: n
                    });
                }
            }
            return a;
        }
        function d(a, b, c) {
            return a && ("length" in a && !a.getLength && "number" == typeof a.length ? g : h).call(a, b, c = c || a), 
            c;
        }
        function e(a, b, c) {
            for (var d in b) !b.hasOwnProperty(d) || c && c[d] || (a[d] = b[d]);
            return a;
        }
        var f = /^(statics|enumerable|beans|preserve)$/, g = [].forEach || function(a, b) {
            for (var c = 0, d = this.length; d > c; c++) a.call(b, this[c], c, this);
        }, h = function(a, b) {
            for (var c in this) this.hasOwnProperty(c) && a.call(b, this[c], c, this);
        }, i = Object.create || function(a) {
            return {
                __proto__: a
            };
        }, j = Object.getOwnPropertyDescriptor || function(a, b) {
            var c = a.__lookupGetter__ && a.__lookupGetter__(b);
            return c ? {
                get: c,
                set: a.__lookupSetter__(b),
                enumerable: !0,
                configurable: !0
            } : a.hasOwnProperty(b) ? {
                value: a[b],
                enumerable: !0,
                configurable: !0,
                writable: !0
            } : null;
        }, k = Object.defineProperty || function(a, b, c) {
            return (c.get || c.set) && a.__defineGetter__ ? (c.get && a.__defineGetter__(b, c.get), 
            c.set && a.__defineSetter__(b, c.set)) : a[b] = c.value, a;
        }, l = function(a, b, c) {
            return delete a[b], k(a, b, c);
        };
        return c(function() {
            for (var a = 0, b = arguments.length; b > a; a++) e(this, arguments[a]);
        }, {
            inject: function(a) {
                if (a) {
                    var b = a.statics === !0 ? a : a.statics, d = a.beans, e = a.preserve;
                    b !== a && c(this.prototype, a, a.enumerable, d, e), c(this, b, !0, d, e);
                }
                for (var f = 1, g = arguments.length; g > f; f++) this.inject(arguments[f]);
                return this;
            },
            extend: function() {
                for (var a, b = this, d = 0, e = arguments.length; e > d && !(a = arguments[d].initialize); d++) ;
                return a = a || function() {
                    b.apply(this, arguments);
                }, a.prototype = i(this.prototype), a.base = b, l(a.prototype, "constructor", {
                    value: a,
                    writable: !0,
                    configurable: !0
                }), c(a, this, !0), arguments.length ? this.inject.apply(a, arguments) : a;
            }
        }, !0).inject({
            inject: function() {
                for (var a = 0, b = arguments.length; b > a; a++) {
                    var d = arguments[a];
                    d && c(this, d, d.enumerable, d.beans, d.preserve);
                }
                return this;
            },
            extend: function() {
                var a = i(this);
                return a.inject.apply(a, arguments);
            },
            each: function(a, b) {
                return d(this, a, b);
            },
            set: function(a) {
                return e(this, a);
            },
            clone: function() {
                return new this.constructor(this);
            },
            statics: {
                each: d,
                create: i,
                define: l,
                describe: j,
                set: e,
                clone: function(a) {
                    return e(new a.constructor(), a);
                },
                isPlainObject: function(a) {
                    var c = null != a && a.constructor;
                    return c && (c === Object || c === b || "Object" === c.name);
                },
                pick: function() {
                    for (var b = 0, c = arguments.length; c > b; b++) if (arguments[b] !== a) return arguments[b];
                }
            }
        });
    }();
    "undefined" != typeof module && (module.exports = b), Array.isArray || (Array.isArray = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a);
    }), document.head || (document.head = document.getElementsByTagName("head")[0]), 
    b.inject({
        toString: function() {
            return null != this._id ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + b.each(this, function(a, b) {
                if (!/^_/.test(b)) {
                    var c = typeof a;
                    this.push(b + ": " + ("number" === c ? f.instance.number(a) : "string" === c ? "'" + a + "'" : a));
                }
            }, []).join(", ") + " }";
        },
        exportJSON: function(a) {
            return b.exportJSON(this, a);
        },
        toJSON: function() {
            return b.serialize(this);
        },
        _set: function(c, d, e) {
            if (c && (e || b.isPlainObject(c))) {
                var f = c._filtering || c;
                for (var g in f) if (f.hasOwnProperty(g) && (!d || !d[g])) {
                    var h = c[g];
                    h !== a && (this[g] = h);
                }
                return !0;
            }
        },
        statics: {
            exports: {
                enumerable: !0
            },
            extend: function ba() {
                var a = ba.base.apply(this, arguments), c = a.prototype._class;
                return c && !b.exports[c] && (b.exports[c] = a), a;
            },
            equals: function(a, c) {
                function d(a, b) {
                    for (var c in a) if (a.hasOwnProperty(c) && !b.hasOwnProperty(c)) return !1;
                    return !0;
                }
                if (a === c) return !0;
                if (a && a.equals) return a.equals(c);
                if (c && c.equals) return c.equals(a);
                if (Array.isArray(a) && Array.isArray(c)) {
                    if (a.length !== c.length) return !1;
                    for (var e = 0, f = a.length; f > e; e++) if (!b.equals(a[e], c[e])) return !1;
                    return !0;
                }
                if (a && "object" == typeof a && c && "object" == typeof c) {
                    if (!d(a, c) || !d(c, a)) return !1;
                    for (var e in a) if (a.hasOwnProperty(e) && !b.equals(a[e], c[e])) return !1;
                    return !0;
                }
                return !1;
            },
            read: function(c, d, e, f) {
                if (this === b) {
                    var g = this.peek(c, d);
                    return c.__index++, g;
                }
                var h = this.prototype, i = h._readIndex, j = d || i && c.__index || 0;
                f || (f = c.length - j);
                var k = c[j];
                return k instanceof this || e && e.readNull && null == k && 1 >= f ? (i && (c.__index = j + 1), 
                k && e && e.clone ? k.clone() : k) : (k = b.create(this.prototype), i && (k.__read = !0), 
                k = k.initialize.apply(k, j > 0 || f < c.length ? Array.prototype.slice.call(c, j, j + f) : c) || k, 
                i && (c.__index = j + k.__read, k.__read = a), k);
            },
            peek: function(a, b) {
                return a[a.__index = b || a.__index || 0];
            },
            remain: function(a) {
                return a.length - (a.__index || 0);
            },
            readAll: function(a, b, c) {
                for (var d, e = [], f = b || 0, g = a.length; g > f; f++) e.push(Array.isArray(d = a[f]) ? this.read(d, 0, c) : this.read(a, f, c, 1));
                return e;
            },
            readNamed: function(c, d, e, f, g) {
                var h = this.getNamed(c, d), i = h !== a;
                if (i) {
                    var j = c._filtered;
                    j || (j = c._filtered = b.create(c[0]), j._filtering = c[0]), j[d] = a;
                }
                return this.read(i ? [ h ] : c, e, f, g);
            },
            getNamed: function(c, d) {
                var e = c[0];
                return c._hasObject === a && (c._hasObject = 1 === c.length && b.isPlainObject(e)), 
                c._hasObject ? d ? e[d] : c._filtered || e : void 0;
            },
            hasNamed: function(a, b) {
                return !!this.getNamed(a, b);
            },
            isPlainValue: function(a, b) {
                return this.isPlainObject(a) || Array.isArray(a) || b && "string" == typeof a;
            },
            serialize: function(a, c, d, e) {
                c = c || {};
                var g, h = !e;
                if (h && (c.formatter = new f(c.precision), e = {
                    length: 0,
                    definitions: {},
                    references: {},
                    add: function(a, b) {
                        var c = "#" + a._id, d = this.references[c];
                        if (!d) {
                            this.length++;
                            var e = b.call(a), f = a._class;
                            f && e[0] !== f && e.unshift(f), this.definitions[c] = e, d = this.references[c] = [ c ];
                        }
                        return d;
                    }
                }), a && a._serialize) {
                    g = a._serialize(c, e);
                    var i = a._class;
                    !i || d || g._compact || g[0] === i || g.unshift(i);
                } else if (Array.isArray(a)) {
                    g = [];
                    for (var j = 0, k = a.length; k > j; j++) g[j] = b.serialize(a[j], c, d, e);
                    d && (g._compact = !0);
                } else if (b.isPlainObject(a)) {
                    g = {};
                    for (var j in a) a.hasOwnProperty(j) && (g[j] = b.serialize(a[j], c, d, e));
                } else g = "number" == typeof a ? c.formatter.number(a, c.precision) : a;
                return h && e.length > 0 ? [ [ "dictionary", e.definitions ], g ] : g;
            },
            deserialize: function(a, c, d) {
                var e = a;
                if (d = d || {}, Array.isArray(a)) {
                    var f = a[0], g = "dictionary" === f;
                    if (!g) {
                        if (d.dictionary && 1 == a.length && /^#/.test(f)) return d.dictionary[f];
                        f = b.exports[f];
                    }
                    e = [];
                    for (var h = f ? 1 : 0, i = a.length; i > h; h++) e.push(b.deserialize(a[h], c, d));
                    if (g) d.dictionary = e[0]; else if (f) {
                        var j = e;
                        c ? e = c(f, j) : (e = b.create(f.prototype), f.apply(e, j));
                    }
                } else if (b.isPlainObject(a)) {
                    e = {};
                    for (var k in a) e[k] = b.deserialize(a[k], c, d);
                }
                return e;
            },
            exportJSON: function(a, c) {
                var d = b.serialize(a, c);
                return c && c.asString === !1 ? d : JSON.stringify(d);
            },
            importJSON: function(a, c) {
                return b.deserialize("string" == typeof a ? JSON.parse(a) : a, function(a, d) {
                    var e = c && c.constructor === a ? c : b.create(a.prototype), f = e === c;
                    if (1 === d.length && e instanceof t && (f || !(e instanceof v))) {
                        var g = d[0];
                        b.isPlainObject(g) && (g.insert = !1);
                    }
                    return a.apply(e, d), f && (c = null), e;
                });
            },
            splice: function(b, c, d, e) {
                var f = c && c.length, g = d === a;
                d = g ? b.length : d, d > b.length && (d = b.length);
                for (var h = 0; f > h; h++) c[h]._index = d + h;
                if (g) return b.push.apply(b, c), [];
                var i = [ d, e ];
                c && i.push.apply(i, c);
                for (var j = b.splice.apply(b, i), h = 0, k = j.length; k > h; h++) j[h]._index = a;
                for (var h = d + f, k = b.length; k > h; h++) b[h]._index = h;
                return j;
            },
            capitalize: function(a) {
                return a.replace(/\b[a-z]/g, function(a) {
                    return a.toUpperCase();
                });
            },
            camelize: function(a) {
                return a.replace(/-(.)/g, function(a, b) {
                    return b.toUpperCase();
                });
            },
            hyphenate: function(a) {
                return a.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
            }
        }
    });
    var c = {
        on: function(a, c) {
            if ("string" != typeof a) b.each(a, function(a, b) {
                this.on(b, a);
            }, this); else {
                var d = this._eventTypes[a];
                if (d) {
                    var e = this._callbacks = this._callbacks || {};
                    e = e[a] = e[a] || [], -1 === e.indexOf(c) && (e.push(c), d.install && 1 == e.length && d.install.call(this, a));
                }
            }
            return this;
        },
        off: function(a, c) {
            if ("string" != typeof a) return void b.each(a, function(a, b) {
                this.off(b, a);
            }, this);
            var d, e = this._eventTypes[a], f = this._callbacks && this._callbacks[a];
            return e && f && (!c || -1 !== (d = f.indexOf(c)) && 1 === f.length ? (e.uninstall && e.uninstall.call(this, a), 
            delete this._callbacks[a]) : -1 !== d && f.splice(d, 1)), this;
        },
        once: function(a, b) {
            return this.on(a, function() {
                b.apply(this, arguments), this.off(a, b);
            });
        },
        emit: function(a, b) {
            var c = this._callbacks && this._callbacks[a];
            if (!c) return !1;
            for (var d = [].slice.call(arguments, 1), e = 0, f = c.length; f > e; e++) if (c[e].apply(this, d) === !1 && b && b.stop) {
                b.stop();
                break;
            }
            return !0;
        },
        responds: function(a) {
            return !(!this._callbacks || !this._callbacks[a]);
        },
        attach: "#on",
        detach: "#off",
        fire: "#emit",
        _installEvents: function(a) {
            var b = this._callbacks, c = a ? "install" : "uninstall";
            for (var d in b) if (b[d].length > 0) {
                var e = this._eventTypes[d], f = e[c];
                f && f.call(this, d);
            }
        },
        statics: {
            inject: function ca(a) {
                var c = a._events;
                if (c) {
                    var d = {};
                    b.each(c, function(c, e) {
                        var f = "string" == typeof c, g = f ? c : e, h = b.capitalize(g), i = g.substring(2).toLowerCase();
                        d[i] = f ? {} : c, g = "_" + g, a["get" + h] = function() {
                            return this[g];
                        }, a["set" + h] = function(a) {
                            var b = this[g];
                            b && this.off(i, b), a && this.on(i, a), this[g] = a;
                        };
                    }), a._eventTypes = d;
                }
                return ca.base.apply(this, arguments);
            }
        }
    }, d = b.extend({
        _class: "PaperScope",
        initialize: function da() {
            paper = this, this.settings = new b({
                applyMatrix: !0,
                handleSize: 4,
                hitTolerance: 0
            }), this.project = null, this.projects = [], this.tools = [], this.palettes = [], 
            this._id = da._id++, da._scopes[this._id] = this;
            var a = da.prototype;
            if (!this.support) {
                var c = Z.getContext(1, 1);
                a.support = {
                    nativeDash: "setLineDash" in c || "mozDash" in c,
                    nativeBlendModes: $.nativeModes
                }, Z.release(c);
            }
            if (!this.browser) {
                var d = a.browser = {};
                navigator.userAgent.toLowerCase().replace(/(opera|chrome|safari|webkit|firefox|msie|trident)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g, function(a, b, c, e, f) {
                    if (!d.chrome) {
                        var g = "opera" === b ? e : c;
                        "trident" === b && (g = f, b = "msie"), d.version = g, d.versionNumber = parseFloat(g), 
                        d.name = b, d[b] = !0;
                    }
                }), d.chrome && delete d.webkit;
            }
        },
        version: "0.9.21",
        getView: function() {
            return this.project && this.project.getView();
        },
        getPaper: function() {
            return this;
        },
        execute: function(a, b, c) {
            paper.PaperScript.execute(a, this, b, c), R.updateFocus();
        },
        install: function(a) {
            var c = this;
            b.each([ "project", "view", "tool" ], function(d) {
                b.define(a, d, {
                    configurable: !0,
                    get: function() {
                        return c[d];
                    }
                });
            });
            for (var d in this) !/^_/.test(d) && this[d] && (a[d] = this[d]);
        },
        setup: function(a) {
            return paper = this, this.project = new r(a), this;
        },
        activate: function() {
            paper = this;
        },
        clear: function() {
            for (var a = this.projects.length - 1; a >= 0; a--) this.projects[a].remove();
            for (var a = this.tools.length - 1; a >= 0; a--) this.tools[a].remove();
            for (var a = this.palettes.length - 1; a >= 0; a--) this.palettes[a].remove();
        },
        remove: function() {
            this.clear(), delete d._scopes[this._id];
        },
        statics: new function() {
            function a(a) {
                return a += "Attribute", function(b, c) {
                    return b[a](c) || b[a]("data-paper-" + c);
                };
            }
            return {
                _scopes: {},
                _id: 0,
                get: function(a) {
                    return this._scopes[a] || null;
                },
                getAttribute: a("get"),
                hasAttribute: a("has")
            };
        }()
    }), e = b.extend(c, {
        initialize: function(a) {
            this._scope = paper, this._index = this._scope[this._list].push(this) - 1, (a || !this._scope[this._reference]) && this.activate();
        },
        activate: function() {
            if (!this._scope) return !1;
            var a = this._scope[this._reference];
            return a && a !== this && a.emit("deactivate"), this._scope[this._reference] = this, 
            this.emit("activate", a), !0;
        },
        isActive: function() {
            return this._scope[this._reference] === this;
        },
        remove: function() {
            return null == this._index ? !1 : (b.splice(this._scope[this._list], null, this._index, 1), 
            this._scope[this._reference] == this && (this._scope[this._reference] = null), this._scope = null, 
            !0);
        }
    }), f = b.extend({
        initialize: function(a) {
            this.precision = a || 5, this.multiplier = Math.pow(10, this.precision);
        },
        number: function(a) {
            return Math.round(a * this.multiplier) / this.multiplier;
        },
        pair: function(a, b, c) {
            return this.number(a) + (c || ",") + this.number(b);
        },
        point: function(a, b) {
            return this.number(a.x) + (b || ",") + this.number(a.y);
        },
        size: function(a, b) {
            return this.number(a.width) + (b || ",") + this.number(a.height);
        },
        rectangle: function(a, b) {
            return this.point(a, b) + (b || ",") + this.size(a, b);
        }
    });
    f.instance = new f();
    var g = new function() {
        function b(b, c, d) {
            var e = c === a, f = c - l, g = d + l, h = 0;
            return function(a) {
                return (e || a > f && g > a) && (b[h++] = c > a ? c : a > d ? d : a), h;
            };
        }
        var c = [ [ .5773502691896257 ], [ 0, .7745966692414834 ], [ .33998104358485626, .8611363115940526 ], [ 0, .5384693101056831, .906179845938664 ], [ .2386191860831969, .6612093864662645, .932469514203152 ], [ 0, .4058451513773972, .7415311855993945, .9491079123427585 ], [ .1834346424956498, .525532409916329, .7966664774136267, .9602898564975363 ], [ 0, .3242534234038089, .6133714327005904, .8360311073266358, .9681602395076261 ], [ .14887433898163122, .4333953941292472, .6794095682990244, .8650633666889845, .9739065285171717 ], [ 0, .26954315595234496, .5190961292068118, .7301520055740494, .8870625997680953, .978228658146057 ], [ .1252334085114689, .3678314989981802, .5873179542866175, .7699026741943047, .9041172563704749, .9815606342467192 ], [ 0, .2304583159551348, .44849275103644687, .6423493394403402, .8015780907333099, .9175983992229779, .9841830547185881 ], [ .10805494870734367, .31911236892788974, .5152486363581541, .6872929048116855, .827201315069765, .9284348836635735, .9862838086968123 ], [ 0, .20119409399743451, .3941513470775634, .5709721726085388, .7244177313601701, .8482065834104272, .937273392400706, .9879925180204854 ], [ .09501250983763744, .2816035507792589, .45801677765722737, .6178762444026438, .755404408355003, .8656312023878318, .9445750230732326, .9894009349916499 ] ], d = [ [ 1 ], [ .8888888888888888, .5555555555555556 ], [ .6521451548625461, .34785484513745385 ], [ .5688888888888889, .47862867049936647, .23692688505618908 ], [ .46791393457269104, .3607615730481386, .17132449237917036 ], [ .4179591836734694, .3818300505051189, .27970539148927664, .1294849661688697 ], [ .362683783378362, .31370664587788727, .22238103445337448, .10122853629037626 ], [ .3302393550012598, .31234707704000286, .26061069640293544, .1806481606948574, .08127438836157441 ], [ .29552422471475287, .26926671930999635, .21908636251598204, .1494513491505806, .06667134430868814 ], [ .2729250867779006, .26280454451024665, .23319376459199048, .18629021092773426, .1255803694649046, .05566856711617366 ], [ .24914704581340277, .2334925365383548, .20316742672306592, .16007832854334622, .10693932599531843, .04717533638651183 ], [ .2325515532308739, .22628318026289723, .2078160475368885, .17814598076194574, .13887351021978725, .09212149983772845, .04048400476531588 ], [ .2152638534631578, .2051984637212956, .18553839747793782, .15720316715819355, .12151857068790319, .08015808715976021, .03511946033175186 ], [ .2025782419255613, .19843148532711158, .1861610000155622, .16626920581699392, .13957067792615432, .10715922046717194, .07036604748810812, .03075324199611727 ], [ .1894506104550685, .18260341504492358, .16915651939500254, .14959598881657674, .12462897125553388, .09515851168249279, .062253523938647894, .027152459411754096 ] ], e = Math.abs, f = Math.sqrt, h = Math.pow, i = Math.cos, j = Math.PI, k = 1e-5, l = 1e-11;
        return {
            TOLERANCE: k,
            EPSILON: l,
            KAPPA: 4 * (f(2) - 1) / 3,
            isZero: function(a) {
                return e(a) <= l;
            },
            integrate: function(a, b, e, f) {
                for (var g = c[f - 2], h = d[f - 2], i = .5 * (e - b), j = i + b, k = 0, l = f + 1 >> 1, m = 1 & f ? h[k++] * a(j) : 0; l > k; ) {
                    var n = i * g[k];
                    m += h[k++] * (a(j + n) + a(j - n));
                }
                return i * m;
            },
            findRoot: function(a, b, c, d, f, g, h) {
                for (var i = 0; g > i; i++) {
                    var j = a(c), k = j / b(c), l = c - k;
                    if (e(k) < h) return l;
                    j > 0 ? (f = c, c = d >= l ? .5 * (d + f) : l) : (d = c, c = l >= f ? .5 * (d + f) : l);
                }
                return c;
            },
            solveQuadratic: function(a, c, d, g, h, i) {
                var j = b(g, h, i);
                if (e(a) < l) return e(c) >= l ? j(-d / c) : e(d) < l ? -1 : 0;
                var k = c / (2 * a), m = d / a, n = k * k;
                if (m - l > n) return 0;
                var o = n > m ? f(n - m) : 0, p = j(o - k);
                return o > 0 && (p = j(-o - k)), p;
            },
            solveCubic: function(a, c, d, k, m, n, o) {
                if (e(a) < l) return g.solveQuadratic(c, d, k, m, n, o);
                c /= a, d /= a, k /= a;
                var p = b(m, n, o), q = c * c, r = (q - 3 * d) / 9, s = (2 * q * c - 9 * c * d + 27 * k) / 54, t = r * r * r, u = s * s - t;
                if (c /= 3, e(u) < l) {
                    if (e(s) < l) return p(-c);
                    var v = f(r), w = s > 0 ? 1 : -1;
                    return p(2 * -w * v - c), p(w * v - c);
                }
                if (0 > u) {
                    var v = f(r), x = Math.acos(s / (v * v * v)) / 3, y = -2 * v, z = 2 * j / 3;
                    return p(y * i(x) - c), p(y * i(x + z) - c), p(y * i(x - z) - c);
                }
                var A = (s > 0 ? -1 : 1) * h(e(s) + f(u), 1 / 3);
                return p(A + r / A - c);
            }
        };
    }(), h = b.extend({
        _class: "Point",
        _readIndex: !0,
        initialize: function(a, b) {
            var c = typeof a;
            if ("number" === c) {
                var d = "number" == typeof b;
                this.x = a, this.y = d ? b : a, this.__read && (this.__read = d ? 2 : 1);
            } else "undefined" === c || null === a ? (this.x = this.y = 0, this.__read && (this.__read = null === a ? 1 : 0)) : (Array.isArray(a) ? (this.x = a[0], 
            this.y = a.length > 1 ? a[1] : a[0]) : null != a.x ? (this.x = a.x, this.y = a.y) : null != a.width ? (this.x = a.width, 
            this.y = a.height) : null != a.angle ? (this.x = a.length, this.y = 0, this.setAngle(a.angle)) : (this.x = this.y = 0, 
            this.__read && (this.__read = 0)), this.__read && (this.__read = 1));
        },
        set: function(a, b) {
            return this.x = a, this.y = b, this;
        },
        equals: function(a) {
            return this === a || a && (this.x === a.x && this.y === a.y || Array.isArray(a) && this.x === a[0] && this.y === a[1]) || !1;
        },
        clone: function() {
            return new h(this.x, this.y);
        },
        toString: function() {
            var a = f.instance;
            return "{ x: " + a.number(this.x) + ", y: " + a.number(this.y) + " }";
        },
        _serialize: function(a) {
            var b = a.formatter;
            return [ b.number(this.x), b.number(this.y) ];
        },
        getLength: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        setLength: function(a) {
            if (this.isZero()) {
                var b = this._angle || 0;
                this.set(Math.cos(b) * a, Math.sin(b) * a);
            } else {
                var c = a / this.getLength();
                g.isZero(c) && this.getAngle(), this.set(this.x * c, this.y * c);
            }
        },
        getAngle: function() {
            return 180 * this.getAngleInRadians.apply(this, arguments) / Math.PI;
        },
        setAngle: function(a) {
            this.setAngleInRadians.call(this, a * Math.PI / 180);
        },
        getAngleInDegrees: "#getAngle",
        setAngleInDegrees: "#setAngle",
        getAngleInRadians: function() {
            if (arguments.length) {
                var a = h.read(arguments), b = this.getLength() * a.getLength();
                if (g.isZero(b)) return NaN;
                var c = this.dot(a) / b;
                return Math.acos(-1 > c ? -1 : c > 1 ? 1 : c);
            }
            return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
        },
        setAngleInRadians: function(a) {
            if (this._angle = a, !this.isZero()) {
                var b = this.getLength();
                this.set(Math.cos(a) * b, Math.sin(a) * b);
            }
        },
        getQuadrant: function() {
            return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
        }
    }, {
        beans: !1,
        getDirectedAngle: function() {
            var a = h.read(arguments);
            return 180 * Math.atan2(this.cross(a), this.dot(a)) / Math.PI;
        },
        getDistance: function() {
            var a = h.read(arguments), c = a.x - this.x, d = a.y - this.y, e = c * c + d * d, f = b.read(arguments);
            return f ? e : Math.sqrt(e);
        },
        normalize: function(b) {
            b === a && (b = 1);
            var c = this.getLength(), d = 0 !== c ? b / c : 0, e = new h(this.x * d, this.y * d);
            return d >= 0 && (e._angle = this._angle), e;
        },
        rotate: function(a, b) {
            if (0 === a) return this.clone();
            a = a * Math.PI / 180;
            var c = b ? this.subtract(b) : this, d = Math.sin(a), e = Math.cos(a);
            return c = new h(c.x * e - c.y * d, c.x * d + c.y * e), b ? c.add(b) : c;
        },
        transform: function(a) {
            return a ? a._transformPoint(this) : this;
        },
        add: function() {
            var a = h.read(arguments);
            return new h(this.x + a.x, this.y + a.y);
        },
        subtract: function() {
            var a = h.read(arguments);
            return new h(this.x - a.x, this.y - a.y);
        },
        multiply: function() {
            var a = h.read(arguments);
            return new h(this.x * a.x, this.y * a.y);
        },
        divide: function() {
            var a = h.read(arguments);
            return new h(this.x / a.x, this.y / a.y);
        },
        modulo: function() {
            var a = h.read(arguments);
            return new h(this.x % a.x, this.y % a.y);
        },
        negate: function() {
            return new h(-this.x, -this.y);
        },
        isInside: function() {
            return n.read(arguments).contains(this);
        },
        isClose: function(a, b) {
            return this.getDistance(a) < b;
        },
        isColinear: function(a) {
            return Math.abs(this.cross(a)) < 1e-5;
        },
        isOrthogonal: function(a) {
            return Math.abs(this.dot(a)) < 1e-5;
        },
        isZero: function() {
            return g.isZero(this.x) && g.isZero(this.y);
        },
        isNaN: function() {
            return isNaN(this.x) || isNaN(this.y);
        },
        dot: function() {
            var a = h.read(arguments);
            return this.x * a.x + this.y * a.y;
        },
        cross: function() {
            var a = h.read(arguments);
            return this.x * a.y - this.y * a.x;
        },
        project: function() {
            var a = h.read(arguments);
            if (a.isZero()) return new h(0, 0);
            var b = this.dot(a) / a.dot(a);
            return new h(a.x * b, a.y * b);
        },
        statics: {
            min: function() {
                var a = h.read(arguments), b = h.read(arguments);
                return new h(Math.min(a.x, b.x), Math.min(a.y, b.y));
            },
            max: function() {
                var a = h.read(arguments), b = h.read(arguments);
                return new h(Math.max(a.x, b.x), Math.max(a.y, b.y));
            },
            random: function() {
                return new h(Math.random(), Math.random());
            }
        }
    }, b.each([ "round", "ceil", "floor", "abs" ], function(a) {
        var b = Math[a];
        this[a] = function() {
            return new h(b(this.x), b(this.y));
        };
    }, {})), j = h.extend({
        initialize: function(a, b, c, d) {
            this._x = a, this._y = b, this._owner = c, this._setter = d;
        },
        set: function(a, b, c) {
            return this._x = a, this._y = b, c || this._owner[this._setter](this), this;
        },
        getX: function() {
            return this._x;
        },
        setX: function(a) {
            this._x = a, this._owner[this._setter](this);
        },
        getY: function() {
            return this._y;
        },
        setY: function(a) {
            this._y = a, this._owner[this._setter](this);
        }
    }), k = b.extend({
        _class: "Size",
        _readIndex: !0,
        initialize: function(a, b) {
            var c = typeof a;
            if ("number" === c) {
                var d = "number" == typeof b;
                this.width = a, this.height = d ? b : a, this.__read && (this.__read = d ? 2 : 1);
            } else "undefined" === c || null === a ? (this.width = this.height = 0, this.__read && (this.__read = null === a ? 1 : 0)) : (Array.isArray(a) ? (this.width = a[0], 
            this.height = a.length > 1 ? a[1] : a[0]) : null != a.width ? (this.width = a.width, 
            this.height = a.height) : null != a.x ? (this.width = a.x, this.height = a.y) : (this.width = this.height = 0, 
            this.__read && (this.__read = 0)), this.__read && (this.__read = 1));
        },
        set: function(a, b) {
            return this.width = a, this.height = b, this;
        },
        equals: function(a) {
            return a === this || a && (this.width === a.width && this.height === a.height || Array.isArray(a) && this.width === a[0] && this.height === a[1]) || !1;
        },
        clone: function() {
            return new k(this.width, this.height);
        },
        toString: function() {
            var a = f.instance;
            return "{ width: " + a.number(this.width) + ", height: " + a.number(this.height) + " }";
        },
        _serialize: function(a) {
            var b = a.formatter;
            return [ b.number(this.width), b.number(this.height) ];
        },
        add: function() {
            var a = k.read(arguments);
            return new k(this.width + a.width, this.height + a.height);
        },
        subtract: function() {
            var a = k.read(arguments);
            return new k(this.width - a.width, this.height - a.height);
        },
        multiply: function() {
            var a = k.read(arguments);
            return new k(this.width * a.width, this.height * a.height);
        },
        divide: function() {
            var a = k.read(arguments);
            return new k(this.width / a.width, this.height / a.height);
        },
        modulo: function() {
            var a = k.read(arguments);
            return new k(this.width % a.width, this.height % a.height);
        },
        negate: function() {
            return new k(-this.width, -this.height);
        },
        isZero: function() {
            return g.isZero(this.width) && g.isZero(this.height);
        },
        isNaN: function() {
            return isNaN(this.width) || isNaN(this.height);
        },
        statics: {
            min: function(a, b) {
                return new k(Math.min(a.width, b.width), Math.min(a.height, b.height));
            },
            max: function(a, b) {
                return new k(Math.max(a.width, b.width), Math.max(a.height, b.height));
            },
            random: function() {
                return new k(Math.random(), Math.random());
            }
        }
    }, b.each([ "round", "ceil", "floor", "abs" ], function(a) {
        var b = Math[a];
        this[a] = function() {
            return new k(b(this.width), b(this.height));
        };
    }, {})), m = k.extend({
        initialize: function(a, b, c, d) {
            this._width = a, this._height = b, this._owner = c, this._setter = d;
        },
        set: function(a, b, c) {
            return this._width = a, this._height = b, c || this._owner[this._setter](this), 
            this;
        },
        getWidth: function() {
            return this._width;
        },
        setWidth: function(a) {
            this._width = a, this._owner[this._setter](this);
        },
        getHeight: function() {
            return this._height;
        },
        setHeight: function(a) {
            this._height = a, this._owner[this._setter](this);
        }
    }), n = b.extend({
        _class: "Rectangle",
        _readIndex: !0,
        beans: !0,
        initialize: function(c, d, e, f) {
            var g = typeof c, i = 0;
            if ("number" === g ? (this.x = c, this.y = d, this.width = e, this.height = f, i = 4) : "undefined" === g || null === c ? (this.x = this.y = this.width = this.height = 0, 
            i = null === c ? 1 : 0) : 1 === arguments.length && (Array.isArray(c) ? (this.x = c[0], 
            this.y = c[1], this.width = c[2], this.height = c[3], i = 1) : c.x !== a || c.width !== a ? (this.x = c.x || 0, 
            this.y = c.y || 0, this.width = c.width || 0, this.height = c.height || 0, i = 1) : c.from === a && c.to === a && (this.x = this.y = this.width = this.height = 0, 
            this._set(c), i = 1)), !i) {
                var j = h.readNamed(arguments, "from"), l = b.peek(arguments);
                if (this.x = j.x, this.y = j.y, l && l.x !== a || b.hasNamed(arguments, "to")) {
                    var m = h.readNamed(arguments, "to");
                    this.width = m.x - j.x, this.height = m.y - j.y, this.width < 0 && (this.x = m.x, 
                    this.width = -this.width), this.height < 0 && (this.y = m.y, this.height = -this.height);
                } else {
                    var n = k.read(arguments);
                    this.width = n.width, this.height = n.height;
                }
                i = arguments.__index;
            }
            this.__read && (this.__read = i);
        },
        set: function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = c, this.height = d, this;
        },
        clone: function() {
            return new n(this.x, this.y, this.width, this.height);
        },
        equals: function(a) {
            var c = b.isPlainValue(a) ? n.read(arguments) : a;
            return c === this || c && this.x === c.x && this.y === c.y && this.width === c.width && this.height === c.height || !1;
        },
        toString: function() {
            var a = f.instance;
            return "{ x: " + a.number(this.x) + ", y: " + a.number(this.y) + ", width: " + a.number(this.width) + ", height: " + a.number(this.height) + " }";
        },
        _serialize: function(a) {
            var b = a.formatter;
            return [ b.number(this.x), b.number(this.y), b.number(this.width), b.number(this.height) ];
        },
        getPoint: function(a) {
            var b = a ? h : j;
            return new b(this.x, this.y, this, "setPoint");
        },
        setPoint: function() {
            var a = h.read(arguments);
            this.x = a.x, this.y = a.y;
        },
        getSize: function(a) {
            var b = a ? k : m;
            return new b(this.width, this.height, this, "setSize");
        },
        setSize: function() {
            var a = k.read(arguments);
            this._fixX && (this.x += (this.width - a.width) * this._fixX), this._fixY && (this.y += (this.height - a.height) * this._fixY), 
            this.width = a.width, this.height = a.height, this._fixW = 1, this._fixH = 1;
        },
        getLeft: function() {
            return this.x;
        },
        setLeft: function(a) {
            this._fixW || (this.width -= a - this.x), this.x = a, this._fixX = 0;
        },
        getTop: function() {
            return this.y;
        },
        setTop: function(a) {
            this._fixH || (this.height -= a - this.y), this.y = a, this._fixY = 0;
        },
        getRight: function() {
            return this.x + this.width;
        },
        setRight: function(b) {
            this._fixX !== a && 1 !== this._fixX && (this._fixW = 0), this._fixW ? this.x = b - this.width : this.width = b - this.x, 
            this._fixX = 1;
        },
        getBottom: function() {
            return this.y + this.height;
        },
        setBottom: function(b) {
            this._fixY !== a && 1 !== this._fixY && (this._fixH = 0), this._fixH ? this.y = b - this.height : this.height = b - this.y, 
            this._fixY = 1;
        },
        getCenterX: function() {
            return this.x + .5 * this.width;
        },
        setCenterX: function(a) {
            this.x = a - .5 * this.width, this._fixX = .5;
        },
        getCenterY: function() {
            return this.y + .5 * this.height;
        },
        setCenterY: function(a) {
            this.y = a - .5 * this.height, this._fixY = .5;
        },
        getCenter: function(a) {
            var b = a ? h : j;
            return new b(this.getCenterX(), this.getCenterY(), this, "setCenter");
        },
        setCenter: function() {
            var a = h.read(arguments);
            return this.setCenterX(a.x), this.setCenterY(a.y), this;
        },
        getArea: function() {
            return this.width * this.height;
        },
        isEmpty: function() {
            return 0 === this.width || 0 === this.height;
        },
        contains: function(b) {
            return b && b.width !== a || 4 == (Array.isArray(b) ? b : arguments).length ? this._containsRectangle(n.read(arguments)) : this._containsPoint(h.read(arguments));
        },
        _containsPoint: function(a) {
            var b = a.x, c = a.y;
            return b >= this.x && c >= this.y && b <= this.x + this.width && c <= this.y + this.height;
        },
        _containsRectangle: function(a) {
            var b = a.x, c = a.y;
            return b >= this.x && c >= this.y && b + a.width <= this.x + this.width && c + a.height <= this.y + this.height;
        },
        intersects: function() {
            var a = n.read(arguments);
            return a.x + a.width > this.x && a.y + a.height > this.y && a.x < this.x + this.width && a.y < this.y + this.height;
        },
        touches: function() {
            var a = n.read(arguments);
            return a.x + a.width >= this.x && a.y + a.height >= this.y && a.x <= this.x + this.width && a.y <= this.y + this.height;
        },
        intersect: function() {
            var a = n.read(arguments), b = Math.max(this.x, a.x), c = Math.max(this.y, a.y), d = Math.min(this.x + this.width, a.x + a.width), e = Math.min(this.y + this.height, a.y + a.height);
            return new n(b, c, d - b, e - c);
        },
        unite: function() {
            var a = n.read(arguments), b = Math.min(this.x, a.x), c = Math.min(this.y, a.y), d = Math.max(this.x + this.width, a.x + a.width), e = Math.max(this.y + this.height, a.y + a.height);
            return new n(b, c, d - b, e - c);
        },
        include: function() {
            var a = h.read(arguments), b = Math.min(this.x, a.x), c = Math.min(this.y, a.y), d = Math.max(this.x + this.width, a.x), e = Math.max(this.y + this.height, a.y);
            return new n(b, c, d - b, e - c);
        },
        expand: function() {
            var a = k.read(arguments), b = a.width, c = a.height;
            return new n(this.x - b / 2, this.y - c / 2, this.width + b, this.height + c);
        },
        scale: function(b, c) {
            return this.expand(this.width * b - this.width, this.height * (c === a ? b : c) - this.height);
        }
    }, b.each([ [ "Top", "Left" ], [ "Top", "Right" ], [ "Bottom", "Left" ], [ "Bottom", "Right" ], [ "Left", "Center" ], [ "Top", "Center" ], [ "Right", "Center" ], [ "Bottom", "Center" ] ], function(a, b) {
        var c = a.join(""), d = /^[RL]/.test(c);
        b >= 4 && (a[1] += d ? "Y" : "X");
        var e = a[d ? 0 : 1], f = a[d ? 1 : 0], g = "get" + e, i = "get" + f, k = "set" + e, l = "set" + f, m = "get" + c, n = "set" + c;
        this[m] = function(a) {
            var b = a ? h : j;
            return new b(this[g](), this[i](), this, n);
        }, this[n] = function() {
            var a = h.read(arguments);
            this[k](a.x), this[l](a.y);
        };
    }, {
        beans: !0
    })), o = n.extend({
        initialize: function(a, b, c, d, e, f) {
            this.set(a, b, c, d, !0), this._owner = e, this._setter = f;
        },
        set: function(a, b, c, d, e) {
            return this._x = a, this._y = b, this._width = c, this._height = d, e || this._owner[this._setter](this), 
            this;
        }
    }, new function() {
        var a = n.prototype;
        return b.each([ "x", "y", "width", "height" ], function(a) {
            var c = b.capitalize(a), d = "_" + a;
            this["get" + c] = function() {
                return this[d];
            }, this["set" + c] = function(a) {
                this[d] = a, this._dontNotify || this._owner[this._setter](this);
            };
        }, b.each([ "Point", "Size", "Center", "Left", "Top", "Right", "Bottom", "CenterX", "CenterY", "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter" ], function(b) {
            var c = "set" + b;
            this[c] = function() {
                this._dontNotify = !0, a[c].apply(this, arguments), this._dontNotify = !1, this._owner[this._setter](this);
            };
        }, {
            isSelected: function() {
                return this._owner._boundsSelected;
            },
            setSelected: function(a) {
                var b = this._owner;
                b.setSelected && (b._boundsSelected = a, b.setSelected(a || b._selectedSegmentState > 0));
            }
        }));
    }()), p = b.extend({
        _class: "Matrix",
        initialize: function ea(a) {
            var b = arguments.length, c = !0;
            if (6 === b ? this.set.apply(this, arguments) : 1 === b ? a instanceof ea ? this.set(a._a, a._c, a._b, a._d, a._tx, a._ty) : Array.isArray(a) ? this.set.apply(this, a) : c = !1 : 0 === b ? this.reset() : c = !1, 
            !c) throw new Error("Unsupported matrix parameters");
        },
        set: function(a, b, c, d, e, f, g) {
            return this._a = a, this._c = b, this._b = c, this._d = d, this._tx = e, this._ty = f, 
            g || this._changed(), this;
        },
        _serialize: function(a) {
            return b.serialize(this.getValues(), a);
        },
        _changed: function() {
            var a = this._owner;
            a && (a._applyMatrix ? a.transform(null, !0) : a._changed(9));
        },
        clone: function() {
            return new p(this._a, this._c, this._b, this._d, this._tx, this._ty);
        },
        equals: function(a) {
            return a === this || a && this._a === a._a && this._b === a._b && this._c === a._c && this._d === a._d && this._tx === a._tx && this._ty === a._ty || !1;
        },
        toString: function() {
            var a = f.instance;
            return "[[" + [ a.number(this._a), a.number(this._b), a.number(this._tx) ].join(", ") + "], [" + [ a.number(this._c), a.number(this._d), a.number(this._ty) ].join(", ") + "]]";
        },
        reset: function(a) {
            return this._a = this._d = 1, this._c = this._b = this._tx = this._ty = 0, a || this._changed(), 
            this;
        },
        apply: function() {
            var a = this._owner;
            return a ? (a.transform(null, !0), this.isIdentity()) : !1;
        },
        translate: function() {
            var a = h.read(arguments), b = a.x, c = a.y;
            return this._tx += b * this._a + c * this._b, this._ty += b * this._c + c * this._d, 
            this._changed(), this;
        },
        scale: function() {
            var a = h.read(arguments), b = h.read(arguments, 0, {
                readNull: !0
            });
            return b && this.translate(b), this._a *= a.x, this._c *= a.x, this._b *= a.y, this._d *= a.y, 
            b && this.translate(b.negate()), this._changed(), this;
        },
        rotate: function(a) {
            a *= Math.PI / 180;
            var b = h.read(arguments, 1), c = b.x, d = b.y, e = Math.cos(a), f = Math.sin(a), g = c - c * e + d * f, i = d - c * f - d * e, j = this._a, k = this._b, l = this._c, m = this._d;
            return this._a = e * j + f * k, this._b = -f * j + e * k, this._c = e * l + f * m, 
            this._d = -f * l + e * m, this._tx += g * j + i * k, this._ty += g * l + i * m, 
            this._changed(), this;
        },
        shear: function() {
            var a = h.read(arguments), b = h.read(arguments, 0, {
                readNull: !0
            });
            b && this.translate(b);
            var c = this._a, d = this._c;
            return this._a += a.y * this._b, this._c += a.y * this._d, this._b += a.x * c, this._d += a.x * d, 
            b && this.translate(b.negate()), this._changed(), this;
        },
        skew: function() {
            var a = h.read(arguments), b = h.read(arguments, 0, {
                readNull: !0
            }), c = Math.PI / 180, d = new h(Math.tan(a.x * c), Math.tan(a.y * c));
            return this.shear(d, b);
        },
        concatenate: function(a) {
            var b = this._a, c = this._b, d = this._c, e = this._d, f = a._a, g = a._b, h = a._c, i = a._d, j = a._tx, k = a._ty;
            return this._a = f * b + h * c, this._b = g * b + i * c, this._c = f * d + h * e, 
            this._d = g * d + i * e, this._tx += j * b + k * c, this._ty += j * d + k * e, this._changed(), 
            this;
        },
        preConcatenate: function(a) {
            var b = this._a, c = this._b, d = this._c, e = this._d, f = this._tx, g = this._ty, h = a._a, i = a._b, j = a._c, k = a._d, l = a._tx, m = a._ty;
            return this._a = h * b + i * d, this._b = h * c + i * e, this._c = j * b + k * d, 
            this._d = j * c + k * e, this._tx = h * f + i * g + l, this._ty = j * f + k * g + m, 
            this._changed(), this;
        },
        chain: function(a) {
            var b = this._a, c = this._b, d = this._c, e = this._d, f = this._tx, g = this._ty, h = a._a, i = a._b, j = a._c, k = a._d, l = a._tx, m = a._ty;
            return new p(h * b + j * c, h * d + j * e, i * b + k * c, i * d + k * e, f + l * b + m * c, g + l * d + m * e);
        },
        isIdentity: function() {
            return 1 === this._a && 0 === this._c && 0 === this._b && 1 === this._d && 0 === this._tx && 0 === this._ty;
        },
        orNullIfIdentity: function() {
            return this.isIdentity() ? null : this;
        },
        isInvertible: function() {
            return !!this._getDeterminant();
        },
        isSingular: function() {
            return !this._getDeterminant();
        },
        transform: function(a, b, c) {
            return arguments.length < 3 ? this._transformPoint(h.read(arguments)) : this._transformCoordinates(a, b, c);
        },
        _transformPoint: function(a, b, c) {
            var d = a.x, e = a.y;
            return b || (b = new h()), b.set(d * this._a + e * this._b + this._tx, d * this._c + e * this._d + this._ty, c);
        },
        _transformCoordinates: function(a, b, c) {
            for (var d = 0, e = 0, f = 2 * c; f > d; ) {
                var g = a[d++], h = a[d++];
                b[e++] = g * this._a + h * this._b + this._tx, b[e++] = g * this._c + h * this._d + this._ty;
            }
            return b;
        },
        _transformCorners: function(a) {
            var b = a.x, c = a.y, d = b + a.width, e = c + a.height, f = [ b, c, d, c, d, e, b, e ];
            return this._transformCoordinates(f, f, 4);
        },
        _transformBounds: function(a, b, c) {
            for (var d = this._transformCorners(a), e = d.slice(0, 2), f = d.slice(), g = 2; 8 > g; g++) {
                var h = d[g], i = 1 & g;
                h < e[i] ? e[i] = h : h > f[i] && (f[i] = h);
            }
            return b || (b = new n()), b.set(e[0], e[1], f[0] - e[0], f[1] - e[1], c);
        },
        inverseTransform: function() {
            return this._inverseTransform(h.read(arguments));
        },
        _getDeterminant: function() {
            var a = this._a * this._d - this._b * this._c;
            return isFinite(a) && !g.isZero(a) && isFinite(this._tx) && isFinite(this._ty) ? a : null;
        },
        _inverseTransform: function(a, b, c) {
            var d = this._getDeterminant();
            if (!d) return null;
            var e = a.x - this._tx, f = a.y - this._ty;
            return b || (b = new h()), b.set((e * this._d - f * this._b) / d, (f * this._a - e * this._c) / d, c);
        },
        decompose: function() {
            var a = this._a, b = this._b, c = this._c, d = this._d;
            if (g.isZero(a * d - b * c)) return null;
            var e = Math.sqrt(a * a + b * b);
            a /= e, b /= e;
            var f = a * c + b * d;
            c -= a * f, d -= b * f;
            var i = Math.sqrt(c * c + d * d);
            return c /= i, d /= i, f /= i, b * c > a * d && (a = -a, b = -b, f = -f, e = -e), 
            {
                scaling: new h(e, i),
                rotation: 180 * -Math.atan2(b, a) / Math.PI,
                shearing: f
            };
        },
        getValues: function() {
            return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
        },
        getTranslation: function() {
            return new h(this._tx, this._ty);
        },
        getScaling: function() {
            return (this.decompose() || {}).scaling;
        },
        getRotation: function() {
            return (this.decompose() || {}).rotation;
        },
        inverted: function() {
            var a = this._getDeterminant();
            return a && new p(this._d / a, -this._c / a, -this._b / a, this._a / a, (this._b * this._ty - this._d * this._tx) / a, (this._c * this._tx - this._a * this._ty) / a);
        },
        shiftless: function() {
            return new p(this._a, this._c, this._b, this._d, 0, 0);
        },
        applyToContext: function(a) {
            a.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
        }
    }, b.each([ "a", "c", "b", "d", "tx", "ty" ], function(a) {
        var c = b.capitalize(a), d = "_" + a;
        this["get" + c] = function() {
            return this[d];
        }, this["set" + c] = function(a) {
            this[d] = a, this._changed();
        };
    }, {})), q = b.extend({
        _class: "Line",
        initialize: function(a, b, c, d, e) {
            var f = !1;
            arguments.length >= 4 ? (this._px = a, this._py = b, this._vx = c, this._vy = d, 
            f = e) : (this._px = a.x, this._py = a.y, this._vx = b.x, this._vy = b.y, f = c), 
            f || (this._vx -= this._px, this._vy -= this._py);
        },
        getPoint: function() {
            return new h(this._px, this._py);
        },
        getVector: function() {
            return new h(this._vx, this._vy);
        },
        getLength: function() {
            return this.getVector().getLength();
        },
        intersect: function(a, b) {
            return q.intersect(this._px, this._py, this._vx, this._vy, a._px, a._py, a._vx, a._vy, !0, b);
        },
        getSide: function(a) {
            return q.getSide(this._px, this._py, this._vx, this._vy, a.x, a.y, !0);
        },
        getDistance: function(a) {
            return Math.abs(q.getSignedDistance(this._px, this._py, this._vx, this._vy, a.x, a.y, !0));
        },
        statics: {
            intersect: function(a, b, c, d, e, f, i, j, k, l) {
                k || (c -= a, d -= b, i -= e, j -= f);
                var m = c * j - d * i;
                if (!g.isZero(m)) {
                    var n = a - e, o = b - f, p = (i * o - j * n) / m, q = (c * o - d * n) / m;
                    if (l || p >= 0 && 1 >= p && q >= 0 && 1 >= q) return new h(a + p * c, b + p * d);
                }
            },
            getSide: function(a, b, c, d, e, f, g) {
                g || (c -= a, d -= b);
                var h = e - a, i = f - b, j = h * d - i * c;
                return 0 === j && (j = h * c + i * d, j > 0 && (h -= c, i -= d, j = h * c + i * d, 
                0 > j && (j = 0))), 0 > j ? -1 : j > 0 ? 1 : 0;
            },
            getSignedDistance: function(a, b, c, d, e, f, h) {
                if (h || (c -= a, d -= b), g.isZero(c)) return e - a;
                var i = d / c, j = b - i * a;
                return (f - i * e - j) / Math.sqrt(i * i + 1);
            }
        }
    }), r = e.extend({
        _class: "Project",
        _list: "projects",
        _reference: "project",
        initialize: function(a) {
            e.call(this, !0), this.layers = [], this._activeLayer = null, this.symbols = [], 
            this._currentStyle = new O(null, null, this), this._view = R.create(this, a || Z.getCanvas(1, 1)), 
            this._selectedItems = {}, this._selectedItemCount = 0, this._updateVersion = 0;
        },
        _serialize: function(a, c) {
            return b.serialize(this.layers, a, !0, c);
        },
        clear: function() {
            for (var a = this.layers.length - 1; a >= 0; a--) this.layers[a].remove();
            this.symbols = [];
        },
        isEmpty: function() {
            return 0 === this.layers.length;
        },
        remove: function fa() {
            return fa.base.call(this) ? (this._view && this._view.remove(), !0) : !1;
        },
        getView: function() {
            return this._view;
        },
        getCurrentStyle: function() {
            return this._currentStyle;
        },
        setCurrentStyle: function(a) {
            this._currentStyle.initialize(a);
        },
        getIndex: function() {
            return this._index;
        },
        getOptions: function() {
            return this._scope.settings;
        },
        getActiveLayer: function() {
            return this._activeLayer || new v({
                project: this
            });
        },
        getSelectedItems: function() {
            var a = [];
            for (var b in this._selectedItems) {
                var c = this._selectedItems[b];
                c.isInserted() && a.push(c);
            }
            return a;
        },
        addChild: function(a) {
            return a instanceof v ? (b.splice(this.layers, [ a ]), this._activeLayer || (this._activeLayer = a)) : a instanceof t ? (this._activeLayer || this.addChild(new v(t.NO_INSERT))).addChild(a) : a = null, 
            a;
        },
        _updateSelection: function(a) {
            var b = a._id, c = this._selectedItems;
            a._selected ? c[b] !== a && (this._selectedItemCount++, c[b] = a) : c[b] === a && (this._selectedItemCount--, 
            delete c[b]);
        },
        selectAll: function() {
            for (var a = this.layers, b = 0, c = a.length; c > b; b++) a[b].setFullySelected(!0);
        },
        deselectAll: function() {
            var a = this._selectedItems;
            for (var b in a) a[b].setFullySelected(!1);
        },
        hitTest: function() {
            for (var a = h.read(arguments), c = z.getOptions(b.read(arguments)), d = this.layers.length - 1; d >= 0; d--) {
                var e = this.layers[d]._hitTest(a, c);
                if (e) return e;
            }
            return null;
        },
        getItems: function(a) {
            return t._getItems(this.layers, a);
        },
        getItem: function(a) {
            return t._getItems(this.layers, a, null, null, !0)[0] || null;
        },
        importJSON: function(a) {
            this.activate();
            var c = this._activeLayer;
            return b.importJSON(a, c && c.isEmpty() && c);
        },
        draw: function(a, c, d) {
            this._updateVersion++, a.save(), c.applyToContext(a);
            for (var e = new b({
                offset: new h(0, 0),
                pixelRatio: d,
                viewMatrix: c.isIdentity() ? null : c,
                matrices: [ new p() ],
                updateMatrix: !0
            }), f = 0, g = this.layers, i = g.length; i > f; f++) g[f].draw(a, e);
            if (a.restore(), this._selectedItemCount > 0) {
                a.save(), a.strokeWidth = 1;
                var j = this._selectedItems, k = this._scope.settings.handleSize, l = this._updateVersion;
                for (var m in j) j[m]._drawSelection(a, c, k, j, l);
                a.restore();
            }
        }
    }), s = b.extend({
        _class: "Symbol",
        initialize: function ga(a, b) {
            this._id = ga._id = (ga._id || 0) + 1, this.project = paper.project, this.project.symbols.push(this), 
            a && this.setDefinition(a, b);
        },
        _serialize: function(a, c) {
            return c.add(this, function() {
                return b.serialize([ this._class, this._definition ], a, !1, c);
            });
        },
        _changed: function(a) {
            8 & a && t._clearBoundsCache(this), 1 & a && (this.project._needsUpdate = !0);
        },
        getDefinition: function() {
            return this._definition;
        },
        setDefinition: function(a, b) {
            a._parentSymbol && (a = a.clone()), this._definition && (this._definition._parentSymbol = null), 
            this._definition = a, a.remove(), a.setSelected(!1), b || a.setPosition(new h()), 
            a._parentSymbol = this, this._changed(9);
        },
        place: function(a) {
            return new y(this, a);
        },
        clone: function() {
            return new s(this._definition.clone(!1));
        }
    }), t = b.extend(c, {
        statics: {
            extend: function ha(a) {
                return a._serializeFields && (a._serializeFields = new b(this.prototype._serializeFields, a._serializeFields)), 
                ha.base.apply(this, arguments);
            },
            NO_INSERT: {
                insert: !1
            }
        },
        _class: "Item",
        _applyMatrix: !0,
        _canApplyMatrix: !0,
        _boundsSelected: !1,
        _selectChildren: !1,
        _serializeFields: {
            name: null,
            applyMatrix: null,
            matrix: new p(),
            pivot: null,
            locked: !1,
            visible: !0,
            blendMode: "normal",
            opacity: 1,
            guide: !1,
            selected: !1,
            clipMask: !1,
            data: {}
        },
        initialize: function() {},
        _initialize: function(a, c) {
            var d = a && b.isPlainObject(a), e = d && a.internal === !0, f = this._matrix = new p(), g = d && a.project || paper.project;
            return e || (this._id = t._id = (t._id || 0) + 1), this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix, 
            c && f.translate(c), f._owner = this, this._style = new O(g._currentStyle, this, g), 
            this._project || (e || d && a.insert === !1 ? this._setProject(g) : d && a.parent ? this.setParent(a.parent) : (g._activeLayer || new v()).addChild(this)), 
            d && a !== t.NO_INSERT && this._set(a, {
                insert: !0,
                parent: !0
            }, !0), d;
        },
        _events: new function() {
            var a = {
                mousedown: {
                    mousedown: 1,
                    mousedrag: 1,
                    click: 1,
                    doubleclick: 1
                },
                mouseup: {
                    mouseup: 1,
                    mousedrag: 1,
                    click: 1,
                    doubleclick: 1
                },
                mousemove: {
                    mousedrag: 1,
                    mousemove: 1,
                    mouseenter: 1,
                    mouseleave: 1
                }
            }, c = {
                install: function(b) {
                    var c = this.getView()._eventCounters;
                    if (c) for (var d in a) c[d] = (c[d] || 0) + (a[d][b] || 0);
                },
                uninstall: function(b) {
                    var c = this.getView()._eventCounters;
                    if (c) for (var d in a) c[d] -= a[d][b] || 0;
                }
            };
            return b.each([ "onMouseDown", "onMouseUp", "onMouseDrag", "onClick", "onDoubleClick", "onMouseMove", "onMouseEnter", "onMouseLeave" ], function(a) {
                this[a] = c;
            }, {
                onFrame: {
                    install: function() {
                        this._animateItem(!0);
                    },
                    uninstall: function() {
                        this._animateItem(!1);
                    }
                },
                onLoad: {}
            });
        }(),
        _animateItem: function(a) {
            this.getView()._animateItem(this, a);
        },
        _serialize: function(a, c) {
            function d(d) {
                for (var g in d) {
                    var h = f[g];
                    b.equals(h, "leading" === g ? 1.2 * d.fontSize : d[g]) || (e[g] = b.serialize(h, a, "data" !== g, c));
                }
            }
            var e = {}, f = this;
            return d(this._serializeFields), this instanceof u || d(this._style._defaults), 
            [ this._class, e ];
        },
        _changed: function(b) {
            var c = this._parentSymbol, d = this._parent || c, e = this._project;
            if (8 & b && (this._bounds = this._position = this._decomposed = this._globalMatrix = this._currentPath = a), 
            d && 40 & b && t._clearBoundsCache(d), 2 & b && t._clearBoundsCache(this), e && (1 & b && (e._needsUpdate = !0), 
            e._changes)) {
                var f = e._changesById[this._id];
                f ? f.flags |= b : (f = {
                    item: this,
                    flags: b
                }, e._changesById[this._id] = f, e._changes.push(f));
            }
            c && c._changed(b);
        },
        set: function(a) {
            return a && this._set(a), this;
        },
        getId: function() {
            return this._id;
        },
        getClassName: function() {
            return this._class;
        },
        getName: function() {
            return this._name;
        },
        setName: function(b, c) {
            if (this._name && this._removeNamed(), b === +b + "") throw new Error("Names consisting only of numbers are not supported.");
            var d = this._parent;
            if (b && d) {
                for (var e = d._children, f = d._namedChildren, g = b, h = 1; c && e[b]; ) b = g + " " + h++;
                (f[b] = f[b] || []).push(this), e[b] = this;
            }
            this._name = b || a, this._changed(128);
        },
        getStyle: function() {
            return this._style;
        },
        setStyle: function(a) {
            this.getStyle().set(a);
        }
    }, b.each([ "locked", "visible", "blendMode", "opacity", "guide" ], function(a) {
        var c = b.capitalize(a), a = "_" + a;
        this["get" + c] = function() {
            return this[a];
        }, this["set" + c] = function(b) {
            b != this[a] && (this[a] = b, this._changed("_locked" === a ? 128 : 129));
        };
    }, {}), {
        beans: !0,
        _locked: !1,
        _visible: !0,
        _blendMode: "normal",
        _opacity: 1,
        _guide: !1,
        isSelected: function() {
            if (this._selectChildren) for (var a = this._children, b = 0, c = a.length; c > b; b++) if (a[b].isSelected()) return !0;
            return this._selected;
        },
        setSelected: function(a, b) {
            if (!b && this._selectChildren) for (var c = this._children, d = 0, e = c.length; e > d; d++) c[d].setSelected(a);
            (a = !!a) ^ this._selected && (this._selected = a, this._project._updateSelection(this), 
            this._changed(129));
        },
        _selected: !1,
        isFullySelected: function() {
            var a = this._children;
            if (a && this._selected) {
                for (var b = 0, c = a.length; c > b; b++) if (!a[b].isFullySelected()) return !1;
                return !0;
            }
            return this._selected;
        },
        setFullySelected: function(a) {
            var b = this._children;
            if (b) for (var c = 0, d = b.length; d > c; c++) b[c].setFullySelected(a);
            this.setSelected(a, !0);
        },
        isClipMask: function() {
            return this._clipMask;
        },
        setClipMask: function(a) {
            this._clipMask != (a = !!a) && (this._clipMask = a, a && (this.setFillColor(null), 
            this.setStrokeColor(null)), this._changed(129), this._parent && this._parent._changed(1024));
        },
        _clipMask: !1,
        getData: function() {
            return this._data || (this._data = {}), this._data;
        },
        setData: function(a) {
            this._data = a;
        },
        getPosition: function(a) {
            var b = this._position, c = a ? h : j;
            if (!b) {
                var d = this._pivot;
                b = this._position = d ? this._matrix._transformPoint(d) : this.getBounds().getCenter(!0);
            }
            return new c(b.x, b.y, this, "setPosition");
        },
        setPosition: function() {
            this.translate(h.read(arguments).subtract(this.getPosition(!0)));
        },
        getPivot: function(a) {
            var b = this._pivot;
            if (b) {
                var c = a ? h : j;
                b = new c(b.x, b.y, this, "setPivot");
            }
            return b;
        },
        setPivot: function() {
            this._pivot = h.read(arguments), this._position = a;
        },
        _pivot: null,
        getRegistration: "#getPivot",
        setRegistration: "#setPivot"
    }, b.each([ "bounds", "strokeBounds", "handleBounds", "roughBounds", "internalBounds", "internalRoughBounds" ], function(a) {
        var c = "get" + b.capitalize(a), d = a.match(/^internal(.*)$/), e = d ? "get" + d[1] : null;
        this[c] = function(b) {
            var d = this._boundsGetter, f = !e && ("string" == typeof d ? d : d && d[c]) || c, g = this._getCachedBounds(f, b, this, e);
            return "bounds" === a ? new o(g.x, g.y, g.width, g.height, this, "setBounds") : g;
        };
    }, {
        beans: !0,
        _getBounds: function(a, b, c) {
            var d = this._children;
            if (!d || 0 == d.length) return new n();
            for (var e = 1 / 0, f = -e, g = e, h = f, i = 0, j = d.length; j > i; i++) {
                var k = d[i];
                if (k._visible && !k.isEmpty()) {
                    var l = k._getCachedBounds(a, b && b.chain(k._matrix), c);
                    e = Math.min(l.x, e), g = Math.min(l.y, g), f = Math.max(l.x + l.width, f), h = Math.max(l.y + l.height, h);
                }
            }
            return isFinite(e) ? new n(e, g, f - e, h - g) : new n();
        },
        setBounds: function() {
            var a = n.read(arguments), b = this.getBounds(), c = new p(), d = a.getCenter();
            c.translate(d), (a.width != b.width || a.height != b.height) && c.scale(0 != b.width ? a.width / b.width : 1, 0 != b.height ? a.height / b.height : 1), 
            d = b.getCenter(), c.translate(-d.x, -d.y), this.transform(c);
        },
        _getCachedBounds: function(a, b, c, d) {
            b = b && b.orNullIfIdentity();
            var e = d ? null : this._matrix.orNullIfIdentity(), f = (!b || b.equals(e)) && a, g = this._parent || this._parentSymbol;
            if (g) {
                var h = c._id, i = g._boundsCache = g._boundsCache || {
                    ids: {},
                    list: []
                };
                i.ids[h] || (i.list.push(c), i.ids[h] = c);
            }
            if (f && this._bounds && this._bounds[f]) return this._bounds[f].clone();
            var j = this._getBounds(d || a, b || e, c);
            if (f) {
                this._bounds || (this._bounds = {});
                var k = this._bounds[f] = j.clone();
                k._internal = !!d;
            }
            return j;
        },
        statics: {
            _clearBoundsCache: function(b) {
                var c = b._boundsCache;
                if (c) {
                    b._bounds = b._position = b._boundsCache = a;
                    for (var d = 0, e = c.list, f = e.length; f > d; d++) {
                        var g = e[d];
                        g !== b && (g._bounds = g._position = a, g._boundsCache && t._clearBoundsCache(g));
                    }
                }
            }
        }
    }), {
        beans: !0,
        _decompose: function() {
            return this._decomposed = this._matrix.decompose();
        },
        getRotation: function() {
            var a = this._decomposed || this._decompose();
            return a && a.rotation;
        },
        setRotation: function(a) {
            var b = this.getRotation();
            if (null != b && null != a) {
                var c = this._decomposed;
                this.rotate(a - b), c.rotation = a, this._decomposed = c;
            }
        },
        getScaling: function(a) {
            var b = this._decomposed || this._decompose(), c = b && b.scaling, d = a ? h : j;
            return c && new d(c.x, c.y, this, "setScaling");
        },
        setScaling: function() {
            var a = this.getScaling();
            if (a) {
                var b = h.read(arguments, 0, {
                    clone: !0
                }), c = this._decomposed;
                this.scale(b.x / a.x, b.y / a.y), c.scaling = b, this._decomposed = c;
            }
        },
        getMatrix: function() {
            return this._matrix;
        },
        setMatrix: function(a) {
            this._matrix.initialize(a), this._applyMatrix ? this.transform(null, !0) : this._changed(9);
        },
        getGlobalMatrix: function(a) {
            var b = this._globalMatrix, c = this._project._updateVersion;
            if (b && b._updateVersion !== c && (b = null), !b) {
                b = this._globalMatrix = this._matrix.clone();
                var d = this._parent;
                d && b.preConcatenate(d.getGlobalMatrix(!0)), b._updateVersion = c;
            }
            return a ? b : b.clone();
        },
        getApplyMatrix: function() {
            return this._applyMatrix;
        },
        setApplyMatrix: function(a) {
            (this._applyMatrix = this._canApplyMatrix && !!a) && this.transform(null, !0);
        },
        getTransformContent: "#getApplyMatrix",
        setTransformContent: "#setApplyMatrix"
    }, {
        getProject: function() {
            return this._project;
        },
        _setProject: function(a, b) {
            if (this._project !== a) {
                this._project && this._installEvents(!1), this._project = a;
                for (var c = this._children, d = 0, e = c && c.length; e > d; d++) c[d]._setProject(a);
                b = !0;
            }
            b && this._installEvents(!0);
        },
        getView: function() {
            return this._project.getView();
        },
        _installEvents: function ia(a) {
            ia.base.call(this, a);
            for (var b = this._children, c = 0, d = b && b.length; d > c; c++) b[c]._installEvents(a);
        },
        getLayer: function() {
            for (var a = this; a = a._parent; ) if (a instanceof v) return a;
            return null;
        },
        getParent: function() {
            return this._parent;
        },
        setParent: function(a) {
            return a.addChild(this);
        },
        getChildren: function() {
            return this._children;
        },
        setChildren: function(a) {
            this.removeChildren(), this.addChildren(a);
        },
        getFirstChild: function() {
            return this._children && this._children[0] || null;
        },
        getLastChild: function() {
            return this._children && this._children[this._children.length - 1] || null;
        },
        getNextSibling: function() {
            return this._parent && this._parent._children[this._index + 1] || null;
        },
        getPreviousSibling: function() {
            return this._parent && this._parent._children[this._index - 1] || null;
        },
        getIndex: function() {
            return this._index;
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && this._style.equals(a._style) && this._matrix.equals(a._matrix) && this._locked === a._locked && this._visible === a._visible && this._blendMode === a._blendMode && this._opacity === a._opacity && this._clipMask === a._clipMask && this._guide === a._guide && this._equals(a) || !1;
        },
        _equals: function(a) {
            return b.equals(this._children, a._children);
        },
        clone: function(a) {
            return this._clone(new this.constructor(t.NO_INSERT), a);
        },
        _clone: function(c, d) {
            if (c.setStyle(this._style), this._children) for (var e = 0, f = this._children.length; f > e; e++) c.addChild(this._children[e].clone(!1), !0);
            (d || d === a) && c.insertAbove(this);
            for (var g = [ "_locked", "_visible", "_blendMode", "_opacity", "_clipMask", "_guide", "_applyMatrix" ], e = 0, f = g.length; f > e; e++) {
                var h = g[e];
                this.hasOwnProperty(h) && (c[h] = this[h]);
            }
            return c._matrix.initialize(this._matrix), c._data = this._data ? b.clone(this._data) : null, 
            c.setSelected(this._selected), this._name && c.setName(this._name, !0), c;
        },
        copyTo: function(a) {
            return a.addChild(this.clone(!1));
        },
        rasterize: function(a) {
            var c = this.getStrokeBounds(), d = (a || this.getView().getResolution()) / 72, e = c.getTopLeft().floor(), f = c.getBottomRight().ceil(), g = new k(f.subtract(e)), h = Z.getCanvas(g.multiply(d)), i = h.getContext("2d"), j = new p().scale(d).translate(e.negate());
            i.save(), j.applyToContext(i), this.draw(i, new b({
                matrices: [ j ]
            })), i.restore();
            var l = new x(t.NO_INSERT);
            return l.setCanvas(h), l.transform(new p().translate(e.add(g.divide(2))).scale(1 / d)), 
            l.insertAbove(this), l;
        },
        contains: function() {
            return !!this._contains(this._matrix._inverseTransform(h.read(arguments)));
        },
        _contains: function(a) {
            if (this._children) {
                for (var b = this._children.length - 1; b >= 0; b--) if (this._children[b].contains(a)) return !0;
                return !1;
            }
            return a.isInside(this.getInternalBounds());
        },
        isInside: function() {
            return n.read(arguments).contains(this.getBounds());
        },
        _asPathItem: function() {
            return new F.Rectangle({
                rectangle: this.getInternalBounds(),
                matrix: this._matrix,
                insert: !1
            });
        },
        intersects: function(a, b) {
            return a instanceof t ? this._asPathItem().getIntersections(a._asPathItem(), b || a._matrix).length > 0 : !1;
        },
        hitTest: function() {
            return this._hitTest(h.read(arguments), z.getOptions(b.read(arguments)));
        },
        _hitTest: function(a, c) {
            function d(c, d) {
                var e = n["get" + d]();
                return a.subtract(e).divide(i).length <= 1 ? new z(c, m, {
                    name: b.hyphenate(d),
                    point: e
                }) : void 0;
            }
            if (this._locked || !this._visible || this._guide && !c.guides || this.isEmpty()) return null;
            var e = this._matrix, f = c._totalMatrix, g = this.getView(), h = c._totalMatrix = f ? f.chain(e) : this.getGlobalMatrix().preConcatenate(g._matrix), i = c._tolerancePadding = new k(F._getPenPadding(1, h.inverted())).multiply(Math.max(c.tolerance, 1e-5));
            if (a = e._inverseTransform(a), !this._children && !this.getInternalRoughBounds().expand(i.multiply(2))._containsPoint(a)) return null;
            var j, l = !(c.guides && !this._guide || c.selected && !this._selected || c.type && c.type !== b.hyphenate(this._class) || c["class"] && !(this instanceof c["class"])), m = this;
            if (l && (c.center || c.bounds) && this._parent) {
                var n = this.getInternalBounds();
                if (c.center && (j = d("center", "Center")), !j && c.bounds) for (var o = [ "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter" ], p = 0; 8 > p && !j; p++) j = d("bounds", o[p]);
            }
            var q = !j && this._children;
            if (q) for (var r = this._getChildHitTestOptions(c), p = q.length - 1; p >= 0 && !j; p--) j = q[p]._hitTest(a, r);
            return !j && l && (j = this._hitTestSelf(a, c)), j && j.point && (j.point = e.transform(j.point)), 
            c._totalMatrix = f, j;
        },
        _getChildHitTestOptions: function(a) {
            return a;
        },
        _hitTestSelf: function(a, b) {
            return b.fill && this.hasFill() && this._contains(a) ? new z("fill", this) : void 0;
        },
        matches: function(a, c) {
            function d(a, c) {
                for (var e in a) if (a.hasOwnProperty(e)) {
                    var f = a[e], g = c[e];
                    if (b.isPlainObject(f) && b.isPlainObject(g)) {
                        if (!d(f, g)) return !1;
                    } else if (!b.equals(f, g)) return !1;
                }
                return !0;
            }
            if ("object" == typeof a) {
                for (var e in a) if (a.hasOwnProperty(e) && !this.matches(e, a[e])) return !1;
            } else {
                var f = /^(empty|editable)$/.test(a) ? this["is" + b.capitalize(a)]() : "type" === a ? b.hyphenate(this._class) : this[a];
                if (/^(constructor|class)$/.test(a)) {
                    if (!(this instanceof c)) return !1;
                } else if (c instanceof RegExp) {
                    if (!c.test(f)) return !1;
                } else if ("function" == typeof c) {
                    if (!c(f)) return !1;
                } else if (b.isPlainObject(c)) {
                    if (!d(c, f)) return !1;
                } else if (!b.equals(f, c)) return !1;
            }
            return !0;
        },
        getItems: function(a) {
            return t._getItems(this._children, a, this._matrix);
        },
        getItem: function(a) {
            return t._getItems(this._children, a, this._matrix, null, !0)[0] || null;
        },
        statics: {
            _getItems: function ja(a, c, d, e, f) {
                if (!e) {
                    var g = c.overlapping, h = c.inside, i = g || h, j = i && n.read([ i ]);
                    e = {
                        items: [],
                        inside: j,
                        overlapping: g && new F.Rectangle({
                            rectangle: j,
                            insert: !1
                        })
                    }, i && (c = b.set({}, c, {
                        inside: !0,
                        overlapping: !0
                    }));
                }
                var k = e.items, h = e.inside, g = e.overlapping;
                d = h && (d || new p());
                for (var l = 0, m = a && a.length; m > l; l++) {
                    var o = a[l], q = d && d.chain(o._matrix), r = !0;
                    if (h) {
                        var i = o.getBounds(q);
                        if (!h.intersects(i)) continue;
                        h && h.contains(i) || g && g.intersects(o, q) || (r = !1);
                    }
                    if (r && o.matches(c) && (k.push(o), f)) break;
                    if (ja(o._children, c, q, e, f), f && k.length > 0) break;
                }
                return k;
            }
        }
    }, {
        importJSON: function(a) {
            var c = b.importJSON(a, this);
            return c !== this ? this.addChild(c) : c;
        },
        addChild: function(b, c) {
            return this.insertChild(a, b, c);
        },
        insertChild: function(a, b, c) {
            var d = this.insertChildren(a, [ b ], c);
            return d && d[0];
        },
        addChildren: function(a, b) {
            return this.insertChildren(this._children.length, a, b);
        },
        insertChildren: function(a, c, d, e) {
            var f = this._children;
            if (f && c && c.length > 0) {
                c = Array.prototype.slice.apply(c);
                for (var g = c.length - 1; g >= 0; g--) {
                    var h = c[g];
                    !e || h instanceof e ? h._remove(!1, !0) : c.splice(g, 1);
                }
                b.splice(f, c, a, 0);
                for (var i = this._project, j = i && i._changes, g = 0, k = c.length; k > g; g++) {
                    var h = c[g];
                    h._parent = this, h._setProject(this._project, !0), h._name && h.setName(h._name), 
                    j && this._changed(5);
                }
                this._changed(11);
            } else c = null;
            return c;
        },
        _insert: function(a, b, c) {
            if (!b._parent) return null;
            var d = b._index + (a ? 1 : 0);
            return b._parent === this._parent && d > this._index && d--, b._parent.insertChild(d, this, c);
        },
        insertAbove: function(a, b) {
            return this._insert(!0, a, b);
        },
        insertBelow: function(a, b) {
            return this._insert(!1, a, b);
        },
        sendToBack: function() {
            return this._parent.insertChild(0, this);
        },
        bringToFront: function() {
            return this._parent.addChild(this);
        },
        appendTop: "#addChild",
        appendBottom: function(a) {
            return this.insertChild(0, a);
        },
        moveAbove: "#insertAbove",
        moveBelow: "#insertBelow",
        reduce: function() {
            if (this._children && 1 === this._children.length) {
                var a = this._children[0].reduce();
                return a.insertAbove(this), a.setStyle(this._style), this.remove(), a;
            }
            return this;
        },
        _removeNamed: function() {
            var a = this._parent;
            if (a) {
                var b = a._children, c = a._namedChildren, d = this._name, e = c[d], f = e ? e.indexOf(this) : -1;
                -1 !== f && (b[d] == this && delete b[d], e.splice(f, 1), e.length ? b[d] = e[e.length - 1] : delete c[d]);
            }
        },
        _remove: function(a, c) {
            var d = this._parent;
            if (d) {
                if (this._name && this._removeNamed(), null != this._index && b.splice(d._children, null, this._index, 1), 
                this._installEvents(!1), a) {
                    var e = this._project;
                    e && e._changes && this._changed(5);
                }
                return c && d._changed(11), this._parent = null, !0;
            }
            return !1;
        },
        remove: function() {
            return this._remove(!0, !0);
        },
        replaceWith: function(a) {
            var b = a && a.insertBelow(this);
            return b && this.remove(), b;
        },
        removeChildren: function(a, c) {
            if (!this._children) return null;
            a = a || 0, c = b.pick(c, this._children.length);
            for (var d = b.splice(this._children, null, a, c - a), e = d.length - 1; e >= 0; e--) d[e]._remove(!0, !1);
            return d.length > 0 && this._changed(11), d;
        },
        clear: "#removeChildren",
        reverseChildren: function() {
            if (this._children) {
                this._children.reverse();
                for (var a = 0, b = this._children.length; b > a; a++) this._children[a]._index = a;
                this._changed(11);
            }
        },
        isEmpty: function() {
            return !this._children || 0 === this._children.length;
        },
        isEditable: function() {
            for (var a = this; a; ) {
                if (!a._visible || a._locked) return !1;
                a = a._parent;
            }
            return !0;
        },
        hasFill: function() {
            return this.getStyle().hasFill();
        },
        hasStroke: function() {
            return this.getStyle().hasStroke();
        },
        hasShadow: function() {
            return this.getStyle().hasShadow();
        },
        _getOrder: function(a) {
            function b(a) {
                var b = [];
                do b.unshift(a); while (a = a._parent);
                return b;
            }
            for (var c = b(this), d = b(a), e = 0, f = Math.min(c.length, d.length); f > e; e++) if (c[e] != d[e]) return c[e]._index < d[e]._index ? 1 : -1;
            return 0;
        },
        hasChildren: function() {
            return this._children && this._children.length > 0;
        },
        isInserted: function() {
            return this._parent ? this._parent.isInserted() : !1;
        },
        isAbove: function(a) {
            return -1 === this._getOrder(a);
        },
        isBelow: function(a) {
            return 1 === this._getOrder(a);
        },
        isParent: function(a) {
            return this._parent === a;
        },
        isChild: function(a) {
            return a && a._parent === this;
        },
        isDescendant: function(a) {
            for (var b = this; b = b._parent; ) if (b == a) return !0;
            return !1;
        },
        isAncestor: function(a) {
            return a ? a.isDescendant(this) : !1;
        },
        isGroupedWith: function(a) {
            for (var b = this._parent; b; ) {
                if (b._parent && /^(Group|Layer|CompoundPath)$/.test(b._class) && a.isDescendant(b)) return !0;
                b = b._parent;
            }
            return !1;
        },
        translate: function() {
            var a = new p();
            return this.transform(a.translate.apply(a, arguments));
        },
        rotate: function(a) {
            return this.transform(new p().rotate(a, h.read(arguments, 1, {
                readNull: !0
            }) || this.getPosition(!0)));
        }
    }, b.each([ "scale", "shear", "skew" ], function(a) {
        this[a] = function() {
            var b = h.read(arguments), c = h.read(arguments, 0, {
                readNull: !0
            });
            return this.transform(new p()[a](b, c || this.getPosition(!0)));
        };
    }, {}), {
        transform: function(a, b) {
            a && a.isIdentity() && (a = null);
            var c = this._matrix, d = (b || this._applyMatrix) && (!c.isIdentity() || a);
            if (!a && !d) return this;
            if (a && c.preConcatenate(a), d = d && this._transformContent(c)) {
                var e = this._pivot, f = this._style, g = f.getFillColor(!0), h = f.getStrokeColor(!0);
                e && c._transformPoint(e, e, !0), g && g.transform(c), h && h.transform(c), c.reset(!0);
            }
            var i = this._bounds, j = this._position;
            this._changed(9);
            var k = i && a && a.decompose();
            if (k && !k.shearing && k.rotation % 90 === 0) {
                for (var l in i) {
                    var m = i[l];
                    (d || !m._internal) && a._transformBounds(m, m);
                }
                var n = this._boundsGetter, m = i[n && n.getBounds || n || "getBounds"];
                m && (this._position = m.getCenter(!0)), this._bounds = i;
            } else a && j && (this._position = a._transformPoint(j, j));
            return this;
        },
        _transformContent: function(a) {
            var b = this._children;
            if (b) {
                for (var c = 0, d = b.length; d > c; c++) b[c].transform(a, !0);
                return !0;
            }
        },
        globalToLocal: function() {
            return this.getGlobalMatrix(!0)._inverseTransform(h.read(arguments));
        },
        localToGlobal: function() {
            return this.getGlobalMatrix(!0)._transformPoint(h.read(arguments));
        },
        parentToLocal: function() {
            return this._matrix._inverseTransform(h.read(arguments));
        },
        localToParent: function() {
            return this._matrix._transformPoint(h.read(arguments));
        },
        fitBounds: function(a, b) {
            a = n.read(arguments);
            var c = this.getBounds(), d = c.height / c.width, e = a.height / a.width, f = (b ? d > e : e > d) ? a.width / c.width : a.height / c.height, g = new n(new h(), new k(c.width * f, c.height * f));
            g.setCenter(a.getCenter()), this.setBounds(g);
        },
        _setStyles: function(a) {
            var b = this._style, c = b.getFillColor(), d = b.getStrokeColor(), e = b.getShadowColor();
            if (c && (a.fillStyle = c.toCanvasStyle(a)), d) {
                var f = b.getStrokeWidth();
                if (f > 0) {
                    a.strokeStyle = d.toCanvasStyle(a), a.lineWidth = f;
                    var g = b.getStrokeJoin(), h = b.getStrokeCap(), i = b.getMiterLimit();
                    if (g && (a.lineJoin = g), h && (a.lineCap = h), i && (a.miterLimit = i), paper.support.nativeDash) {
                        var j = b.getDashArray(), k = b.getDashOffset();
                        j && j.length && ("setLineDash" in a ? (a.setLineDash(j), a.lineDashOffset = k) : (a.mozDash = j, 
                        a.mozDashOffset = k));
                    }
                }
            }
            if (e) {
                var l = b.getShadowBlur();
                if (l > 0) {
                    a.shadowColor = e.toCanvasStyle(a), a.shadowBlur = l;
                    var m = this.getShadowOffset();
                    a.shadowOffsetX = m.x, a.shadowOffsetY = m.y;
                }
            }
        },
        draw: function(a, b, c) {
            function d(a) {
                return g ? g.chain(a) : a;
            }
            var e = this._updateVersion = this._project._updateVersion;
            if (this._visible && 0 !== this._opacity) {
                var f = b.matrices, g = b.viewMatrix, h = this._matrix, i = f[f.length - 1].chain(h);
                if (i.isInvertible()) {
                    f.push(i), b.updateMatrix && (i._updateVersion = e, this._globalMatrix = i);
                    var j, k, l, m = this._blendMode, n = this._opacity, o = "normal" === m, p = $.nativeModes[m], q = o && 1 === n || b.dontStart || b.clip || (p || o && 1 > n) && this._canComposite(), r = b.pixelRatio;
                    if (!q) {
                        var s = this.getStrokeBounds(d(i));
                        if (!s.width || !s.height) return;
                        l = b.offset, k = b.offset = s.getTopLeft().floor(), j = a, a = Z.getContext(s.getSize().ceil().add(1).multiply(r)), 
                        1 !== r && a.scale(r, r);
                    }
                    a.save();
                    var t = c ? c.chain(h) : !this.getStrokeScaling(!0) && d(i), u = !q && b.clipItem, v = !t || u;
                    if (q ? (a.globalAlpha = n, p && (a.globalCompositeOperation = m)) : v && a.translate(-k.x, -k.y), 
                    v && (q ? h : d(i)).applyToContext(a), u && b.clipItem.draw(a, b.extend({
                        clip: !0
                    })), t) {
                        a.setTransform(r, 0, 0, r, 0, 0);
                        var w = b.offset;
                        w && a.translate(-w.x, -w.y);
                    }
                    this._draw(a, b, t), a.restore(), f.pop(), b.clip && !b.dontFinish && a.clip(), 
                    q || ($.process(m, a, j, n, k.subtract(l).multiply(r)), Z.release(a), b.offset = l);
                }
            }
        },
        _isUpdated: function(a) {
            var b = this._parent;
            if (b instanceof G) return b._isUpdated(a);
            var c = this._updateVersion === a;
            return !c && b && b._visible && b._isUpdated(a) && (this._updateVersion = a, c = !0), 
            c;
        },
        _drawSelection: function(a, b, c, d, e) {
            if ((this._drawSelected || this._boundsSelected) && this._isUpdated(e)) {
                var f = this.getSelectedColor(!0) || this.getLayer().getSelectedColor(!0), g = b.chain(this.getGlobalMatrix(!0));
                if (a.strokeStyle = a.fillStyle = f ? f.toCanvasStyle(a) : "#009dec", this._drawSelected && this._drawSelected(a, g, d), 
                this._boundsSelected) {
                    var h = c / 2;
                    coords = g._transformCorners(this.getInternalBounds()), a.beginPath();
                    for (var i = 0; 8 > i; i++) a[0 === i ? "moveTo" : "lineTo"](coords[i], coords[++i]);
                    a.closePath(), a.stroke();
                    for (var i = 0; 8 > i; i++) a.fillRect(coords[i] - h, coords[++i] - h, c, c);
                }
            }
        },
        _canComposite: function() {
            return !1;
        }
    }, b.each([ "down", "drag", "up", "move" ], function(a) {
        this["removeOn" + b.capitalize(a)] = function() {
            var b = {};
            return b[a] = !0, this.removeOn(b);
        };
    }, {
        removeOn: function(a) {
            for (var b in a) if (a[b]) {
                var c = "mouse" + b, d = this._project, e = d._removeSets = d._removeSets || {};
                e[c] = e[c] || {}, e[c][this._id] = this;
            }
            return this;
        }
    })), u = t.extend({
        _class: "Group",
        _selectChildren: !0,
        _serializeFields: {
            children: []
        },
        initialize: function(a) {
            this._children = [], this._namedChildren = {}, this._initialize(a) || this.addChildren(Array.isArray(a) ? a : arguments);
        },
        _changed: function ka(b) {
            ka.base.call(this, b), 1026 & b && (this._clipItem = a);
        },
        _getClipItem: function() {
            var b = this._clipItem;
            if (b === a) {
                b = null;
                for (var c = 0, d = this._children.length; d > c; c++) {
                    var e = this._children[c];
                    if (e._clipMask) {
                        b = e;
                        break;
                    }
                }
                this._clipItem = b;
            }
            return b;
        },
        isClipped: function() {
            return !!this._getClipItem();
        },
        setClipped: function(a) {
            var b = this.getFirstChild();
            b && b.setClipMask(a);
        },
        _draw: function(a, b) {
            var c = b.clip, d = !c && this._getClipItem(), e = !0;
            if (b = b.extend({
                clipItem: d,
                clip: !1
            }), c ? this._currentPath ? (a.currentPath = this._currentPath, e = !1) : (a.beginPath(), 
            b.dontStart = b.dontFinish = !0) : d && d.draw(a, b.extend({
                clip: !0
            })), e) for (var f = 0, g = this._children.length; g > f; f++) {
                var h = this._children[f];
                h !== d && h.draw(a, b);
            }
            c && (this._currentPath = a.currentPath);
        }
    }), v = u.extend({
        _class: "Layer",
        initialize: function(c) {
            var d = b.isPlainObject(c) ? new b(c) : {
                children: Array.isArray(c) ? c : arguments
            }, e = d.insert;
            d.insert = !1, u.call(this, d), (e || e === a) && (this._project.addChild(this), 
            this.activate());
        },
        _remove: function la(a) {
            if (this._parent) return la.base.call(this, a);
            if (null != this._index) {
                var c = this._project;
                return c._activeLayer === this && (c._activeLayer = this.getNextSibling() || this.getPreviousSibling()), 
                b.splice(c.layers, null, this._index, 1), this._installEvents(!1), c._needsUpdate = !0, 
                !0;
            }
            return !1;
        },
        getNextSibling: function ma() {
            return this._parent ? ma.base.call(this) : this._project.layers[this._index + 1] || null;
        },
        getPreviousSibling: function na() {
            return this._parent ? na.base.call(this) : this._project.layers[this._index - 1] || null;
        },
        isInserted: function oa() {
            return this._parent ? oa.base.call(this) : null != this._index;
        },
        activate: function() {
            this._project._activeLayer = this;
        },
        _insert: function pa(a, c, d) {
            return c instanceof v && !c._parent ? (this._remove(!0, !0), b.splice(c._project.layers, [ this ], c._index + (a ? 1 : 0), 0), 
            this._setProject(c._project, !0), this) : pa.base.call(this, a, c, d);
        }
    }), w = t.extend({
        _class: "Shape",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsSelected: !0,
        _serializeFields: {
            type: null,
            size: null,
            radius: null
        },
        initialize: function(a) {
            this._initialize(a);
        },
        _equals: function(a) {
            return this._type === a._type && this._size.equals(a._size) && b.equals(this._radius, a._radius);
        },
        clone: function(a) {
            var b = new w(t.NO_INSERT);
            return b.setType(this._type), b.setSize(this._size), b.setRadius(this._radius), 
            this._clone(b, a);
        },
        getType: function() {
            return this._type;
        },
        setType: function(a) {
            this._type = a;
        },
        getShape: "#getType",
        setShape: "#setType",
        getSize: function() {
            var a = this._size;
            return new m(a.width, a.height, this, "setSize");
        },
        setSize: function() {
            var a = k.read(arguments);
            if (this._size) {
                if (!this._size.equals(a)) {
                    var b = this._type, c = a.width, d = a.height;
                    if ("rectangle" === b) {
                        var e = k.min(this._radius, a.divide(2));
                        this._radius.set(e.width, e.height);
                    } else "circle" === b ? (c = d = (c + d) / 2, this._radius = c / 2) : "ellipse" === b && this._radius.set(c / 2, d / 2);
                    this._size.set(c, d), this._changed(9);
                }
            } else this._size = a.clone();
        },
        getRadius: function() {
            var a = this._radius;
            return "circle" === this._type ? a : new m(a.width, a.height, this, "setRadius");
        },
        setRadius: function(a) {
            var b = this._type;
            if ("circle" === b) {
                if (a === this._radius) return;
                var c = 2 * a;
                this._radius = a, this._size.set(c, c);
            } else if (a = k.read(arguments), this._radius) {
                if (this._radius.equals(a)) return;
                if (this._radius.set(a.width, a.height), "rectangle" === b) {
                    var c = k.max(this._size, a.multiply(2));
                    this._size.set(c.width, c.height);
                } else "ellipse" === b && this._size.set(2 * a.width, 2 * a.height);
            } else this._radius = a.clone();
            this._changed(9);
        },
        isEmpty: function() {
            return !1;
        },
        toPath: function(c) {
            var d = new (F[b.capitalize(this._type)])({
                center: new h(),
                size: this._size,
                radius: this._radius,
                insert: !1
            });
            return d.setStyle(this._style), d.transform(this._matrix), (c || c === a) && d.insertAbove(this), 
            d;
        },
        _draw: function(a, b, c) {
            var d = this._style, e = d.hasFill(), f = d.hasStroke(), g = b.dontFinish || b.clip, h = !c;
            if (e || f || g) {
                var i = this._type, j = this._radius, k = "circle" === i;
                if (b.dontStart || a.beginPath(), h && k) a.arc(0, 0, j, 0, 2 * Math.PI, !0); else {
                    var l = k ? j : j.width, m = k ? j : j.height, n = this._size, o = n.width, p = n.height;
                    if (h && "rect" === i && 0 === l && 0 === m) a.rect(-o / 2, -p / 2, o, p); else {
                        var q = o / 2, r = p / 2, s = .44771525016920644, t = l * s, u = m * s, v = [ -q, -r + m, -q, -r + u, -q + t, -r, -q + l, -r, q - l, -r, q - t, -r, q, -r + u, q, -r + m, q, r - m, q, r - u, q - t, r, q - l, r, -q + l, r, -q + t, r, -q, r - u, -q, r - m ];
                        c && c.transform(v, v, 32), a.moveTo(v[0], v[1]), a.bezierCurveTo(v[2], v[3], v[4], v[5], v[6], v[7]), 
                        q !== l && a.lineTo(v[8], v[9]), a.bezierCurveTo(v[10], v[11], v[12], v[13], v[14], v[15]), 
                        r !== m && a.lineTo(v[16], v[17]), a.bezierCurveTo(v[18], v[19], v[20], v[21], v[22], v[23]), 
                        q !== l && a.lineTo(v[24], v[25]), a.bezierCurveTo(v[26], v[27], v[28], v[29], v[30], v[31]);
                    }
                }
                a.closePath();
            }
            g || !e && !f || (this._setStyles(a), e && (a.fill(d.getWindingRule()), a.shadowColor = "rgba(0,0,0,0)"), 
            f && a.stroke());
        },
        _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
        },
        _getBounds: function(a, b) {
            var c = new n(this._size).setCenter(0, 0);
            return "getBounds" !== a && this.hasStroke() && (c = c.expand(this.getStrokeWidth())), 
            b ? b._transformBounds(c) : c;
        }
    }, new function() {
        function a(a, b, c) {
            var d = a._radius;
            if (!d.isZero()) for (var e = a._size.divide(2), f = 0; 4 > f; f++) {
                var g = new h(1 & f ? 1 : -1, f > 1 ? 1 : -1), i = g.multiply(e), j = i.subtract(g.multiply(d)), k = new n(i, j);
                if ((c ? k.expand(c) : k).contains(b)) return j;
            }
        }
        function b(a, b) {
            var c = a.getAngleInRadians(), d = 2 * b.width, e = 2 * b.height, f = d * Math.sin(c), g = e * Math.cos(c);
            return d * e / (2 * Math.sqrt(f * f + g * g));
        }
        return {
            _contains: function c(b) {
                if ("rectangle" === this._type) {
                    var d = a(this, b);
                    return d ? b.subtract(d).divide(this._radius).getLength() <= 1 : c.base.call(this, b);
                }
                return b.divide(this.size).getLength() <= .5;
            },
            _hitTestSelf: function d(c, e) {
                var f = !1;
                if (this.hasStroke()) {
                    var g = this._type, h = this._radius, i = this.getStrokeWidth() + 2 * e.tolerance;
                    if ("rectangle" === g) {
                        var j = a(this, c, i);
                        if (j) {
                            var k = c.subtract(j);
                            f = 2 * Math.abs(k.getLength() - b(k, h)) <= i;
                        } else {
                            var l = new n(this._size).setCenter(0, 0), m = l.expand(i), o = l.expand(-i);
                            f = m._containsPoint(c) && !o._containsPoint(c);
                        }
                    } else "ellipse" === g && (h = b(c, h)), f = 2 * Math.abs(c.getLength() - h) <= i;
                }
                return f ? new z("stroke", this) : d.base.apply(this, arguments);
            }
        };
    }(), {
        statics: new function() {
            function a(a, c, d, e, f) {
                var g = new w(b.getNamed(f));
                return g._type = a, g._size = d, g._radius = e, g.translate(c);
            }
            return {
                Circle: function() {
                    var c = h.readNamed(arguments, "center"), d = b.readNamed(arguments, "radius");
                    return a("circle", c, new k(2 * d), d, arguments);
                },
                Rectangle: function() {
                    var b = n.readNamed(arguments, "rectangle"), c = k.min(k.readNamed(arguments, "radius"), b.getSize(!0).divide(2));
                    return a("rectangle", b.getCenter(!0), b.getSize(!0), c, arguments);
                },
                Ellipse: function() {
                    var b = w._readEllipse(arguments), c = b.radius;
                    return a("ellipse", b.center, c.multiply(2), c, arguments);
                },
                _readEllipse: function(a) {
                    var c, d;
                    if (b.hasNamed(a, "radius")) c = h.readNamed(a, "center"), d = k.readNamed(a, "radius"); else {
                        var e = n.readNamed(a, "rectangle");
                        c = e.getCenter(!0), d = e.getSize(!0).divide(2);
                    }
                    return {
                        center: c,
                        radius: d
                    };
                }
            };
        }()
    }), x = t.extend({
        _class: "Raster",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsGetter: "getBounds",
        _boundsSelected: !0,
        _serializeFields: {
            source: null
        },
        initialize: function(b, c) {
            this._initialize(b, c !== a && h.read(arguments, 1)) || ("string" == typeof b ? this.setSource(b) : this.setImage(b)), 
            this._size || (this._size = new k());
        },
        _equals: function(a) {
            return this.getSource() === a.getSource();
        },
        clone: function(a) {
            var b = new x(t.NO_INSERT), c = this._image, d = this._canvas;
            if (c) b.setImage(c); else if (d) {
                var e = Z.getCanvas(this._size);
                e.getContext("2d").drawImage(d, 0, 0), b.setCanvas(e);
            }
            return this._clone(b, a);
        },
        getSize: function() {
            var a = this._size;
            return new m(a.width, a.height, this, "setSize");
        },
        setSize: function() {
            var a = k.read(arguments);
            if (!this._size.equals(a)) {
                var b = this.getElement();
                this.setCanvas(Z.getCanvas(a)), b && this.getContext(!0).drawImage(b, 0, 0, a.width, a.height);
            }
        },
        getWidth: function() {
            return this._size.width;
        },
        getHeight: function() {
            return this._size.height;
        },
        isEmpty: function() {
            return 0 === this._size.width && 0 === this._size.height;
        },
        getResolution: function() {
            var a = this._matrix, b = new h(0, 0).transform(a), c = new h(1, 0).transform(a).subtract(b), d = new h(0, 1).transform(a).subtract(b);
            return new k(72 / c.getLength(), 72 / d.getLength());
        },
        getPpi: "#getResolution",
        getImage: function() {
            return this._image;
        },
        setImage: function(a) {
            this._canvas && Z.release(this._canvas), a && a.getContext ? (this._image = null, 
            this._canvas = a) : (this._image = a, this._canvas = null), this._size = new k(a ? a.naturalWidth || a.width : 0, a ? a.naturalHeight || a.height : 0), 
            this._context = null, this._changed(521);
        },
        getCanvas: function() {
            if (!this._canvas) {
                var a = Z.getContext(this._size);
                try {
                    this._image && a.drawImage(this._image, 0, 0), this._canvas = a.canvas;
                } catch (b) {
                    Z.release(a);
                }
            }
            return this._canvas;
        },
        setCanvas: "#setImage",
        getContext: function(a) {
            return this._context || (this._context = this.getCanvas().getContext("2d")), a && (this._image = null, 
            this._changed(513)), this._context;
        },
        setContext: function(a) {
            this._context = a;
        },
        getSource: function() {
            return this._image && this._image.src || this.toDataURL();
        },
        setSource: function(a) {
            function b() {
                var a = d.getView();
                a && (paper = a._scope, d.setImage(c), d.emit("load"), a.update());
            }
            var c, d = this;
            c = document.getElementById(a) || new Image(), c.naturalWidth && c.naturalHeight ? setTimeout(b, 0) : (Q.add(c, {
                load: b
            }), c.src || (c.src = a)), this.setImage(c);
        },
        getElement: function() {
            return this._canvas || this._image;
        }
    }, {
        beans: !1,
        getSubCanvas: function() {
            var a = n.read(arguments), b = Z.getContext(a.getSize());
            return b.drawImage(this.getCanvas(), a.x, a.y, a.width, a.height, 0, 0, a.width, a.height), 
            b.canvas;
        },
        getSubRaster: function() {
            var a = n.read(arguments), b = new x(t.NO_INSERT);
            return b.setCanvas(this.getSubCanvas(a)), b.translate(a.getCenter().subtract(this.getSize().divide(2))), 
            b._matrix.preConcatenate(this._matrix), b.insertAbove(this), b;
        },
        toDataURL: function() {
            var a = this._image && this._image.src;
            if (/^data:/.test(a)) return a;
            var b = this.getCanvas();
            return b ? b.toDataURL() : null;
        },
        drawImage: function(a) {
            var b = h.read(arguments, 1);
            this.getContext(!0).drawImage(a, b.x, b.y);
        },
        getAverageColor: function(a) {
            var c, d;
            a ? a instanceof E ? (d = a, c = a.getBounds()) : a.width ? c = new n(a) : a.x && (c = new n(a.x - .5, a.y - .5, 1, 1)) : c = this.getBounds();
            var e = 32, f = Math.min(c.width, e), g = Math.min(c.height, e), h = x._sampleContext;
            h ? h.clearRect(0, 0, e + 1, e + 1) : h = x._sampleContext = Z.getContext(new k(e)), 
            h.save();
            var i = new p().scale(f / c.width, g / c.height).translate(-c.x, -c.y);
            i.applyToContext(h), d && d.draw(h, new b({
                clip: !0,
                matrices: [ i ]
            })), this._matrix.applyToContext(h), h.drawImage(this.getElement(), -this._size.width / 2, -this._size.height / 2), 
            h.restore();
            for (var j = h.getImageData(.5, .5, Math.ceil(f), Math.ceil(g)).data, l = [ 0, 0, 0 ], m = 0, o = 0, q = j.length; q > o; o += 4) {
                var r = j[o + 3];
                m += r, r /= 255, l[0] += j[o] * r, l[1] += j[o + 1] * r, l[2] += j[o + 2] * r;
            }
            for (var o = 0; 3 > o; o++) l[o] /= m;
            return m ? L.read(l) : null;
        },
        getPixel: function() {
            var a = h.read(arguments), b = this.getContext().getImageData(a.x, a.y, 1, 1).data;
            return new L("rgb", [ b[0] / 255, b[1] / 255, b[2] / 255 ], b[3] / 255);
        },
        setPixel: function() {
            var a = h.read(arguments), b = L.read(arguments), c = b._convert("rgb"), d = b._alpha, e = this.getContext(!0), f = e.createImageData(1, 1), g = f.data;
            g[0] = 255 * c[0], g[1] = 255 * c[1], g[2] = 255 * c[2], g[3] = null != d ? 255 * d : 255, 
            e.putImageData(f, a.x, a.y);
        },
        createImageData: function() {
            var a = k.read(arguments);
            return this.getContext().createImageData(a.width, a.height);
        },
        getImageData: function() {
            var a = n.read(arguments);
            return a.isEmpty() && (a = new n(this._size)), this.getContext().getImageData(a.x, a.y, a.width, a.height);
        },
        setImageData: function(a) {
            var b = h.read(arguments, 1);
            this.getContext(!0).putImageData(a, b.x, b.y);
        },
        _getBounds: function(a, b) {
            var c = new n(this._size).setCenter(0, 0);
            return b ? b._transformBounds(c) : c;
        },
        _hitTestSelf: function(a) {
            if (this._contains(a)) {
                var b = this;
                return new z("pixel", b, {
                    offset: a.add(b._size.divide(2)).round(),
                    color: {
                        get: function() {
                            return b.getPixel(this.offset);
                        }
                    }
                });
            }
        },
        _draw: function(a) {
            var b = this.getElement();
            b && (a.globalAlpha = this._opacity, a.drawImage(b, -this._size.width / 2, -this._size.height / 2));
        },
        _canComposite: function() {
            return !0;
        }
    }), y = t.extend({
        _class: "PlacedSymbol",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsGetter: {
            getBounds: "getStrokeBounds"
        },
        _boundsSelected: !0,
        _serializeFields: {
            symbol: null
        },
        initialize: function(b, c) {
            this._initialize(b, c !== a && h.read(arguments, 1)) || this.setSymbol(b instanceof s ? b : new s(b));
        },
        _equals: function(a) {
            return this._symbol === a._symbol;
        },
        getSymbol: function() {
            return this._symbol;
        },
        setSymbol: function(a) {
            this._symbol = a, this._changed(9);
        },
        clone: function(a) {
            var b = new y(t.NO_INSERT);
            return b.setSymbol(this._symbol), this._clone(b, a);
        },
        isEmpty: function() {
            return this._symbol._definition.isEmpty();
        },
        _getBounds: function(a, b, c) {
            var d = this.symbol._definition;
            return d._getCachedBounds(a, b && b.chain(d._matrix), c);
        },
        _hitTestSelf: function(a, b) {
            var c = this._symbol._definition._hitTest(a, b);
            return c && (c.item = this), c;
        },
        _draw: function(a, b) {
            this.symbol._definition.draw(a, b);
        }
    }), z = b.extend({
        _class: "HitResult",
        initialize: function(a, b, c) {
            this.type = a, this.item = b, c && (c.enumerable = !0, this.inject(c));
        },
        statics: {
            getOptions: function(a) {
                return new b({
                    type: null,
                    tolerance: paper.settings.hitTolerance,
                    fill: !a,
                    stroke: !a,
                    segments: !a,
                    handles: !1,
                    ends: !1,
                    center: !1,
                    bounds: !1,
                    guides: !1,
                    selected: !1
                }, a);
            }
        }
    }), A = b.extend({
        _class: "Segment",
        beans: !0,
        initialize: function(b, c, d, e, f, g) {
            var h, i, j, k = arguments.length;
            0 === k || (1 === k ? b.point ? (h = b.point, i = b.handleIn, j = b.handleOut) : h = b : 2 === k && "number" == typeof b ? h = arguments : 3 >= k ? (h = b, 
            i = c, j = d) : (h = b !== a ? [ b, c ] : null, i = d !== a ? [ d, e ] : null, j = f !== a ? [ f, g ] : null)), 
            new B(h, this, "_point"), new B(i, this, "_handleIn"), new B(j, this, "_handleOut");
        },
        _serialize: function(a) {
            return b.serialize(this.isLinear() ? this._point : [ this._point, this._handleIn, this._handleOut ], a, !0);
        },
        _changed: function(a) {
            var b = this._path;
            if (b) {
                var c, d = b._curves, e = this._index;
                d && (a && a !== this._point && a !== this._handleIn || !(c = e > 0 ? d[e - 1] : b._closed ? d[d.length - 1] : null) || c._changed(), 
                a && a !== this._point && a !== this._handleOut || !(c = d[e]) || c._changed()), 
                b._changed(25);
            }
        },
        getPoint: function() {
            return this._point;
        },
        setPoint: function() {
            var a = h.read(arguments);
            this._point.set(a.x, a.y);
        },
        getHandleIn: function() {
            return this._handleIn;
        },
        setHandleIn: function() {
            var a = h.read(arguments);
            this._handleIn.set(a.x, a.y);
        },
        getHandleOut: function() {
            return this._handleOut;
        },
        setHandleOut: function() {
            var a = h.read(arguments);
            this._handleOut.set(a.x, a.y);
        },
        isLinear: function() {
            return this._handleIn.isZero() && this._handleOut.isZero();
        },
        setLinear: function(a) {
            a && (this._handleIn.set(0, 0), this._handleOut.set(0, 0));
        },
        isColinear: function(a) {
            var b = this.getNext(), c = a.getNext();
            return this._handleOut.isZero() && b._handleIn.isZero() && a._handleOut.isZero() && c._handleIn.isZero() && b._point.subtract(this._point).isColinear(c._point.subtract(a._point));
        },
        isOrthogonal: function() {
            var a = this.getPrevious(), b = this.getNext();
            return a._handleOut.isZero() && this._handleIn.isZero() && this._handleOut.isZero() && b._handleIn.isZero() && this._point.subtract(a._point).isOrthogonal(b._point.subtract(this._point));
        },
        isArc: function() {
            var a = this.getNext(), b = this._handleOut, c = a._handleIn, d = .5522847498307936;
            if (b.isOrthogonal(c)) {
                var e = this._point, f = a._point, h = new q(e, b, !0).intersect(new q(f, c, !0), !0);
                return h && g.isZero(b.getLength() / h.subtract(e).getLength() - d) && g.isZero(c.getLength() / h.subtract(f).getLength() - d);
            }
            return !1;
        },
        _selectionState: 0,
        isSelected: function(a) {
            var b = this._selectionState;
            return a ? a === this._point ? !!(4 & b) : a === this._handleIn ? !!(1 & b) : a === this._handleOut ? !!(2 & b) : !1 : !!(7 & b);
        },
        setSelected: function(a, b) {
            var c = this._path, a = !!a, d = this._selectionState, e = d, f = b ? b === this._point ? 4 : b === this._handleIn ? 1 : b === this._handleOut ? 2 : 0 : 7;
            a ? d |= f : d &= ~f, this._selectionState = d, c && d !== e && (c._updateSelection(this, e, d), 
            c._changed(129));
        },
        getIndex: function() {
            return this._index !== a ? this._index : null;
        },
        getPath: function() {
            return this._path || null;
        },
        getCurve: function() {
            var a = this._path, b = this._index;
            return a ? (b > 0 && !a._closed && b === a._segments.length - 1 && b--, a.getCurves()[b] || null) : null;
        },
        getLocation: function() {
            var a = this.getCurve();
            return a ? new D(a, this === a._segment1 ? 0 : 1) : null;
        },
        getNext: function() {
            var a = this._path && this._path._segments;
            return a && (a[this._index + 1] || this._path._closed && a[0]) || null;
        },
        getPrevious: function() {
            var a = this._path && this._path._segments;
            return a && (a[this._index - 1] || this._path._closed && a[a.length - 1]) || null;
        },
        reverse: function() {
            return new A(this._point, this._handleOut, this._handleIn);
        },
        remove: function() {
            return this._path ? !!this._path.removeSegment(this._index) : !1;
        },
        clone: function() {
            return new A(this._point, this._handleIn, this._handleOut);
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && this._point.equals(a._point) && this._handleIn.equals(a._handleIn) && this._handleOut.equals(a._handleOut) || !1;
        },
        toString: function() {
            var a = [ "point: " + this._point ];
            return this._handleIn.isZero() || a.push("handleIn: " + this._handleIn), this._handleOut.isZero() || a.push("handleOut: " + this._handleOut), 
            "{ " + a.join(", ") + " }";
        },
        transform: function(a) {
            this._transformCoordinates(a, new Array(6), !0), this._changed();
        },
        _transformCoordinates: function(a, b, c) {
            var d = this._point, e = c && this._handleIn.isZero() ? null : this._handleIn, f = c && this._handleOut.isZero() ? null : this._handleOut, g = d._x, h = d._y, i = 2;
            return b[0] = g, b[1] = h, e && (b[i++] = e._x + g, b[i++] = e._y + h), f && (b[i++] = f._x + g, 
            b[i++] = f._y + h), a && (a._transformCoordinates(b, b, i / 2), g = b[0], h = b[1], 
            c ? (d._x = g, d._y = h, i = 2, e && (e._x = b[i++] - g, e._y = b[i++] - h), f && (f._x = b[i++] - g, 
            f._y = b[i++] - h)) : (e || (b[i++] = g, b[i++] = h), f || (b[i++] = g, b[i++] = h))), 
            b;
        }
    }), B = h.extend({
        initialize: function(b, c, d) {
            var e, f, g;
            if (b) if ((e = b[0]) !== a) f = b[1]; else {
                var i = b;
                (e = i.x) === a && (i = h.read(arguments), e = i.x), f = i.y, g = i.selected;
            } else e = f = 0;
            this._x = e, this._y = f, this._owner = c, c[d] = this, g && this.setSelected(!0);
        },
        set: function(a, b) {
            return this._x = a, this._y = b, this._owner._changed(this), this;
        },
        _serialize: function(a) {
            var b = a.formatter, c = b.number(this._x), d = b.number(this._y);
            return this.isSelected() ? {
                x: c,
                y: d,
                selected: !0
            } : [ c, d ];
        },
        getX: function() {
            return this._x;
        },
        setX: function(a) {
            this._x = a, this._owner._changed(this);
        },
        getY: function() {
            return this._y;
        },
        setY: function(a) {
            this._y = a, this._owner._changed(this);
        },
        isZero: function() {
            return g.isZero(this._x) && g.isZero(this._y);
        },
        setSelected: function(a) {
            this._owner.setSelected(a, this);
        },
        isSelected: function() {
            return this._owner.isSelected(this);
        }
    }), C = b.extend({
        _class: "Curve",
        initialize: function(a, b, c, d, e, f, g, h) {
            var i = arguments.length;
            if (3 === i) this._path = a, this._segment1 = b, this._segment2 = c; else if (0 === i) this._segment1 = new A(), 
            this._segment2 = new A(); else if (1 === i) this._segment1 = new A(a.segment1), 
            this._segment2 = new A(a.segment2); else if (2 === i) this._segment1 = new A(a), 
            this._segment2 = new A(b); else {
                var j, k, l, m;
                4 === i ? (j = a, k = b, l = c, m = d) : 8 === i && (j = [ a, b ], m = [ g, h ], 
                k = [ c - a, d - b ], l = [ e - g, f - h ]), this._segment1 = new A(j, null, k), 
                this._segment2 = new A(m, l, null);
            }
        },
        _changed: function() {
            this._length = this._bounds = a;
        },
        getPoint1: function() {
            return this._segment1._point;
        },
        setPoint1: function() {
            var a = h.read(arguments);
            this._segment1._point.set(a.x, a.y);
        },
        getPoint2: function() {
            return this._segment2._point;
        },
        setPoint2: function() {
            var a = h.read(arguments);
            this._segment2._point.set(a.x, a.y);
        },
        getHandle1: function() {
            return this._segment1._handleOut;
        },
        setHandle1: function() {
            var a = h.read(arguments);
            this._segment1._handleOut.set(a.x, a.y);
        },
        getHandle2: function() {
            return this._segment2._handleIn;
        },
        setHandle2: function() {
            var a = h.read(arguments);
            this._segment2._handleIn.set(a.x, a.y);
        },
        getSegment1: function() {
            return this._segment1;
        },
        getSegment2: function() {
            return this._segment2;
        },
        getPath: function() {
            return this._path;
        },
        getIndex: function() {
            return this._segment1._index;
        },
        getNext: function() {
            var a = this._path && this._path._curves;
            return a && (a[this._segment1._index + 1] || this._path._closed && a[0]) || null;
        },
        getPrevious: function() {
            var a = this._path && this._path._curves;
            return a && (a[this._segment1._index - 1] || this._path._closed && a[a.length - 1]) || null;
        },
        isSelected: function() {
            return this.getPoint1().isSelected() && this.getHandle2().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
        },
        setSelected: function(a) {
            this.getPoint1().setSelected(a), this.getHandle1().setSelected(a), this.getHandle2().setSelected(a), 
            this.getPoint2().setSelected(a);
        },
        getValues: function(a) {
            return C.getValues(this._segment1, this._segment2, a);
        },
        getPoints: function() {
            for (var a = this.getValues(), b = [], c = 0; 8 > c; c += 2) b.push(new h(a[c], a[c + 1]));
            return b;
        },
        getLength: function() {
            return null == this._length && (this._length = this.isLinear() ? this._segment2._point.getDistance(this._segment1._point) : C.getLength(this.getValues(), 0, 1)), 
            this._length;
        },
        getArea: function() {
            return C.getArea(this.getValues());
        },
        getPart: function(a, b) {
            return new C(C.getPart(this.getValues(), a, b));
        },
        getPartLength: function(a, b) {
            return C.getLength(this.getValues(), a, b);
        },
        isLinear: function() {
            return this._segment1._handleOut.isZero() && this._segment2._handleIn.isZero();
        },
        isHorizontal: function() {
            return this.isLinear() && g.isZero(this._segment1._point._y - this._segment2._point._y);
        },
        getIntersections: function(a) {
            return C.getIntersections(this.getValues(), a.getValues(), this, a, []);
        },
        _getParameter: function(b, c) {
            return c ? b : b && b.curve === this ? b.parameter : b === a && c === a ? .5 : this.getParameterAt(b, 0);
        },
        divide: function(a, b, c) {
            var d = this._getParameter(a, b), e = 1e-5, f = null;
            if (d > e && 1 - e > d) {
                var g = C.subdivide(this.getValues(), d), i = c ? !1 : this.isLinear(), j = g[0], k = g[1];
                i || (this._segment1._handleOut.set(j[2] - j[0], j[3] - j[1]), this._segment2._handleIn.set(k[4] - k[6], k[5] - k[7]));
                var l = j[6], m = j[7], n = new A(new h(l, m), !i && new h(j[4] - l, j[5] - m), !i && new h(k[2] - l, k[3] - m));
                if (this._path) this._segment1._index > 0 && 0 === this._segment2._index ? this._path.add(n) : this._path.insert(this._segment2._index, n), 
                f = this; else {
                    var o = this._segment2;
                    this._segment2 = n, f = new C(n, o);
                }
            }
            return f;
        },
        split: function(a, b) {
            return this._path ? this._path.split(this._segment1._index, this._getParameter(a, b)) : null;
        },
        reverse: function() {
            return new C(this._segment2.reverse(), this._segment1.reverse());
        },
        remove: function() {
            var a = !1;
            if (this._path) {
                var b = this._segment2, c = b._handleOut;
                a = b.remove(), a && this._segment1._handleOut.set(c.x, c.y);
            }
            return a;
        },
        clone: function() {
            return new C(this._segment1, this._segment2);
        },
        toString: function() {
            var a = [ "point1: " + this._segment1._point ];
            return this._segment1._handleOut.isZero() || a.push("handle1: " + this._segment1._handleOut), 
            this._segment2._handleIn.isZero() || a.push("handle2: " + this._segment2._handleIn), 
            a.push("point2: " + this._segment2._point), "{ " + a.join(", ") + " }";
        },
        statics: {
            getValues: function(a, b, c) {
                var d = a._point, e = a._handleOut, f = b._handleIn, g = b._point, h = [ d._x, d._y, d._x + e._x, d._y + e._y, g._x + f._x, g._y + f._y, g._x, g._y ];
                return c && c._transformCoordinates(h, h, 4), h;
            },
            evaluate: function(a, b, c) {
                var d, e, f = a[0], g = a[1], i = a[2], j = a[3], k = a[4], l = a[5], m = a[6], n = a[7], o = 1e-5;
                if (0 === c && (o > b || b > 1 - o)) {
                    var p = o > b;
                    d = p ? f : m, e = p ? g : n;
                } else {
                    var q = 3 * (i - f), r = 3 * (k - i) - q, s = m - f - q - r, t = 3 * (j - g), u = 3 * (l - j) - t, v = n - g - t - u;
                    if (0 === c) d = ((s * b + r) * b + q) * b + f, e = ((v * b + u) * b + t) * b + g; else if (o > b && i === f && j === g || b > 1 - o && k === m && l === n ? (d = k - i, 
                    e = l - j) : o > b ? (d = q, e = t) : b > 1 - o ? (d = 3 * (m - k), e = 3 * (n - l)) : (d = (3 * s * b + 2 * r) * b + q, 
                    e = (3 * v * b + 2 * u) * b + t), 3 === c) {
                        var w = 6 * s * b + 2 * r, x = 6 * v * b + 2 * u;
                        return (d * x - e * w) / Math.pow(d * d + e * e, 1.5);
                    }
                }
                return 2 === c ? new h(e, -d) : new h(d, e);
            },
            subdivide: function(b, c) {
                var d = b[0], e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7];
                c === a && (c = .5);
                var l = 1 - c, m = l * d + c * f, n = l * e + c * g, o = l * f + c * h, p = l * g + c * i, q = l * h + c * j, r = l * i + c * k, s = l * m + c * o, t = l * n + c * p, u = l * o + c * q, v = l * p + c * r, w = l * s + c * u, x = l * t + c * v;
                return [ [ d, e, m, n, s, t, w, x ], [ w, x, u, v, q, r, j, k ] ];
            },
            solveCubic: function(a, b, c, d, e, f) {
                var h = a[b], i = a[b + 2], j = a[b + 4], k = a[b + 6], l = 3 * (i - h), m = 3 * (j - i) - l, n = k - h - l - m;
                return g.solveCubic(n, m, l, h - c, d, e, f);
            },
            getParameterOf: function(a, b, c) {
                var d = 1e-5;
                if (Math.abs(a[0] - b) < d && Math.abs(a[1] - c) < d) return 0;
                if (Math.abs(a[6] - b) < d && Math.abs(a[7] - c) < d) return 1;
                for (var e, f, g = [], h = [], i = C.solveCubic(a, 0, b, g, 0, 1), j = C.solveCubic(a, 1, c, h, 0, 1), k = 0; -1 == i || i > k; ) if (-1 == i || (e = g[k++]) >= 0 && 1 >= e) {
                    for (var l = 0; -1 == j || j > l; ) if ((-1 == j || (f = h[l++]) >= 0 && 1 >= f) && (-1 == i ? e = f : -1 == j && (f = e), 
                    Math.abs(e - f) < d)) return .5 * (e + f);
                    if (-1 == i) break;
                }
                return null;
            },
            getPart: function(a, b, c) {
                return b > 0 && (a = C.subdivide(a, b)[1]), 1 > c && (a = C.subdivide(a, (c - b) / (1 - b))[0]), 
                a;
            },
            isLinear: function(a) {
                var b = g.isZero;
                return b(a[0] - a[2]) && b(a[1] - a[3]) && b(a[4] - a[6]) && b(a[5] - a[7]);
            },
            isFlatEnough: function(a, b) {
                var c = a[0], d = a[1], e = a[2], f = a[3], g = a[4], h = a[5], i = a[6], j = a[7], k = 3 * e - 2 * c - i, l = 3 * f - 2 * d - j, m = 3 * g - 2 * i - c, n = 3 * h - 2 * j - d;
                return Math.max(k * k, m * m) + Math.max(l * l, n * n) < 10 * b * b;
            },
            getArea: function(a) {
                var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7];
                return (3 * e * b - 1.5 * e * f - 1.5 * e * h - 3 * c * d - 1.5 * c * f - .5 * c * h + 1.5 * g * b + 1.5 * g * d - 3 * g * h + .5 * i * b + 1.5 * i * d + 3 * i * f) / 10;
            },
            getBounds: function(a) {
                for (var b = a.slice(0, 2), c = b.slice(), d = [ 0, 0 ], e = 0; 2 > e; e++) C._addBounds(a[e], a[e + 2], a[e + 4], a[e + 6], e, 0, b, c, d);
                return new n(b[0], b[1], c[0] - b[0], c[1] - b[1]);
            },
            _addBounds: function(a, b, c, d, e, f, h, i, j) {
                function k(a, b) {
                    var c = a - b, d = a + b;
                    c < h[e] && (h[e] = c), d > i[e] && (i[e] = d);
                }
                var l = 3 * (b - c) - a + d, m = 2 * (a + c) - 4 * b, n = b - a, o = g.solveQuadratic(l, m, n, j), p = 1e-5, q = 1 - p;
                k(d, 0);
                for (var r = 0; o > r; r++) {
                    var s = j[r], t = 1 - s;
                    s > p && q > s && k(t * t * t * a + 3 * t * t * s * b + 3 * t * s * s * c + s * s * s * d, f);
                }
            }
        }
    }, b.each([ "getBounds", "getStrokeBounds", "getHandleBounds", "getRoughBounds" ], function(a) {
        this[a] = function() {
            this._bounds || (this._bounds = {});
            var b = this._bounds[a];
            return b || (b = this._bounds[a] = F[a]([ this._segment1, this._segment2 ], !1, this._path.getStyle())), 
            b.clone();
        };
    }, {}), b.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(a, b) {
        this[a + "At"] = function(a, c) {
            var d = this.getValues();
            return C.evaluate(d, c ? a : C.getParameterAt(d, a, 0), b);
        }, this[a] = function(a) {
            return C.evaluate(this.getValues(), a, b);
        };
    }, {
        beans: !1,
        getParameterAt: function(a, b) {
            return C.getParameterAt(this.getValues(), a, b);
        },
        getParameterOf: function() {
            var a = h.read(arguments);
            return C.getParameterOf(this.getValues(), a.x, a.y);
        },
        getLocationAt: function(a, b) {
            return b || (a = this.getParameterAt(a)), a >= 0 && 1 >= a && new D(this, a);
        },
        getLocationOf: function() {
            return this.getLocationAt(this.getParameterOf(h.read(arguments)), !0);
        },
        getOffsetOf: function() {
            var a = this.getLocationOf.apply(this, arguments);
            return a ? a.getOffset() : null;
        },
        getNearestLocation: function() {
            function a(a) {
                if (a >= 0 && 1 >= a) {
                    var d = b.getDistance(C.evaluate(c, a, 0), !0);
                    if (e > d) return e = d, f = a, !0;
                }
            }
            for (var b = h.read(arguments), c = this.getValues(), d = 100, e = 1 / 0, f = 0, g = 0; d >= g; g++) a(g / d);
            for (var i = 1 / (2 * d); i > 1e-5; ) a(f - i) || a(f + i) || (i /= 2);
            var j = C.evaluate(c, f, 0);
            return new D(this, f, j, null, null, null, b.getDistance(j));
        },
        getNearestPoint: function() {
            return this.getNearestLocation.apply(this, arguments).getPoint();
        }
    }), new function() {
        function b(a) {
            var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], j = 9 * (d - f) + 3 * (h - b), k = 6 * (b + f) - 12 * d, l = 3 * (d - b), m = 9 * (e - g) + 3 * (i - c), n = 6 * (c + g) - 12 * e, o = 3 * (e - c);
            return function(a) {
                var b = (j * a + k) * a + l, c = (m * a + n) * a + o;
                return Math.sqrt(b * b + c * c);
            };
        }
        function c(a, b) {
            return Math.max(2, Math.min(16, Math.ceil(32 * Math.abs(b - a))));
        }
        return {
            statics: !0,
            getLength: function(d, e, f) {
                e === a && (e = 0), f === a && (f = 1);
                var h = g.isZero;
                if (0 === e && 1 === f && h(d[0] - d[2]) && h(d[1] - d[3]) && h(d[6] - d[4]) && h(d[7] - d[5])) {
                    var i = d[6] - d[0], j = d[7] - d[1];
                    return Math.sqrt(i * i + j * j);
                }
                var k = b(d);
                return g.integrate(k, e, f, c(e, f));
            },
            getParameterAt: function(d, e, f) {
                function h(a) {
                    return o += g.integrate(l, f, a, c(f, a)), f = a, o - e;
                }
                if (f === a && (f = 0 > e ? 1 : 0), 0 === e) return f;
                var i = e > 0, j = i ? f : 0, k = i ? 1 : f, l = b(d), m = g.integrate(l, j, k, c(j, k));
                if (Math.abs(e) >= m) return i ? k : j;
                var n = e / m, o = 0;
                return g.findRoot(h, l, f + n, j, k, 16, 1e-5);
            }
        };
    }(), new function() {
        function a(a, b, c, d, e, f, g, h) {
            var i = new D(c, d, e, f, g, h);
            (!b || b(i)) && a.push(i);
        }
        function b(e, f, g, h, i, j, k, l, m, n, o, p, r) {
            if (!(r > 20)) {
                var s, t, u, v = f[0], w = f[1], x = f[6], y = f[7], z = 1e-5, A = 1e-9, B = q.getSignedDistance, D = B(v, w, x, y, f[2], f[3]) || 0, E = B(v, w, x, y, f[4], f[5]) || 0, F = D * E > 0 ? .75 : 4 / 9, G = F * Math.min(0, D, E), H = F * Math.max(0, D, E), I = B(v, w, x, y, e[0], e[1]), J = B(v, w, x, y, e[2], e[3]), K = B(v, w, x, y, e[4], e[5]), L = B(v, w, x, y, e[6], e[7]);
                if (v === x && A >= n - m && r > 3) s = (l + k) / 2, t = s, u = 0; else {
                    var M, N, O = c(I, J, K, L), P = O[0], Q = O[1];
                    if (M = d(P, Q, G, H), P.reverse(), Q.reverse(), N = d(P, Q, G, H), null == M || null == N) return !1;
                    e = C.getPart(e, M, N), u = N - M, s = l * M + k * (1 - M), t = l * N + k * (1 - N);
                }
                if (o > .8 && u > .8) if (t - s > n - m) {
                    var R = C.subdivide(e, .5), S = s + (t - s) / 2;
                    b(f, R[0], h, g, i, j, m, n, s, S, u, !p, ++r), b(f, R[1], h, g, i, j, m, n, S, t, u, !p, r);
                } else {
                    var R = C.subdivide(f, .5), S = m + (n - m) / 2;
                    b(R[0], e, h, g, i, j, m, S, s, t, u, !p, ++r), b(R[1], e, h, g, i, j, S, n, s, t, u, !p, r);
                } else if (Math.max(n - m, t - s) < z) {
                    var T = s + (t - s) / 2, U = m + (n - m) / 2;
                    p ? a(i, j, h, U, C.evaluate(f, U, 0), g, T, C.evaluate(e, T, 0)) : a(i, j, g, T, C.evaluate(e, T, 0), h, U, C.evaluate(f, U, 0));
                } else b(f, e, h, g, i, j, m, n, s, t, u, !p, ++r);
            }
        }
        function c(a, b, c, d) {
            var e, f = [ 0, a ], g = [ 1 / 3, b ], h = [ 2 / 3, c ], i = [ 1, d ], j = q.getSignedDistance, k = j(0, a, 1, d, 1 / 3, b), l = j(0, a, 1, d, 2 / 3, c), m = !1;
            if (0 > k * l) e = [ [ f, g, i ], [ f, h, i ] ], m = 0 > k; else {
                var n, o = 0, p = 0 === k || 0 === l;
                Math.abs(k) > Math.abs(l) ? (n = g, o = (d - c - (d - a) / 3) * (2 * (d - c) - d + b) / 3) : (n = h, 
                o = (b - a + (a - d) / 3) * (-2 * (a - b) + a - c) / 3), e = 0 > o || p ? [ [ f, n, i ], [ f, i ] ] : [ [ f, g, h, i ], [ f, i ] ], 
                m = k ? 0 > k : 0 > l;
            }
            return m ? e.reverse() : e;
        }
        function d(a, b, c, d) {
            for (var e, f, g, h, i, j = null, k = 0, l = b.length - 1; l > k; k++) {
                if (g = b[k][1], i = b[k + 1][1], i > g) e = null; else {
                    if (!(d >= i)) continue;
                    f = b[k][0], h = b[k + 1][0], e = f + (d - g) * (h - f) / (i - g);
                }
                break;
            }
            a[0][1] <= d && (e = a[0][0]);
            for (var k = 0, l = a.length - 1; l > k; k++) {
                if (g = a[k][1], i = a[k + 1][1], g >= c) j = e; else if (g > i) j = null; else {
                    if (!(i >= c)) continue;
                    f = a[k][0], h = a[k + 1][0], j = f + (c - g) * (h - f) / (i - g);
                }
                break;
            }
            return j;
        }
        function e(b, c, d, e, f, g) {
            for (var h = C.isLinear(b), i = h ? c : b, j = h ? b : c, k = j[0], l = j[1], m = j[6], n = j[7], o = m - k, p = n - l, q = Math.atan2(-p, o), r = Math.sin(q), s = Math.cos(q), t = o * s - p * r, u = [ 0, 0, 0, 0, t, 0, t, 0 ], v = [], w = 0; 8 > w; w += 2) {
                var x = i[w] - k, y = i[w + 1] - l;
                v.push(x * s - y * r, y * s + x * r);
            }
            for (var z = [], A = C.solveCubic(v, 1, 0, z, 0, 1), w = 0; A > w; w++) {
                var B = z[w], x = C.evaluate(v, B, 0).x;
                if (x >= 0 && t >= x) {
                    var D = C.getParameterOf(u, x, 0), E = h ? D : B, F = h ? B : D;
                    a(f, g, d, E, C.evaluate(b, E, 0), e, F, C.evaluate(c, F, 0));
                }
            }
        }
        function f(b, c, d, e, f, g) {
            var h = q.intersect(b[0], b[1], b[6], b[7], c[0], c[1], c[6], c[7]);
            if (h) {
                var i = h.x, j = h.y;
                a(f, g, d, C.getParameterOf(b, i, j), h, e, C.getParameterOf(c, i, j), h);
            }
        }
        return {
            statics: {
                getIntersections: function(a, c, d, g, h, i) {
                    var j = C.isLinear(a), k = C.isLinear(c);
                    return (j && k ? f : j || k ? e : b)(a, c, d, g, h, i, 0, 1, 0, 1, 0, !1, 0), h;
                }
            }
        };
    }()), D = b.extend({
        _class: "CurveLocation",
        beans: !0,
        initialize: function qa(a, b, c, d, e, f, g) {
            this._id = qa._id = (qa._id || 0) + 1, this._curve = a, this._segment1 = a._segment1, 
            this._segment2 = a._segment2, this._parameter = b, this._point = c, this._curve2 = d, 
            this._parameter2 = e, this._point2 = f, this._distance = g;
        },
        getSegment: function(a) {
            if (!this._segment) {
                var b = this.getCurve(), c = this.getParameter();
                if (1 === c) this._segment = b._segment2; else if (0 === c || a) this._segment = b._segment1; else {
                    if (null == c) return null;
                    this._segment = b.getPartLength(0, c) < b.getPartLength(c, 1) ? b._segment1 : b._segment2;
                }
            }
            return this._segment;
        },
        getCurve: function(a) {
            return (!this._curve || a) && (this._curve = this._segment1.getCurve(), null == this._curve.getParameterOf(this._point) && (this._curve = this._segment2.getPrevious().getCurve())), 
            this._curve;
        },
        getIntersection: function() {
            var a = this._intersection;
            if (!a && this._curve2) {
                var b = this._parameter2;
                this._intersection = a = new D(this._curve2, b, this._point2 || this._point, this), 
                a._intersection = this;
            }
            return a;
        },
        getPath: function() {
            var a = this.getCurve();
            return a && a._path;
        },
        getIndex: function() {
            var a = this.getCurve();
            return a && a.getIndex();
        },
        getOffset: function() {
            var a = this.getPath();
            return a ? a._getOffset(this) : this.getCurveOffset();
        },
        getCurveOffset: function() {
            var a = this.getCurve(), b = this.getParameter();
            return null != b && a && a.getPartLength(0, b);
        },
        getParameter: function(a) {
            if ((null == this._parameter || a) && this._point) {
                var b = this.getCurve(a);
                this._parameter = b && b.getParameterOf(this._point);
            }
            return this._parameter;
        },
        getPoint: function(a) {
            if ((!this._point || a) && null != this._parameter) {
                var b = this.getCurve(a);
                this._point = b && b.getPointAt(this._parameter, !0);
            }
            return this._point;
        },
        getDistance: function() {
            return this._distance;
        },
        divide: function() {
            var a = this.getCurve(!0);
            return a && a.divide(this.getParameter(!0), !0);
        },
        split: function() {
            var a = this.getCurve(!0);
            return a && a.split(this.getParameter(!0), !0);
        },
        equals: function(a) {
            var b = g.isZero;
            return this === a || a && this._curve === a._curve && this._curve2 === a._curve2 && b(this._parameter - a._parameter) && b(this._parameter2 - a._parameter2) || !1;
        },
        toString: function() {
            var a = [], b = this.getPoint(), c = f.instance;
            b && a.push("point: " + b);
            var d = this.getIndex();
            null != d && a.push("index: " + d);
            var e = this.getParameter();
            return null != e && a.push("parameter: " + c.number(e)), null != this._distance && a.push("distance: " + c.number(this._distance)), 
            "{ " + a.join(", ") + " }";
        }
    }, b.each([ "getTangent", "getNormal", "getCurvature" ], function(a) {
        var b = a + "At";
        this[a] = function() {
            var a = this.getParameter(), c = this.getCurve();
            return null != a && c && c[b](a, !0);
        };
    }, {})), E = t.extend({
        _class: "PathItem",
        initialize: function() {},
        getIntersections: function(a, b, c) {
            function d(a, b) {
                var c = a.getPath(), d = b.getPath();
                return c === d ? a.getIndex() + a.getParameter() - (b.getIndex() + b.getParameter()) : c._id - d._id;
            }
            this === a && (a = null);
            var e = [], f = this.getCurves(), g = a ? a.getCurves() : f, h = this._matrix.orNullIfIdentity(), i = a ? (b || a._matrix).orNullIfIdentity() : h, j = f.length, k = a ? g.length : j, l = [], m = 1e-11, n = 1 - 1e-11;
            if (a && !this.getBounds(h).touches(a.getBounds(i))) return [];
            for (var o = 0; k > o; o++) l[o] = g[o].getValues(i);
            for (var o = 0; j > o; o++) {
                var p = f[o], r = a ? p.getValues(h) : l[o];
                if (!a) {
                    var s = p.getSegment1(), t = p.getSegment2(), u = s._handleOut, v = t._handleIn;
                    if (new q(s._point.subtract(u), u.multiply(2), !0).intersect(new q(t._point.subtract(v), v.multiply(2), !0), !1)) {
                        var w = C.subdivide(r);
                        C.getIntersections(w[0], w[1], p, p, e, function(a) {
                            return a._parameter <= n ? (a._parameter /= 2, a._parameter2 = .5 + a._parameter2 / 2, 
                            !0) : void 0;
                        });
                    }
                }
                for (var x = a ? 0 : o + 1; k > x; x++) C.getIntersections(r, l[x], p, g[x], e, !a && (x === o + 1 || x === k - 1 && 0 === o) && function(a) {
                    var b = a._parameter;
                    return b >= m && n >= b;
                });
            }
            for (var y = e.length - 1, o = y; o >= 0; o--) {
                var z = e[o], A = z._curve.getNext(), B = z._curve2.getNext();
                A && z._parameter >= n && (z._parameter = 0, z._curve = A), B && z._parameter2 >= n && (z._parameter2 = 0, 
                z._curve2 = B);
            }
            if (y > 0) {
                e.sort(d);
                for (var o = y; o >= 1; o--) e[o].equals(e[0 === o ? y : o - 1]) && (e.splice(o, 1), 
                y--);
            }
            if (c) {
                for (var o = y; o >= 0; o--) e.push(e[o].getIntersection());
                e.sort(d);
            }
            return e;
        },
        _asPathItem: function() {
            return this;
        },
        setPathData: function(a) {
            function b(a, b) {
                var c = +d[a];
                return i && (c += j[b]), c;
            }
            function c(a) {
                return new h(b(a, "x"), b(a + 1, "y"));
            }
            var d, e, f, g = a.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/gi), i = !1, j = new h(), l = new h();
            this.clear();
            for (var m = 0, n = g.length; n > m; m++) {
                var o = g[m], p = o[0], q = p.toLowerCase();
                d = o.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
                var r = d && d.length;
                switch (i = p === q, "z" !== e || /[mz]/.test(q) || this.moveTo(j = l), q) {
                  case "m":
                  case "l":
                    var s = "m" === q;
                    s && e && "z" !== e && this.closePath(!0);
                    for (var t = 0; r > t; t += 2) this[0 === t && s ? "moveTo" : "lineTo"](j = c(t));
                    f = j, s && (l = j);
                    break;

                  case "h":
                  case "v":
                    for (var u = "h" === q ? "x" : "y", t = 0; r > t; t++) j[u] = b(t, u), this.lineTo(j);
                    f = j;
                    break;

                  case "c":
                    for (var t = 0; r > t; t += 6) this.cubicCurveTo(c(t), f = c(t + 2), j = c(t + 4));
                    break;

                  case "s":
                    for (var t = 0; r > t; t += 4) this.cubicCurveTo(/[cs]/.test(e) ? j.multiply(2).subtract(f) : j, f = c(t), j = c(t + 2)), 
                    e = q;
                    break;

                  case "q":
                    for (var t = 0; r > t; t += 4) this.quadraticCurveTo(f = c(t), j = c(t + 2));
                    break;

                  case "t":
                    for (var t = 0; r > t; t += 2) this.quadraticCurveTo(f = /[qt]/.test(e) ? j.multiply(2).subtract(f) : j, j = c(t)), 
                    e = q;
                    break;

                  case "a":
                    for (var t = 0; r > t; t += 7) this.arcTo(j = c(t + 5), new k(+d[0], +d[1]), +d[2], +d[4], +d[3]);
                    break;

                  case "z":
                    this.closePath(!0);
                }
                e = q;
            }
        },
        _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
        },
        _contains: function(a) {
            var b = this._getWinding(a, !1, !0);
            return !!("evenodd" === this.getWindingRule() ? 1 & b : b);
        }
    }), F = E.extend({
        _class: "Path",
        _serializeFields: {
            segments: [],
            closed: !1
        },
        initialize: function(b) {
            this._closed = !1, this._segments = [];
            var c = Array.isArray(b) ? "object" == typeof b[0] ? b : arguments : !b || b.size !== a || b.x === a && b.point === a ? null : arguments;
            c && c.length > 0 ? this.setSegments(c) : (this._curves = a, this._selectedSegmentState = 0, 
            c || "string" != typeof b || (this.setPathData(b), b = null)), this._initialize(!c && b);
        },
        _equals: function(a) {
            return b.equals(this._segments, a._segments);
        },
        clone: function(b) {
            var c = new F(t.NO_INSERT);
            return c.setSegments(this._segments), c._closed = this._closed, this._clockwise !== a && (c._clockwise = this._clockwise), 
            this._clone(c, b);
        },
        _changed: function ra(b) {
            if (ra.base.call(this, b), 8 & b) {
                var c = this._parent;
                if (c && (c._currentPath = a), this._length = this._clockwise = a, this._curves && !(16 & b)) for (var d = 0, e = this._curves.length; e > d; d++) this._curves[d]._changed();
                this._monoCurves = a;
            } else 32 & b && (this._bounds = a);
        },
        getStyle: function() {
            var a = this._parent;
            return (a instanceof G ? a : this)._style;
        },
        getSegments: function() {
            return this._segments;
        },
        setSegments: function(b) {
            var c = this.isFullySelected();
            this._segments.length = 0, this._selectedSegmentState = 0, this._curves = a, b && b.length > 0 && this._add(A.readAll(b)), 
            c && this.setFullySelected(!0);
        },
        getFirstSegment: function() {
            return this._segments[0];
        },
        getLastSegment: function() {
            return this._segments[this._segments.length - 1];
        },
        getCurves: function() {
            var a = this._curves, b = this._segments;
            if (!a) {
                var c = this._countCurves();
                a = this._curves = new Array(c);
                for (var d = 0; c > d; d++) a[d] = new C(this, b[d], b[d + 1] || b[0]);
            }
            return a;
        },
        getFirstCurve: function() {
            return this.getCurves()[0];
        },
        getLastCurve: function() {
            var a = this.getCurves();
            return a[a.length - 1];
        },
        isClosed: function() {
            return this._closed;
        },
        setClosed: function(a) {
            if (this._closed != (a = !!a)) {
                if (this._closed = a, this._curves) {
                    var b = this._curves.length = this._countCurves();
                    a && (this._curves[b - 1] = new C(this, this._segments[b - 1], this._segments[0]));
                }
                this._changed(25);
            }
        }
    }, {
        beans: !0,
        getPathData: function(a, b) {
            function c(b, c) {
                b._transformCoordinates(a, p, !1), d = p[0], e = p[1], q ? (r.push("M" + o.pair(d, e)), 
                q = !1) : (i = p[2], j = p[3], i === d && j === e && k === g && l === h ? c || r.push("l" + o.pair(d - g, e - h)) : r.push("c" + o.pair(k - g, l - h) + " " + o.pair(i - g, j - h) + " " + o.pair(d - g, e - h))), 
                g = d, h = e, k = p[4], l = p[5];
            }
            var d, e, g, h, i, j, k, l, m = this._segments, n = m.length, o = new f(b), p = new Array(6), q = !0, r = [];
            if (0 === n) return "";
            for (var s = 0; n > s; s++) c(m[s]);
            return this._closed && n > 0 && (c(m[0], !0), r.push("z")), r.join("");
        }
    }, {
        isEmpty: function() {
            return 0 === this._segments.length;
        },
        isPolygon: function() {
            for (var a = 0, b = this._segments.length; b > a; a++) if (!this._segments[a].isLinear()) return !1;
            return !0;
        },
        _transformContent: function(a) {
            for (var b = new Array(6), c = 0, d = this._segments.length; d > c; c++) this._segments[c]._transformCoordinates(a, b, !0);
            return !0;
        },
        _add: function(a, b) {
            for (var c = this._segments, d = this._curves, e = a.length, f = null == b, b = f ? c.length : b, g = 0; e > g; g++) {
                var h = a[g];
                h._path && (h = a[g] = h.clone()), h._path = this, h._index = b + g, h._selectionState && this._updateSelection(h, 0, h._selectionState);
            }
            if (f) c.push.apply(c, a); else {
                c.splice.apply(c, [ b, 0 ].concat(a));
                for (var g = b + e, i = c.length; i > g; g++) c[g]._index = g;
            }
            if (d || a._curves) {
                d || (d = this._curves = []);
                var j = b > 0 ? b - 1 : b, k = j, l = Math.min(j + e, this._countCurves());
                a._curves && (d.splice.apply(d, [ j, 0 ].concat(a._curves)), k += a._curves.length);
                for (var g = k; l > g; g++) d.splice(g, 0, new C(this, null, null));
                this._adjustCurves(j, l);
            }
            return this._changed(25), a;
        },
        _adjustCurves: function(a, b) {
            for (var c, d = this._segments, e = this._curves, f = a; b > f; f++) c = e[f], c._path = this, 
            c._segment1 = d[f], c._segment2 = d[f + 1] || d[0], c._changed();
            (c = e[this._closed && 0 === a ? d.length - 1 : a - 1]) && (c._segment2 = d[a] || d[0], 
            c._changed()), (c = e[b]) && (c._segment1 = d[b], c._changed());
        },
        _countCurves: function() {
            var a = this._segments.length;
            return !this._closed && a > 0 ? a - 1 : a;
        },
        add: function(a) {
            return arguments.length > 1 && "number" != typeof a ? this._add(A.readAll(arguments)) : this._add([ A.read(arguments) ])[0];
        },
        insert: function(a, b) {
            return arguments.length > 2 && "number" != typeof b ? this._add(A.readAll(arguments, 1), a) : this._add([ A.read(arguments, 1) ], a)[0];
        },
        addSegment: function() {
            return this._add([ A.read(arguments) ])[0];
        },
        insertSegment: function(a) {
            return this._add([ A.read(arguments, 1) ], a)[0];
        },
        addSegments: function(a) {
            return this._add(A.readAll(a));
        },
        insertSegments: function(a, b) {
            return this._add(A.readAll(b), a);
        },
        removeSegment: function(a) {
            return this.removeSegments(a, a + 1)[0] || null;
        },
        removeSegments: function(a, c, d) {
            a = a || 0, c = b.pick(c, this._segments.length);
            var e = this._segments, f = this._curves, g = e.length, h = e.splice(a, c - a), i = h.length;
            if (!i) return h;
            for (var j = 0; i > j; j++) {
                var k = h[j];
                k._selectionState && this._updateSelection(k, k._selectionState, 0), k._index = k._path = null;
            }
            for (var j = a, l = e.length; l > j; j++) e[j]._index = j;
            if (f) {
                var m = a > 0 && c === g + (this._closed ? 1 : 0) ? a - 1 : a, f = f.splice(m, i);
                d && (h._curves = f.slice(1)), this._adjustCurves(m, m);
            }
            return this._changed(25), h;
        },
        clear: "#removeSegments",
        getLength: function() {
            if (null == this._length) {
                var a = this.getCurves();
                this._length = 0;
                for (var b = 0, c = a.length; c > b; b++) this._length += a[b].getLength();
            }
            return this._length;
        },
        getArea: function() {
            for (var a = this.getCurves(), b = 0, c = 0, d = a.length; d > c; c++) b += a[c].getArea();
            return b;
        },
        isFullySelected: function() {
            var a = this._segments.length;
            return this._selected && a > 0 && this._selectedSegmentState === 7 * a;
        },
        setFullySelected: function(a) {
            a && this._selectSegments(!0), this.setSelected(a);
        },
        setSelected: function sa(a) {
            a || this._selectSegments(!1), sa.base.call(this, a);
        },
        _selectSegments: function(a) {
            var b = this._segments.length;
            this._selectedSegmentState = a ? 7 * b : 0;
            for (var c = 0; b > c; c++) this._segments[c]._selectionState = a ? 7 : 0;
        },
        _updateSelection: function(a, b, c) {
            a._selectionState = c;
            var d = this._selectedSegmentState += c - b;
            d > 0 && this.setSelected(!0);
        },
        flatten: function(a) {
            for (var b = new H(this, 64, .1), c = 0, d = b.length / Math.ceil(b.length / a), e = b.length + (this._closed ? -d : d) / 2, f = []; e >= c; ) f.push(new A(b.evaluate(c, 0))), 
            c += d;
            this.setSegments(f);
        },
        reduce: function() {
            for (var a = this.getCurves(), b = a.length - 1; b >= 0; b--) {
                var c = a[b];
                c.isLinear() && 0 === c.getLength() && c.remove();
            }
            return this;
        },
        simplify: function(a) {
            if (this._segments.length > 2) {
                var b = new I(this, a || 2.5);
                this.setSegments(b.fit());
            }
        },
        split: function(a, b) {
            if (null !== b) {
                if (1 === arguments.length) {
                    var c = a;
                    "number" == typeof c && (c = this.getLocationAt(c)), a = c.index, b = c.parameter;
                }
                var d = 1e-5;
                b >= 1 - d && (a++, b--);
                var e = this.getCurves();
                if (a >= 0 && a < e.length) {
                    b > d && e[a++].divide(b, !0);
                    var f, g = this.removeSegments(a, this._segments.length, !0);
                    return this._closed ? (this.setClosed(!1), f = this) : a > 0 && (f = this._clone(new F().insertAbove(this, !0))), 
                    f._add(g, 0), this.addSegment(g[0]), f;
                }
                return null;
            }
        },
        isClockwise: function() {
            return this._clockwise !== a ? this._clockwise : F.isClockwise(this._segments);
        },
        setClockwise: function(a) {
            this.isClockwise() != (a = !!a) && this.reverse(), this._clockwise = a;
        },
        reverse: function() {
            this._segments.reverse();
            for (var b = 0, c = this._segments.length; c > b; b++) {
                var d = this._segments[b], e = d._handleIn;
                d._handleIn = d._handleOut, d._handleOut = e, d._index = b;
            }
            this._curves = null, this._clockwise !== a && (this._clockwise = !this._clockwise), 
            this._changed(9);
        },
        join: function(a) {
            if (a) {
                var b = a._segments, c = this.getLastSegment(), d = a.getLastSegment();
                c._point.equals(d._point) && a.reverse();
                var e, f = a.getFirstSegment();
                c._point.equals(f._point) ? (c.setHandleOut(f._handleOut), this._add(b.slice(1))) : (e = this.getFirstSegment(), 
                e._point.equals(f._point) && a.reverse(), d = a.getLastSegment(), e._point.equals(d._point) ? (e.setHandleIn(d._handleIn), 
                this._add(b.slice(0, b.length - 1), 0)) : this._add(b.slice())), a.closed && this._add([ b[0] ]), 
                a.remove();
            }
            var g = this.getFirstSegment(), h = this.getLastSegment();
            g !== h && g._point.equals(h._point) && (g.setHandleIn(h._handleIn), h.remove(), 
            this.setClosed(!0));
        },
        toShape: function(b) {
            function c(a, b) {
                return m[a].isColinear(m[b]);
            }
            function d(a) {
                return m[a].isOrthogonal();
            }
            function e(a) {
                return m[a].isArc();
            }
            function f(a, b) {
                return m[a]._point.getDistance(m[b]._point);
            }
            if (!this._closed) return null;
            var h, i, j, l, m = this._segments;
            if (this.isPolygon() && 4 === m.length && c(0, 2) && c(1, 3) && d(1) ? (h = w.Rectangle, 
            i = new k(f(0, 3), f(0, 1)), l = m[1]._point.add(m[2]._point).divide(2)) : 8 === m.length && e(0) && e(2) && e(4) && e(6) && c(1, 5) && c(3, 7) ? (h = w.Rectangle, 
            i = new k(f(1, 6), f(0, 3)), j = i.subtract(new k(f(0, 7), f(1, 2))).divide(2), 
            l = m[3]._point.add(m[4]._point).divide(2)) : 4 === m.length && e(0) && e(1) && e(2) && e(3) && (g.isZero(f(0, 2) - f(1, 3)) ? (h = w.Circle, 
            j = f(0, 2) / 2) : (h = w.Ellipse, j = new k(f(2, 0) / 2, f(3, 1) / 2)), l = m[1]._point), 
            h) {
                var n = this.getPosition(!0), o = new h({
                    center: n,
                    size: i,
                    radius: j,
                    insert: !1
                });
                return o.rotate(l.subtract(n).getAngle() + 90), o.setStyle(this._style), (b || b === a) && o.insertAbove(this), 
                o;
            }
            return null;
        },
        _hitTestSelf: function(a, b) {
            function c(b, c) {
                return a.subtract(b).divide(c).length <= 1;
            }
            function d(a, d, e) {
                if (!b.selected || d.isSelected()) {
                    var f = a._point;
                    if (d !== f && (d = d.add(f)), c(d, u)) return new z(e, o, {
                        segment: a,
                        point: d
                    });
                }
            }
            function e(a, c) {
                return (c || b.segments) && d(a, a._point, "segment") || !c && b.handles && (d(a, a._handleIn, "handle-in") || d(a, a._handleOut, "handle-out"));
            }
            function f(a) {
                l.add(a);
            }
            function g(b) {
                if (("round" !== i || "round" !== j) && (l = new F({
                    internal: !0,
                    closed: !0
                }), s || b._index > 0 && b._index < r - 1 ? "round" !== i && (b._handleIn.isZero() || b._handleOut.isZero()) && F._addBevelJoin(b, i, y, k, f, !0) : "round" !== j && F._addSquareCap(b, j, y, f, !0), 
                !l.isEmpty())) {
                    var d;
                    return l.contains(a) || (d = l.getNearestLocation(a)) && c(d.getPoint(), t);
                }
                return c(b._point, u);
            }
            var i, j, k, l, m, n, o = this, p = this.getStyle(), q = this._segments, r = q.length, s = this._closed, t = b._tolerancePadding, u = t, v = b.stroke && p.hasStroke(), w = b.fill && p.hasFill(), x = b.curves, y = v ? p.getStrokeWidth() / 2 : w && b.tolerance > 0 || x ? 0 : null;
            if (null !== y && (y > 0 ? (i = p.getStrokeJoin(), j = p.getStrokeCap(), k = y * p.getMiterLimit(), 
            u = t.add(new h(y, y))) : i = j = "round"), !b.ends || b.segments || s) {
                if (b.segments || b.handles) for (var A = 0; r > A; A++) if (n = e(q[A])) return n;
            } else if (n = e(q[0], !0) || e(q[r - 1], !0)) return n;
            if (null !== y) {
                if (m = this.getNearestLocation(a)) {
                    var B = m.getParameter();
                    0 === B || 1 === B && r > 1 ? g(m.getSegment()) || (m = null) : c(m.getPoint(), u) || (m = null);
                }
                if (!m && "miter" === i && r > 1) for (var A = 0; r > A; A++) {
                    var C = q[A];
                    if (a.getDistance(C._point) <= k && g(C)) {
                        m = C.getLocation();
                        break;
                    }
                }
            }
            return !m && w && this._contains(a) || m && !v && !x ? new z("fill", this) : m ? new z(v ? "stroke" : "curve", this, {
                location: m,
                point: m.getPoint()
            }) : null;
        }
    }, b.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(a) {
        this[a + "At"] = function(b, c) {
            var d = this.getLocationAt(b, c);
            return d && d[a]();
        };
    }, {
        beans: !1,
        _getOffset: function(a) {
            var b = a && a.getIndex();
            if (null != b) {
                for (var c = this.getCurves(), d = 0, e = 0; b > e; e++) d += c[e].getLength();
                var f = c[b], g = a.getParameter();
                return g > 0 && (d += f.getPartLength(0, g)), d;
            }
            return null;
        },
        getLocationOf: function() {
            for (var a = h.read(arguments), b = this.getCurves(), c = 0, d = b.length; d > c; c++) {
                var e = b[c].getLocationOf(a);
                if (e) return e;
            }
            return null;
        },
        getOffsetOf: function() {
            var a = this.getLocationOf.apply(this, arguments);
            return a ? a.getOffset() : null;
        },
        getLocationAt: function(a, b) {
            var c = this.getCurves(), d = 0;
            if (b) {
                var e = ~~a;
                return c[e].getLocationAt(a - e, !0);
            }
            for (var f = 0, g = c.length; g > f; f++) {
                var h = d, i = c[f];
                if (d += i.getLength(), d > a) return i.getLocationAt(a - h);
            }
            return a <= this.getLength() ? new D(c[c.length - 1], 1) : null;
        },
        getNearestLocation: function() {
            for (var a = h.read(arguments), b = this.getCurves(), c = 1 / 0, d = null, e = 0, f = b.length; f > e; e++) {
                var g = b[e].getNearestLocation(a);
                g._distance < c && (c = g._distance, d = g);
            }
            return d;
        },
        getNearestPoint: function() {
            return this.getNearestLocation.apply(this, arguments).getPoint();
        }
    }), new function() {
        function a(a, b, c, d) {
            function e(b) {
                var c = g[b], d = g[b + 1];
                (l != c || m != d) && (a.beginPath(), a.moveTo(l, m), a.lineTo(c, d), a.stroke(), 
                a.beginPath(), a.arc(c, d, f, 0, 2 * Math.PI, !0), a.fill());
            }
            for (var f = d / 2, g = new Array(6), h = 0, i = b.length; i > h; h++) {
                var j = b[h];
                j._transformCoordinates(c, g, !1);
                var k = j._selectionState, l = g[0], m = g[1];
                if (1 & k && e(2), 2 & k && e(4), a.fillRect(l - f, m - f, d, d), !(4 & k)) {
                    var n = a.fillStyle;
                    a.fillStyle = "#ffffff", a.fillRect(l - f + 1, m - f + 1, d - 2, d - 2), a.fillStyle = n;
                }
            }
        }
        function b(a, b, c) {
            function d(b) {
                if (c) b._transformCoordinates(c, o, !1), e = o[0], f = o[1]; else {
                    var d = b._point;
                    e = d._x, f = d._y;
                }
                if (p) a.moveTo(e, f), p = !1; else {
                    if (c) i = o[2], j = o[3]; else {
                        var m = b._handleIn;
                        i = e + m._x, j = f + m._y;
                    }
                    i === e && j === f && k === g && l === h ? a.lineTo(e, f) : a.bezierCurveTo(k, l, i, j, e, f);
                }
                if (g = e, h = f, c) k = o[4], l = o[5]; else {
                    var m = b._handleOut;
                    k = g + m._x, l = h + m._y;
                }
            }
            for (var e, f, g, h, i, j, k, l, m = b._segments, n = m.length, o = new Array(6), p = !0, q = 0; n > q; q++) d(m[q]);
            b._closed && n > 0 && d(m[0]);
        }
        return {
            _draw: function(a, c, d) {
                function e(a) {
                    return k[(a % l + l) % l];
                }
                var f = c.dontStart, g = c.dontFinish || c.clip, h = this.getStyle(), i = h.hasFill(), j = h.hasStroke(), k = h.getDashArray(), l = !paper.support.nativeDash && j && k && k.length;
                if (f || a.beginPath(), !f && this._currentPath ? a.currentPath = this._currentPath : (i || j && !l || g) && (b(a, this, d), 
                this._closed && a.closePath(), f || (this._currentPath = a.currentPath)), !g && (i || j) && (this._setStyles(a), 
                i && (a.fill(h.getWindingRule()), a.shadowColor = "rgba(0,0,0,0)"), j)) {
                    if (l) {
                        f || a.beginPath();
                        var m, n = new H(this, 32, .25, d), o = n.length, p = -h.getDashOffset(), q = 0;
                        for (p %= o; p > 0; ) p -= e(q--) + e(q--);
                        for (;o > p; ) m = p + e(q++), (p > 0 || m > 0) && n.drawPart(a, Math.max(p, 0), Math.max(m, 0)), 
                        p = m + e(q++);
                    }
                    a.stroke();
                }
            },
            _drawSelected: function(c, d) {
                c.beginPath(), b(c, this, d), c.stroke(), a(c, this._segments, d, paper.settings.handleSize);
            }
        };
    }(), new function() {
        function a(a) {
            var b = a.length, c = [], d = [], e = 2;
            c[0] = a[0] / e;
            for (var f = 1; b > f; f++) d[f] = 1 / e, e = (b - 1 > f ? 4 : 2) - d[f], c[f] = (a[f] - c[f - 1]) / e;
            for (var f = 1; b > f; f++) c[b - f - 1] -= d[b - f] * c[b - f];
            return c;
        }
        return {
            smooth: function() {
                var b = this._segments, c = b.length, d = this._closed, e = c, f = 0;
                if (!(2 >= c)) {
                    d && (f = Math.min(c, 4), e += 2 * Math.min(c, f));
                    for (var g = [], i = 0; c > i; i++) g[i + f] = b[i]._point;
                    if (d) for (var i = 0; f > i; i++) g[i] = b[i + c - f]._point, g[i + c + f] = b[i]._point; else e--;
                    for (var j = [], i = 1; e - 1 > i; i++) j[i] = 4 * g[i]._x + 2 * g[i + 1]._x;
                    j[0] = g[0]._x + 2 * g[1]._x, j[e - 1] = 3 * g[e - 1]._x;
                    for (var k = a(j), i = 1; e - 1 > i; i++) j[i] = 4 * g[i]._y + 2 * g[i + 1]._y;
                    j[0] = g[0]._y + 2 * g[1]._y, j[e - 1] = 3 * g[e - 1]._y;
                    var l = a(j);
                    if (d) {
                        for (var i = 0, m = c; f > i; i++, m++) {
                            var n = i / f, o = 1 - n, p = i + f, q = m + f;
                            k[m] = k[i] * n + k[m] * o, l[m] = l[i] * n + l[m] * o, k[q] = k[p] * o + k[q] * n, 
                            l[q] = l[p] * o + l[q] * n;
                        }
                        e--;
                    }
                    for (var r = null, i = f; e - f >= i; i++) {
                        var s = b[i - f];
                        r && s.setHandleIn(r.subtract(s._point)), e > i && (s.setHandleOut(new h(k[i], l[i]).subtract(s._point)), 
                        r = e - 1 > i ? new h(2 * g[i + 1]._x - k[i + 1], 2 * g[i + 1]._y - l[i + 1]) : new h((g[e]._x + k[e - 1]) / 2, (g[e]._y + l[e - 1]) / 2));
                    }
                    if (d && r) {
                        var s = this._segments[0];
                        s.setHandleIn(r.subtract(s._point));
                    }
                }
            }
        };
    }(), new function() {
        function a(a) {
            var b = a._segments;
            if (0 === b.length) throw new Error("Use a moveTo() command first");
            return b[b.length - 1];
        }
        return {
            moveTo: function() {
                var a = this._segments;
                1 === a.length && this.removeSegment(0), a.length || this._add([ new A(h.read(arguments)) ]);
            },
            moveBy: function() {
                throw new Error("moveBy() is unsupported on Path items.");
            },
            lineTo: function() {
                this._add([ new A(h.read(arguments)) ]);
            },
            cubicCurveTo: function() {
                var b = h.read(arguments), c = h.read(arguments), d = h.read(arguments), e = a(this);
                e.setHandleOut(b.subtract(e._point)), this._add([ new A(d, c.subtract(d)) ]);
            },
            quadraticCurveTo: function() {
                var b = h.read(arguments), c = h.read(arguments), d = a(this)._point;
                this.cubicCurveTo(b.add(d.subtract(b).multiply(1 / 3)), b.add(c.subtract(b).multiply(1 / 3)), c);
            },
            curveTo: function() {
                var c = h.read(arguments), d = h.read(arguments), e = b.pick(b.read(arguments), .5), f = 1 - e, g = a(this)._point, i = c.subtract(g.multiply(f * f)).subtract(d.multiply(e * e)).divide(2 * e * f);
                if (i.isNaN()) throw new Error("Cannot put a curve through points with parameter = " + e);
                this.quadraticCurveTo(i, d);
            },
            arcTo: function() {
                var c, d, e, f, g, i = a(this), j = i._point, l = h.read(arguments), m = b.peek(arguments), n = b.pick(m, !0);
                if ("boolean" == typeof n) var o = j.add(l).divide(2), c = o.add(o.subtract(j).rotate(n ? -90 : 90)); else if (b.remain(arguments) <= 2) c = l, 
                l = h.read(arguments); else {
                    var r = k.read(arguments);
                    if (r.isZero()) return this.lineTo(l);
                    var s = b.read(arguments), n = !!b.read(arguments), t = !!b.read(arguments), o = j.add(l).divide(2), u = j.subtract(o).rotate(-s), v = u.x, w = u.y, x = Math.abs, y = 1e-11, z = x(r.width), B = x(r.height), C = z * z, D = B * B, E = v * v, F = w * w, G = Math.sqrt(E / C + F / D);
                    if (G > 1 && (z *= G, B *= G, C = z * z, D = B * B), G = (C * D - C * F - D * E) / (C * F + D * E), 
                    x(G) < y && (G = 0), 0 > G) throw new Error("Cannot create an arc with the given arguments");
                    d = new h(z * w / B, -B * v / z).multiply((t === n ? -1 : 1) * Math.sqrt(G)).rotate(s).add(o), 
                    g = new p().translate(d).rotate(s).scale(z, B), f = g._inverseTransform(j), e = f.getDirectedAngle(g._inverseTransform(l)), 
                    !n && e > 0 ? e -= 360 : n && 0 > e && (e += 360);
                }
                if (c) {
                    var H = new q(j.add(c).divide(2), c.subtract(j).rotate(90), !0), I = new q(c.add(l).divide(2), l.subtract(c).rotate(90), !0), J = new q(j, l), K = J.getSide(c);
                    if (d = H.intersect(I, !0), !d) {
                        if (!K) return this.lineTo(l);
                        throw new Error("Cannot create an arc with the given arguments");
                    }
                    f = j.subtract(d), e = f.getDirectedAngle(l.subtract(d));
                    var L = J.getSide(d);
                    0 === L ? e = K * Math.abs(e) : K === L && (e += 0 > e ? 360 : -360);
                }
                for (var M = Math.abs(e), N = M >= 360 ? 4 : Math.ceil(M / 90), O = e / N, P = O * Math.PI / 360, Q = 4 / 3 * Math.sin(P) / (1 + Math.cos(P)), R = [], S = 0; N >= S; S++) {
                    var u = l, T = null;
                    if (N > S && (T = f.rotate(90).multiply(Q), g ? (u = g._transformPoint(f), T = g._transformPoint(f.add(T)).subtract(u)) : u = d.add(f)), 
                    0 === S) i.setHandleOut(T); else {
                        var U = f.rotate(-90).multiply(Q);
                        g && (U = g._transformPoint(f.add(U)).subtract(u)), R.push(new A(u, U, T));
                    }
                    f = f.rotate(O);
                }
                this._add(R);
            },
            lineBy: function() {
                var b = h.read(arguments), c = a(this)._point;
                this.lineTo(c.add(b));
            },
            curveBy: function() {
                var c = h.read(arguments), d = h.read(arguments), e = b.read(arguments), f = a(this)._point;
                this.curveTo(f.add(c), f.add(d), e);
            },
            cubicCurveBy: function() {
                var b = h.read(arguments), c = h.read(arguments), d = h.read(arguments), e = a(this)._point;
                this.cubicCurveTo(e.add(b), e.add(c), e.add(d));
            },
            quadraticCurveBy: function() {
                var b = h.read(arguments), c = h.read(arguments), d = a(this)._point;
                this.quadraticCurveTo(d.add(b), d.add(c));
            },
            arcBy: function() {
                var c = a(this)._point, d = c.add(h.read(arguments)), e = b.pick(b.peek(arguments), !0);
                "boolean" == typeof e ? this.arcTo(d, e) : this.arcTo(d, c.add(h.read(arguments)));
            },
            closePath: function(a) {
                this.setClosed(!0), a && this.join();
            }
        };
    }(), {
        _getBounds: function(a, b) {
            return F[a](this._segments, this._closed, this.getStyle(), b);
        },
        statics: {
            isClockwise: function(a) {
                for (var b = 0, c = 0, d = a.length; d > c; c++) for (var e = C.getValues(a[c], a[d > c + 1 ? c + 1 : 0]), f = 2; 8 > f; f += 2) b += (e[f - 2] - e[f]) * (e[f + 1] + e[f - 1]);
                return b > 0;
            },
            getBounds: function(a, b, c, d, e) {
                function f(a) {
                    a._transformCoordinates(d, h, !1);
                    for (var b = 0; 2 > b; b++) C._addBounds(i[b], i[b + 4], h[b + 2], h[b], b, e ? e[b] : 0, j, k, l);
                    var c = i;
                    i = h, h = c;
                }
                var g = a[0];
                if (!g) return new n();
                for (var h = new Array(6), i = g._transformCoordinates(d, new Array(6), !1), j = i.slice(0, 2), k = j.slice(), l = new Array(2), m = 1, o = a.length; o > m; m++) f(a[m]);
                return b && f(g), new n(j[0], j[1], k[0] - j[0], k[1] - j[1]);
            },
            getStrokeBounds: function(a, b, c, d) {
                function e(a) {
                    m = m.include(d ? d._transformPoint(a, a) : a);
                }
                function f(a) {
                    m = m.unite(r.setCenter(d ? d._transformPoint(a._point) : a._point));
                }
                function g(a, b) {
                    var c = a._handleIn, d = a._handleOut;
                    "round" === b || !c.isZero() && !d.isZero() && c.isColinear(d) ? f(a) : F._addBevelJoin(a, b, j, q, e);
                }
                function h(a, b) {
                    "round" === b ? f(a) : F._addSquareCap(a, b, j, e);
                }
                if (!c.hasStroke()) return F.getBounds(a, b, c, d);
                for (var i = a.length - (b ? 0 : 1), j = c.getStrokeWidth() / 2, l = F._getPenPadding(j, d), m = F.getBounds(a, b, c, d, l), o = c.getStrokeJoin(), p = c.getStrokeCap(), q = j * c.getMiterLimit(), r = new n(new k(l).multiply(2)), s = 1; i > s; s++) g(a[s], o);
                return b ? g(a[0], o) : i > 0 && (h(a[0], p), h(a[a.length - 1], p)), m;
            },
            _getPenPadding: function(a, b) {
                if (!b) return [ a, a ];
                var c = b.shiftless(), d = c.transform(new h(a, 0)), e = c.transform(new h(0, a)), f = d.getAngleInRadians(), g = d.getLength(), i = e.getLength(), j = Math.sin(f), k = Math.cos(f), l = Math.tan(f), m = -Math.atan(i * l / g), n = Math.atan(i / (l * g));
                return [ Math.abs(g * Math.cos(m) * k - i * Math.sin(m) * j), Math.abs(i * Math.sin(n) * k + g * Math.cos(n) * j) ];
            },
            _addBevelJoin: function(a, b, c, d, e, f) {
                var g = a.getCurve(), i = g.getPrevious(), j = g.getPointAt(0, !0), k = i.getNormalAt(1, !0), l = g.getNormalAt(0, !0), m = k.getDirectedAngle(l) < 0 ? -c : c;
                if (k.setLength(m), l.setLength(m), f && (e(j), e(j.add(k))), "miter" === b) {
                    var n = new q(j.add(k), new h(-k.y, k.x), !0).intersect(new q(j.add(l), new h(-l.y, l.x), !0), !0);
                    if (n && j.getDistance(n) <= d && (e(n), !f)) return;
                }
                f || e(j.add(k)), e(j.add(l));
            },
            _addSquareCap: function(a, b, c, d, e) {
                var f = a._point, g = a.getLocation(), h = g.getNormal().normalize(c);
                e && (d(f.subtract(h)), d(f.add(h))), "square" === b && (f = f.add(h.rotate(0 === g.getParameter() ? -90 : 90))), 
                d(f.add(h)), d(f.subtract(h));
            },
            getHandleBounds: function(a, b, c, d, e, f) {
                for (var g = new Array(6), h = 1 / 0, i = -h, j = h, k = i, l = 0, m = a.length; m > l; l++) {
                    var o = a[l];
                    o._transformCoordinates(d, g, !1);
                    for (var p = 0; 6 > p; p += 2) {
                        var q = 0 === p ? f : e, r = q ? q[0] : 0, s = q ? q[1] : 0, t = g[p], u = g[p + 1], v = t - r, w = t + r, x = u - s, y = u + s;
                        h > v && (h = v), w > i && (i = w), j > x && (j = x), y > k && (k = y);
                    }
                }
                return new n(h, j, i - h, k - j);
            },
            getRoughBounds: function(a, b, c, d) {
                var e = c.hasStroke() ? c.getStrokeWidth() / 2 : 0, f = e;
                return e > 0 && ("miter" === c.getStrokeJoin() && (f = e * c.getMiterLimit()), "square" === c.getStrokeCap() && (f = Math.max(f, e * Math.sqrt(2)))), 
                F.getHandleBounds(a, b, c, d, F._getPenPadding(e, d), F._getPenPadding(f, d));
            }
        }
    });
    F.inject({
        statics: new function() {
            function a(a, c, d) {
                var e = b.getNamed(d), f = new F(e && e.insert === !1 && t.NO_INSERT);
                return f._add(a), f._closed = c, f.set(e);
            }
            function c(b, c, d) {
                for (var f = new Array(4), g = 0; 4 > g; g++) {
                    var h = e[g];
                    f[g] = new A(h._point.multiply(c).add(b), h._handleIn.multiply(c), h._handleOut.multiply(c));
                }
                return a(f, !0, d);
            }
            var d = .5522847498307936, e = [ new A([ -1, 0 ], [ 0, d ], [ 0, -d ]), new A([ 0, -1 ], [ -d, 0 ], [ d, 0 ]), new A([ 1, 0 ], [ 0, -d ], [ 0, d ]), new A([ 0, 1 ], [ d, 0 ], [ -d, 0 ]) ];
            return {
                Line: function() {
                    return a([ new A(h.readNamed(arguments, "from")), new A(h.readNamed(arguments, "to")) ], !1, arguments);
                },
                Circle: function() {
                    var a = h.readNamed(arguments, "center"), d = b.readNamed(arguments, "radius");
                    return c(a, new k(d), arguments);
                },
                Rectangle: function() {
                    var b, c = n.readNamed(arguments, "rectangle"), e = k.readNamed(arguments, "radius", 0, {
                        readNull: !0
                    }), f = c.getBottomLeft(!0), g = c.getTopLeft(!0), h = c.getTopRight(!0), i = c.getBottomRight(!0);
                    if (!e || e.isZero()) b = [ new A(f), new A(g), new A(h), new A(i) ]; else {
                        e = k.min(e, c.getSize(!0).divide(2));
                        var j = e.width, l = e.height, m = j * d, o = l * d;
                        b = [ new A(f.add(j, 0), null, [ -m, 0 ]), new A(f.subtract(0, l), [ 0, o ]), new A(g.add(0, l), null, [ 0, -o ]), new A(g.add(j, 0), [ -m, 0 ], null), new A(h.subtract(j, 0), null, [ m, 0 ]), new A(h.add(0, l), [ 0, -o ], null), new A(i.subtract(0, l), null, [ 0, o ]), new A(i.subtract(j, 0), [ m, 0 ]) ];
                    }
                    return a(b, !0, arguments);
                },
                RoundRectangle: "#Rectangle",
                Ellipse: function() {
                    var a = w._readEllipse(arguments);
                    return c(a.center, a.radius, arguments);
                },
                Oval: "#Ellipse",
                Arc: function() {
                    var a = h.readNamed(arguments, "from"), c = h.readNamed(arguments, "through"), d = h.readNamed(arguments, "to"), e = b.getNamed(arguments), f = new F(e && e.insert === !1 && t.NO_INSERT);
                    return f.moveTo(a), f.arcTo(c, d), f.set(e);
                },
                RegularPolygon: function() {
                    for (var c = h.readNamed(arguments, "center"), d = b.readNamed(arguments, "sides"), e = b.readNamed(arguments, "radius"), f = 360 / d, g = !(d % 3), i = new h(0, g ? -e : e), j = g ? -1 : .5, k = new Array(d), l = 0; d > l; l++) k[l] = new A(c.add(i.rotate((l + j) * f)));
                    return a(k, !0, arguments);
                },
                Star: function() {
                    for (var c = h.readNamed(arguments, "center"), d = 2 * b.readNamed(arguments, "points"), e = b.readNamed(arguments, "radius1"), f = b.readNamed(arguments, "radius2"), g = 360 / d, i = new h(0, -1), j = new Array(d), k = 0; d > k; k++) j[k] = new A(c.add(i.rotate(g * k).multiply(k % 2 ? f : e)));
                    return a(j, !0, arguments);
                }
            };
        }()
    });
    var G = E.extend({
        _class: "CompoundPath",
        _serializeFields: {
            children: []
        },
        initialize: function(a) {
            this._children = [], this._namedChildren = {}, this._initialize(a) || ("string" == typeof a ? this.setPathData(a) : this.addChildren(Array.isArray(a) ? a : arguments));
        },
        insertChildren: function ta(b, c, d) {
            c = ta.base.call(this, b, c, d, F);
            for (var e = 0, f = !d && c && c.length; f > e; e++) {
                var g = c[e];
                g._clockwise === a && g.setClockwise(0 === g._index);
            }
            return c;
        },
        reverse: function() {
            for (var a = this._children, b = 0, c = a.length; c > b; b++) a[b].reverse();
        },
        smooth: function() {
            for (var a = 0, b = this._children.length; b > a; a++) this._children[a].smooth();
        },
        isClockwise: function() {
            var a = this.getFirstChild();
            return a && a.isClockwise();
        },
        setClockwise: function(a) {
            this.isClockwise() !== !!a && this.reverse();
        },
        getFirstSegment: function() {
            var a = this.getFirstChild();
            return a && a.getFirstSegment();
        },
        getLastSegment: function() {
            var a = this.getLastChild();
            return a && a.getLastSegment();
        },
        getCurves: function() {
            for (var a = this._children, b = [], c = 0, d = a.length; d > c; c++) b.push.apply(b, a[c].getCurves());
            return b;
        },
        getFirstCurve: function() {
            var a = this.getFirstChild();
            return a && a.getFirstCurve();
        },
        getLastCurve: function() {
            var a = this.getLastChild();
            return a && a.getFirstCurve();
        },
        getArea: function() {
            for (var a = this._children, b = 0, c = 0, d = a.length; d > c; c++) b += a[c].getArea();
            return b;
        }
    }, {
        beans: !0,
        getPathData: function(a, b) {
            for (var c = this._children, d = [], e = 0, f = c.length; f > e; e++) {
                var g = c[e], h = g._matrix;
                d.push(g.getPathData(a && !h.isIdentity() ? a.chain(h) : h, b));
            }
            return d.join(" ");
        }
    }, {
        _getChildHitTestOptions: function(a) {
            return a["class"] === F || "path" === a.type ? a : new b(a, {
                fill: !1
            });
        },
        _draw: function(a, b, c) {
            var d = this._children;
            if (0 !== d.length) {
                if (this._currentPath) a.currentPath = this._currentPath; else {
                    b = b.extend({
                        dontStart: !0,
                        dontFinish: !0
                    }), a.beginPath();
                    for (var e = 0, f = d.length; f > e; e++) d[e].draw(a, b, c);
                    this._currentPath = a.currentPath;
                }
                if (!b.clip) {
                    this._setStyles(a);
                    var g = this._style;
                    g.hasFill() && (a.fill(g.getWindingRule()), a.shadowColor = "rgba(0,0,0,0)"), g.hasStroke() && a.stroke();
                }
            }
        },
        _drawSelected: function(a, b, c) {
            for (var d = this._children, e = 0, f = d.length; f > e; e++) {
                var g = d[e], h = g._matrix;
                c[g._id] || g._drawSelected(a, h.isIdentity() ? b : b.chain(h));
            }
        }
    }, new function() {
        function a(a, b) {
            var c = a._children;
            if (b && 0 === c.length) throw new Error("Use a moveTo() command first");
            return c[c.length - 1];
        }
        var c = {
            moveTo: function() {
                var b = a(this), c = b && b.isEmpty() ? b : new F();
                c !== b && this.addChild(c), c.moveTo.apply(c, arguments);
            },
            moveBy: function() {
                var b = a(this, !0), c = b && b.getLastSegment(), d = h.read(arguments);
                this.moveTo(c ? d.add(c._point) : d);
            },
            closePath: function(b) {
                a(this, !0).closePath(b);
            }
        };
        return b.each([ "lineTo", "cubicCurveTo", "quadraticCurveTo", "curveTo", "arcTo", "lineBy", "cubicCurveBy", "quadraticCurveBy", "curveBy", "arcBy" ], function(b) {
            c[b] = function() {
                var c = a(this, !0);
                c[b].apply(c, arguments);
            };
        }), c;
    }());
    E.inject(new function() {
        function a(a, e, f, g) {
            function h(a) {
                return a.clone(!1).reduce().reorient().transform(null, !0);
            }
            function i(a) {
                for (var b = 0, c = a.length; c > b; b++) {
                    var d = a[b];
                    o.push.apply(o, d._segments), p.push.apply(p, d._getMonoCurves());
                }
            }
            var j = h(a), k = e && a !== e && h(e);
            j.isClockwise() || j.reverse(), !k || g ^ k.isClockwise() || k.reverse(), b(j.getIntersections(k, null, !0));
            var l = [], m = [], n = [], o = [], p = [];
            i(j._children || [ j ]), k && i(k._children || [ k ]), o.sort(function(a, b) {
                var c = a._intersection, d = b._intersection;
                return !c && !d || c && d ? 0 : c ? -1 : 1;
            });
            for (var q = 0, r = o.length; r > q; q++) {
                var s = o[q];
                if (null == s._winding) {
                    l.length = m.length = n.length = 0;
                    var t = 0, u = s;
                    do l.push(s), n.push(t += s.getCurve().getLength()), s = s.getNext(); while (s && !s._intersection && s !== u);
                    for (var v = 0; 3 > v; v++) {
                        var w = t * Math.random(), x = n.length, y = 0;
                        do if (n[y] >= w) {
                            y > 0 && (w -= n[y - 1]);
                            break;
                        } while (++y < x);
                        var z = l[y].getCurve(), A = z.getPointAt(w), B = z.isHorizontal(), C = z._path;
                        C._parent instanceof G && (C = C._parent), m[v] = g && k && (C === j && k._getWinding(A, B) || C === k && !j._getWinding(A, B)) ? 0 : c(A, p, B);
                    }
                    m.sort();
                    for (var D = m[1], v = l.length - 1; v >= 0; v--) l[v]._winding = D;
                }
            }
            var E = new G();
            return E.addChildren(d(o, f), !0), j.remove(), k && k.remove(), E = E.reduce(), 
            E.setStyle(a._style), E;
        }
        function b(a) {
            function b() {
                for (var a = 0, b = c.length; b > a; a++) {
                    var d = c[a];
                    d._handleOut.set(0, 0), d._handleIn.set(0, 0);
                }
            }
            for (var c, d, e, f = 1e-5, g = a.length - 1; g >= 0; g--) {
                var h = a[g], i = h._parameter;
                e && e._curve === h._curve && e._parameter > 0 ? i /= e._parameter : (c && b(), 
                d = h._curve, c = d.isLinear() && []);
                var j, k;
                (j = d.divide(i, !0, !0)) ? (k = j._segment1, d = j.getPrevious()) : k = f > i ? d._segment1 : i > 1 - f ? d._segment2 : d.getPartLength(0, i) < d.getPartLength(i, 1) ? d._segment1 : d._segment2, 
                k._intersection = h.getIntersection(), h._segment = k, c && c.push(k), e = h;
            }
            c && b();
        }
        function c(a, b, d, e) {
            var f = 1e-5, g = a.x, i = a.y, j = 0, k = 0, l = [], m = Math.abs, n = 1 - f;
            if (d) {
                for (var o = -(1 / 0), p = 1 / 0, q = i - f, r = i + f, s = 0, t = b.length; t > s; s++) {
                    var u = b[s].values;
                    if (C.solveCubic(u, 0, g, l, 0, 1) > 0) for (var v = l.length - 1; v >= 0; v--) {
                        var w = C.evaluate(u, l[v], 0).y;
                        q > w && w > o ? o = w : w > r && p > w && (p = w);
                    }
                }
                o = (o + i) / 2, p = (p + i) / 2, o > -(1 / 0) && (j = c(new h(g, o), b)), 1 / 0 > p && (k = c(new h(g, p), b));
            } else for (var x = g - f, y = g + f, s = 0, t = b.length; t > s; s++) {
                var z = b[s], u = z.values, A = z.winding, B = z.next;
                if (A && (1 === A && i >= u[1] && i <= u[7] || i >= u[7] && i <= u[1]) && 1 === C.solveCubic(u, 1, i, l, 0, B.winding || B.values[1] !== i ? n : 1)) {
                    var D = l[0], E = C.evaluate(u, D, 0).x, F = C.evaluate(u, D, 1).y;
                    m(F) < f && !C.isLinear(u) || f > D && F * C.evaluate(z.previous.values, D, 1).y < 0 ? e && E >= x && y >= E && (++j, 
                    ++k) : x >= E ? j += A : E >= y && (k += A);
                }
            }
            return Math.max(m(j), m(k));
        }
        function d(a, b, c) {
            b = b || function() {
                return !0;
            };
            for (var d, e, f = [], g = .001, h = .999, i = 0, j = a.length; j > i; i++) if (d = e = a[i], 
            !d._visited && b(d._winding)) {
                var k = new F(t.NO_INSERT), l = d._intersection, m = l && l._segment, n = !1, o = 1;
                do {
                    var p, q = o > 0 ? d._handleIn : d._handleOut, r = o > 0 ? d._handleOut : d._handleIn;
                    if (n && (!b(d._winding) || c) && (l = d._intersection) && (p = l._segment) && p !== e) {
                        if (c) d._visited = p._visited, d = p, o = 1; else {
                            var s = d.getCurve();
                            o > 0 && (s = s.getPrevious());
                            var u = s.getTangentAt(1 > o ? g : h, !0), v = p.getCurve(), w = v.getPrevious(), x = w.getTangentAt(h, !0), y = v.getTangentAt(g, !0), z = u.cross(x), B = u.cross(y);
                            if (z * B !== 0) {
                                var C = B > z ? w : v, D = b(C._segment1._winding) ? C : B > z ? v : w, E = D._segment1;
                                o = D === w ? -1 : 1, E._visited && d._path !== E._path || !b(E._winding) ? o = 1 : (d._visited = p._visited, 
                                d = p, E._visited && (o = 1));
                            } else o = 1;
                        }
                        r = o > 0 ? d._handleOut : d._handleIn;
                    }
                    k.add(new A(d._point, n && q, r)), n = !0, d._visited = !0, d = o > 0 ? d.getNext() : d.getPrevious();
                } while (d && !d._visited && d !== e && d !== m && (d._intersection || b(d._winding)));
                !d || d !== e && d !== m ? k.lastSegment._handleOut.set(0, 0) : (k.firstSegment.setHandleIn((d === m ? m : d)._handleIn), 
                k.setClosed(!0)), k._segments.length > (k._closed ? k.isPolygon() ? 2 : 0 : 1) && f.push(k);
            }
            return f;
        }
        return {
            _getWinding: function(a, b, d) {
                return c(a, this._getMonoCurves(), b, d);
            },
            unite: function(b) {
                return a(this, b, function(a) {
                    return 1 === a || 0 === a;
                }, !1);
            },
            intersect: function(b) {
                return a(this, b, function(a) {
                    return 2 === a;
                }, !1);
            },
            subtract: function(b) {
                return a(this, b, function(a) {
                    return 1 === a;
                }, !0);
            },
            exclude: function(a) {
                return new u([ this.subtract(a), a.subtract(this) ]);
            },
            divide: function(a) {
                return new u([ this.subtract(a), this.intersect(a) ]);
            }
        };
    }()), F.inject({
        _getMonoCurves: function() {
            function a(a) {
                var b = a[1], e = a[7], f = {
                    values: a,
                    winding: b === e ? 0 : b > e ? -1 : 1,
                    previous: c,
                    next: null
                };
                c && (c.next = f), d.push(f), c = f;
            }
            function b(b) {
                if (0 !== C.getLength(b)) {
                    var c = b[1], d = b[3], e = b[5], f = b[7];
                    if (C.isLinear(b)) a(b); else {
                        var h = 3 * (d - e) - c + f, i = 2 * (c + e) - 4 * d, j = d - c, k = 1e-5, l = [], m = g.solveQuadratic(h, i, j, l, k, 1 - k);
                        if (0 === m) a(b); else {
                            l.sort();
                            var n = l[0], o = C.subdivide(b, n);
                            a(o[0]), m > 1 && (n = (l[1] - n) / (1 - n), o = C.subdivide(o[1], n), a(o[0])), 
                            a(o[1]);
                        }
                    }
                }
            }
            var c, d = this._monoCurves;
            if (!d) {
                d = this._monoCurves = [];
                for (var e = this.getCurves(), f = this._segments, h = 0, i = e.length; i > h; h++) b(e[h].getValues());
                if (!this._closed && f.length > 1) {
                    var j = f[f.length - 1]._point, k = f[0]._point, l = j._x, m = j._y, n = k._x, o = k._y;
                    b([ l, m, l, m, n, o, n, o ]);
                }
                if (d.length > 0) {
                    var p = d[0], q = d[d.length - 1];
                    p.previous = q, q.next = p;
                }
            }
            return d;
        },
        getInteriorPoint: function() {
            var a = this.getBounds(), b = a.getCenter(!0);
            if (!this.contains(b)) {
                for (var c = this._getMonoCurves(), d = [], e = b.y, f = [], g = 0, h = c.length; h > g; g++) {
                    var i = c[g].values;
                    if ((1 === c[g].winding && e >= i[1] && e <= i[7] || e >= i[7] && e <= i[1]) && C.solveCubic(i, 1, e, d, 0, 1) > 0) for (var j = d.length - 1; j >= 0; j--) f.push(C.evaluate(i, d[j], 0).x);
                    if (f.length > 1) break;
                }
                b.x = (f[0] + f[1]) / 2;
            }
            return b;
        },
        reorient: function() {
            return this.setClockwise(!0), this;
        }
    }), G.inject({
        _getMonoCurves: function() {
            for (var a = this._children, b = [], c = 0, d = a.length; d > c; c++) b.push.apply(b, a[c]._getMonoCurves());
            return b;
        },
        reorient: function() {
            var a = this.removeChildren().sort(function(a, b) {
                return b.getBounds().getArea() - a.getBounds().getArea();
            });
            this.addChildren(a);
            for (var b = a[0].isClockwise(), c = 1, d = a.length; d > c; c++) {
                for (var e = a[c].getInteriorPoint(), f = 0, g = c - 1; g >= 0; g--) a[g].contains(e) && f++;
                a[c].setClockwise(f % 2 === 0 && b);
            }
            return this;
        }
    });
    var H = b.extend({
        _class: "PathIterator",
        initialize: function(a, b, c, d) {
            function e(a, b) {
                var c = C.getValues(a, b, d);
                h.push(c), f(c, a._index, 0, 1);
            }
            function f(a, b, d, e) {
                if (e - d > k && !C.isFlatEnough(a, c || .25)) {
                    var g = C.subdivide(a), h = (d + e) / 2;
                    f(g[0], b, d, h), f(g[1], b, h, e);
                } else {
                    var l = a[6] - a[0], m = a[7] - a[1], n = Math.sqrt(l * l + m * m);
                    n > 1e-5 && (j += n, i.push({
                        offset: j,
                        value: e,
                        index: b
                    }));
                }
            }
            for (var g, h = [], i = [], j = 0, k = 1 / (b || 32), l = a._segments, m = l[0], n = 1, o = l.length; o > n; n++) g = l[n], 
            e(m, g), m = g;
            a._closed && e(g, l[0]), this.curves = h, this.parts = i, this.length = j, this.index = 0;
        },
        getParameterAt: function(a) {
            for (var b, c = this.index; b = c, !(0 == c || this.parts[--c].offset < a); ) ;
            for (var d = this.parts.length; d > b; b++) {
                var e = this.parts[b];
                if (e.offset >= a) {
                    this.index = b;
                    var f = this.parts[b - 1], g = f && f.index == e.index ? f.value : 0, h = f ? f.offset : 0;
                    return {
                        value: g + (e.value - g) * (a - h) / (e.offset - h),
                        index: e.index
                    };
                }
            }
            var e = this.parts[this.parts.length - 1];
            return {
                value: 1,
                index: e.index
            };
        },
        evaluate: function(a, b) {
            var c = this.getParameterAt(a);
            return C.evaluate(this.curves[c.index], c.value, b);
        },
        drawPart: function(a, b, c) {
            b = this.getParameterAt(b), c = this.getParameterAt(c);
            for (var d = b.index; d <= c.index; d++) {
                var e = C.getPart(this.curves[d], d == b.index ? b.value : 0, d == c.index ? c.value : 1);
                d == b.index && a.moveTo(e[0], e[1]), a.bezierCurveTo.apply(a, e.slice(2));
            }
        }
    }, b.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(a, b) {
        this[a + "At"] = function(a) {
            return this.evaluate(a, b);
        };
    }, {})), I = b.extend({
        initialize: function(a, b) {
            this.points = [];
            for (var c, d = a._segments, e = 0, f = d.length; f > e; e++) {
                var g = d[e].point.clone();
                c && c.equals(g) || (this.points.push(g), c = g);
            }
            this.error = b;
        },
        fit: function() {
            var a = this.points, b = a.length;
            return this.segments = b > 0 ? [ new A(a[0]) ] : [], b > 1 && this.fitCubic(0, b - 1, a[1].subtract(a[0]).normalize(), a[b - 2].subtract(a[b - 1]).normalize()), 
            this.segments;
        },
        fitCubic: function(a, b, c, d) {
            if (b - a == 1) {
                var e = this.points[a], f = this.points[b], g = e.getDistance(f) / 3;
                return void this.addCurve([ e, e.add(c.normalize(g)), f.add(d.normalize(g)), f ]);
            }
            for (var h, i = this.chordLengthParameterize(a, b), j = Math.max(this.error, this.error * this.error), k = 0; 4 >= k; k++) {
                var l = this.generateBezier(a, b, i, c, d), m = this.findMaxError(a, b, l, i);
                if (m.error < this.error) return void this.addCurve(l);
                if (h = m.index, m.error >= j) break;
                this.reparameterize(a, b, i, l), j = m.error;
            }
            var n = this.points[h - 1].subtract(this.points[h]), o = this.points[h].subtract(this.points[h + 1]), p = n.add(o).divide(2).normalize();
            this.fitCubic(a, h, c, p), this.fitCubic(h, b, p.negate(), d);
        },
        addCurve: function(a) {
            var b = this.segments[this.segments.length - 1];
            b.setHandleOut(a[1].subtract(a[0])), this.segments.push(new A(a[3], a[2].subtract(a[3])));
        },
        generateBezier: function(a, b, c, d, e) {
            for (var f = 1e-11, g = this.points[a], h = this.points[b], i = [ [ 0, 0 ], [ 0, 0 ] ], j = [ 0, 0 ], k = 0, l = b - a + 1; l > k; k++) {
                var m = c[k], n = 1 - m, o = 3 * m * n, p = n * n * n, q = o * n, r = o * m, s = m * m * m, t = d.normalize(q), u = e.normalize(r), v = this.points[a + k].subtract(g.multiply(p + q)).subtract(h.multiply(r + s));
                i[0][0] += t.dot(t), i[0][1] += t.dot(u), i[1][0] = i[0][1], i[1][1] += u.dot(u), 
                j[0] += t.dot(v), j[1] += u.dot(v);
            }
            var w, x, y = i[0][0] * i[1][1] - i[1][0] * i[0][1];
            if (Math.abs(y) > f) {
                var z = i[0][0] * j[1] - i[1][0] * j[0], A = j[0] * i[1][1] - j[1] * i[0][1];
                w = A / y, x = z / y;
            } else {
                var B = i[0][0] + i[0][1], C = i[1][0] + i[1][1];
                w = x = Math.abs(B) > f ? j[0] / B : Math.abs(C) > f ? j[1] / C : 0;
            }
            var D = h.getDistance(g);
            return f *= D, (f > w || f > x) && (w = x = D / 3), [ g, g.add(d.normalize(w)), h.add(e.normalize(x)), h ];
        },
        reparameterize: function(a, b, c, d) {
            for (var e = a; b >= e; e++) c[e - a] = this.findRoot(d, this.points[e], c[e - a]);
        },
        findRoot: function(a, b, c) {
            for (var d = [], e = [], f = 0; 2 >= f; f++) d[f] = a[f + 1].subtract(a[f]).multiply(3);
            for (var f = 0; 1 >= f; f++) e[f] = d[f + 1].subtract(d[f]).multiply(2);
            var g = this.evaluate(3, a, c), h = this.evaluate(2, d, c), i = this.evaluate(1, e, c), j = g.subtract(b), k = h.dot(h) + j.dot(i);
            return Math.abs(k) < 1e-5 ? c : c - j.dot(h) / k;
        },
        evaluate: function(a, b, c) {
            for (var d = b.slice(), e = 1; a >= e; e++) for (var f = 0; a - e >= f; f++) d[f] = d[f].multiply(1 - c).add(d[f + 1].multiply(c));
            return d[0];
        },
        chordLengthParameterize: function(a, b) {
            for (var c = [ 0 ], d = a + 1; b >= d; d++) c[d - a] = c[d - a - 1] + this.points[d].getDistance(this.points[d - 1]);
            for (var d = 1, e = b - a; e >= d; d++) c[d] /= c[e];
            return c;
        },
        findMaxError: function(a, b, c, d) {
            for (var e = Math.floor((b - a + 1) / 2), f = 0, g = a + 1; b > g; g++) {
                var h = this.evaluate(3, c, d[g - a]), i = h.subtract(this.points[g]), j = i.x * i.x + i.y * i.y;
                j >= f && (f = j, e = g);
            }
            return {
                error: f,
                index: e
            };
        }
    }), J = t.extend({
        _class: "TextItem",
        _boundsSelected: !0,
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _serializeFields: {
            content: null
        },
        _boundsGetter: "getBounds",
        initialize: function(c) {
            this._content = "", this._lines = [];
            var d = c && b.isPlainObject(c) && c.x === a && c.y === a;
            this._initialize(d && c, !d && h.read(arguments));
        },
        _equals: function(a) {
            return this._content === a._content;
        },
        _clone: function ua(a) {
            return a.setContent(this._content), ua.base.call(this, a);
        },
        getContent: function() {
            return this._content;
        },
        setContent: function(a) {
            this._content = "" + a, this._lines = this._content.split(/\r\n|\n|\r/gm), this._changed(265);
        },
        isEmpty: function() {
            return !this._content;
        },
        getCharacterStyle: "#getStyle",
        setCharacterStyle: "#setStyle",
        getParagraphStyle: "#getStyle",
        setParagraphStyle: "#setStyle"
    }), K = J.extend({
        _class: "PointText",
        initialize: function() {
            J.apply(this, arguments);
        },
        clone: function(a) {
            return this._clone(new K(t.NO_INSERT), a);
        },
        getPoint: function() {
            var a = this._matrix.getTranslation();
            return new j(a.x, a.y, this, "setPoint");
        },
        setPoint: function() {
            var a = h.read(arguments);
            this.translate(a.subtract(this._matrix.getTranslation()));
        },
        _draw: function(a) {
            if (this._content) {
                this._setStyles(a);
                var b = this._style, c = this._lines, d = b.getLeading(), e = a.shadowColor;
                a.font = b.getFontStyle(), a.textAlign = b.getJustification();
                for (var f = 0, g = c.length; g > f; f++) {
                    a.shadowColor = e;
                    var h = c[f];
                    b.hasFill() && (a.fillText(h, 0, 0), a.shadowColor = "rgba(0,0,0,0)"), b.hasStroke() && a.strokeText(h, 0, 0), 
                    a.translate(0, d);
                }
            }
        },
        _getBounds: function(a, b) {
            var c = this._style, d = this._lines, e = d.length, f = c.getJustification(), g = c.getLeading(), h = this.getView().getTextWidth(c.getFontStyle(), d), i = 0;
            "left" !== f && (i -= h / ("center" === f ? 2 : 1));
            var j = new n(i, e ? -.75 * g : 0, h, e * g);
            return b ? b._transformBounds(j, j) : j;
        }
    }), L = b.extend(new function() {
        function a(a) {
            var b, d = a.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/);
            if (d) {
                b = [ 0, 0, 0 ];
                for (var e = 0; 3 > e; e++) {
                    var f = d[e + 1];
                    b[e] = parseInt(1 == f.length ? f + f : f, 16) / 255;
                }
            } else if (d = a.match(/^rgba?\((.*)\)$/)) {
                b = d[1].split(",");
                for (var e = 0, h = b.length; h > e; e++) {
                    var f = +b[e];
                    b[e] = 3 > e ? f / 255 : f;
                }
            } else {
                var i = g[a];
                if (!i) {
                    c || (c = Z.getContext(1, 1), c.globalCompositeOperation = "copy"), c.fillStyle = "rgba(0,0,0,0)", 
                    c.fillStyle = a, c.fillRect(0, 0, 1, 1);
                    var j = c.getImageData(0, 0, 1, 1).data;
                    i = g[a] = [ j[0] / 255, j[1] / 255, j[2] / 255 ];
                }
                b = i.slice();
            }
            return b;
        }
        var c, d = {
            gray: [ "gray" ],
            rgb: [ "red", "green", "blue" ],
            hsb: [ "hue", "saturation", "brightness" ],
            hsl: [ "hue", "saturation", "lightness" ],
            gradient: [ "gradient", "origin", "destination", "highlight" ]
        }, e = {}, g = {}, i = [ [ 0, 3, 1 ], [ 2, 0, 1 ], [ 1, 0, 3 ], [ 1, 2, 0 ], [ 3, 1, 0 ], [ 0, 1, 2 ] ], j = {
            "rgb-hsb": function(a, b, c) {
                var d = Math.max(a, b, c), e = Math.min(a, b, c), f = d - e, g = 0 === f ? 0 : 60 * (d == a ? (b - c) / f + (c > b ? 6 : 0) : d == b ? (c - a) / f + 2 : (a - b) / f + 4);
                return [ g, 0 === d ? 0 : f / d, d ];
            },
            "hsb-rgb": function(a, b, c) {
                a = (a / 60 % 6 + 6) % 6;
                var d = Math.floor(a), e = a - d, d = i[d], f = [ c, c * (1 - b), c * (1 - b * e), c * (1 - b * (1 - e)) ];
                return [ f[d[0]], f[d[1]], f[d[2]] ];
            },
            "rgb-hsl": function(a, b, c) {
                var d = Math.max(a, b, c), e = Math.min(a, b, c), f = d - e, g = 0 === f, h = g ? 0 : 60 * (d == a ? (b - c) / f + (c > b ? 6 : 0) : d == b ? (c - a) / f + 2 : (a - b) / f + 4), i = (d + e) / 2, j = g ? 0 : .5 > i ? f / (d + e) : f / (2 - d - e);
                return [ h, j, i ];
            },
            "hsl-rgb": function(a, b, c) {
                if (a = (a / 360 % 1 + 1) % 1, 0 === b) return [ c, c, c ];
                for (var d = [ a + 1 / 3, a, a - 1 / 3 ], e = .5 > c ? c * (1 + b) : c + b - c * b, f = 2 * c - e, g = [], h = 0; 3 > h; h++) {
                    var i = d[h];
                    0 > i && (i += 1), i > 1 && (i -= 1), g[h] = 1 > 6 * i ? f + 6 * (e - f) * i : 1 > 2 * i ? e : 2 > 3 * i ? f + (e - f) * (2 / 3 - i) * 6 : f;
                }
                return g;
            },
            "rgb-gray": function(a, b, c) {
                return [ .2989 * a + .587 * b + .114 * c ];
            },
            "gray-rgb": function(a) {
                return [ a, a, a ];
            },
            "gray-hsb": function(a) {
                return [ 0, 0, a ];
            },
            "gray-hsl": function(a) {
                return [ 0, 0, a ];
            },
            "gradient-rgb": function() {
                return [];
            },
            "rgb-gradient": function() {
                return [];
            }
        };
        return b.each(d, function(a, c) {
            e[c] = [], b.each(a, function(a, f) {
                var g = b.capitalize(a), i = /^(hue|saturation)$/.test(a), j = e[c][f] = "gradient" === a ? function(a) {
                    var b = this._components[0];
                    return a = M.read(Array.isArray(a) ? a : arguments, 0, {
                        readNull: !0
                    }), b !== a && (b && b._removeOwner(this), a && a._addOwner(this)), a;
                } : "gradient" === c ? function() {
                    return h.read(arguments, 0, {
                        readNull: "highlight" === a,
                        clone: !0
                    });
                } : function(a) {
                    return null == a || isNaN(a) ? 0 : a;
                };
                this["get" + g] = function() {
                    return this._type === c || i && /^hs[bl]$/.test(this._type) ? this._components[f] : this._convert(c)[f];
                }, this["set" + g] = function(a) {
                    this._type === c || i && /^hs[bl]$/.test(this._type) || (this._components = this._convert(c), 
                    this._properties = d[c], this._type = c), a = j.call(this, a), null != a && (this._components[f] = a, 
                    this._changed());
                };
            }, this);
        }, {
            _class: "Color",
            _readIndex: !0,
            initialize: function k(b) {
                var c, f, g, h, i = Array.prototype.slice, j = arguments, l = 0;
                Array.isArray(b) && (j = b, b = j[0]);
                var m = null != b && typeof b;
                if ("string" === m && b in d && (c = b, b = j[1], Array.isArray(b) ? (f = b, g = j[2]) : (this.__read && (l = 1), 
                j = i.call(j, 1), m = typeof b)), !f) {
                    if (h = "number" === m ? j : "object" === m && null != b.length ? b : null) {
                        c || (c = h.length >= 3 ? "rgb" : "gray");
                        var n = d[c].length;
                        g = h[n], this.__read && (l += h === arguments ? n + (null != g ? 1 : 0) : 1), h.length > n && (h = i.call(h, 0, n));
                    } else if ("string" === m) c = "rgb", f = a(b), 4 === f.length && (g = f[3], f.length--); else if ("object" === m) if (b.constructor === k) {
                        if (c = b._type, f = b._components.slice(), g = b._alpha, "gradient" === c) for (var o = 1, p = f.length; p > o; o++) {
                            var q = f[o];
                            q && (f[o] = q.clone());
                        }
                    } else if (b.constructor === M) c = "gradient", h = j; else {
                        c = "hue" in b ? "lightness" in b ? "hsl" : "hsb" : "gradient" in b || "stops" in b || "radial" in b ? "gradient" : "gray" in b ? "gray" : "rgb";
                        var r = d[c];
                        t = e[c], this._components = f = [];
                        for (var o = 0, p = r.length; p > o; o++) {
                            var s = b[r[o]];
                            null == s && 0 === o && "gradient" === c && "stops" in b && (s = {
                                stops: b.stops,
                                radial: b.radial
                            }), s = t[o].call(this, s), null != s && (f[o] = s);
                        }
                        g = b.alpha;
                    }
                    this.__read && c && (l = 1);
                }
                if (this._type = c || "rgb", "gradient" === c && (this._id = k._id = (k._id || 0) + 1), 
                !f) {
                    this._components = f = [];
                    for (var t = e[this._type], o = 0, p = t.length; p > o; o++) {
                        var s = t[o].call(this, h && h[o]);
                        null != s && (f[o] = s);
                    }
                }
                this._components = f, this._properties = d[this._type], this._alpha = g, this.__read && (this.__read = l);
            },
            _serialize: function(a, c) {
                var d = this.getComponents();
                return b.serialize(/^(gray|rgb)$/.test(this._type) ? d : [ this._type ].concat(d), a, !0, c);
            },
            _changed: function() {
                this._canvasStyle = null, this._owner && this._owner._changed(65);
            },
            _convert: function(a) {
                var b;
                return this._type === a ? this._components.slice() : (b = j[this._type + "-" + a]) ? b.apply(this, this._components) : j["rgb-" + a].apply(this, j[this._type + "-rgb"].apply(this, this._components));
            },
            convert: function(a) {
                return new L(a, this._convert(a), this._alpha);
            },
            getType: function() {
                return this._type;
            },
            setType: function(a) {
                this._components = this._convert(a), this._properties = d[a], this._type = a;
            },
            getComponents: function() {
                var a = this._components.slice();
                return null != this._alpha && a.push(this._alpha), a;
            },
            getAlpha: function() {
                return null != this._alpha ? this._alpha : 1;
            },
            setAlpha: function(a) {
                this._alpha = null == a ? null : Math.min(Math.max(a, 0), 1), this._changed();
            },
            hasAlpha: function() {
                return null != this._alpha;
            },
            equals: function(a) {
                var c = b.isPlainValue(a, !0) ? L.read(arguments) : a;
                return c === this || c && this._class === c._class && this._type === c._type && this._alpha === c._alpha && b.equals(this._components, c._components) || !1;
            },
            toString: function() {
                for (var a = this._properties, b = [], c = "gradient" === this._type, d = f.instance, e = 0, g = a.length; g > e; e++) {
                    var h = this._components[e];
                    null != h && b.push(a[e] + ": " + (c ? h : d.number(h)));
                }
                return null != this._alpha && b.push("alpha: " + d.number(this._alpha)), "{ " + b.join(", ") + " }";
            },
            toCSS: function(a) {
                function b(a) {
                    return Math.round(255 * (0 > a ? 0 : a > 1 ? 1 : a));
                }
                var c = this._convert("rgb"), d = a || null == this._alpha ? 1 : this._alpha;
                return c = [ b(c[0]), b(c[1]), b(c[2]) ], 1 > d && c.push(0 > d ? 0 : d), a ? "#" + ((1 << 24) + (c[0] << 16) + (c[1] << 8) + c[2]).toString(16).slice(1) : (4 == c.length ? "rgba(" : "rgb(") + c.join(",") + ")";
            },
            toCanvasStyle: function(a) {
                if (this._canvasStyle) return this._canvasStyle;
                if ("gradient" !== this._type) return this._canvasStyle = this.toCSS();
                var b, c = this._components, d = c[0], e = d._stops, f = c[1], g = c[2];
                if (d._radial) {
                    var h = g.getDistance(f), i = c[3];
                    if (i) {
                        var j = i.subtract(f);
                        j.getLength() > h && (i = f.add(j.normalize(h - .1)));
                    }
                    var k = i || f;
                    b = a.createRadialGradient(k.x, k.y, 0, f.x, f.y, h);
                } else b = a.createLinearGradient(f.x, f.y, g.x, g.y);
                for (var l = 0, m = e.length; m > l; l++) {
                    var n = e[l];
                    b.addColorStop(n._rampPoint, n._color.toCanvasStyle());
                }
                return this._canvasStyle = b;
            },
            transform: function(a) {
                if ("gradient" === this._type) {
                    for (var b = this._components, c = 1, d = b.length; d > c; c++) {
                        var e = b[c];
                        a._transformPoint(e, e, !0);
                    }
                    this._changed();
                }
            },
            statics: {
                _types: d,
                random: function() {
                    var a = Math.random;
                    return new L(a(), a(), a());
                }
            }
        });
    }(), new function() {
        var a = {
            add: function(a, b) {
                return a + b;
            },
            subtract: function(a, b) {
                return a - b;
            },
            multiply: function(a, b) {
                return a * b;
            },
            divide: function(a, b) {
                return a / b;
            }
        };
        return b.each(a, function(a, b) {
            this[b] = function(b) {
                b = L.read(arguments);
                for (var c = this._type, d = this._components, e = b._convert(c), f = 0, g = d.length; g > f; f++) e[f] = a(d[f], e[f]);
                return new L(c, e, null != this._alpha ? a(this._alpha, b.getAlpha()) : null);
            };
        }, {});
    }());
    b.each(L._types, function(a, c) {
        var d = this[b.capitalize(c) + "Color"] = function(a) {
            var b = null != a && typeof a, d = "object" === b && null != a.length ? a : "string" === b ? null : arguments;
            return d ? new L(c, d) : new L(a);
        };
        if (3 == c.length) {
            var e = c.toUpperCase();
            L[e] = this[e + "Color"] = d;
        }
    }, b.exports);
    var M = b.extend({
        _class: "Gradient",
        initialize: function va(a, b) {
            this._id = va._id = (va._id || 0) + 1, a && this._set(a) && (a = b = null), this._stops || this.setStops(a || [ "white", "black" ]), 
            null == this._radial && this.setRadial("string" == typeof b && "radial" === b || b || !1);
        },
        _serialize: function(a, c) {
            return c.add(this, function() {
                return b.serialize([ this._stops, this._radial ], a, !0, c);
            });
        },
        _changed: function() {
            for (var a = 0, b = this._owners && this._owners.length; b > a; a++) this._owners[a]._changed();
        },
        _addOwner: function(a) {
            this._owners || (this._owners = []), this._owners.push(a);
        },
        _removeOwner: function(b) {
            var c = this._owners ? this._owners.indexOf(b) : -1;
            -1 != c && (this._owners.splice(c, 1), 0 === this._owners.length && (this._owners = a));
        },
        clone: function() {
            for (var a = [], b = 0, c = this._stops.length; c > b; b++) a[b] = this._stops[b].clone();
            return new M(a);
        },
        getStops: function() {
            return this._stops;
        },
        setStops: function(b) {
            if (this.stops) for (var c = 0, d = this._stops.length; d > c; c++) this._stops[c]._owner = a;
            if (b.length < 2) throw new Error("Gradient stop list needs to contain at least two stops.");
            this._stops = N.readAll(b, 0, {
                clone: !0
            });
            for (var c = 0, d = this._stops.length; d > c; c++) {
                var e = this._stops[c];
                e._owner = this, e._defaultRamp && e.setRampPoint(c / (d - 1));
            }
            this._changed();
        },
        getRadial: function() {
            return this._radial;
        },
        setRadial: function(a) {
            this._radial = a, this._changed();
        },
        equals: function(a) {
            if (a === this) return !0;
            if (a && this._class === a._class && this._stops.length === a._stops.length) {
                for (var b = 0, c = this._stops.length; c > b; b++) if (!this._stops[b].equals(a._stops[b])) return !1;
                return !0;
            }
            return !1;
        }
    }), N = b.extend({
        _class: "GradientStop",
        initialize: function(b, c) {
            if (b) {
                var d, e;
                c === a && Array.isArray(b) ? (d = b[0], e = b[1]) : b.color ? (d = b.color, e = b.rampPoint) : (d = b, 
                e = c), this.setColor(d), this.setRampPoint(e);
            }
        },
        clone: function() {
            return new N(this._color.clone(), this._rampPoint);
        },
        _serialize: function(a, c) {
            return b.serialize([ this._color, this._rampPoint ], a, !0, c);
        },
        _changed: function() {
            this._owner && this._owner._changed(65);
        },
        getRampPoint: function() {
            return this._rampPoint;
        },
        setRampPoint: function(a) {
            this._defaultRamp = null == a, this._rampPoint = a || 0, this._changed();
        },
        getColor: function() {
            return this._color;
        },
        setColor: function(a) {
            this._color = L.read(arguments), this._color === a && (this._color = a.clone()), 
            this._color._owner = this, this._changed();
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && this._color.equals(a._color) && this._rampPoint == a._rampPoint || !1;
        }
    }), O = b.extend(new function() {
        var c = {
            fillColor: a,
            strokeColor: a,
            strokeWidth: 1,
            strokeCap: "butt",
            strokeJoin: "miter",
            strokeScaling: !0,
            miterLimit: 10,
            dashOffset: 0,
            dashArray: [],
            windingRule: "nonzero",
            shadowColor: a,
            shadowBlur: 0,
            shadowOffset: new h(),
            selectedColor: a,
            fontFamily: "sans-serif",
            fontWeight: "normal",
            fontSize: 12,
            font: "sans-serif",
            leading: null,
            justification: "left"
        }, d = {
            strokeWidth: 97,
            strokeCap: 97,
            strokeJoin: 97,
            strokeScaling: 105,
            miterLimit: 97,
            fontFamily: 9,
            fontWeight: 9,
            fontSize: 9,
            font: 9,
            leading: 9,
            justification: 9
        }, e = {
            beans: !0
        }, f = {
            _defaults: c,
            _textDefaults: new b(c, {
                fillColor: new L()
            }),
            beans: !0
        };
        return b.each(c, function(c, g) {
            var i = /Color$/.test(g), j = "shadowOffset" === g, k = b.capitalize(g), l = d[g], m = "set" + k, n = "get" + k;
            f[m] = function(b) {
                var c = this._owner, d = c && c._children;
                if (d && d.length > 0 && !(c instanceof G)) for (var e = 0, f = d.length; f > e; e++) d[e]._style[m](b); else {
                    var h = this._values[g];
                    h != b && (i && (h && (h._owner = a), b && b.constructor === L && (b._owner && (b = b.clone()), 
                    b._owner = c)), this._values[g] = b, c && c._changed(l || 65));
                }
            }, f[n] = function(c) {
                var d, e = this._owner, f = e && e._children;
                if (!f || 0 === f.length || c || e instanceof G) {
                    var d = this._values[g];
                    if (d === a) d = this._defaults[g], d && d.clone && (d = d.clone()), this._values[g] = d; else {
                        var k = i ? L : j ? h : null;
                        !k || d && d.constructor === k || (this._values[g] = d = k.read([ d ], 0, {
                            readNull: !0,
                            clone: !0
                        }), d && i && (d._owner = e));
                    }
                    return d;
                }
                for (var l = 0, m = f.length; m > l; l++) {
                    var o = f[l]._style[n]();
                    if (0 === l) d = o; else if (!b.equals(d, o)) return a;
                }
                return d;
            }, e[n] = function(a) {
                return this._style[n](a);
            }, e[m] = function(a) {
                this._style[m](a);
            };
        }), t.inject(e), f;
    }(), {
        _class: "Style",
        initialize: function(a, b, c) {
            this._values = {}, this._owner = b, this._project = b && b._project || c || paper.project, 
            b instanceof J && (this._defaults = this._textDefaults), a && this.set(a);
        },
        set: function(a) {
            var b = a instanceof O, c = b ? a._values : a;
            if (c) for (var d in c) if (d in this._defaults) {
                var e = c[d];
                this[d] = e && b && e.clone ? e.clone() : e;
            }
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && b.equals(this._values, a._values) || !1;
        },
        hasFill: function() {
            return !!this.getFillColor();
        },
        hasStroke: function() {
            return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
        },
        hasShadow: function() {
            return !!this.getShadowColor() && this.getShadowBlur() > 0;
        },
        getView: function() {
            return this._project.getView();
        },
        getFontStyle: function() {
            var a = this.getFontSize();
            return this.getFontWeight() + " " + a + (/[a-z]/i.test(a + "") ? " " : "px ") + this.getFontFamily();
        },
        getFont: "#getFontFamily",
        setFont: "#setFontFamily",
        getLeading: function wa() {
            var a = wa.base.call(this), b = this.getFontSize();
            return /pt|em|%|px/.test(b) && (b = this.getView().getPixelSize(b)), null != a ? a : 1.2 * b;
        }
    }), P = new function() {
        function a(a, b, c, d) {
            for (var e = [ "", "webkit", "moz", "Moz", "ms", "o" ], f = b[0].toUpperCase() + b.substring(1), g = 0; 6 > g; g++) {
                var h = e[g], i = h ? h + f : b;
                if (i in a) {
                    if (!c) return a[i];
                    a[i] = d;
                    break;
                }
            }
        }
        return {
            getStyles: function(a) {
                var b = a && 9 !== a.nodeType ? a.ownerDocument : a, c = b && b.defaultView;
                return c && c.getComputedStyle(a, "");
            },
            getBounds: function(a, b) {
                var c, d = a.ownerDocument, e = d.body, f = d.documentElement;
                try {
                    c = a.getBoundingClientRect();
                } catch (g) {
                    c = {
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0
                    };
                }
                var h = c.left - (f.clientLeft || e.clientLeft || 0), i = c.top - (f.clientTop || e.clientTop || 0);
                if (!b) {
                    var j = d.defaultView;
                    h += j.pageXOffset || f.scrollLeft || e.scrollLeft, i += j.pageYOffset || f.scrollTop || e.scrollTop;
                }
                return new n(h, i, c.width, c.height);
            },
            getViewportBounds: function(a) {
                var b = a.ownerDocument, c = b.defaultView, d = b.documentElement;
                return new n(0, 0, c.innerWidth || d.clientWidth, c.innerHeight || d.clientHeight);
            },
            getOffset: function(a, b) {
                return P.getBounds(a, b).getPoint();
            },
            getSize: function(a) {
                return P.getBounds(a, !0).getSize();
            },
            isInvisible: function(a) {
                return P.getSize(a).equals(new k(0, 0));
            },
            isInView: function(a) {
                return !P.isInvisible(a) && P.getViewportBounds(a).intersects(P.getBounds(a, !0));
            },
            getPrefixed: function(b, c) {
                return a(b, c);
            },
            setPrefixed: function(b, c, d) {
                if ("object" == typeof c) for (var e in c) a(b, e, !0, c[e]); else a(b, c, !0, d);
            }
        };
    }(), Q = {
        add: function(a, b) {
            for (var c in b) for (var d = b[c], e = c.split(/[\s,]+/g), f = 0, g = e.length; g > f; f++) a.addEventListener(e[f], d, !1);
        },
        remove: function(a, b) {
            for (var c in b) for (var d = b[c], e = c.split(/[\s,]+/g), f = 0, g = e.length; g > f; f++) a.removeEventListener(e[f], d, !1);
        },
        getPoint: function(a) {
            var b = a.targetTouches ? a.targetTouches.length ? a.targetTouches[0] : a.changedTouches[0] : a;
            return new h(b.pageX || b.clientX + document.documentElement.scrollLeft, b.pageY || b.clientY + document.documentElement.scrollTop);
        },
        getTarget: function(a) {
            return a.target || a.srcElement;
        },
        getRelatedTarget: function(a) {
            return a.relatedTarget || a.toElement;
        },
        getOffset: function(a, b) {
            return Q.getPoint(a).subtract(P.getOffset(b || Q.getTarget(a)));
        },
        stop: function(a) {
            a.stopPropagation(), a.preventDefault();
        }
    };
    Q.requestAnimationFrame = new function() {
        function a() {
            for (var b = f.length - 1; b >= 0; b--) {
                var h = f[b], i = h[0], j = h[1];
                (!j || ("true" == d.getAttribute(j, "keepalive") || g) && P.isInView(j)) && (f.splice(b, 1), 
                i());
            }
            c && (f.length ? c(a) : e = !1);
        }
        var b, c = P.getPrefixed(window, "requestAnimationFrame"), e = !1, f = [], g = !0;
        return Q.add(window, {
            focus: function() {
                g = !0;
            },
            blur: function() {
                g = !1;
            }
        }), function(d, g) {
            f.push([ d, g ]), c ? e || (c(a), e = !0) : b || (b = setInterval(a, 1e3 / 60));
        };
    }();
    var R = b.extend(c, {
        _class: "View",
        initialize: function xa(a, b) {
            this._project = a, this._scope = a._scope, this._element = b;
            var c;
            this._pixelRatio || (this._pixelRatio = window.devicePixelRatio || 1), this._id = b.getAttribute("id"), 
            null == this._id && b.setAttribute("id", this._id = "view-" + xa._id++), Q.add(b, this._viewEvents);
            var e = "none";
            if (P.setPrefixed(b.style, {
                userSelect: e,
                touchAction: e,
                touchCallout: e,
                contentZooming: e,
                userDrag: e,
                tapHighlightColor: "rgba(0,0,0,0)"
            }), d.hasAttribute(b, "resize")) {
                var f = P.getOffset(b, !0), g = this;
                c = P.getViewportBounds(b).getSize().subtract(f), this._windowEvents = {
                    resize: function() {
                        P.isInvisible(b) || (f = P.getOffset(b, !0)), g.setViewSize(P.getViewportBounds(b).getSize().subtract(f));
                    }
                }, Q.add(window, this._windowEvents);
            } else if (c = P.getSize(b), c.isNaN() || c.isZero()) {
                var h = function(a) {
                    return b[a] || parseInt(b.getAttribute(a), 10);
                };
                c = new k(h("width"), h("height"));
            }
            if (this._setViewSize(c), d.hasAttribute(b, "stats") && "undefined" != typeof Stats) {
                this._stats = new Stats();
                var i = this._stats.domElement, j = i.style, f = P.getOffset(b);
                j.position = "absolute", j.left = f.x + "px", j.top = f.y + "px", document.body.appendChild(i);
            }
            xa._views.push(this), xa._viewsById[this._id] = this, this._viewSize = c, (this._matrix = new p())._owner = this, 
            this._zoom = 1, xa._focused || (xa._focused = this), this._frameItems = {}, this._frameItemCount = 0;
        },
        remove: function() {
            return this._project ? (R._focused === this && (R._focused = null), R._views.splice(R._views.indexOf(this), 1), 
            delete R._viewsById[this._id], this._project._view === this && (this._project._view = null), 
            Q.remove(this._element, this._viewEvents), Q.remove(window, this._windowEvents), 
            this._element = this._project = null, this.off("frame"), this._animate = !1, this._frameItems = {}, 
            !0) : !1;
        },
        _events: {
            onFrame: {
                install: function() {
                    this.play();
                },
                uninstall: function() {
                    this.pause();
                }
            },
            onResize: {}
        },
        _animate: !1,
        _time: 0,
        _count: 0,
        _requestFrame: function() {
            var a = this;
            Q.requestAnimationFrame(function() {
                a._requested = !1, a._animate && (a._requestFrame(), a._handleFrame());
            }, this._element), this._requested = !0;
        },
        _handleFrame: function() {
            paper = this._scope;
            var a = Date.now() / 1e3, c = this._before ? a - this._before : 0;
            this._before = a, this._handlingFrame = !0, this.emit("frame", new b({
                delta: c,
                time: this._time += c,
                count: this._count++
            })), this._stats && this._stats.update(), this._handlingFrame = !1, this.update();
        },
        _animateItem: function(a, b) {
            var c = this._frameItems;
            b ? (c[a._id] = {
                item: a,
                time: 0,
                count: 0
            }, 1 === ++this._frameItemCount && this.on("frame", this._handleFrameItems)) : (delete c[a._id], 
            0 === --this._frameItemCount && this.off("frame", this._handleFrameItems));
        },
        _handleFrameItems: function(a) {
            for (var c in this._frameItems) {
                var d = this._frameItems[c];
                d.item.emit("frame", new b(a, {
                    time: d.time += a.delta,
                    count: d.count++
                }));
            }
        },
        _update: function() {
            this._project._needsUpdate = !0, this._handlingFrame || (this._animate ? this._handleFrame() : this.update());
        },
        _changed: function(a) {
            1 & a && (this._project._needsUpdate = !0);
        },
        _transform: function(a) {
            this._matrix.concatenate(a), this._bounds = null, this._update();
        },
        getElement: function() {
            return this._element;
        },
        getPixelRatio: function() {
            return this._pixelRatio;
        },
        getResolution: function() {
            return 72 * this._pixelRatio;
        },
        getViewSize: function() {
            var a = this._viewSize;
            return new m(a.width, a.height, this, "setViewSize");
        },
        setViewSize: function() {
            var a = k.read(arguments), b = a.subtract(this._viewSize);
            b.isZero() || (this._viewSize.set(a.width, a.height), this._setViewSize(a), this._bounds = null, 
            this.emit("resize", {
                size: a,
                delta: b
            }), this._update());
        },
        _setViewSize: function(a) {
            var b = this._element;
            b.width = a.width, b.height = a.height;
        },
        getBounds: function() {
            return this._bounds || (this._bounds = this._matrix.inverted()._transformBounds(new n(new h(), this._viewSize))), 
            this._bounds;
        },
        getSize: function() {
            return this.getBounds().getSize();
        },
        getCenter: function() {
            return this.getBounds().getCenter();
        },
        setCenter: function() {
            var a = h.read(arguments);
            this.scrollBy(a.subtract(this.getCenter()));
        },
        getZoom: function() {
            return this._zoom;
        },
        setZoom: function(a) {
            this._transform(new p().scale(a / this._zoom, this.getCenter())), this._zoom = a;
        },
        isVisible: function() {
            return P.isInView(this._element);
        },
        scrollBy: function() {
            this._transform(new p().translate(h.read(arguments).negate()));
        },
        play: function() {
            this._animate = !0, this._requested || this._requestFrame();
        },
        pause: function() {
            this._animate = !1;
        },
        draw: function() {
            this.update();
        },
        projectToView: function() {
            return this._matrix._transformPoint(h.read(arguments));
        },
        viewToProject: function() {
            return this._matrix._inverseTransform(h.read(arguments));
        }
    }, {
        statics: {
            _views: [],
            _viewsById: {},
            _id: 0,
            create: function(a, b) {
                return "string" == typeof b && (b = document.getElementById(b)), new S(a, b);
            }
        }
    }, new function() {
        function a(a) {
            var b = Q.getTarget(a);
            return b.getAttribute && R._viewsById[b.getAttribute("id")];
        }
        function b(a, b) {
            return a.viewToProject(Q.getOffset(b, a._element));
        }
        function c() {
            if (!R._focused || !R._focused.isVisible()) for (var a = 0, b = R._views.length; b > a; a++) {
                var c = R._views[a];
                if (c && c.isVisible()) {
                    R._focused = g = c;
                    break;
                }
            }
        }
        function d(a, b, c) {
            a._handleEvent("mousemove", b, c);
            var d = a._scope.tool;
            return d && d._handleEvent(k && d.responds("mousedrag") ? "mousedrag" : "mousemove", b, c), 
            a.update(), d;
        }
        var e, f, g, h, i, j, k = !1, l = window.navigator;
        l.pointerEnabled || l.msPointerEnabled ? (h = "pointerdown MSPointerDown", i = "pointermove MSPointerMove", 
        j = "pointerup pointercancel MSPointerUp MSPointerCancel") : (h = "touchstart", 
        i = "touchmove", j = "touchend touchcancel", "ontouchstart" in window && l.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i) || (h += " mousedown", 
        i += " mousemove", j += " mouseup"));
        var m = {
            "selectstart dragstart": function(a) {
                k && a.preventDefault();
            }
        }, n = {
            mouseout: function(a) {
                var c = R._focused, e = Q.getRelatedTarget(a);
                !c || e && "HTML" !== e.nodeName || d(c, b(c, a), a);
            },
            scroll: c
        };
        return m[h] = function(c) {
            var d = R._focused = a(c), f = b(d, c);
            k = !0, d._handleEvent("mousedown", f, c), (e = d._scope.tool) && e._handleEvent("mousedown", f, c), 
            d.update();
        }, n[i] = function(h) {
            var i = R._focused;
            if (!k) {
                var j = a(h);
                j ? (i !== j && d(i, b(i, h), h), f = i, i = R._focused = g = j) : g && g === i && (i = R._focused = f, 
                c());
            }
            if (i) {
                var l = b(i, h);
                (k || i.getBounds().contains(l)) && (e = d(i, l, h));
            }
        }, n[j] = function(a) {
            var c = R._focused;
            if (c && k) {
                var d = b(c, a);
                k = !1, c._handleEvent("mouseup", d, a), e && e._handleEvent("mouseup", d, a), c.update();
            }
        }, Q.add(document, n), Q.add(window, {
            load: c
        }), {
            _viewEvents: m,
            _handleEvent: function() {},
            statics: {
                updateFocus: c
            }
        };
    }()), S = R.extend({
        _class: "CanvasView",
        initialize: function(a, b) {
            if (!(b instanceof HTMLCanvasElement)) {
                var c = k.read(arguments);
                if (c.isZero()) throw new Error("Cannot create CanvasView with the provided argument: " + [].slice.call(arguments, 1));
                b = Z.getCanvas(c);
            }
            if (this._context = b.getContext("2d"), this._eventCounters = {}, this._pixelRatio = 1, 
            !/^off|false$/.test(d.getAttribute(b, "hidpi"))) {
                var e = window.devicePixelRatio || 1, f = P.getPrefixed(this._context, "backingStorePixelRatio") || 1;
                this._pixelRatio = e / f;
            }
            R.call(this, a, b);
        },
        _setViewSize: function(a) {
            var b = a.width, c = a.height, d = this._pixelRatio, e = this._element, f = e.style;
            e.width = b * d, e.height = c * d, 1 !== d && (f.width = b + "px", f.height = c + "px", 
            this._context.scale(d, d));
        },
        getPixelSize: function(a) {
            var b = this._context, c = b.font;
            return b.font = a + " serif", a = parseFloat(b.font), b.font = c, a;
        },
        getTextWidth: function(a, b) {
            var c = this._context, d = c.font, e = 0;
            c.font = a;
            for (var f = 0, g = b.length; g > f; f++) e = Math.max(e, c.measureText(b[f]).width);
            return c.font = d, e;
        },
        update: function() {
            var a = this._project;
            if (!a || !a._needsUpdate) return !1;
            var b = this._context, c = this._viewSize;
            return b.clearRect(0, 0, c.width + 1, c.height + 1), a.draw(b, this._matrix, this._pixelRatio), 
            a._needsUpdate = !1, !0;
        }
    }, new function() {
        function a(a, b, c, d, e, f) {
            function g(a) {
                return a.responds(b) && (h || (h = new W(b, c, d, e, f ? d.subtract(f) : null)), 
                a.emit(b, h) && h.isStopped) ? (c.preventDefault(), !0) : void 0;
            }
            for (var h, i = e; i; ) {
                if (g(i)) return !0;
                i = i.getParent();
            }
            return g(a) ? !0 : !1;
        }
        var b, c, d, e, f, g, h, i, j;
        return {
            _handleEvent: function(k, l, m) {
                if (this._eventCounters[k]) {
                    var n = this._project, o = n.hitTest(l, {
                        tolerance: 0,
                        fill: !0,
                        stroke: !0
                    }), p = o && o.item, q = !1;
                    switch (k) {
                      case "mousedown":
                        for (q = a(this, k, m, l, p), i = f == p && Date.now() - j < 300, e = f = p, b = c = d = l, 
                        h = !q && p; h && !h.responds("mousedrag"); ) h = h._parent;
                        break;

                      case "mouseup":
                        q = a(this, k, m, l, p, b), h && (c && !c.equals(l) && a(this, "mousedrag", m, l, h, c), 
                        p !== h && (d = l, a(this, "mousemove", m, l, p, d))), !q && p && p === e && (j = Date.now(), 
                        a(this, i && e.responds("doubleclick") ? "doubleclick" : "click", m, b, p), i = !1), 
                        e = h = null;
                        break;

                      case "mousemove":
                        h && (q = a(this, "mousedrag", m, l, h, c)), q || (p !== g && (d = l), q = a(this, k, m, l, p, d)), 
                        c = d = l, p !== g && (a(this, "mouseleave", m, l, g), g = p, a(this, "mouseenter", m, l, p));
                    }
                    return q;
                }
            }
        };
    }()), T = b.extend({
        _class: "Event",
        initialize: function(a) {
            this.event = a;
        },
        isPrevented: !1,
        isStopped: !1,
        preventDefault: function() {
            this.isPrevented = !0, this.event.preventDefault();
        },
        stopPropagation: function() {
            this.isStopped = !0, this.event.stopPropagation();
        },
        stop: function() {
            this.stopPropagation(), this.preventDefault();
        },
        getModifiers: function() {
            return V.modifiers;
        }
    }), U = T.extend({
        _class: "KeyEvent",
        initialize: function(a, b, c, d) {
            T.call(this, d), this.type = a ? "keydown" : "keyup", this.key = b, this.character = c;
        },
        toString: function() {
            return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
        }
    }), V = new function() {
        function a(a, c, e, i) {
            var j, k = e ? String.fromCharCode(e) : "", l = d[c], m = l || k.toLowerCase(), n = a ? "keydown" : "keyup", o = R._focused, p = o && o.isVisible() && o._scope, q = p && p.tool;
            h[m] = a, l && (j = b.camelize(l)) in f && (f[j] = a), a ? g[c] = e : delete g[c], 
            q && q.responds(n) && (paper = p, q.emit(n, new U(a, m, k, i)), o && o.update());
        }
        var c, d = {
            8: "backspace",
            9: "tab",
            13: "enter",
            16: "shift",
            17: "control",
            18: "option",
            19: "pause",
            20: "caps-lock",
            27: "escape",
            32: "space",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            46: "delete",
            91: "command",
            93: "command",
            224: "command"
        }, e = {
            9: !0,
            13: !0,
            32: !0
        }, f = new b({
            shift: !1,
            control: !1,
            option: !1,
            command: !1,
            capsLock: !1,
            space: !1
        }), g = {}, h = {};
        return Q.add(document, {
            keydown: function(b) {
                var g = b.which || b.keyCode;
                g in d || f.command ? a(!0, g, g in e || f.command ? g : 0, b) : c = g;
            },
            keypress: function(b) {
                null != c && (a(!0, c, b.which || b.keyCode, b), c = null);
            },
            keyup: function(b) {
                var c = b.which || b.keyCode;
                c in g && a(!1, c, g[c], b);
            }
        }), Q.add(window, {
            blur: function(b) {
                for (var c in g) a(!1, c, g[c], b);
            }
        }), {
            modifiers: f,
            isDown: function(a) {
                return !!h[a];
            }
        };
    }(), W = T.extend({
        _class: "MouseEvent",
        initialize: function(a, b, c, d, e) {
            T.call(this, b), this.type = a, this.point = c, this.target = d, this.delta = e;
        },
        toString: function() {
            return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }";
        }
    }), X = T.extend({
        _class: "ToolEvent",
        _item: null,
        initialize: function(a, b, c) {
            this.tool = a, this.type = b, this.event = c;
        },
        _choosePoint: function(a, b) {
            return a ? a : b ? b.clone() : null;
        },
        getPoint: function() {
            return this._choosePoint(this._point, this.tool._point);
        },
        setPoint: function(a) {
            this._point = a;
        },
        getLastPoint: function() {
            return this._choosePoint(this._lastPoint, this.tool._lastPoint);
        },
        setLastPoint: function(a) {
            this._lastPoint = a;
        },
        getDownPoint: function() {
            return this._choosePoint(this._downPoint, this.tool._downPoint);
        },
        setDownPoint: function(a) {
            this._downPoint = a;
        },
        getMiddlePoint: function() {
            return !this._middlePoint && this.tool._lastPoint ? this.tool._point.add(this.tool._lastPoint).divide(2) : this._middlePoint;
        },
        setMiddlePoint: function(a) {
            this._middlePoint = a;
        },
        getDelta: function() {
            return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
        },
        setDelta: function(a) {
            this._delta = a;
        },
        getCount: function() {
            return /^mouse(down|up)$/.test(this.type) ? this.tool._downCount : this.tool._count;
        },
        setCount: function(a) {
            this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = a;
        },
        getItem: function() {
            if (!this._item) {
                var a = this.tool._scope.project.hitTest(this.getPoint());
                if (a) {
                    for (var b = a.item, c = b._parent; /^(Group|CompoundPath)$/.test(c._class); ) b = c, 
                    c = c._parent;
                    this._item = b;
                }
            }
            return this._item;
        },
        setItem: function(a) {
            this._item = a;
        },
        toString: function() {
            return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }";
        }
    }), Y = (e.extend({
        _class: "Tool",
        _list: "tools",
        _reference: "tool",
        _events: [ "onActivate", "onDeactivate", "onEditOptions", "onMouseDown", "onMouseUp", "onMouseDrag", "onMouseMove", "onKeyDown", "onKeyUp" ],
        initialize: function(a) {
            e.call(this), this._firstMove = !0, this._count = 0, this._downCount = 0, this._set(a);
        },
        getMinDistance: function() {
            return this._minDistance;
        },
        setMinDistance: function(a) {
            this._minDistance = a, null != this._minDistance && null != this._maxDistance && this._minDistance > this._maxDistance && (this._maxDistance = this._minDistance);
        },
        getMaxDistance: function() {
            return this._maxDistance;
        },
        setMaxDistance: function(a) {
            this._maxDistance = a, null != this._minDistance && null != this._maxDistance && this._maxDistance < this._minDistance && (this._minDistance = a);
        },
        getFixedDistance: function() {
            return this._minDistance == this._maxDistance ? this._minDistance : null;
        },
        setFixedDistance: function(a) {
            this._minDistance = a, this._maxDistance = a;
        },
        _updateEvent: function(a, b, c, d, e, f, g) {
            if (!e) {
                if (null != c || null != d) {
                    var h = null != c ? c : 0, i = b.subtract(this._point), j = i.getLength();
                    if (h > j) return !1;
                    var k = null != d ? d : 0;
                    if (0 != k) if (j > k) b = this._point.add(i.normalize(k)); else if (g) return !1;
                }
                if (f && b.equals(this._point)) return !1;
            }
            switch (this._lastPoint = e && "mousemove" == a ? b : this._point, this._point = b, 
            a) {
              case "mousedown":
                this._lastPoint = this._downPoint, this._downPoint = this._point, this._downCount++;
                break;

              case "mouseup":
                this._lastPoint = this._downPoint;
            }
            return this._count = e ? 0 : this._count + 1, !0;
        },
        _fireEvent: function(a, b) {
            var c = paper.project._removeSets;
            if (c) {
                "mouseup" === a && (c.mousedrag = null);
                var d = c[a];
                if (d) {
                    for (var e in d) {
                        var f = d[e];
                        for (var g in c) {
                            var h = c[g];
                            h && h != d && delete h[f._id];
                        }
                        f.remove();
                    }
                    c[a] = null;
                }
            }
            return this.responds(a) && this.emit(a, new X(this, a, b));
        },
        _handleEvent: function(a, b, c) {
            paper = this._scope;
            var d = !1;
            switch (a) {
              case "mousedown":
                this._updateEvent(a, b, null, null, !0, !1, !1), d = this._fireEvent(a, c);
                break;

              case "mousedrag":
                for (var e = !1, f = !1; this._updateEvent(a, b, this.minDistance, this.maxDistance, !1, e, f); ) d = this._fireEvent(a, c) || d, 
                e = !0, f = !0;
                break;

              case "mouseup":
                !b.equals(this._point) && this._updateEvent("mousedrag", b, this.minDistance, this.maxDistance, !1, !1, !1) && (d = this._fireEvent("mousedrag", c)), 
                this._updateEvent(a, b, null, this.maxDistance, !1, !1, !1), d = this._fireEvent(a, c) || d, 
                this._updateEvent(a, b, null, null, !0, !1, !1), this._firstMove = !0;
                break;

              case "mousemove":
                for (;this._updateEvent(a, b, this.minDistance, this.maxDistance, this._firstMove, !0, !1); ) d = this._fireEvent(a, c) || d, 
                this._firstMove = !1;
            }
            return d && c.preventDefault(), d;
        }
    }), {
        request: function(a, b, c) {
            var d = new (window.ActiveXObject || XMLHttpRequest)("Microsoft.XMLHTTP");
            return d.open(a.toUpperCase(), b, !0), "overrideMimeType" in d && d.overrideMimeType("text/plain"), 
            d.onreadystatechange = function() {
                if (4 === d.readyState) {
                    var a = d.status;
                    if (0 !== a && 200 !== a) throw new Error("Could not load " + b + " (Error " + a + ")");
                    c.call(d, d.responseText);
                }
            }, d.send(null);
        }
    }), Z = {
        canvases: [],
        getCanvas: function(a, b) {
            var c, d = !0;
            "object" == typeof a && (b = a.height, a = a.width), c = this.canvases.length ? this.canvases.pop() : document.createElement("canvas");
            var e = c.getContext("2d");
            return c.width === a && c.height === b ? d && e.clearRect(0, 0, a + 1, b + 1) : (c.width = a, 
            c.height = b), e.save(), c;
        },
        getContext: function(a, b) {
            return this.getCanvas(a, b).getContext("2d");
        },
        release: function(a) {
            var b = a.canvas ? a.canvas : a;
            b.getContext("2d").restore(), this.canvases.push(b);
        }
    }, $ = new function() {
        function a(a, b, c) {
            return .2989 * a + .587 * b + .114 * c;
        }
        function c(b, c, d, e) {
            var f = e - a(b, c, d);
            n = b + f, o = c + f, p = d + f;
            var e = a(n, o, p), g = q(n, o, p), h = r(n, o, p);
            if (0 > g) {
                var i = e - g;
                n = e + (n - e) * e / i, o = e + (o - e) * e / i, p = e + (p - e) * e / i;
            }
            if (h > 255) {
                var j = 255 - e, k = h - e;
                n = e + (n - e) * j / k, o = e + (o - e) * j / k, p = e + (p - e) * j / k;
            }
        }
        function d(a, b, c) {
            return r(a, b, c) - q(a, b, c);
        }
        function e(a, b, c, d) {
            var e, f = [ a, b, c ], g = r(a, b, c), h = q(a, b, c);
            h = h === a ? 0 : h === b ? 1 : 2, g = g === a ? 0 : g === b ? 1 : 2, e = 0 === q(h, g) ? 1 === r(h, g) ? 2 : 1 : 0, 
            f[g] > f[h] ? (f[e] = (f[e] - f[h]) * d / (f[g] - f[h]), f[g] = d) : f[e] = f[g] = 0, 
            f[h] = 0, n = f[0], o = f[1], p = f[2];
        }
        var f, g, h, i, j, k, l, m, n, o, p, q = Math.min, r = Math.max, s = Math.abs, t = {
            multiply: function() {
                n = j * f / 255, o = k * g / 255, p = l * h / 255;
            },
            screen: function() {
                n = j + f - j * f / 255, o = k + g - k * g / 255, p = l + h - l * h / 255;
            },
            overlay: function() {
                n = 128 > j ? 2 * j * f / 255 : 255 - 2 * (255 - j) * (255 - f) / 255, o = 128 > k ? 2 * k * g / 255 : 255 - 2 * (255 - k) * (255 - g) / 255, 
                p = 128 > l ? 2 * l * h / 255 : 255 - 2 * (255 - l) * (255 - h) / 255;
            },
            "soft-light": function() {
                var a = f * j / 255;
                n = a + j * (255 - (255 - j) * (255 - f) / 255 - a) / 255, a = g * k / 255, o = a + k * (255 - (255 - k) * (255 - g) / 255 - a) / 255, 
                a = h * l / 255, p = a + l * (255 - (255 - l) * (255 - h) / 255 - a) / 255;
            },
            "hard-light": function() {
                n = 128 > f ? 2 * f * j / 255 : 255 - 2 * (255 - f) * (255 - j) / 255, o = 128 > g ? 2 * g * k / 255 : 255 - 2 * (255 - g) * (255 - k) / 255, 
                p = 128 > h ? 2 * h * l / 255 : 255 - 2 * (255 - h) * (255 - l) / 255;
            },
            "color-dodge": function() {
                n = 0 === j ? 0 : 255 === f ? 255 : q(255, 255 * j / (255 - f)), o = 0 === k ? 0 : 255 === g ? 255 : q(255, 255 * k / (255 - g)), 
                p = 0 === l ? 0 : 255 === h ? 255 : q(255, 255 * l / (255 - h));
            },
            "color-burn": function() {
                n = 255 === j ? 255 : 0 === f ? 0 : r(0, 255 - 255 * (255 - j) / f), o = 255 === k ? 255 : 0 === g ? 0 : r(0, 255 - 255 * (255 - k) / g), 
                p = 255 === l ? 255 : 0 === h ? 0 : r(0, 255 - 255 * (255 - l) / h);
            },
            darken: function() {
                n = f > j ? j : f, o = g > k ? k : g, p = h > l ? l : h;
            },
            lighten: function() {
                n = j > f ? j : f, o = k > g ? k : g, p = l > h ? l : h;
            },
            difference: function() {
                n = j - f, 0 > n && (n = -n), o = k - g, 0 > o && (o = -o), p = l - h, 0 > p && (p = -p);
            },
            exclusion: function() {
                n = j + f * (255 - j - j) / 255, o = k + g * (255 - k - k) / 255, p = l + h * (255 - l - l) / 255;
            },
            hue: function() {
                e(f, g, h, d(j, k, l)), c(n, o, p, a(j, k, l));
            },
            saturation: function() {
                e(j, k, l, d(f, g, h)), c(n, o, p, a(j, k, l));
            },
            luminosity: function() {
                c(j, k, l, a(f, g, h));
            },
            color: function() {
                c(f, g, h, a(j, k, l));
            },
            add: function() {
                n = q(j + f, 255), o = q(k + g, 255), p = q(l + h, 255);
            },
            subtract: function() {
                n = r(j - f, 0), o = r(k - g, 0), p = r(l - h, 0);
            },
            average: function() {
                n = (j + f) / 2, o = (k + g) / 2, p = (l + h) / 2;
            },
            negation: function() {
                n = 255 - s(255 - f - j), o = 255 - s(255 - g - k), p = 255 - s(255 - h - l);
            }
        }, u = this.nativeModes = b.each([ "source-over", "source-in", "source-out", "source-atop", "destination-over", "destination-in", "destination-out", "destination-atop", "lighter", "darker", "copy", "xor" ], function(a) {
            this[a] = !0;
        }, {}), v = Z.getContext(1, 1);
        b.each(t, function(a, b) {
            var c = "darken" === b, d = !1;
            v.save();
            try {
                v.fillStyle = c ? "#300" : "#a00", v.fillRect(0, 0, 1, 1), v.globalCompositeOperation = b, 
                v.globalCompositeOperation === b && (v.fillStyle = c ? "#a00" : "#300", v.fillRect(0, 0, 1, 1), 
                d = v.getImageData(0, 0, 1, 1).data[0] !== c ? 170 : 51);
            } catch (e) {}
            v.restore(), u[b] = d;
        }), Z.release(v), this.process = function(a, b, c, d, e) {
            var q = b.canvas, r = "normal" === a;
            if (r || u[a]) c.save(), c.setTransform(1, 0, 0, 1, 0, 0), c.globalAlpha = d, r || (c.globalCompositeOperation = a), 
            c.drawImage(q, e.x, e.y), c.restore(); else {
                var s = t[a];
                if (!s) return;
                for (var v = c.getImageData(e.x, e.y, q.width, q.height), w = v.data, x = b.getImageData(0, 0, q.width, q.height).data, y = 0, z = w.length; z > y; y += 4) {
                    f = x[y], j = w[y], g = x[y + 1], k = w[y + 1], h = x[y + 2], l = w[y + 2], i = x[y + 3], 
                    m = w[y + 3], s();
                    var A = i * d / 255, B = 1 - A;
                    w[y] = A * n + B * j, w[y + 1] = A * o + B * k, w[y + 2] = A * p + B * l, w[y + 3] = i * d + B * m;
                }
                c.putImageData(v, e.x, e.y);
            }
        };
    }(), _ = b.each({
        fillColor: [ "fill", "color" ],
        strokeColor: [ "stroke", "color" ],
        strokeWidth: [ "stroke-width", "number" ],
        strokeCap: [ "stroke-linecap", "string" ],
        strokeJoin: [ "stroke-linejoin", "string" ],
        strokeScaling: [ "vector-effect", "lookup", {
            "true": "none",
            "false": "non-scaling-stroke"
        }, function(a, b) {
            return !b && (a instanceof E || a instanceof w || a instanceof J);
        } ],
        miterLimit: [ "stroke-miterlimit", "number" ],
        dashArray: [ "stroke-dasharray", "array" ],
        dashOffset: [ "stroke-dashoffset", "number" ],
        fontFamily: [ "font-family", "string" ],
        fontWeight: [ "font-weight", "string" ],
        fontSize: [ "font-size", "number" ],
        justification: [ "text-anchor", "lookup", {
            left: "start",
            center: "middle",
            right: "end"
        } ],
        opacity: [ "opacity", "number" ],
        blendMode: [ "mix-blend-mode", "string" ]
    }, function(a, c) {
        var d = b.capitalize(c), e = a[2];
        this[c] = {
            type: a[1],
            property: c,
            attribute: a[0],
            toSVG: e,
            fromSVG: e && b.each(e, function(a, b) {
                this[a] = b;
            }, {}),
            exportFilter: a[3],
            get: "get" + d,
            set: "set" + d
        };
    }, {}), aa = {
        href: "http://www.w3.org/1999/xlink",
        xlink: "http://www.w3.org/2000/xmlns"
    };
    return new function() {
        function a(a, b) {
            for (var c in b) {
                var d = b[c], e = aa[c];
                "number" == typeof d && (d = y.number(d)), e ? a.setAttributeNS(e, c, d) : a.setAttribute(c, d);
            }
            return a;
        }
        function c(b, c) {
            return a(document.createElementNS("http://www.w3.org/2000/svg", b), c);
        }
        function d(a, c, d) {
            var e = new b(), f = a.getTranslation();
            if (c) {
                a = a.shiftless();
                var h = a._inverseTransform(f);
                e[d ? "cx" : "x"] = h.x, e[d ? "cy" : "y"] = h.y, f = null;
            }
            if (!a.isIdentity()) {
                var i = a.decompose();
                if (i && !i.shearing) {
                    var j = [], k = i.rotation, l = i.scaling;
                    f && !f.isZero() && j.push("translate(" + y.point(f) + ")"), k && j.push("rotate(" + y.number(k) + ")"), 
                    g.isZero(l.x - 1) && g.isZero(l.y - 1) || j.push("scale(" + y.point(l) + ")"), e.transform = j.join(" ");
                } else e.transform = "matrix(" + a.getValues().join(",") + ")";
            }
            return e;
        }
        function e(b, e) {
            for (var f = d(b._matrix), g = b._children, h = c("g", f), i = 0, j = g.length; j > i; i++) {
                var k = g[i], l = w(k, e);
                if (l) if (k.isClipMask()) {
                    var m = c("clipPath");
                    m.appendChild(l), u(k, m, "clip"), a(h, {
                        "clip-path": "url(#" + m.id + ")"
                    });
                } else h.appendChild(l);
            }
            return h;
        }
        function h(a) {
            var b = d(a._matrix, !0), e = a.getSize();
            return b.x -= e.width / 2, b.y -= e.height / 2, b.width = e.width, b.height = e.height, 
            b.href = a.toDataURL(), c("image", b);
        }
        function j(a, b) {
            if (b.matchShapes) {
                var e = a.toShape(!1);
                if (e) return k(e, b);
            }
            var f, g = a._segments, h = d(a._matrix);
            if (0 === g.length) return null;
            if (a.isPolygon()) if (g.length >= 3) {
                f = a._closed ? "polygon" : "polyline";
                var j = [];
                for (i = 0, l = g.length; i < l; i++) j.push(y.point(g[i]._point));
                h.points = j.join(" ");
            } else {
                f = "line";
                var m = g[0]._point, n = g[g.length - 1]._point;
                h.set({
                    x1: m.x,
                    y1: m.y,
                    x2: n.x,
                    y2: n.y
                });
            } else f = "path", h.d = a.getPathData(null, b.precision);
            return c(f, h);
        }
        function k(a) {
            var b = a._type, e = a._radius, f = d(a._matrix, !0, "rectangle" !== b);
            if ("rectangle" === b) {
                b = "rect";
                var g = a._size, h = g.width, i = g.height;
                f.x -= h / 2, f.y -= i / 2, f.width = h, f.height = i, e.isZero() && (e = null);
            }
            return e && ("circle" === b ? f.r = e : (f.rx = e.width, f.ry = e.height)), c(b, f);
        }
        function m(a, b) {
            var e = d(a._matrix), f = a.getPathData(null, b.precision);
            return f && (e.d = f), c("path", e);
        }
        function n(a, b) {
            var e = d(a._matrix, !0), f = a.getSymbol(), g = s(f, "symbol"), h = f.getDefinition(), i = h.getBounds();
            return g || (g = c("symbol", {
                viewBox: y.rectangle(i)
            }), g.appendChild(w(h, b)), u(f, g, "symbol")), e.href = "#" + g.id, e.x += i.x, 
            e.y += i.y, e.width = y.number(i.width), e.height = y.number(i.height), c("use", e);
        }
        function o(a) {
            var b = s(a, "color");
            if (!b) {
                var d, e = a.getGradient(), f = e._radial, g = a.getOrigin().transform(), h = a.getDestination().transform();
                if (f) {
                    d = {
                        cx: g.x,
                        cy: g.y,
                        r: g.getDistance(h)
                    };
                    var i = a.getHighlight();
                    i && (i = i.transform(), d.fx = i.x, d.fy = i.y);
                } else d = {
                    x1: g.x,
                    y1: g.y,
                    x2: h.x,
                    y2: h.y
                };
                d.gradientUnits = "userSpaceOnUse", b = c((f ? "radial" : "linear") + "Gradient", d);
                for (var j = e._stops, k = 0, l = j.length; l > k; k++) {
                    var m = j[k], n = m._color, o = n.getAlpha();
                    d = {
                        offset: m._rampPoint,
                        "stop-color": n.toCSS(!0)
                    }, 1 > o && (d["stop-opacity"] = o), b.appendChild(c("stop", d));
                }
                u(a, b, "color");
            }
            return "url(#" + b.id + ")";
        }
        function p(a) {
            var b = c("text", d(a._matrix, !0));
            return b.textContent = a._content, b;
        }
        function q(c, d, e) {
            var f = {}, g = !e && c.getParent();
            return null != c._name && (f.id = c._name), b.each(_, function(a) {
                var d = a.get, e = a.type, h = c[d]();
                if (a.exportFilter ? a.exportFilter(c, h) : !g || !b.equals(g[d](), h)) {
                    if ("color" === e && null != h) {
                        var i = h.getAlpha();
                        1 > i && (f[a.attribute + "-opacity"] = i);
                    }
                    f[a.attribute] = null == h ? "none" : "number" === e ? y.number(h) : "color" === e ? h.gradient ? o(h, c) : h.toCSS(!0) : "array" === e ? h.join(",") : "lookup" === e ? a.toSVG[h] : h;
                }
            }), 1 === f.opacity && delete f.opacity, c._visible || (f.visibility = "hidden"), 
            a(d, f);
        }
        function s(a, b) {
            return z || (z = {
                ids: {},
                svgs: {}
            }), a && z.svgs[b + "-" + a._id];
        }
        function u(a, b, c) {
            z || s();
            var d = z.ids[c] = (z.ids[c] || 0) + 1;
            b.id = c + "-" + d, z.svgs[c + "-" + a._id] = b;
        }
        function v(a, b) {
            var d = a, e = null;
            if (z) {
                d = "svg" === a.nodeName.toLowerCase() && a;
                for (var f in z.svgs) e || (d || (d = c("svg"), d.appendChild(a)), e = d.insertBefore(c("defs"), d.firstChild)), 
                e.appendChild(z.svgs[f]);
                z = null;
            }
            return b.asString ? new XMLSerializer().serializeToString(d) : d;
        }
        function w(a, b, c) {
            var d = A[a._class], e = d && d(a, b);
            if (e) {
                var f = b.onExport;
                f && (e = f(a, e, b) || e);
                var g = JSON.stringify(a._data);
                g && "{}" !== g && e.setAttribute("data-paper-data", g);
            }
            return e && q(a, e, c);
        }
        function x(a) {
            return a || (a = {}), y = new f(a.precision), a;
        }
        var y, z, A = {
            Group: e,
            Layer: e,
            Raster: h,
            Path: j,
            Shape: k,
            CompoundPath: m,
            PlacedSymbol: n,
            PointText: p
        };
        t.inject({
            exportSVG: function(a) {
                return a = x(a), v(w(this, a, !0), a);
            }
        }), r.inject({
            exportSVG: function(a) {
                a = x(a);
                var b = this.layers, e = this.getView(), f = e.getViewSize(), g = c("svg", {
                    x: 0,
                    y: 0,
                    width: f.width,
                    height: f.height,
                    version: "1.1",
                    xmlns: "http://www.w3.org/2000/svg",
                    "xmlns:xlink": "http://www.w3.org/1999/xlink"
                }), h = g, i = e._matrix;
                i.isIdentity() || (h = g.appendChild(c("g", d(i))));
                for (var j = 0, k = b.length; k > j; j++) h.appendChild(w(b[j], a, !0));
                return v(g, a);
            }
        });
    }(), new function() {
        function c(a, b, c, d) {
            var e = aa[b], f = e ? a.getAttributeNS(e, b) : a.getAttribute(b);
            return "null" === f && (f = null), null == f ? d ? null : c ? "" : 0 : c ? f : parseFloat(f);
        }
        function d(a, b, d, e) {
            return b = c(a, b, !1, e), d = c(a, d, !1, e), !e || null != b && null != d ? new h(b, d) : null;
        }
        function e(a, b, d, e) {
            return b = c(a, b, !1, e), d = c(a, d, !1, e), !e || null != b && null != d ? new k(b, d) : null;
        }
        function f(a, b, c) {
            return "none" === a ? null : "number" === b ? parseFloat(a) : "array" === b ? a ? a.split(/[\s,]+/g).map(parseFloat) : [] : "color" === b ? y(a) || a : "lookup" === b ? c[a] : a;
        }
        function g(a, b, c, d) {
            var e = a.childNodes, f = "clippath" === b, g = new u(), h = g._project, i = h._currentStyle, j = [];
            f || (g = v(g, a, d), h._currentStyle = g._style.clone());
            for (var k = 0, l = e.length; l > k; k++) {
                var m, n = e[k];
                1 !== n.nodeType || !(m = z(n, c, !1)) || m instanceof s || j.push(m);
            }
            return g.addChildren(j), f && (g = v(g.reduce(), a, d)), h._currentStyle = i, (f || "defs" === b) && (g.remove(), 
            g = null), g;
        }
        function i(a, b) {
            for (var c = a.getAttribute("points").match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g), d = [], e = 0, f = c.length; f > e; e += 2) d.push(new h(parseFloat(c[e]), parseFloat(c[e + 1])));
            var g = new F(d);
            return "polygon" === b && g.closePath(), g;
        }
        function j(a) {
            var b = a.getAttribute("d"), c = {
                pathData: b
            };
            return (b.match(/m/gi) || []).length > 1 || /z\S+/i.test(b) ? new G(c) : new F(c);
        }
        function l(a, b) {
            var e, f = (c(a, "href", !0) || "").substring(1), g = "radialgradient" === b;
            if (f) e = C[f].getGradient(); else {
                for (var h = a.childNodes, i = [], j = 0, k = h.length; k > j; j++) {
                    var l = h[j];
                    1 === l.nodeType && i.push(v(new N(), l));
                }
                e = new M(i, g);
            }
            var m, n, o;
            return g ? (m = d(a, "cx", "cy"), n = m.add(c(a, "r"), 0), o = d(a, "fx", "fy", !0)) : (m = d(a, "x1", "y1"), 
            n = d(a, "x2", "y2")), v(new L(e, m, n, o), a), null;
        }
        function m(a, b, c, d) {
            for (var e = (d.getAttribute(c) || "").split(/\)\s*/g), f = new p(), g = 0, h = e.length; h > g; g++) {
                var i = e[g];
                if (!i) break;
                for (var j = i.split(/\(\s*/), k = j[0], l = j[1].split(/[\s,]+/g), m = 0, n = l.length; n > m; m++) l[m] = parseFloat(l[m]);
                switch (k) {
                  case "matrix":
                    f.concatenate(new p(l[0], l[1], l[2], l[3], l[4], l[5]));
                    break;

                  case "rotate":
                    f.rotate(l[0], l[1], l[2]);
                    break;

                  case "translate":
                    f.translate(l[0], l[1]);
                    break;

                  case "scale":
                    f.scale(l);
                    break;

                  case "skewX":
                    f.skew(l[0], 0);
                    break;

                  case "skewY":
                    f.skew(0, l[0]);
                }
            }
            a.transform(f);
        }
        function o(a, b, c) {
            var d = a["fill-opacity" === c ? "getFillColor" : "getStrokeColor"]();
            d && d.setAlpha(parseFloat(b));
        }
        function q(c, d, e) {
            var f = c.attributes[d], g = f && f.value;
            if (!g) {
                var h = b.camelize(d);
                g = c.style[h], g || e.node[h] === e.parent[h] || (g = e.node[h]);
            }
            return g ? "none" === g ? null : g : a;
        }
        function v(c, d, e) {
            var f = {
                node: P.getStyles(d) || {},
                parent: !e && P.getStyles(d.parentNode) || {}
            };
            return b.each(B, function(e, g) {
                var h = q(d, g, f);
                h !== a && (c = b.pick(e(c, h, g, d, f), c));
            }), c;
        }
        function y(a) {
            var b = a && a.match(/\((?:#|)([^)']+)/);
            return b && C[b[1]];
        }
        function z(a, b, c) {
            function d(a) {
                paper = f;
                var d = z(a, b, c), e = b.onLoad, g = f.project && f.getView();
                e && e.call(this, d), g.update();
            }
            if (!a) return null;
            b ? "function" == typeof b && (b = {
                onLoad: b
            }) : b = {};
            var e = a, f = paper;
            if (c) if ("string" != typeof a || /^.*</.test(a)) {
                if ("undefined" != typeof File && a instanceof File) {
                    var g = new FileReader();
                    return g.onload = function() {
                        d(g.result);
                    }, g.readAsText(a);
                }
            } else {
                if (e = document.getElementById(a), !e) return Y.request("get", a, d);
                a = null;
            }
            if ("string" == typeof a && (e = new DOMParser().parseFromString(a, "image/svg+xml")), 
            !e.nodeName) throw new Error("Unsupported SVG source: " + a);
            var h, i = e.nodeName.toLowerCase(), j = A[i], k = e.getAttribute && e.getAttribute("data-paper-data"), l = f.settings, m = l.applyMatrix;
            if (l.applyMatrix = !1, h = j && j(e, i, b, c) || null, l.applyMatrix = m, h) {
                "#document" === i || h instanceof u || (h = v(h, e, c));
                var n = b.onImport;
                n && (h = n(e, h, b) || h), b.expandShapes && h instanceof w && (h.remove(), h = h.toPath()), 
                k && (h._data = JSON.parse(k));
            }
            return c && (C = {}), h;
        }
        var A = {
            "#document": function(a, b, c, d) {
                for (var e = a.childNodes, f = 0, g = e.length; g > f; f++) {
                    var h = e[f];
                    if (1 === h.nodeType) {
                        var i = h.nextSibling;
                        document.body.appendChild(h);
                        var j = z(h, c, d);
                        return i ? a.insertBefore(h, i) : a.appendChild(h), j;
                    }
                }
            },
            g: g,
            svg: g,
            clippath: g,
            polygon: i,
            polyline: i,
            path: j,
            lineargradient: l,
            radialgradient: l,
            image: function(a) {
                var b = new x(c(a, "href", !0));
                return b.on("load", function() {
                    var b = e(a, "width", "height");
                    this.setSize(b);
                    var c = this._matrix._transformPoint(d(a, "x", "y").add(b.divide(2)));
                    this.translate(c);
                }), b;
            },
            symbol: function(a, b, c, d) {
                return new s(g(a, b, c, d), !0);
            },
            defs: g,
            use: function(a) {
                var b = (c(a, "href", !0) || "").substring(1), e = C[b], f = d(a, "x", "y");
                return e ? e instanceof s ? e.place(f) : e.clone().translate(f) : null;
            },
            circle: function(a) {
                return new w.Circle(d(a, "cx", "cy"), c(a, "r"));
            },
            ellipse: function(a) {
                return new w.Ellipse({
                    center: d(a, "cx", "cy"),
                    radius: e(a, "rx", "ry")
                });
            },
            rect: function(a) {
                var b = d(a, "x", "y"), c = e(a, "width", "height"), f = e(a, "rx", "ry");
                return new w.Rectangle(new n(b, c), f);
            },
            line: function(a) {
                return new F.Line(d(a, "x1", "y1"), d(a, "x2", "y2"));
            },
            text: function(a) {
                var b = new K(d(a, "x", "y").add(d(a, "dx", "dy")));
                return b.setContent(a.textContent.trim() || ""), b;
            }
        }, B = b.each(_, function(a) {
            this[a.attribute] = function(b, c) {
                if (b[a.set](f(c, a.type, a.fromSVG)), "color" === a.type && b instanceof w) {
                    var d = b[a.get]();
                    d && d.transform(new p().translate(b.getPosition(!0).negate()));
                }
            };
        }, {
            id: function(a, b) {
                C[b] = a, a.setName && a.setName(b);
            },
            "clip-path": function(a, b) {
                var c = y(b);
                if (c) {
                    if (c = c.clone(), c.setClipMask(!0), !(a instanceof u)) return new u(c, a);
                    a.insertChild(0, c);
                }
            },
            gradientTransform: m,
            transform: m,
            "fill-opacity": o,
            "stroke-opacity": o,
            visibility: function(a, b) {
                a.setVisible("visible" === b);
            },
            display: function(a, b) {
                a.setVisible(null !== b);
            },
            "stop-color": function(a, b) {
                a.setColor && a.setColor(b);
            },
            "stop-opacity": function(a, b) {
                a._color && a._color.setAlpha(parseFloat(b));
            },
            offset: function(a, b) {
                var c = b.match(/(.*)%$/);
                a.setRampPoint(c ? c[1] / 100 : parseFloat(b));
            },
            viewBox: function(a, b, c, d, g) {
                var h = new n(f(b, "array")), i = e(d, "width", "height", !0);
                if (a instanceof u) {
                    var j = i ? h.getSize().divide(i) : 1, k = new p().translate(h.getPoint()).scale(j);
                    a.transform(k.inverted());
                } else if (a instanceof s) {
                    i && h.setSize(i);
                    var l = "visible" != q(d, "overflow", g), m = a._definition;
                    l && !h.contains(m.getBounds()) && (l = new w.Rectangle(h).transform(m._matrix), 
                    l.setClipMask(!0), m.addChild(l));
                }
            }
        }), C = {};
        t.inject({
            importSVG: function(a, b) {
                return this.addChild(z(a, b, !0));
            }
        }), r.inject({
            importSVG: function(a, b) {
                return this.activate(), z(a, b, !0);
            }
        });
    }(), paper = new (d.inject(b.exports, {
        enumerable: !0,
        Base: b,
        Numerical: g,
        Key: V
    }))(), "function" == typeof define && define.amd ? define("paper", paper) : "object" == typeof module && module && (module.exports = paper), 
    paper;
}();

(function() {
    var a = this, b = b || {};
    b.WEBGL_RENDERER = 0, b.CANVAS_RENDERER = 1, b.VERSION = "v2.2.9", b.blendModes = {
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16
    }, b.scaleModes = {
        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1
    }, b._UID = 0, "undefined" != typeof Float32Array ? (b.Float32Array = Float32Array, 
    b.Uint16Array = Uint16Array, b.Uint32Array = Uint32Array, b.ArrayBuffer = ArrayBuffer) : (b.Float32Array = Array, 
    b.Uint16Array = Array), b.INTERACTION_FREQUENCY = 30, b.AUTO_PREVENT_DEFAULT = !0, 
    b.PI_2 = 2 * Math.PI, b.RAD_TO_DEG = 180 / Math.PI, b.DEG_TO_RAD = Math.PI / 180, 
    b.RETINA_PREFIX = "@2x", b.dontSayHello = !1, b.defaultRenderOptions = {
        view: null,
        transparent: !1,
        antialias: !1,
        preserveDrawingBuffer: !1,
        resolution: 1,
        clearBeforeRender: !0,
        autoResize: !1
    }, b.sayHello = function(a) {
        if (!b.dontSayHello) {
            if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                var c = [ "%c %c %c Pixi.js " + b.VERSION + " - " + a + "  %c  %c  http://www.pixijs.com/  %c %c %c%c ", "background: #ff66a5", "background: #ff66a5", "color: #ff66a5; background: #030307;", "background: #ff66a5", "background: #ffc3dc", "background: #ff66a5", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff" ];
                console.log.apply(console, c);
            } else window.console && console.log("Pixi.js " + b.VERSION + " - http://www.pixijs.com/");
            b.dontSayHello = !0;
        }
    }, b.Point = function(a, b) {
        this.x = a || 0, this.y = b || 0;
    }, b.Point.prototype.clone = function() {
        return new b.Point(this.x, this.y);
    }, b.Point.prototype.set = function(a, b) {
        this.x = a || 0, this.y = b || (0 !== b ? this.x : 0);
    }, b.Point.prototype.constructor = b.Point, b.Rectangle = function(a, b, c, d) {
        this.x = a || 0, this.y = b || 0, this.width = c || 0, this.height = d || 0;
    }, b.Rectangle.prototype.clone = function() {
        return new b.Rectangle(this.x, this.y, this.width, this.height);
    }, b.Rectangle.prototype.contains = function(a, b) {
        if (this.width <= 0 || this.height <= 0) return !1;
        var c = this.x;
        if (a >= c && a <= c + this.width) {
            var d = this.y;
            if (b >= d && b <= d + this.height) return !0;
        }
        return !1;
    }, b.Rectangle.prototype.constructor = b.Rectangle, b.EmptyRectangle = new b.Rectangle(0, 0, 0, 0), 
    b.Polygon = function(a) {
        if (a instanceof Array || (a = Array.prototype.slice.call(arguments)), a[0] instanceof b.Point) {
            for (var c = [], d = 0, e = a.length; e > d; d++) c.push(a[d].x, a[d].y);
            a = c;
        }
        this.closed = !0, this.points = a;
    }, b.Polygon.prototype.clone = function() {
        var a = this.points.slice();
        return new b.Polygon(a);
    }, b.Polygon.prototype.contains = function(a, b) {
        for (var c = !1, d = this.points.length / 2, e = 0, f = d - 1; d > e; f = e++) {
            var g = this.points[2 * e], h = this.points[2 * e + 1], i = this.points[2 * f], j = this.points[2 * f + 1], k = h > b != j > b && (i - g) * (b - h) / (j - h) + g > a;
            k && (c = !c);
        }
        return c;
    }, b.Polygon.prototype.constructor = b.Polygon, b.Circle = function(a, b, c) {
        this.x = a || 0, this.y = b || 0, this.radius = c || 0;
    }, b.Circle.prototype.clone = function() {
        return new b.Circle(this.x, this.y, this.radius);
    }, b.Circle.prototype.contains = function(a, b) {
        if (this.radius <= 0) return !1;
        var c = this.x - a, d = this.y - b, e = this.radius * this.radius;
        return c *= c, d *= d, e >= c + d;
    }, b.Circle.prototype.getBounds = function() {
        return new b.Rectangle(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);
    }, b.Circle.prototype.constructor = b.Circle, b.Ellipse = function(a, b, c, d) {
        this.x = a || 0, this.y = b || 0, this.width = c || 0, this.height = d || 0;
    }, b.Ellipse.prototype.clone = function() {
        return new b.Ellipse(this.x, this.y, this.width, this.height);
    }, b.Ellipse.prototype.contains = function(a, b) {
        if (this.width <= 0 || this.height <= 0) return !1;
        var c = (a - this.x) / this.width, d = (b - this.y) / this.height;
        return c *= c, d *= d, 1 >= c + d;
    }, b.Ellipse.prototype.getBounds = function() {
        return new b.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }, b.Ellipse.prototype.constructor = b.Ellipse, b.RoundedRectangle = function(a, b, c, d, e) {
        this.x = a || 0, this.y = b || 0, this.width = c || 0, this.height = d || 0, this.radius = e || 20;
    }, b.RoundedRectangle.prototype.clone = function() {
        return new b.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }, b.RoundedRectangle.prototype.contains = function(a, b) {
        if (this.width <= 0 || this.height <= 0) return !1;
        var c = this.x;
        if (a >= c && a <= c + this.width) {
            var d = this.y;
            if (b >= d && b <= d + this.height) return !0;
        }
        return !1;
    }, b.RoundedRectangle.prototype.constructor = b.RoundedRectangle, b.Matrix = function() {
        this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0;
    }, b.Matrix.prototype.fromArray = function(a) {
        this.a = a[0], this.b = a[1], this.c = a[3], this.d = a[4], this.tx = a[2], this.ty = a[5];
    }, b.Matrix.prototype.toArray = function(a) {
        this.array || (this.array = new b.Float32Array(9));
        var c = this.array;
        return a ? (c[0] = this.a, c[1] = this.b, c[2] = 0, c[3] = this.c, c[4] = this.d, 
        c[5] = 0, c[6] = this.tx, c[7] = this.ty, c[8] = 1) : (c[0] = this.a, c[1] = this.c, 
        c[2] = this.tx, c[3] = this.b, c[4] = this.d, c[5] = this.ty, c[6] = 0, c[7] = 0, 
        c[8] = 1), c;
    }, b.Matrix.prototype.apply = function(a, c) {
        return c = c || new b.Point(), c.x = this.a * a.x + this.c * a.y + this.tx, c.y = this.b * a.x + this.d * a.y + this.ty, 
        c;
    }, b.Matrix.prototype.applyInverse = function(a, c) {
        c = c || new b.Point();
        var d = 1 / (this.a * this.d + this.c * -this.b);
        return c.x = this.d * d * a.x + -this.c * d * a.y + (this.ty * this.c - this.tx * this.d) * d, 
        c.y = this.a * d * a.y + -this.b * d * a.x + (-this.ty * this.a + this.tx * this.b) * d, 
        c;
    }, b.Matrix.prototype.translate = function(a, b) {
        return this.tx += a, this.ty += b, this;
    }, b.Matrix.prototype.scale = function(a, b) {
        return this.a *= a, this.d *= b, this.c *= a, this.b *= b, this.tx *= a, this.ty *= b, 
        this;
    }, b.Matrix.prototype.rotate = function(a) {
        var b = Math.cos(a), c = Math.sin(a), d = this.a, e = this.c, f = this.tx;
        return this.a = d * b - this.b * c, this.b = d * c + this.b * b, this.c = e * b - this.d * c, 
        this.d = e * c + this.d * b, this.tx = f * b - this.ty * c, this.ty = f * c + this.ty * b, 
        this;
    }, b.Matrix.prototype.append = function(a) {
        var b = this.a, c = this.b, d = this.c, e = this.d;
        return this.a = a.a * b + a.b * d, this.b = a.a * c + a.b * e, this.c = a.c * b + a.d * d, 
        this.d = a.c * c + a.d * e, this.tx = a.tx * b + a.ty * d + this.tx, this.ty = a.tx * c + a.ty * e + this.ty, 
        this;
    }, b.Matrix.prototype.identity = function() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, 
        this;
    }, b.identityMatrix = new b.Matrix(), b.DisplayObject = function() {
        this.position = new b.Point(), this.scale = new b.Point(1, 1), this.pivot = new b.Point(0, 0), 
        this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.buttonMode = !1, 
        this.renderable = !1, this.parent = null, this.stage = null, this.worldAlpha = 1, 
        this._interactive = !1, this.defaultCursor = "pointer", this.worldTransform = new b.Matrix(), 
        this._sr = 0, this._cr = 1, this.filterArea = null, this._bounds = new b.Rectangle(0, 0, 1, 1), 
        this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1;
    }, b.DisplayObject.prototype.constructor = b.DisplayObject, Object.defineProperty(b.DisplayObject.prototype, "interactive", {
        get: function() {
            return this._interactive;
        },
        set: function(a) {
            this._interactive = a, this.stage && (this.stage.dirty = !0);
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "worldVisible", {
        get: function() {
            var a = this;
            do {
                if (!a.visible) return !1;
                a = a.parent;
            } while (a);
            return !0;
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask;
        },
        set: function(a) {
            this._mask && (this._mask.isMask = !1), this._mask = a, this._mask && (this._mask.isMask = !0);
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "filters", {
        get: function() {
            return this._filters;
        },
        set: function(a) {
            if (a) {
                for (var b = [], c = 0; c < a.length; c++) for (var d = a[c].passes, e = 0; e < d.length; e++) b.push(d[e]);
                this._filterBlock = {
                    target: this,
                    filterPasses: b
                };
            }
            this._filters = a;
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(a) {
            this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(), 
            this._cacheAsBitmap = a);
        }
    }), b.DisplayObject.prototype.updateTransform = function() {
        var a, c, d, e, f, g, h = this.parent.worldTransform, i = this.worldTransform;
        this.rotation % b.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, 
        this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), a = this._cr * this.scale.x, 
        c = this._sr * this.scale.x, d = -this._sr * this.scale.y, e = this._cr * this.scale.y, 
        f = this.position.x, g = this.position.y, (this.pivot.x || this.pivot.y) && (f -= this.pivot.x * a + this.pivot.y * d, 
        g -= this.pivot.x * c + this.pivot.y * e), i.a = a * h.a + c * h.c, i.b = a * h.b + c * h.d, 
        i.c = d * h.a + e * h.c, i.d = d * h.b + e * h.d, i.tx = f * h.a + g * h.c + h.tx, 
        i.ty = f * h.b + g * h.d + h.ty) : (a = this.scale.x, e = this.scale.y, f = this.position.x - this.pivot.x * a, 
        g = this.position.y - this.pivot.y * e, i.a = a * h.a, i.b = a * h.b, i.c = e * h.c, 
        i.d = e * h.d, i.tx = f * h.a + g * h.c + h.tx, i.ty = f * h.b + g * h.d + h.ty), 
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, b.DisplayObject.prototype.displayObjectUpdateTransform = b.DisplayObject.prototype.updateTransform, 
    b.DisplayObject.prototype.getBounds = function(a) {
        return a = a, b.EmptyRectangle;
    }, b.DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(b.identityMatrix);
    }, b.DisplayObject.prototype.setStageReference = function(a) {
        this.stage = a, this._interactive && (this.stage.dirty = !0);
    }, b.DisplayObject.prototype.generateTexture = function(a, c, d) {
        var e = this.getLocalBounds(), f = new b.RenderTexture(0 | e.width, 0 | e.height, d, c, a);
        return b.DisplayObject._tempMatrix.tx = -e.x, b.DisplayObject._tempMatrix.ty = -e.y, 
        f.render(this, b.DisplayObject._tempMatrix), f;
    }, b.DisplayObject.prototype.updateCache = function() {
        this._generateCachedSprite();
    }, b.DisplayObject.prototype.toGlobal = function(a) {
        return this.displayObjectUpdateTransform(), this.worldTransform.apply(a);
    }, b.DisplayObject.prototype.toLocal = function(a, b) {
        return b && (a = b.toGlobal(a)), this.displayObjectUpdateTransform(), this.worldTransform.applyInverse(a);
    }, b.DisplayObject.prototype._renderCachedSprite = function(a) {
        this._cachedSprite.worldAlpha = this.worldAlpha, a.gl ? b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
    }, b.DisplayObject.prototype._generateCachedSprite = function() {
        this._cacheAsBitmap = !1;
        var a = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.texture.resize(0 | a.width, 0 | a.height); else {
            var c = new b.RenderTexture(0 | a.width, 0 | a.height);
            this._cachedSprite = new b.Sprite(c), this._cachedSprite.worldTransform = this.worldTransform;
        }
        var d = this._filters;
        this._filters = null, this._cachedSprite.filters = d, b.DisplayObject._tempMatrix.tx = -a.x, 
        b.DisplayObject._tempMatrix.ty = -a.y, this._cachedSprite.texture.render(this, b.DisplayObject._tempMatrix, !0), 
        this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), 
        this._filters = d, this._cacheAsBitmap = !0;
    }, b.DisplayObject.prototype._destroyCachedSprite = function() {
        this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null);
    }, b.DisplayObject.prototype._renderWebGL = function(a) {
        a = a;
    }, b.DisplayObject.prototype._renderCanvas = function(a) {
        a = a;
    }, b.DisplayObject._tempMatrix = new b.Matrix(), Object.defineProperty(b.DisplayObject.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(a) {
            this.position.x = a;
        }
    }), Object.defineProperty(b.DisplayObject.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(a) {
            this.position.y = a;
        }
    }), b.DisplayObjectContainer = function() {
        b.DisplayObject.call(this), this.children = [];
    }, b.DisplayObjectContainer.prototype = Object.create(b.DisplayObject.prototype), 
    b.DisplayObjectContainer.prototype.constructor = b.DisplayObjectContainer, Object.defineProperty(b.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function(a) {
            var b = this.getLocalBounds().width;
            this.scale.x = 0 !== b ? a / b : 1, this._width = a;
        }
    }), Object.defineProperty(b.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.scale.y * this.getLocalBounds().height;
        },
        set: function(a) {
            var b = this.getLocalBounds().height;
            this.scale.y = 0 !== b ? a / b : 1, this._height = a;
        }
    }), b.DisplayObjectContainer.prototype.addChild = function(a) {
        return this.addChildAt(a, this.children.length);
    }, b.DisplayObjectContainer.prototype.addChildAt = function(a, b) {
        if (b >= 0 && b <= this.children.length) return a.parent && a.parent.removeChild(a), 
        a.parent = this, this.children.splice(b, 0, a), this.stage && a.setStageReference(this.stage), 
        a;
        throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length);
    }, b.DisplayObjectContainer.prototype.swapChildren = function(a, b) {
        if (a !== b) {
            var c = this.getChildIndex(a), d = this.getChildIndex(b);
            if (0 > c || 0 > d) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[c] = b, this.children[d] = a;
        }
    }, b.DisplayObjectContainer.prototype.getChildIndex = function(a) {
        var b = this.children.indexOf(a);
        if (-1 === b) throw new Error("The supplied DisplayObject must be a child of the caller");
        return b;
    }, b.DisplayObjectContainer.prototype.setChildIndex = function(a, b) {
        if (0 > b || b >= this.children.length) throw new Error("The supplied index is out of bounds");
        var c = this.getChildIndex(a);
        this.children.splice(c, 1), this.children.splice(b, 0, a);
    }, b.DisplayObjectContainer.prototype.getChildAt = function(a) {
        if (0 > a || a >= this.children.length) throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[a];
    }, b.DisplayObjectContainer.prototype.removeChild = function(a) {
        var b = this.children.indexOf(a);
        return -1 !== b ? this.removeChildAt(b) : void 0;
    }, b.DisplayObjectContainer.prototype.removeChildAt = function(a) {
        var b = this.getChildAt(a);
        return this.stage && b.removeStageReference(), b.parent = void 0, this.children.splice(a, 1), 
        b;
    }, b.DisplayObjectContainer.prototype.removeChildren = function(a, b) {
        var c = a || 0, d = "number" == typeof b ? b : this.children.length, e = d - c;
        if (e > 0 && d >= e) {
            for (var f = this.children.splice(c, e), g = 0; g < f.length; g++) {
                var h = f[g];
                this.stage && h.removeStageReference(), h.parent = void 0;
            }
            return f;
        }
        if (0 === e && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
    }, b.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) for (var a = 0, b = this.children.length; b > a; a++) this.children[a].updateTransform();
    }, b.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = b.DisplayObjectContainer.prototype.updateTransform, 
    b.DisplayObjectContainer.prototype.getBounds = function() {
        if (0 === this.children.length) return b.EmptyRectangle;
        for (var a, c, d, e = 1 / 0, f = 1 / 0, g = -(1 / 0), h = -(1 / 0), i = !1, j = 0, k = this.children.length; k > j; j++) {
            var l = this.children[j];
            l.visible && (i = !0, a = this.children[j].getBounds(), e = e < a.x ? e : a.x, f = f < a.y ? f : a.y, 
            c = a.width + a.x, d = a.height + a.y, g = g > c ? g : c, h = h > d ? h : d);
        }
        if (!i) return b.EmptyRectangle;
        var m = this._bounds;
        return m.x = e, m.y = f, m.width = g - e, m.height = h - f, m;
    }, b.DisplayObjectContainer.prototype.getLocalBounds = function() {
        var a = this.worldTransform;
        this.worldTransform = b.identityMatrix;
        for (var c = 0, d = this.children.length; d > c; c++) this.children[c].updateTransform();
        var e = this.getBounds();
        return this.worldTransform = a, e;
    }, b.DisplayObjectContainer.prototype.setStageReference = function(a) {
        this.stage = a, this._interactive && (this.stage.dirty = !0);
        for (var b = 0, c = this.children.length; c > b; b++) {
            var d = this.children[b];
            d.setStageReference(a);
        }
    }, b.DisplayObjectContainer.prototype.removeStageReference = function() {
        for (var a = 0, b = this.children.length; b > a; a++) {
            var c = this.children[a];
            c.removeStageReference();
        }
        this._interactive && (this.stage.dirty = !0), this.stage = null;
    }, b.DisplayObjectContainer.prototype._renderWebGL = function(a) {
        if (this.visible && !(this.alpha <= 0)) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
            var b, c;
            if (this._mask || this._filters) {
                for (this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), 
                this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), 
                b = 0, c = this.children.length; c > b; b++) this.children[b]._renderWebGL(a);
                a.spriteBatch.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), 
                a.spriteBatch.start();
            } else for (b = 0, c = this.children.length; c > b; b++) this.children[b]._renderWebGL(a);
        }
    }, b.DisplayObjectContainer.prototype._renderCanvas = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha) {
            if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
            this._mask && a.maskManager.pushMask(this._mask, a);
            for (var b = 0, c = this.children.length; c > b; b++) {
                var d = this.children[b];
                d._renderCanvas(a);
            }
            this._mask && a.maskManager.popMask(a);
        }
    }, b.Sprite = function(a) {
        b.DisplayObjectContainer.call(this), this.anchor = new b.Point(), this.texture = a || b.Texture.emptyTexture, 
        this._width = 0, this._height = 0, this.tint = 16777215, this.blendMode = b.blendModes.NORMAL, 
        this.shader = null, this.texture.baseTexture.hasLoaded ? this.onTextureUpdate() : this.texture.on("update", this.onTextureUpdate.bind(this)), 
        this.renderable = !0;
    }, b.Sprite.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Sprite.prototype.constructor = b.Sprite, 
    Object.defineProperty(b.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width;
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width, this._width = a;
        }
    }), Object.defineProperty(b.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height;
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height, this._height = a;
        }
    }), b.Sprite.prototype.setTexture = function(a) {
        this.texture = a, this.cachedTint = 16777215;
    }, b.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height);
    }, b.Sprite.prototype.getBounds = function(a) {
        var b = this.texture.frame.width, c = this.texture.frame.height, d = b * (1 - this.anchor.x), e = b * -this.anchor.x, f = c * (1 - this.anchor.y), g = c * -this.anchor.y, h = a || this.worldTransform, i = h.a, j = h.b, k = h.c, l = h.d, m = h.tx, n = h.ty, o = -(1 / 0), p = -(1 / 0), q = 1 / 0, r = 1 / 0;
        if (0 === j && 0 === k) 0 > i && (i *= -1), 0 > l && (l *= -1), q = i * e + m, o = i * d + m, 
        r = l * g + n, p = l * f + n; else {
            var s = i * e + k * g + m, t = l * g + j * e + n, u = i * d + k * g + m, v = l * g + j * d + n, w = i * d + k * f + m, x = l * f + j * d + n, y = i * e + k * f + m, z = l * f + j * e + n;
            q = q > s ? s : q, q = q > u ? u : q, q = q > w ? w : q, q = q > y ? y : q, r = r > t ? t : r, 
            r = r > v ? v : r, r = r > x ? x : r, r = r > z ? z : r, o = s > o ? s : o, o = u > o ? u : o, 
            o = w > o ? w : o, o = y > o ? y : o, p = t > p ? t : p, p = v > p ? v : p, p = x > p ? x : p, 
            p = z > p ? z : p;
        }
        var A = this._bounds;
        return A.x = q, A.width = o - q, A.y = r, A.height = p - r, this._currentBounds = A, 
        A;
    }, b.Sprite.prototype._renderWebGL = function(a) {
        if (this.visible && !(this.alpha <= 0)) {
            var b, c;
            if (this._mask || this._filters) {
                var d = a.spriteBatch;
                for (this._filters && (d.flush(), a.filterManager.pushFilter(this._filterBlock)), 
                this._mask && (d.stop(), a.maskManager.pushMask(this.mask, a), d.start()), d.render(this), 
                b = 0, c = this.children.length; c > b; b++) this.children[b]._renderWebGL(a);
                d.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), 
                d.start();
            } else for (a.spriteBatch.render(this), b = 0, c = this.children.length; c > b; b++) this.children[b]._renderWebGL(a);
        }
    }, b.Sprite.prototype._renderCanvas = function(a) {
        if (!(this.visible === !1 || 0 === this.alpha || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            if (this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, 
            a.context.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a), 
            this.texture.valid) {
                var c = this.texture.baseTexture.resolution / a.resolution;
                a.context.globalAlpha = this.worldAlpha, a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && (a.scaleMode = this.texture.baseTexture.scaleMode, 
                a.context[a.smoothProperty] = a.scaleMode === b.scaleModes.LINEAR);
                var d = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width, e = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
                a.roundPixels ? (a.context.setTransform(this.worldTransform.a, this.worldTransform.b, this.worldTransform.c, this.worldTransform.d, this.worldTransform.tx * a.resolution | 0, this.worldTransform.ty * a.resolution | 0), 
                d = 0 | d, e = 0 | e) : a.context.setTransform(this.worldTransform.a, this.worldTransform.b, this.worldTransform.c, this.worldTransform.d, this.worldTransform.tx * a.resolution, this.worldTransform.ty * a.resolution), 
                16777215 !== this.tint ? (this.cachedTint !== this.tint && (this.cachedTint = this.tint, 
                this.tintedTexture = b.CanvasTinter.getTintedTexture(this, this.tint)), a.context.drawImage(this.tintedTexture, 0, 0, this.texture.crop.width, this.texture.crop.height, d / c, e / c, this.texture.crop.width / c, this.texture.crop.height / c)) : a.context.drawImage(this.texture.baseTexture.source, this.texture.crop.x, this.texture.crop.y, this.texture.crop.width, this.texture.crop.height, d / c, e / c, this.texture.crop.width / c, this.texture.crop.height / c);
            }
            for (var f = 0, g = this.children.length; g > f; f++) this.children[f]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, b.Sprite.fromFrame = function(a) {
        var c = b.TextureCache[a];
        if (!c) throw new Error('The frameId "' + a + '" does not exist in the texture cache' + this);
        return new b.Sprite(c);
    }, b.Sprite.fromImage = function(a, c, d) {
        var e = b.Texture.fromImage(a, c, d);
        return new b.Sprite(e);
    }, b.SpriteBatch = function(a) {
        b.DisplayObjectContainer.call(this), this.textureThing = a, this.ready = !1;
    }, b.SpriteBatch.prototype = Object.create(b.DisplayObjectContainer.prototype), 
    b.SpriteBatch.prototype.constructor = b.SpriteBatch, b.SpriteBatch.prototype.initWebGL = function(a) {
        this.fastSpriteBatch = new b.WebGLFastSpriteBatch(a), this.ready = !0;
    }, b.SpriteBatch.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform();
    }, b.SpriteBatch.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(a.gl), 
        this.fastSpriteBatch.gl !== a.gl && this.fastSpriteBatch.setContext(a.gl), a.spriteBatch.stop(), 
        a.shaderManager.setShader(a.shaderManager.fastShader), this.fastSpriteBatch.begin(this, a), 
        this.fastSpriteBatch.render(this), a.spriteBatch.start());
    }, b.SpriteBatch.prototype._renderCanvas = function(a) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var b = a.context;
            b.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for (var c = this.worldTransform, d = !0, e = 0; e < this.children.length; e++) {
                var f = this.children[e];
                if (f.visible) {
                    var g = f.texture, h = g.frame;
                    if (b.globalAlpha = this.worldAlpha * f.alpha, f.rotation % (2 * Math.PI) === 0) d && (b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty), 
                    d = !1), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width * f.scale.x + f.position.x + .5 | 0, f.anchor.y * -h.height * f.scale.y + f.position.y + .5 | 0, h.width * f.scale.x, h.height * f.scale.y); else {
                        d || (d = !0), f.displayObjectUpdateTransform();
                        var i = f.worldTransform;
                        a.roundPixels ? b.setTransform(i.a, i.b, i.c, i.d, 0 | i.tx, 0 | i.ty) : b.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), 
                        b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width + .5 | 0, f.anchor.y * -h.height + .5 | 0, h.width, h.height);
                    }
                }
            }
        }
    }, b.MovieClip = function(a) {
        b.Sprite.call(this, a[0]), this.textures = a, this.animationSpeed = 1, this.loop = !0, 
        this.onComplete = null, this.currentFrame = 0, this.playing = !1;
    }, b.MovieClip.prototype = Object.create(b.Sprite.prototype), b.MovieClip.prototype.constructor = b.MovieClip, 
    Object.defineProperty(b.MovieClip.prototype, "totalFrames", {
        get: function() {
            return this.textures.length;
        }
    }), b.MovieClip.prototype.stop = function() {
        this.playing = !1;
    }, b.MovieClip.prototype.play = function() {
        this.playing = !0;
    }, b.MovieClip.prototype.gotoAndStop = function(a) {
        this.playing = !1, this.currentFrame = a;
        var b = this.currentFrame + .5 | 0;
        this.setTexture(this.textures[b % this.textures.length]);
    }, b.MovieClip.prototype.gotoAndPlay = function(a) {
        this.currentFrame = a, this.playing = !0;
    }, b.MovieClip.prototype.updateTransform = function() {
        if (this.displayObjectContainerUpdateTransform(), this.playing) {
            this.currentFrame += this.animationSpeed;
            var a = this.currentFrame + .5 | 0;
            this.currentFrame = this.currentFrame % this.textures.length, this.loop || a < this.textures.length ? this.setTexture(this.textures[a % this.textures.length]) : a >= this.textures.length && (this.gotoAndStop(this.textures.length - 1), 
            this.onComplete && this.onComplete());
        }
    }, b.MovieClip.fromFrames = function(a) {
        for (var c = [], d = 0; d < a.length; d++) c.push(new b.Texture.fromFrame(a[d]));
        return new b.MovieClip(c);
    }, b.MovieClip.fromImages = function(a) {
        for (var c = [], d = 0; d < a.length; d++) c.push(new b.Texture.fromImage(a[d]));
        return new b.MovieClip(c);
    }, b.FilterBlock = function() {
        this.visible = !0, this.renderable = !0;
    }, b.FilterBlock.prototype.constructor = b.FilterBlock, b.Text = function(a, c) {
        this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), 
        this.resolution = 1, b.Sprite.call(this, b.Texture.fromCanvas(this.canvas)), this.setText(a), 
        this.setStyle(c);
    }, b.Text.prototype = Object.create(b.Sprite.prototype), b.Text.prototype.constructor = b.Text, 
    Object.defineProperty(b.Text.prototype, "width", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width;
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width, this._width = a;
        }
    }), Object.defineProperty(b.Text.prototype, "height", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height;
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height, this._height = a;
        }
    }), b.Text.prototype.setStyle = function(a) {
        a = a || {}, a.font = a.font || "bold 20pt Arial", a.fill = a.fill || "black", a.align = a.align || "left", 
        a.stroke = a.stroke || "black", a.strokeThickness = a.strokeThickness || 0, a.wordWrap = a.wordWrap || !1, 
        a.wordWrapWidth = a.wordWrapWidth || 100, a.dropShadow = a.dropShadow || !1, a.dropShadowAngle = a.dropShadowAngle || Math.PI / 6, 
        a.dropShadowDistance = a.dropShadowDistance || 4, a.dropShadowColor = a.dropShadowColor || "black", 
        a.lineJoin = a.lineJoin || "miter", a.lineHeight = a.lineHeight || !1, this.style = a, 
        this.dirty = !0;
    }, b.Text.prototype.setText = function(a) {
        this.text = a.toString() || " ", this.dirty = !0;
    }, b.Text.prototype.updateText = function() {
        this.texture.baseTexture.resolution = this.resolution, this.context.font = this.style.font;
        var a = this.text;
        this.style.wordWrap && (a = this.wordWrap(this.text));
        for (var b = a.split(/(?:\r\n|\r|\n)/), c = [], d = 0, e = this.determineFontProperties(this.style.font), f = 0; f < b.length; f++) {
            var g = this.context.measureText(b[f]).width;
            c[f] = g, d = Math.max(d, g);
        }
        var h = d + this.style.strokeThickness;
        this.style.dropShadow && (h += this.style.dropShadowDistance), this.canvas.width = (h + this.context.lineWidth) * this.resolution;
        var i = this.style.lineHeight || e.fontSize + this.style.strokeThickness, j = i * b.length;
        this.style.dropShadow && (j += this.style.dropShadowDistance), this.canvas.height = j * this.resolution, 
        this.context.scale(this.resolution, this.resolution), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), 
        this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, 
        this.context.lineWidth = this.style.strokeThickness, this.context.textBaseline = "alphabetic", 
        this.context.lineJoin = this.style.lineJoin;
        var k, l;
        if (this.style.dropShadow) {
            this.context.fillStyle = this.style.dropShadowColor;
            var m = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance, n = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;
            for (f = 0; f < b.length; f++) k = this.style.strokeThickness / 2, l = this.style.strokeThickness / 2 + f * i + e.ascent, 
            "right" === this.style.align ? k += d - c[f] : "center" === this.style.align && (k += (d - c[f]) / 2), 
            this.style.fill && this.context.fillText(b[f], k + m, l + n);
        }
        for (this.context.fillStyle = this.style.fill, f = 0; f < b.length; f++) k = this.style.strokeThickness / 2, 
        l = this.style.strokeThickness / 2 + f * i + e.ascent, "right" === this.style.align ? k += d - c[f] : "center" === this.style.align && (k += (d - c[f]) / 2), 
        this.style.stroke && this.style.strokeThickness && this.context.strokeText(b[f], k, l), 
        this.style.fill && this.context.fillText(b[f], k, l);
        this.updateTexture();
    }, b.Text.prototype.updateTexture = function() {
        this.texture.baseTexture.width = this.canvas.width, this.texture.baseTexture.height = this.canvas.height, 
        this.texture.crop.width = this.texture.frame.width = this.canvas.width, this.texture.crop.height = this.texture.frame.height = this.canvas.height, 
        this._width = this.canvas.width, this._height = this.canvas.height, this.texture.baseTexture.dirty();
    }, b.Text.prototype._renderWebGL = function(a) {
        this.dirty && (this.resolution = a.resolution, this.updateText(), this.dirty = !1), 
        b.Sprite.prototype._renderWebGL.call(this, a);
    }, b.Text.prototype._renderCanvas = function(a) {
        this.dirty && (this.resolution = a.resolution, this.updateText(), this.dirty = !1), 
        b.Sprite.prototype._renderCanvas.call(this, a);
    }, b.Text.prototype.determineFontProperties = function(a) {
        var c = b.Text.fontPropertiesCache[a];
        if (!c) {
            c = {};
            var d = b.Text.fontPropertiesCanvas, e = b.Text.fontPropertiesContext;
            e.font = a;
            var f = Math.ceil(e.measureText("|Mq").width), g = Math.ceil(e.measureText("M").width), h = 2 * g;
            g = 1.4 * g | 0, d.width = f, d.height = h, e.fillStyle = "#f00", e.fillRect(0, 0, f, h), 
            e.font = a, e.textBaseline = "alphabetic", e.fillStyle = "#000", e.fillText("|Mq", 0, g);
            var i, j, k = e.getImageData(0, 0, f, h).data, l = k.length, m = 4 * f, n = 0, o = !1;
            for (i = 0; g > i; i++) {
                for (j = 0; m > j; j += 4) if (255 !== k[n + j]) {
                    o = !0;
                    break;
                }
                if (o) break;
                n += m;
            }
            for (c.ascent = g - i, n = l - m, o = !1, i = h; i > g; i--) {
                for (j = 0; m > j; j += 4) if (255 !== k[n + j]) {
                    o = !0;
                    break;
                }
                if (o) break;
                n -= m;
            }
            c.descent = i - g, c.descent += 6, c.fontSize = c.ascent + c.descent, b.Text.fontPropertiesCache[a] = c;
        }
        return c;
    }, b.Text.prototype.wordWrap = function(a) {
        for (var b = "", c = a.split("\n"), d = 0; d < c.length; d++) {
            for (var e = this.style.wordWrapWidth, f = c[d].split(" "), g = 0; g < f.length; g++) {
                var h = this.context.measureText(f[g]).width, i = h + this.context.measureText(" ").width;
                0 === g || i > e ? (g > 0 && (b += "\n"), b += f[g], e = this.style.wordWrapWidth - h) : (e -= i, 
                b += " " + f[g]);
            }
            d < c.length - 1 && (b += "\n");
        }
        return b;
    }, b.Text.prototype.getBounds = function(a) {
        return this.dirty && (this.updateText(), this.dirty = !1), b.Sprite.prototype.getBounds.call(this, a);
    }, b.Text.prototype.destroy = function(a) {
        this.context = null, this.canvas = null, this.texture.destroy(void 0 === a ? !0 : a);
    }, b.Text.fontPropertiesCache = {}, b.Text.fontPropertiesCanvas = document.createElement("canvas"), 
    b.Text.fontPropertiesContext = b.Text.fontPropertiesCanvas.getContext("2d"), b.BitmapText = function(a, c) {
        b.DisplayObjectContainer.call(this), this.textWidth = 0, this.textHeight = 0, this._pool = [], 
        this.setText(a), this.setStyle(c), this.updateText(), this.dirty = !1;
    }, b.BitmapText.prototype = Object.create(b.DisplayObjectContainer.prototype), b.BitmapText.prototype.constructor = b.BitmapText, 
    b.BitmapText.prototype.setText = function(a) {
        this.text = a || " ", this.dirty = !0;
    }, b.BitmapText.prototype.setStyle = function(a) {
        a = a || {}, a.align = a.align || "left", this.style = a;
        var c = a.font.split(" ");
        this.fontName = c[c.length - 1], this.fontSize = c.length >= 2 ? parseInt(c[c.length - 2], 10) : b.BitmapText.fonts[this.fontName].size, 
        this.dirty = !0, this.tint = a.tint;
    }, b.BitmapText.prototype.updateText = function() {
        for (var a = b.BitmapText.fonts[this.fontName], c = new b.Point(), d = null, e = [], f = 0, g = [], h = 0, i = this.fontSize / a.size, j = 0; j < this.text.length; j++) {
            var k = this.text.charCodeAt(j);
            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(j))) g.push(c.x), f = Math.max(f, c.x), 
            h++, c.x = 0, c.y += a.lineHeight, d = null; else {
                var l = a.chars[k];
                l && (d && l.kerning[d] && (c.x += l.kerning[d]), e.push({
                    texture: l.texture,
                    line: h,
                    charCode: k,
                    position: new b.Point(c.x + l.xOffset, c.y + l.yOffset)
                }), c.x += l.xAdvance, d = k);
            }
        }
        g.push(c.x), f = Math.max(f, c.x);
        var m = [];
        for (j = 0; h >= j; j++) {
            var n = 0;
            "right" === this.style.align ? n = f - g[j] : "center" === this.style.align && (n = (f - g[j]) / 2), 
            m.push(n);
        }
        var o = this.children.length, p = e.length, q = this.tint || 16777215;
        for (j = 0; p > j; j++) {
            var r = o > j ? this.children[j] : this._pool.pop();
            r ? r.setTexture(e[j].texture) : r = new b.Sprite(e[j].texture), r.position.x = (e[j].position.x + m[e[j].line]) * i, 
            r.position.y = e[j].position.y * i, r.scale.x = r.scale.y = i, r.tint = q, r.parent || this.addChild(r);
        }
        for (;this.children.length > p; ) {
            var s = this.getChildAt(this.children.length - 1);
            this._pool.push(s), this.removeChild(s);
        }
        this.textWidth = f * i, this.textHeight = (c.y + a.lineHeight) * i;
    }, b.BitmapText.prototype.updateTransform = function() {
        this.dirty && (this.updateText(), this.dirty = !1), b.DisplayObjectContainer.prototype.updateTransform.call(this);
    }, b.BitmapText.fonts = {}, b.InteractionData = function() {
        this.global = new b.Point(), this.target = null, this.originalEvent = null;
    }, b.InteractionData.prototype.getLocalPosition = function(a, c, d) {
        var e = a.worldTransform, f = d ? d : this.global, g = e.a, h = e.c, i = e.tx, j = e.b, k = e.d, l = e.ty, m = 1 / (g * k + h * -j);
        return c = c || new b.Point(), c.x = k * m * f.x + -h * m * f.y + (l * h - i * k) * m, 
        c.y = g * m * f.y + -j * m * f.x + (-l * g + i * j) * m, c;
    }, b.InteractionData.prototype.constructor = b.InteractionData, b.InteractionManager = function(a) {
        this.stage = a, this.mouse = new b.InteractionData(), this.touches = {}, this.tempPoint = new b.Point(), 
        this.mouseoverEnabled = !0, this.pool = [], this.interactiveItems = [], this.interactionDOMElement = null, 
        this.onMouseMove = this.onMouseMove.bind(this), this.onMouseDown = this.onMouseDown.bind(this), 
        this.onMouseOut = this.onMouseOut.bind(this), this.onMouseUp = this.onMouseUp.bind(this), 
        this.onTouchStart = this.onTouchStart.bind(this), this.onTouchEnd = this.onTouchEnd.bind(this), 
        this.onTouchCancel = this.onTouchCancel.bind(this), this.onTouchMove = this.onTouchMove.bind(this), 
        this.last = 0, this.currentCursorStyle = "inherit", this.mouseOut = !1, this.resolution = 1, 
        this._tempPoint = new b.Point();
    }, b.InteractionManager.prototype.constructor = b.InteractionManager, b.InteractionManager.prototype.collectInteractiveSprite = function(a, b) {
        for (var c = a.children, d = c.length, e = d - 1; e >= 0; e--) {
            var f = c[e];
            f._interactive ? (b.interactiveChildren = !0, this.interactiveItems.push(f), f.children.length > 0 && this.collectInteractiveSprite(f, f)) : (f.__iParent = null, 
            f.children.length > 0 && this.collectInteractiveSprite(f, b));
        }
    }, b.InteractionManager.prototype.setTarget = function(a) {
        this.target = a, this.resolution = a.resolution, null === this.interactionDOMElement && this.setTargetDomElement(a.view);
    }, b.InteractionManager.prototype.setTargetDomElement = function(a) {
        this.removeEvents(), window.navigator.msPointerEnabled && (a.style["-ms-content-zooming"] = "none", 
        a.style["-ms-touch-action"] = "none"), this.interactionDOMElement = a, a.addEventListener("mousemove", this.onMouseMove, !0), 
        a.addEventListener("mousedown", this.onMouseDown, !0), a.addEventListener("mouseout", this.onMouseOut, !0), 
        a.addEventListener("touchstart", this.onTouchStart, !0), a.addEventListener("touchend", this.onTouchEnd, !0), 
        a.addEventListener("touchleave", this.onTouchCancel, !0), a.addEventListener("touchcancel", this.onTouchCancel, !0), 
        a.addEventListener("touchmove", this.onTouchMove, !0), window.addEventListener("mouseup", this.onMouseUp, !0);
    }, b.InteractionManager.prototype.removeEvents = function() {
        this.interactionDOMElement && (this.interactionDOMElement.style["-ms-content-zooming"] = "", 
        this.interactionDOMElement.style["-ms-touch-action"] = "", this.interactionDOMElement.removeEventListener("mousemove", this.onMouseMove, !0), 
        this.interactionDOMElement.removeEventListener("mousedown", this.onMouseDown, !0), 
        this.interactionDOMElement.removeEventListener("mouseout", this.onMouseOut, !0), 
        this.interactionDOMElement.removeEventListener("touchstart", this.onTouchStart, !0), 
        this.interactionDOMElement.removeEventListener("touchend", this.onTouchEnd, !0), 
        this.interactionDOMElement.removeEventListener("touchleave", this.onTouchCancel, !0), 
        this.interactionDOMElement.removeEventListener("touchcancel", this.onTouchCancel, !0), 
        this.interactionDOMElement.removeEventListener("touchmove", this.onTouchMove, !0), 
        this.interactionDOMElement = null, window.removeEventListener("mouseup", this.onMouseUp, !0));
    }, b.InteractionManager.prototype.update = function() {
        if (this.target) {
            var a = Date.now(), c = a - this.last;
            if (c = c * b.INTERACTION_FREQUENCY / 1e3, !(1 > c)) {
                this.last = a;
                var d = 0;
                this.dirty && this.rebuildInteractiveGraph();
                var e = this.interactiveItems.length, f = "inherit", g = !1;
                for (d = 0; e > d; d++) {
                    var h = this.interactiveItems[d];
                    h.__hit = this.hitTest(h, this.mouse), this.mouse.target = h, h.__hit && !g ? (h.buttonMode && (f = h.defaultCursor), 
                    h.interactiveChildren || (g = !0), h.__isOver || (h.mouseover && h.mouseover(this.mouse), 
                    h.__isOver = !0)) : h.__isOver && (h.mouseout && h.mouseout(this.mouse), h.__isOver = !1);
                }
                this.currentCursorStyle !== f && (this.currentCursorStyle = f, this.interactionDOMElement.style.cursor = f);
            }
        }
    }, b.InteractionManager.prototype.rebuildInteractiveGraph = function() {
        this.dirty = !1;
        for (var a = this.interactiveItems.length, b = 0; a > b; b++) this.interactiveItems[b].interactiveChildren = !1;
        this.interactiveItems = [], this.stage.interactive && this.interactiveItems.push(this.stage), 
        this.collectInteractiveSprite(this.stage, this.stage);
    }, b.InteractionManager.prototype.onMouseMove = function(a) {
        this.dirty && this.rebuildInteractiveGraph(), this.mouse.originalEvent = a;
        var b = this.interactionDOMElement.getBoundingClientRect();
        this.mouse.global.x = (a.clientX - b.left) * (this.target.width / b.width) / this.resolution, 
        this.mouse.global.y = (a.clientY - b.top) * (this.target.height / b.height) / this.resolution;
        for (var c = this.interactiveItems.length, d = 0; c > d; d++) {
            var e = this.interactiveItems[d];
            e.mousemove && e.mousemove(this.mouse);
        }
    }, b.InteractionManager.prototype.onMouseDown = function(a) {
        this.dirty && this.rebuildInteractiveGraph(), this.mouse.originalEvent = a, b.AUTO_PREVENT_DEFAULT && this.mouse.originalEvent.preventDefault();
        for (var c = this.interactiveItems.length, d = this.mouse.originalEvent, e = 2 === d.button || 3 === d.which, f = e ? "rightdown" : "mousedown", g = e ? "rightclick" : "click", h = e ? "__rightIsDown" : "__mouseIsDown", i = e ? "__isRightDown" : "__isDown", j = 0; c > j; j++) {
            var k = this.interactiveItems[j];
            if ((k[f] || k[g]) && (k[h] = !0, k.__hit = this.hitTest(k, this.mouse), k.__hit && (k[f] && k[f](this.mouse), 
            k[i] = !0, !k.interactiveChildren))) break;
        }
    }, b.InteractionManager.prototype.onMouseOut = function(a) {
        this.dirty && this.rebuildInteractiveGraph(), this.mouse.originalEvent = a;
        var b = this.interactiveItems.length;
        this.interactionDOMElement.style.cursor = "inherit";
        for (var c = 0; b > c; c++) {
            var d = this.interactiveItems[c];
            d.__isOver && (this.mouse.target = d, d.mouseout && d.mouseout(this.mouse), d.__isOver = !1);
        }
        this.mouseOut = !0, this.mouse.global.x = -1e4, this.mouse.global.y = -1e4;
    }, b.InteractionManager.prototype.onMouseUp = function(a) {
        this.dirty && this.rebuildInteractiveGraph(), this.mouse.originalEvent = a;
        for (var b = this.interactiveItems.length, c = !1, d = this.mouse.originalEvent, e = 2 === d.button || 3 === d.which, f = e ? "rightup" : "mouseup", g = e ? "rightclick" : "click", h = e ? "rightupoutside" : "mouseupoutside", i = e ? "__isRightDown" : "__isDown", j = 0; b > j; j++) {
            var k = this.interactiveItems[j];
            (k[g] || k[f] || k[h]) && (k.__hit = this.hitTest(k, this.mouse), k.__hit && !c ? (k[f] && k[f](this.mouse), 
            k[i] && k[g] && k[g](this.mouse), k.interactiveChildren || (c = !0)) : k[i] && k[h] && k[h](this.mouse), 
            k[i] = !1);
        }
    }, b.InteractionManager.prototype.hitTest = function(a, c) {
        var d = c.global;
        if (!a.worldVisible) return !1;
        a.worldTransform.applyInverse(d, this._tempPoint);
        var e, f = this._tempPoint.x, g = this._tempPoint.y;
        if (c.target = a, a.hitArea && a.hitArea.contains) return a.hitArea.contains(f, g);
        if (a instanceof b.Sprite) {
            var h, i = a.texture.frame.width, j = a.texture.frame.height, k = -i * a.anchor.x;
            if (f > k && k + i > f && (h = -j * a.anchor.y, g > h && h + j > g)) return !0;
        } else if (a instanceof b.Graphics) {
            var l = a.graphicsData;
            for (e = 0; e < l.length; e++) {
                var m = l[e];
                if (m.fill && m.shape && m.shape.contains(f, g)) return !0;
            }
        }
        var n = a.children.length;
        for (e = 0; n > e; e++) {
            var o = a.children[e], p = this.hitTest(o, c);
            if (p) return c.target = a, !0;
        }
        return !1;
    }, b.InteractionManager.prototype.onTouchMove = function(a) {
        this.dirty && this.rebuildInteractiveGraph();
        for (var b, c, d = this.interactionDOMElement.getBoundingClientRect(), e = a.changedTouches, f = e.length, g = this.target.width / d.width, h = this.target.height / d.height, i = navigator.isCocoonJS && !d.left && !d.top && !a.target.style.width && !a.target.style.height, j = 0; f > j; j++) c = e[j], 
        i ? (c.globalX = c.clientX, c.globalY = c.clientY) : (c.globalX = (c.clientX - d.left) * g / this.resolution, 
        c.globalY = (c.clientY - d.top) * h / this.resolution);
        for (var k = 0; f > k; k++) {
            c = e[k], b = this.touches[c.identifier], b.originalEvent = a, i ? (b.global.x = c.clientX, 
            b.global.y = c.clientY) : (c.globalX = b.global.x = (c.clientX - d.left) * g / this.resolution, 
            c.globalY = b.global.y = (c.clientY - d.top) * h / this.resolution);
            for (var l = 0; l < this.interactiveItems.length; l++) {
                var m = this.interactiveItems[l];
                m.touchmove && m.__touchData && m.__touchData[c.identifier] && m.touchmove(b);
            }
        }
    }, b.InteractionManager.prototype.onTouchStart = function(a) {
        this.dirty && this.rebuildInteractiveGraph();
        var c = this.interactionDOMElement.getBoundingClientRect();
        b.AUTO_PREVENT_DEFAULT && a.preventDefault();
        for (var d, e = a.changedTouches, f = e.length, g = this.target.width / c.width, h = this.target.height / c.height, i = navigator.isCocoonJS && !c.left && !c.top && !a.target.style.width && !a.target.style.height, j = 0; f > j; j++) d = e[j], 
        i ? (d.globalX = d.clientX, d.globalY = d.clientY) : (d.globalX = (d.clientX - c.left) * g / this.resolution, 
        d.globalY = (d.clientY - c.top) * h / this.resolution);
        for (var k = 0; f > k; k++) {
            d = e[k];
            var l = this.pool.pop();
            l || (l = new b.InteractionData()), l.originalEvent = a, this.touches[d.identifier] = l, 
            i ? (l.global.x = d.clientX, l.global.y = d.clientY) : (l.global.x = (d.clientX - c.left) * g / this.resolution, 
            l.global.y = (d.clientY - c.top) * h / this.resolution);
            for (var m = this.interactiveItems.length, n = 0; m > n; n++) {
                var o = this.interactiveItems[n];
                if ((o.touchstart || o.tap) && (o.__hit = this.hitTest(o, l), o.__hit && (o.touchstart && o.touchstart(l), 
                o.__isDown = !0, o.__touchData = o.__touchData || {}, o.__touchData[d.identifier] = l, 
                !o.interactiveChildren))) break;
            }
        }
    }, b.InteractionManager.prototype.onTouchEnd = function(a) {
        this.dirty && this.rebuildInteractiveGraph();
        for (var b, c = this.interactionDOMElement.getBoundingClientRect(), d = a.changedTouches, e = d.length, f = this.target.width / c.width, g = this.target.height / c.height, h = navigator.isCocoonJS && !c.left && !c.top && !a.target.style.width && !a.target.style.height, i = 0; e > i; i++) b = d[i], 
        h ? (b.globalX = b.clientX, b.globalY = b.clientY) : (b.globalX = (b.clientX - c.left) * f / this.resolution, 
        b.globalY = (b.clientY - c.top) * g / this.resolution);
        for (var j = 0; e > j; j++) {
            b = d[j];
            var k = this.touches[b.identifier], l = !1;
            h ? (k.global.x = b.clientX, k.global.y = b.clientY) : (k.global.x = (b.clientX - c.left) * f / this.resolution, 
            k.global.y = (b.clientY - c.top) * g / this.resolution);
            for (var m = this.interactiveItems.length, n = 0; m > n; n++) {
                var o = this.interactiveItems[n];
                o.__touchData && o.__touchData[b.identifier] && (o.__hit = this.hitTest(o, o.__touchData[b.identifier]), 
                k.originalEvent = a, (o.touchend || o.tap) && (o.__hit && !l ? (o.touchend && o.touchend(k), 
                o.__isDown && o.tap && o.tap(k), o.interactiveChildren || (l = !0)) : o.__isDown && o.touchendoutside && o.touchendoutside(k), 
                o.__isDown = !1), o.__touchData[b.identifier] = null);
            }
            this.pool.push(k), this.touches[b.identifier] = null;
        }
    }, b.InteractionManager.prototype.onTouchCancel = function(a) {
        this.dirty && this.rebuildInteractiveGraph();
        for (var b, c = this.interactionDOMElement.getBoundingClientRect(), d = a.changedTouches, e = d.length, f = this.target.width / c.width, g = this.target.height / c.height, h = navigator.isCocoonJS && !c.left && !c.top && !a.target.style.width && !a.target.style.height, i = 0; e > i; i++) b = d[i], 
        h ? (b.globalX = b.clientX, b.globalY = b.clientY) : (b.globalX = (b.clientX - c.left) * f / this.resolution, 
        b.globalY = (b.clientY - c.top) * g / this.resolution);
        for (var j = 0; e > j; j++) {
            b = d[j];
            var k = this.touches[b.identifier], l = !1;
            h ? (k.global.x = b.clientX, k.global.y = b.clientY) : (k.global.x = (b.clientX - c.left) * f / this.resolution, 
            k.global.y = (b.clientY - c.top) * g / this.resolution);
            for (var m = this.interactiveItems.length, n = 0; m > n; n++) {
                var o = this.interactiveItems[n];
                o.__touchData && o.__touchData[b.identifier] && (o.__hit = this.hitTest(o, o.__touchData[b.identifier]), 
                k.originalEvent = a, o.touchcancel && !l && (o.touchcancel(k), o.interactiveChildren || (l = !0)), 
                o.__isDown = !1, o.__touchData[b.identifier] = null);
            }
            this.pool.push(k), this.touches[b.identifier] = null;
        }
    }, b.Stage = function(a) {
        b.DisplayObjectContainer.call(this), this.worldTransform = new b.Matrix(), this.interactive = !0, 
        this.interactionManager = new b.InteractionManager(this), this.dirty = !0, this.stage = this, 
        this.stage.hitArea = new b.Rectangle(0, 0, 1e5, 1e5), this.setBackgroundColor(a);
    }, b.Stage.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Stage.prototype.constructor = b.Stage, 
    b.Stage.prototype.setInteractionDelegate = function(a) {
        this.interactionManager.setTargetDomElement(a);
    }, b.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var a = 0, b = this.children.length; b > a; a++) this.children[a].updateTransform();
        this.dirty && (this.dirty = !1, this.interactionManager.dirty = !0), this.interactive && this.interactionManager.update();
    }, b.Stage.prototype.setBackgroundColor = function(a) {
        this.backgroundColor = a || 0, this.backgroundColorSplit = b.hex2rgb(this.backgroundColor);
        var c = this.backgroundColor.toString(16);
        c = "000000".substr(0, 6 - c.length) + c, this.backgroundColorString = "#" + c;
    }, b.Stage.prototype.getMousePosition = function() {
        return this.interactionManager.mouse.global;
    }, function(a) {
        for (var b = 0, c = [ "ms", "moz", "webkit", "o" ], d = 0; d < c.length && !a.requestAnimationFrame; ++d) a.requestAnimationFrame = a[c[d] + "RequestAnimationFrame"], 
        a.cancelAnimationFrame = a[c[d] + "CancelAnimationFrame"] || a[c[d] + "CancelRequestAnimationFrame"];
        a.requestAnimationFrame || (a.requestAnimationFrame = function(c) {
            var d = new Date().getTime(), e = Math.max(0, 16 - (d - b)), f = a.setTimeout(function() {
                c(d + e);
            }, e);
            return b = d + e, f;
        }), a.cancelAnimationFrame || (a.cancelAnimationFrame = function(a) {
            clearTimeout(a);
        }), a.requestAnimFrame = a.requestAnimationFrame;
    }(this), b.hex2rgb = function(a) {
        return [ (a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255 ];
    }, b.rgb2hex = function(a) {
        return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
    }, "function" != typeof Function.prototype.bind && (Function.prototype.bind = function() {
        return function(a) {
            function b() {
                for (var d = arguments.length, f = new Array(d); d--; ) f[d] = arguments[d];
                return f = e.concat(f), c.apply(this instanceof b ? this : a, f);
            }
            var c = this, d = arguments.length - 1, e = [];
            if (d > 0) for (e.length = d; d--; ) e[d] = arguments[d + 1];
            if ("function" != typeof c) throw new TypeError();
            return b.prototype = function f(a) {
                return a && (f.prototype = a), this instanceof f ? void 0 : new f();
            }(c.prototype), b;
        };
    }()), b.AjaxRequest = function() {
        var a = [ "Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP" ];
        if (!window.ActiveXObject) return window.XMLHttpRequest ? new window.XMLHttpRequest() : !1;
        for (var b = 0; b < a.length; b++) try {
            return new window.ActiveXObject(a[b]);
        } catch (c) {}
    }, b.canUseNewCanvasBlendModes = function() {
        if ("undefined" == typeof document) return !1;
        var a = document.createElement("canvas");
        a.width = 1, a.height = 1;
        var b = a.getContext("2d");
        return b.fillStyle = "#000", b.fillRect(0, 0, 1, 1), b.globalCompositeOperation = "multiply", 
        b.fillStyle = "#fff", b.fillRect(0, 0, 1, 1), 0 === b.getImageData(0, 0, 1, 1).data[0];
    }, b.getNextPowerOfTwo = function(a) {
        if (a > 0 && 0 === (a & a - 1)) return a;
        for (var b = 1; a > b; ) b <<= 1;
        return b;
    }, b.isPowerOfTwo = function(a, b) {
        return a > 0 && 0 === (a & a - 1) && b > 0 && 0 === (b & b - 1);
    }, b.EventTarget = {
        call: function(a) {
            a && (a = a.prototype || a, b.EventTarget.mixin(a));
        },
        mixin: function(a) {
            a.listeners = function(a) {
                return this._listeners = this._listeners || {}, this._listeners[a] ? this._listeners[a].slice() : [];
            }, a.emit = a.dispatchEvent = function(a, c) {
                if (this._listeners = this._listeners || {}, "object" == typeof a && (c = a, a = a.type), 
                c && c.__isEventObject === !0 || (c = new b.Event(this, a, c)), this._listeners && this._listeners[a]) {
                    var d, e = this._listeners[a].slice(0), f = e.length, g = e[0];
                    for (d = 0; f > d; g = e[++d]) if (g.call(this, c), c.stoppedImmediate) return this;
                    if (c.stopped) return this;
                }
                return this.parent && this.parent.emit && this.parent.emit.call(this.parent, a, c), 
                this;
            }, a.on = a.addEventListener = function(a, b) {
                return this._listeners = this._listeners || {}, (this._listeners[a] = this._listeners[a] || []).push(b), 
                this;
            }, a.once = function(a, b) {
                function c() {
                    b.apply(d.off(a, c), arguments);
                }
                this._listeners = this._listeners || {};
                var d = this;
                return c._originalHandler = b, this.on(a, c);
            }, a.off = a.removeEventListener = function(a, b) {
                if (this._listeners = this._listeners || {}, !this._listeners[a]) return this;
                for (var c = this._listeners[a], d = b ? c.length : 0; d-- > 0; ) (c[d] === b || c[d]._originalHandler === b) && c.splice(d, 1);
                return 0 === c.length && delete this._listeners[a], this;
            }, a.removeAllListeners = function(a) {
                return this._listeners = this._listeners || {}, this._listeners[a] ? (delete this._listeners[a], 
                this) : this;
            };
        }
    }, b.Event = function(a, b, c) {
        this.__isEventObject = !0, this.stopped = !1, this.stoppedImmediate = !1, this.target = a, 
        this.type = b, this.data = c, this.content = c, this.timeStamp = Date.now();
    }, b.Event.prototype.stopPropagation = function() {
        this.stopped = !0;
    }, b.Event.prototype.stopImmediatePropagation = function() {
        this.stoppedImmediate = !0;
    }, b.autoDetectRenderer = function(a, c, d) {
        a || (a = 800), c || (c = 600);
        var e = function() {
            try {
                var a = document.createElement("canvas");
                return !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"));
            } catch (b) {
                return !1;
            }
        }();
        return e ? new b.WebGLRenderer(a, c, d) : new b.CanvasRenderer(a, c, d);
    }, b.autoDetectRecommendedRenderer = function(a, c, d) {
        a || (a = 800), c || (c = 600);
        var e = function() {
            try {
                var a = document.createElement("canvas");
                return !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"));
            } catch (b) {
                return !1;
            }
        }(), f = /Android/i.test(navigator.userAgent);
        return e && !f ? new b.WebGLRenderer(a, c, d) : new b.CanvasRenderer(a, c, d);
    }, b.PolyK = {}, b.PolyK.Triangulate = function(a) {
        var c = !0, d = a.length >> 1;
        if (3 > d) return [];
        for (var e = [], f = [], g = 0; d > g; g++) f.push(g);
        g = 0;
        for (var h = d; h > 3; ) {
            var i = f[(g + 0) % h], j = f[(g + 1) % h], k = f[(g + 2) % h], l = a[2 * i], m = a[2 * i + 1], n = a[2 * j], o = a[2 * j + 1], p = a[2 * k], q = a[2 * k + 1], r = !1;
            if (b.PolyK._convex(l, m, n, o, p, q, c)) {
                r = !0;
                for (var s = 0; h > s; s++) {
                    var t = f[s];
                    if (t !== i && t !== j && t !== k && b.PolyK._PointInTriangle(a[2 * t], a[2 * t + 1], l, m, n, o, p, q)) {
                        r = !1;
                        break;
                    }
                }
            }
            if (r) e.push(i, j, k), f.splice((g + 1) % h, 1), h--, g = 0; else if (g++ > 3 * h) {
                if (!c) return null;
                for (e = [], f = [], g = 0; d > g; g++) f.push(g);
                g = 0, h = d, c = !1;
            }
        }
        return e.push(f[0], f[1], f[2]), e;
    }, b.PolyK._PointInTriangle = function(a, b, c, d, e, f, g, h) {
        var i = g - c, j = h - d, k = e - c, l = f - d, m = a - c, n = b - d, o = i * i + j * j, p = i * k + j * l, q = i * m + j * n, r = k * k + l * l, s = k * m + l * n, t = 1 / (o * r - p * p), u = (r * q - p * s) * t, v = (o * s - p * q) * t;
        return u >= 0 && v >= 0 && 1 > u + v;
    }, b.PolyK._convex = function(a, b, c, d, e, f, g) {
        return (b - d) * (e - c) + (c - a) * (f - d) >= 0 === g;
    }, b.initDefaultShaders = function() {}, b.CompileVertexShader = function(a, c) {
        return b._CompileShader(a, c, a.VERTEX_SHADER);
    }, b.CompileFragmentShader = function(a, c) {
        return b._CompileShader(a, c, a.FRAGMENT_SHADER);
    }, b._CompileShader = function(a, b, c) {
        var d = b.join("\n"), e = a.createShader(c);
        return a.shaderSource(e, d), a.compileShader(e), a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)), 
        null);
    }, b.compileProgram = function(a, c, d) {
        var e = b.CompileFragmentShader(a, d), f = b.CompileVertexShader(a, c), g = a.createProgram();
        return a.attachShader(g, f), a.attachShader(g, e), a.linkProgram(g), a.getProgramParameter(g, a.LINK_STATUS) || window.console.log("Could not initialise shaders"), 
        g;
    }, b.PixiShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ], 
        this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], 
        this.init();
    }, b.PixiShader.prototype.constructor = b.PixiShader, b.PixiShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc || b.PixiShader.defaultVertexSrc, this.fragmentSrc);
        a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), 
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), 
        this.colorAttribute = a.getAttribLocation(c, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), 
        this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute ];
        for (var d in this.uniforms) this.uniforms[d].uniformLocation = a.getUniformLocation(c, d);
        this.initUniforms(), this.program = c;
    }, b.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var a, b = this.gl;
        for (var c in this.uniforms) {
            a = this.uniforms[c];
            var d = a.type;
            "sampler2D" === d ? (a._init = !1, null !== a.value && this.initSampler2D(a)) : "mat2" === d || "mat3" === d || "mat4" === d ? (a.glMatrix = !0, 
            a.glValueLength = 1, "mat2" === d ? a.glFunc = b.uniformMatrix2fv : "mat3" === d ? a.glFunc = b.uniformMatrix3fv : "mat4" === d && (a.glFunc = b.uniformMatrix4fv)) : (a.glFunc = b["uniform" + d], 
            a.glValueLength = "2f" === d || "2i" === d ? 2 : "3f" === d || "3i" === d ? 3 : "4f" === d || "4i" === d ? 4 : 1);
        }
    }, b.PixiShader.prototype.initSampler2D = function(a) {
        if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
            var b = this.gl;
            if (b.activeTexture(b["TEXTURE" + this.textureCount]), b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]), 
            a.textureData) {
                var c = a.textureData, d = c.magFilter ? c.magFilter : b.LINEAR, e = c.minFilter ? c.minFilter : b.LINEAR, f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE, g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE, h = c.luminance ? b.LUMINANCE : b.RGBA;
                if (c.repeat && (f = b.REPEAT, g = b.REPEAT), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY), 
                c.width) {
                    var i = c.width ? c.width : 512, j = c.height ? c.height : 2, k = c.border ? c.border : 0;
                    b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null);
                } else b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e), 
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g);
            }
            b.uniform1i(a.uniformLocation, this.textureCount), a._init = !0, this.textureCount++;
        }
    }, b.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var a, c = this.gl;
        for (var d in this.uniforms) a = this.uniforms[d], 1 === a.glValueLength ? a.glMatrix === !0 ? a.glFunc.call(c, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(c, a.uniformLocation, a.value) : 2 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y) : 3 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" === a.type && (a._init ? (c.activeTexture(c["TEXTURE" + this.textureCount]), 
        a.value.baseTexture._dirty[c.id] ? b.instances[c.id].updateTexture(a.value.baseTexture) : c.bindTexture(c.TEXTURE_2D, a.value.baseTexture._glTextures[c.id]), 
        c.uniform1i(a.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(a));
    }, b.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, b.PixiShader.defaultVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}" ], 
    b.PixiFastShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}" ], 
        this.textureCount = 0, this.init();
    }, b.PixiFastShader.prototype.constructor = b.PixiFastShader, b.PixiFastShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), 
        this.uMatrix = a.getUniformLocation(c, "uMatrix"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), 
        this.aPositionCoord = a.getAttribLocation(c, "aPositionCoord"), this.aScale = a.getAttribLocation(c, "aScale"), 
        this.aRotation = a.getAttribLocation(c, "aRotation"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), 
        this.colorAttribute = a.getAttribLocation(c, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), 
        this.attributes = [ this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute ], 
        this.program = c;
    }, b.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, b.StripShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}" ], 
        this.init();
    }, b.StripShader.prototype.constructor = b.StripShader, b.StripShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.colorAttribute = a.getAttribLocation(c, "aColor"), 
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), 
        this.attributes = [ this.aVertexPosition, this.aTextureCoord ], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), 
        this.alpha = a.getUniformLocation(c, "alpha"), this.program = c;
    }, b.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
    }, b.PrimitiveShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}" ], 
        this.init();
    }, b.PrimitiveShader.prototype.constructor = b.PrimitiveShader, b.PrimitiveShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), 
        this.flipY = a.getUniformLocation(c, "flipY"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), 
        this.colorAttribute = a.getAttribLocation(c, "aColor"), this.attributes = [ this.aVertexPosition, this.colorAttribute ], 
        this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), 
        this.program = c;
    }, b.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null;
    }, b.ComplexPrimitiveShader = function(a) {
        this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ], 
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}" ], 
        this.init();
    }, b.ComplexPrimitiveShader.prototype.constructor = b.ComplexPrimitiveShader, b.ComplexPrimitiveShader.prototype.init = function() {
        var a = this.gl, c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), 
        this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), 
        this.color = a.getUniformLocation(c, "color"), this.flipY = a.getUniformLocation(c, "flipY"), 
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.attributes = [ this.aVertexPosition, this.colorAttribute ], 
        this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), 
        this.program = c;
    }, b.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null;
    }, b.WebGLGraphics = function() {}, b.WebGLGraphics.renderGraphics = function(a, c) {
        var d, e = c.gl, f = c.projection, g = c.offset, h = c.shaderManager.primitiveShader;
        a.dirty && b.WebGLGraphics.updateGraphics(a, e);
        for (var i = a._webGL[e.id], j = 0; j < i.data.length; j++) 1 === i.data[j].mode ? (d = i.data[j], 
        c.stencilManager.pushStencil(a, d, c), e.drawElements(e.TRIANGLE_FAN, 4, e.UNSIGNED_SHORT, 2 * (d.indices.length - 4)), 
        c.stencilManager.popStencil(a, d, c)) : (d = i.data[j], c.shaderManager.setShader(h), 
        h = c.shaderManager.primitiveShader, e.uniformMatrix3fv(h.translationMatrix, !1, a.worldTransform.toArray(!0)), 
        e.uniform1f(h.flipY, 1), e.uniform2f(h.projectionVector, f.x, -f.y), e.uniform2f(h.offsetVector, -g.x, -g.y), 
        e.uniform3fv(h.tintColor, b.hex2rgb(a.tint)), e.uniform1f(h.alpha, a.worldAlpha), 
        e.bindBuffer(e.ARRAY_BUFFER, d.buffer), e.vertexAttribPointer(h.aVertexPosition, 2, e.FLOAT, !1, 24, 0), 
        e.vertexAttribPointer(h.colorAttribute, 4, e.FLOAT, !1, 24, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, d.indexBuffer), 
        e.drawElements(e.TRIANGLE_STRIP, d.indices.length, e.UNSIGNED_SHORT, 0));
    }, b.WebGLGraphics.updateGraphics = function(a, c) {
        var d = a._webGL[c.id];
        d || (d = a._webGL[c.id] = {
            lastIndex: 0,
            data: [],
            gl: c
        }), a.dirty = !1;
        var e;
        if (a.clearDirty) {
            for (a.clearDirty = !1, e = 0; e < d.data.length; e++) {
                var f = d.data[e];
                f.reset(), b.WebGLGraphics.graphicsDataPool.push(f);
            }
            d.data = [], d.lastIndex = 0;
        }
        var g;
        for (e = d.lastIndex; e < a.graphicsData.length; e++) {
            var h = a.graphicsData[e];
            if (h.type === b.Graphics.POLY) {
                if (h.points = h.shape.points.slice(), h.shape.closed && (h.points[0] !== h.points[h.points.length - 2] || h.points[1] !== h.points[h.points.length - 1]) && h.points.push(h.points[0], h.points[1]), 
                h.fill && h.points.length >= 6) if (h.points.length < 12) {
                    g = b.WebGLGraphics.switchMode(d, 0);
                    var i = b.WebGLGraphics.buildPoly(h, g);
                    i || (g = b.WebGLGraphics.switchMode(d, 1), b.WebGLGraphics.buildComplexPoly(h, g));
                } else g = b.WebGLGraphics.switchMode(d, 1), b.WebGLGraphics.buildComplexPoly(h, g);
                h.lineWidth > 0 && (g = b.WebGLGraphics.switchMode(d, 0), b.WebGLGraphics.buildLine(h, g));
            } else g = b.WebGLGraphics.switchMode(d, 0), h.type === b.Graphics.RECT ? b.WebGLGraphics.buildRectangle(h, g) : h.type === b.Graphics.CIRC || h.type === b.Graphics.ELIP ? b.WebGLGraphics.buildCircle(h, g) : h.type === b.Graphics.RREC && b.WebGLGraphics.buildRoundedRectangle(h, g);
            d.lastIndex++;
        }
        for (e = 0; e < d.data.length; e++) g = d.data[e], g.dirty && g.upload();
    }, b.WebGLGraphics.switchMode = function(a, c) {
        var d;
        return a.data.length ? (d = a.data[a.data.length - 1], (d.mode !== c || 1 === c) && (d = b.WebGLGraphics.graphicsDataPool.pop() || new b.WebGLGraphicsData(a.gl), 
        d.mode = c, a.data.push(d))) : (d = b.WebGLGraphics.graphicsDataPool.pop() || new b.WebGLGraphicsData(a.gl), 
        d.mode = c, a.data.push(d)), d.dirty = !0, d;
    }, b.WebGLGraphics.buildRectangle = function(a, c) {
        var d = a.shape, e = d.x, f = d.y, g = d.width, h = d.height;
        if (a.fill) {
            var i = b.hex2rgb(a.fillColor), j = a.fillAlpha, k = i[0] * j, l = i[1] * j, m = i[2] * j, n = c.points, o = c.indices, p = n.length / 6;
            n.push(e, f), n.push(k, l, m, j), n.push(e + g, f), n.push(k, l, m, j), n.push(e, f + h), 
            n.push(k, l, m, j), n.push(e + g, f + h), n.push(k, l, m, j), o.push(p, p, p + 1, p + 2, p + 3, p + 3);
        }
        if (a.lineWidth) {
            var q = a.points;
            a.points = [ e, f, e + g, f, e + g, f + h, e, f + h, e, f ], b.WebGLGraphics.buildLine(a, c), 
            a.points = q;
        }
    }, b.WebGLGraphics.buildRoundedRectangle = function(a, c) {
        var d = a.shape, e = d.x, f = d.y, g = d.width, h = d.height, i = d.radius, j = [];
        if (j.push(e, f + i), j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e, f + h - i, e, f + h, e + i, f + h)), 
        j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e + g - i, f + h, e + g, f + h, e + g, f + h - i)), 
        j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e + g, f + i, e + g, f, e + g - i, f)), 
        j = j.concat(b.WebGLGraphics.quadraticBezierCurve(e + i, f, e, f, e, f + i)), a.fill) {
            var k = b.hex2rgb(a.fillColor), l = a.fillAlpha, m = k[0] * l, n = k[1] * l, o = k[2] * l, p = c.points, q = c.indices, r = p.length / 6, s = b.PolyK.Triangulate(j), t = 0;
            for (t = 0; t < s.length; t += 3) q.push(s[t] + r), q.push(s[t] + r), q.push(s[t + 1] + r), 
            q.push(s[t + 2] + r), q.push(s[t + 2] + r);
            for (t = 0; t < j.length; t++) p.push(j[t], j[++t], m, n, o, l);
        }
        if (a.lineWidth) {
            var u = a.points;
            a.points = j, b.WebGLGraphics.buildLine(a, c), a.points = u;
        }
    }, b.WebGLGraphics.quadraticBezierCurve = function(a, b, c, d, e, f) {
        function g(a, b, c) {
            var d = b - a;
            return a + d * c;
        }
        for (var h, i, j, k, l, m, n = 20, o = [], p = 0, q = 0; n >= q; q++) p = q / n, 
        h = g(a, c, p), i = g(b, d, p), j = g(c, e, p), k = g(d, f, p), l = g(h, j, p), 
        m = g(i, k, p), o.push(l, m);
        return o;
    }, b.WebGLGraphics.buildCircle = function(a, c) {
        var d, e, f = a.shape, g = f.x, h = f.y;
        a.type === b.Graphics.CIRC ? (d = f.radius, e = f.radius) : (d = f.width, e = f.height);
        var i = 40, j = 2 * Math.PI / i, k = 0;
        if (a.fill) {
            var l = b.hex2rgb(a.fillColor), m = a.fillAlpha, n = l[0] * m, o = l[1] * m, p = l[2] * m, q = c.points, r = c.indices, s = q.length / 6;
            for (r.push(s), k = 0; i + 1 > k; k++) q.push(g, h, n, o, p, m), q.push(g + Math.sin(j * k) * d, h + Math.cos(j * k) * e, n, o, p, m), 
            r.push(s++, s++);
            r.push(s - 1);
        }
        if (a.lineWidth) {
            var t = a.points;
            for (a.points = [], k = 0; i + 1 > k; k++) a.points.push(g + Math.sin(j * k) * d, h + Math.cos(j * k) * e);
            b.WebGLGraphics.buildLine(a, c), a.points = t;
        }
    }, b.WebGLGraphics.buildLine = function(a, c) {
        var d = 0, e = a.points;
        if (0 !== e.length) {
            if (a.lineWidth % 2) for (d = 0; d < e.length; d++) e[d] += .5;
            var f = new b.Point(e[0], e[1]), g = new b.Point(e[e.length - 2], e[e.length - 1]);
            if (f.x === g.x && f.y === g.y) {
                e = e.slice(), e.pop(), e.pop(), g = new b.Point(e[e.length - 2], e[e.length - 1]);
                var h = g.x + .5 * (f.x - g.x), i = g.y + .5 * (f.y - g.y);
                e.unshift(h, i), e.push(h, i);
            }
            var j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G = c.points, H = c.indices, I = e.length / 2, J = e.length, K = G.length / 6, L = a.lineWidth / 2, M = b.hex2rgb(a.lineColor), N = a.lineAlpha, O = M[0] * N, P = M[1] * N, Q = M[2] * N;
            for (l = e[0], m = e[1], n = e[2], o = e[3], r = -(m - o), s = l - n, F = Math.sqrt(r * r + s * s), 
            r /= F, s /= F, r *= L, s *= L, G.push(l - r, m - s, O, P, Q, N), G.push(l + r, m + s, O, P, Q, N), 
            d = 1; I - 1 > d; d++) l = e[2 * (d - 1)], m = e[2 * (d - 1) + 1], n = e[2 * d], 
            o = e[2 * d + 1], p = e[2 * (d + 1)], q = e[2 * (d + 1) + 1], r = -(m - o), s = l - n, 
            F = Math.sqrt(r * r + s * s), r /= F, s /= F, r *= L, s *= L, t = -(o - q), u = n - p, 
            F = Math.sqrt(t * t + u * u), t /= F, u /= F, t *= L, u *= L, x = -s + m - (-s + o), 
            y = -r + n - (-r + l), z = (-r + l) * (-s + o) - (-r + n) * (-s + m), A = -u + q - (-u + o), 
            B = -t + n - (-t + p), C = (-t + p) * (-u + o) - (-t + n) * (-u + q), D = x * B - A * y, 
            Math.abs(D) < .1 ? (D += 10.1, G.push(n - r, o - s, O, P, Q, N), G.push(n + r, o + s, O, P, Q, N)) : (j = (y * C - B * z) / D, 
            k = (A * z - x * C) / D, E = (j - n) * (j - n) + (k - o) + (k - o), E > 19600 ? (v = r - t, 
            w = s - u, F = Math.sqrt(v * v + w * w), v /= F, w /= F, v *= L, w *= L, G.push(n - v, o - w), 
            G.push(O, P, Q, N), G.push(n + v, o + w), G.push(O, P, Q, N), G.push(n - v, o - w), 
            G.push(O, P, Q, N), J++) : (G.push(j, k), G.push(O, P, Q, N), G.push(n - (j - n), o - (k - o)), 
            G.push(O, P, Q, N)));
            for (l = e[2 * (I - 2)], m = e[2 * (I - 2) + 1], n = e[2 * (I - 1)], o = e[2 * (I - 1) + 1], 
            r = -(m - o), s = l - n, F = Math.sqrt(r * r + s * s), r /= F, s /= F, r *= L, s *= L, 
            G.push(n - r, o - s), G.push(O, P, Q, N), G.push(n + r, o + s), G.push(O, P, Q, N), 
            H.push(K), d = 0; J > d; d++) H.push(K++);
            H.push(K - 1);
        }
    }, b.WebGLGraphics.buildComplexPoly = function(a, c) {
        var d = a.points.slice();
        if (!(d.length < 6)) {
            var e = c.indices;
            c.points = d, c.alpha = a.fillAlpha, c.color = b.hex2rgb(a.fillColor);
            for (var f, g, h = 1 / 0, i = -(1 / 0), j = 1 / 0, k = -(1 / 0), l = 0; l < d.length; l += 2) f = d[l], 
            g = d[l + 1], h = h > f ? f : h, i = f > i ? f : i, j = j > g ? g : j, k = g > k ? g : k;
            d.push(h, j, i, j, i, k, h, k);
            var m = d.length / 2;
            for (l = 0; m > l; l++) e.push(l);
        }
    }, b.WebGLGraphics.buildPoly = function(a, c) {
        var d = a.points;
        if (!(d.length < 6)) {
            var e = c.points, f = c.indices, g = d.length / 2, h = b.hex2rgb(a.fillColor), i = a.fillAlpha, j = h[0] * i, k = h[1] * i, l = h[2] * i, m = b.PolyK.Triangulate(d);
            if (!m) return !1;
            var n = e.length / 6, o = 0;
            for (o = 0; o < m.length; o += 3) f.push(m[o] + n), f.push(m[o] + n), f.push(m[o + 1] + n), 
            f.push(m[o + 2] + n), f.push(m[o + 2] + n);
            for (o = 0; g > o; o++) e.push(d[2 * o], d[2 * o + 1], j, k, l, i);
            return !0;
        }
    }, b.WebGLGraphics.graphicsDataPool = [], b.WebGLGraphicsData = function(a) {
        this.gl = a, this.color = [ 0, 0, 0 ], this.points = [], this.indices = [], this.buffer = a.createBuffer(), 
        this.indexBuffer = a.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0;
    }, b.WebGLGraphicsData.prototype.reset = function() {
        this.points = [], this.indices = [];
    }, b.WebGLGraphicsData.prototype.upload = function() {
        var a = this.gl;
        this.glPoints = new b.Float32Array(this.points), a.bindBuffer(a.ARRAY_BUFFER, this.buffer), 
        a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW), this.glIndicies = new b.Uint16Array(this.indices), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW), 
        this.dirty = !1;
    }, b.glContexts = [], b.instances = [], b.WebGLRenderer = function(a, c, d) {
        if (d) for (var e in b.defaultRenderOptions) "undefined" == typeof d[e] && (d[e] = b.defaultRenderOptions[e]); else d = b.defaultRenderOptions;
        b.defaultRenderer || (b.sayHello("webGL"), b.defaultRenderer = this), this.type = b.WEBGL_RENDERER, 
        this.resolution = d.resolution, this.transparent = d.transparent, this.autoResize = d.autoResize || !1, 
        this.preserveDrawingBuffer = d.preserveDrawingBuffer, this.clearBeforeRender = d.clearBeforeRender, 
        this.width = a || 800, this.height = c || 600, this.view = d.view || document.createElement("canvas"), 
        this.contextLostBound = this.handleContextLost.bind(this), this.contextRestoredBound = this.handleContextRestored.bind(this), 
        this.view.addEventListener("webglcontextlost", this.contextLostBound, !1), this.view.addEventListener("webglcontextrestored", this.contextRestoredBound, !1), 
        this._contextOptions = {
            alpha: this.transparent,
            antialias: d.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: d.preserveDrawingBuffer
        }, this.projection = new b.Point(), this.offset = new b.Point(0, 0), this.shaderManager = new b.WebGLShaderManager(), 
        this.spriteBatch = new b.WebGLSpriteBatch(), this.maskManager = new b.WebGLMaskManager(), 
        this.filterManager = new b.WebGLFilterManager(), this.stencilManager = new b.WebGLStencilManager(), 
        this.blendModeManager = new b.WebGLBlendModeManager(), this.renderSession = {}, 
        this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, 
        this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, 
        this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, 
        this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, 
        this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes();
    }, b.WebGLRenderer.prototype.constructor = b.WebGLRenderer, b.WebGLRenderer.prototype.initContext = function() {
        var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = a, !a) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = a.id = b.WebGLRenderer.glContextId++, b.glContexts[this.glContextId] = a, 
        b.instances[this.glContextId] = this, a.disable(a.DEPTH_TEST), a.disable(a.CULL_FACE), 
        a.enable(a.BLEND), this.shaderManager.setContext(a), this.spriteBatch.setContext(a), 
        this.maskManager.setContext(a), this.filterManager.setContext(a), this.blendModeManager.setContext(a), 
        this.stencilManager.setContext(a), this.renderSession.gl = this.gl, this.resize(this.width, this.height);
    }, b.WebGLRenderer.prototype.render = function(a) {
        if (!this.contextLost) {
            this.__stage !== a && (a.interactive && a.interactionManager.removeEvents(), this.__stage = a), 
            a.updateTransform();
            var b = this.gl;
            a._interactive ? a._interactiveEventsAdded || (a._interactiveEventsAdded = !0, a.interactionManager.setTarget(this)) : a._interactiveEventsAdded && (a._interactiveEventsAdded = !1, 
            a.interactionManager.setTarget(this)), b.viewport(0, 0, this.width, this.height), 
            b.bindFramebuffer(b.FRAMEBUFFER, null), this.clearBeforeRender && (this.transparent ? b.clearColor(0, 0, 0, 0) : b.clearColor(a.backgroundColorSplit[0], a.backgroundColorSplit[1], a.backgroundColorSplit[2], 1), 
            b.clear(b.COLOR_BUFFER_BIT)), this.renderDisplayObject(a, this.projection);
        }
    }, b.WebGLRenderer.prototype.renderDisplayObject = function(a, c, d) {
        this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL), this.renderSession.drawCount = 0, 
        this.renderSession.flipY = d ? -1 : 1, this.renderSession.projection = c, this.renderSession.offset = this.offset, 
        this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, d), 
        a._renderWebGL(this.renderSession), this.spriteBatch.end();
    }, b.WebGLRenderer.prototype.resize = function(a, b) {
        this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, 
        this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", 
        this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), 
        this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution;
    }, b.WebGLRenderer.prototype.updateTexture = function(a) {
        if (a.hasLoaded) {
            var c = this.gl;
            return a._glTextures[c.id] || (a._glTextures[c.id] = c.createTexture()), c.bindTexture(c.TEXTURE_2D, a._glTextures[c.id]), 
            c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a.source), 
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), 
            a.mipmap && b.isPowerOfTwo(a.width, a.height) ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR_MIPMAP_LINEAR : c.NEAREST_MIPMAP_NEAREST), 
            c.generateMipmap(c.TEXTURE_2D)) : c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), 
            a._powerOf2 ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT)) : (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), 
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE)), a._dirty[c.id] = !1, 
            a._glTextures[c.id];
        }
    }, b.WebGLRenderer.prototype.handleContextLost = function(a) {
        a.preventDefault(), this.contextLost = !0;
    }, b.WebGLRenderer.prototype.handleContextRestored = function() {
        this.initContext();
        for (var a in b.TextureCache) {
            var c = b.TextureCache[a].baseTexture;
            c._glTextures = [];
        }
        this.contextLost = !1;
    }, b.WebGLRenderer.prototype.destroy = function() {
        this.view.removeEventListener("webglcontextlost", this.contextLostBound), this.view.removeEventListener("webglcontextrestored", this.contextRestoredBound), 
        b.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, 
        this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), 
        this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, 
        this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null;
    }, b.WebGLRenderer.prototype.mapBlendModes = function() {
        var a = this.gl;
        b.blendModesWebGL || (b.blendModesWebGL = [], b.blendModesWebGL[b.blendModes.NORMAL] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.ADD] = [ a.SRC_ALPHA, a.DST_ALPHA ], b.blendModesWebGL[b.blendModes.MULTIPLY] = [ a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.SCREEN] = [ a.SRC_ALPHA, a.ONE ], b.blendModesWebGL[b.blendModes.OVERLAY] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.DARKEN] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.LIGHTEN] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.COLOR_DODGE] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.COLOR_BURN] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.HARD_LIGHT] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.SOFT_LIGHT] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.DIFFERENCE] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.EXCLUSION] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.HUE] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.SATURATION] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], b.blendModesWebGL[b.blendModes.COLOR] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ], 
        b.blendModesWebGL[b.blendModes.LUMINOSITY] = [ a.ONE, a.ONE_MINUS_SRC_ALPHA ]);
    }, b.WebGLRenderer.glContextId = 0, b.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999;
    }, b.WebGLBlendModeManager.prototype.constructor = b.WebGLBlendModeManager, b.WebGLBlendModeManager.prototype.setContext = function(a) {
        this.gl = a;
    }, b.WebGLBlendModeManager.prototype.setBlendMode = function(a) {
        if (this.currentBlendMode === a) return !1;
        this.currentBlendMode = a;
        var c = b.blendModesWebGL[this.currentBlendMode];
        return this.gl.blendFunc(c[0], c[1]), !0;
    }, b.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null;
    }, b.WebGLMaskManager = function() {}, b.WebGLMaskManager.prototype.constructor = b.WebGLMaskManager, 
    b.WebGLMaskManager.prototype.setContext = function(a) {
        this.gl = a;
    }, b.WebGLMaskManager.prototype.pushMask = function(a, c) {
        var d = c.gl;
        a.dirty && b.WebGLGraphics.updateGraphics(a, d), a._webGL[d.id].data.length && c.stencilManager.pushStencil(a, a._webGL[d.id].data[0], c);
    }, b.WebGLMaskManager.prototype.popMask = function(a, b) {
        var c = this.gl;
        b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b);
    }, b.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null;
    }, b.WebGLStencilManager = function() {
        this.stencilStack = [], this.reverse = !0, this.count = 0;
    }, b.WebGLStencilManager.prototype.setContext = function(a) {
        this.gl = a;
    }, b.WebGLStencilManager.prototype.pushStencil = function(a, b, c) {
        var d = this.gl;
        this.bindGraphics(a, b, c), 0 === this.stencilStack.length && (d.enable(d.STENCIL_TEST), 
        d.clear(d.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(b);
        var e = this.count;
        d.colorMask(!1, !1, !1, !1), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), 
        1 === b.mode ? (d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), 
        this.reverse ? (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, e, 255), 
        d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), 
        this.reverse ? d.stencilFunc(d.EQUAL, 255 - (e + 1), 255) : d.stencilFunc(d.EQUAL, e + 1, 255), 
        this.reverse = !this.reverse) : (this.reverse ? (d.stencilFunc(d.EQUAL, e, 255), 
        d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), 
        d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e + 1, 255) : d.stencilFunc(d.EQUAL, 255 - (e + 1), 255)), 
        d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP), this.count++;
    }, b.WebGLStencilManager.prototype.bindGraphics = function(a, c, d) {
        this._currentGraphics = a;
        var e, f = this.gl, g = d.projection, h = d.offset;
        1 === c.mode ? (e = d.shaderManager.complexPrimitiveShader, d.shaderManager.setShader(e), 
        f.uniform1f(e.flipY, d.flipY), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), 
        f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), 
        f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform3fv(e.color, c.color), f.uniform1f(e.alpha, a.worldAlpha * c.alpha), 
        f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 8, 0), 
        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer)) : (e = d.shaderManager.primitiveShader, 
        d.shaderManager.setShader(e), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), 
        f.uniform1f(e.flipY, d.flipY), f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), 
        f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform1f(e.alpha, a.worldAlpha), 
        f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 24, 0), 
        f.vertexAttribPointer(e.colorAttribute, 4, f.FLOAT, !1, 24, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer));
    }, b.WebGLStencilManager.prototype.popStencil = function(a, b, c) {
        var d = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) d.disable(d.STENCIL_TEST); else {
            var e = this.count;
            this.bindGraphics(a, b, c), d.colorMask(!1, !1, !1, !1), 1 === b.mode ? (this.reverse = !this.reverse, 
            this.reverse ? (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, e + 1, 255), 
            d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), 
            d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), 
            this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)) : (this.reverse ? (d.stencilFunc(d.EQUAL, e + 1, 255), 
            d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), 
            d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), 
            this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)), 
            d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP);
        }
    }, b.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null, this.gl = null;
    }, b.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var a = 0; a < this.maxAttibs; a++) this.attribState[a] = !1;
        this.stack = [];
    }, b.WebGLShaderManager.prototype.constructor = b.WebGLShaderManager, b.WebGLShaderManager.prototype.setContext = function(a) {
        this.gl = a, this.primitiveShader = new b.PrimitiveShader(a), this.complexPrimitiveShader = new b.ComplexPrimitiveShader(a), 
        this.defaultShader = new b.PixiShader(a), this.fastShader = new b.PixiFastShader(a), 
        this.stripShader = new b.StripShader(a), this.setShader(this.defaultShader);
    }, b.WebGLShaderManager.prototype.setAttribs = function(a) {
        var b;
        for (b = 0; b < this.tempAttribState.length; b++) this.tempAttribState[b] = !1;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            this.tempAttribState[c] = !0;
        }
        var d = this.gl;
        for (b = 0; b < this.attribState.length; b++) this.attribState[b] !== this.tempAttribState[b] && (this.attribState[b] = this.tempAttribState[b], 
        this.tempAttribState[b] ? d.enableVertexAttribArray(b) : d.disableVertexAttribArray(b));
    }, b.WebGLShaderManager.prototype.setShader = function(a) {
        return this._currentId === a._UID ? !1 : (this._currentId = a._UID, this.currentShader = a, 
        this.gl.useProgram(a.program), this.setAttribs(a.attributes), !0);
    }, b.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), 
        this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), 
        this.stripShader.destroy(), this.gl = null;
    }, b.WebGLSpriteBatch = function() {
        this.vertSize = 5, this.size = 2e3;
        var a = 4 * this.size * 4 * this.vertSize, c = 6 * this.size;
        this.vertices = new b.ArrayBuffer(a), this.positions = new b.Float32Array(this.vertices), 
        this.colors = new b.Uint32Array(this.vertices), this.indices = new b.Uint16Array(c), 
        this.lastIndexCount = 0;
        for (var d = 0, e = 0; c > d; d += 6, e += 4) this.indices[d + 0] = e + 0, this.indices[d + 1] = e + 1, 
        this.indices[d + 2] = e + 2, this.indices[d + 3] = e + 0, this.indices[d + 4] = e + 2, 
        this.indices[d + 5] = e + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, 
        this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], 
        this.defaultShader = new b.AbstractFilter([ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ]);
    }, b.WebGLSpriteBatch.prototype.setContext = function(a) {
        this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), 
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW), 
        this.currentBlendMode = 99999;
        var c = new b.PixiShader(a);
        c.fragmentSrc = this.defaultShader.fragmentSrc, c.uniforms = {}, c.init(), this.defaultShader.shaders[a.id] = c;
    }, b.WebGLSpriteBatch.prototype.begin = function(a) {
        this.renderSession = a, this.shader = this.renderSession.shaderManager.defaultShader, 
        this.start();
    }, b.WebGLSpriteBatch.prototype.end = function() {
        this.flush();
    }, b.WebGLSpriteBatch.prototype.render = function(a) {
        var b = a.texture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = b.baseTexture);
        var c = b._uvs;
        if (c) {
            var d, e, f, g, h = a.anchor.x, i = a.anchor.y;
            if (b.trim) {
                var j = b.trim;
                e = j.x - h * j.width, d = e + b.crop.width, g = j.y - i * j.height, f = g + b.crop.height;
            } else d = b.frame.width * (1 - h), e = b.frame.width * -h, f = b.frame.height * (1 - i), 
            g = b.frame.height * -i;
            var k = 4 * this.currentBatchSize * this.vertSize, l = b.baseTexture.resolution, m = a.worldTransform, n = m.a / l, o = m.b / l, p = m.c / l, q = m.d / l, r = m.tx, s = m.ty, t = this.colors, u = this.positions;
            this.renderSession.roundPixels ? (u[k] = n * e + p * g + r | 0, u[k + 1] = q * g + o * e + s | 0, 
            u[k + 5] = n * d + p * g + r | 0, u[k + 6] = q * g + o * d + s | 0, u[k + 10] = n * d + p * f + r | 0, 
            u[k + 11] = q * f + o * d + s | 0, u[k + 15] = n * e + p * f + r | 0, u[k + 16] = q * f + o * e + s | 0) : (u[k] = n * e + p * g + r, 
            u[k + 1] = q * g + o * e + s, u[k + 5] = n * d + p * g + r, u[k + 6] = q * g + o * d + s, 
            u[k + 10] = n * d + p * f + r, u[k + 11] = q * f + o * d + s, u[k + 15] = n * e + p * f + r, 
            u[k + 16] = q * f + o * e + s), u[k + 2] = c.x0, u[k + 3] = c.y0, u[k + 7] = c.x1, 
            u[k + 8] = c.y1, u[k + 12] = c.x2, u[k + 13] = c.y2, u[k + 17] = c.x3, u[k + 18] = c.y3;
            var v = a.tint;
            t[k + 4] = t[k + 9] = t[k + 14] = t[k + 19] = (v >> 16) + (65280 & v) + ((255 & v) << 16) + (255 * a.worldAlpha << 24), 
            this.sprites[this.currentBatchSize++] = a;
        }
    }, b.WebGLSpriteBatch.prototype.renderTilingSprite = function(a) {
        var c = a.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture), 
        a._uvs || (a._uvs = new b.TextureUvs());
        var d = a._uvs;
        a.tilePosition.x %= c.baseTexture.width * a.tileScaleOffset.x, a.tilePosition.y %= c.baseTexture.height * a.tileScaleOffset.y;
        var e = a.tilePosition.x / (c.baseTexture.width * a.tileScaleOffset.x), f = a.tilePosition.y / (c.baseTexture.height * a.tileScaleOffset.y), g = a.width / c.baseTexture.width / (a.tileScale.x * a.tileScaleOffset.x), h = a.height / c.baseTexture.height / (a.tileScale.y * a.tileScaleOffset.y);
        d.x0 = 0 - e, d.y0 = 0 - f, d.x1 = 1 * g - e, d.y1 = 0 - f, d.x2 = 1 * g - e, d.y2 = 1 * h - f, 
        d.x3 = 0 - e, d.y3 = 1 * h - f;
        var i = a.tint, j = (i >> 16) + (65280 & i) + ((255 & i) << 16) + (255 * a.alpha << 24), k = this.positions, l = this.colors, m = a.width, n = a.height, o = a.anchor.x, p = a.anchor.y, q = m * (1 - o), r = m * -o, s = n * (1 - p), t = n * -p, u = 4 * this.currentBatchSize * this.vertSize, v = c.baseTexture.resolution, w = a.worldTransform, x = w.a / v, y = w.b / v, z = w.c / v, A = w.d / v, B = w.tx, C = w.ty;
        k[u++] = x * r + z * t + B, k[u++] = A * t + y * r + C, k[u++] = d.x0, k[u++] = d.y0, 
        l[u++] = j, k[u++] = x * q + z * t + B, k[u++] = A * t + y * q + C, k[u++] = d.x1, 
        k[u++] = d.y1, l[u++] = j, k[u++] = x * q + z * s + B, k[u++] = A * s + y * q + C, 
        k[u++] = d.x2, k[u++] = d.y2, l[u++] = j, k[u++] = x * r + z * s + B, k[u++] = A * s + y * r + C, 
        k[u++] = d.x3, k[u++] = d.y3, l[u++] = j, this.sprites[this.currentBatchSize++] = a;
    }, b.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a, c = this.gl;
            if (this.dirty) {
                this.dirty = !1, c.activeTexture(c.TEXTURE0), c.bindBuffer(c.ARRAY_BUFFER, this.vertexBuffer), 
                c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a = this.defaultShader.shaders[c.id];
                var d = 4 * this.vertSize;
                c.vertexAttribPointer(a.aVertexPosition, 2, c.FLOAT, !1, d, 0), c.vertexAttribPointer(a.aTextureCoord, 2, c.FLOAT, !1, d, 8), 
                c.vertexAttribPointer(a.colorAttribute, 4, c.UNSIGNED_BYTE, !0, d, 16);
            }
            if (this.currentBatchSize > .5 * this.size) c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices); else {
                var e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                c.bufferSubData(c.ARRAY_BUFFER, 0, e);
            }
            for (var f, g, h, i, j = 0, k = 0, l = null, m = this.renderSession.blendModeManager.currentBlendMode, n = null, o = !1, p = !1, q = 0, r = this.currentBatchSize; r > q; q++) {
                if (i = this.sprites[q], f = i.texture.baseTexture, g = i.blendMode, h = i.shader || this.defaultShader, 
                o = m !== g, p = n !== h, (l !== f || o || p) && (this.renderBatch(l, j, k), k = q, 
                j = 0, l = f, o && (m = g, this.renderSession.blendModeManager.setBlendMode(m)), 
                p)) {
                    n = h, a = n.shaders[c.id], a || (a = new b.PixiShader(c), a.fragmentSrc = n.fragmentSrc, 
                    a.uniforms = n.uniforms, a.init(), n.shaders[c.id] = a), this.renderSession.shaderManager.setShader(a), 
                    a.dirty && a.syncUniforms();
                    var s = this.renderSession.projection;
                    c.uniform2f(a.projectionVector, s.x, s.y);
                    var t = this.renderSession.offset;
                    c.uniform2f(a.offsetVector, t.x, t.y);
                }
                j++;
            }
            this.renderBatch(l, j, k), this.currentBatchSize = 0;
        }
    }, b.WebGLSpriteBatch.prototype.renderBatch = function(a, b, c) {
        if (0 !== b) {
            var d = this.gl;
            a._dirty[d.id] ? this.renderSession.renderer.updateTexture(a) : d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]), 
            d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2), this.renderSession.drawCount++;
        }
    }, b.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(), this.dirty = !0;
    }, b.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0;
    }, b.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), 
        this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null;
    }, b.WebGLFastSpriteBatch = function(a) {
        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
        var c = 4 * this.size * this.vertSize, d = 6 * this.maxSize;
        this.vertices = new b.Float32Array(c), this.indices = new b.Uint16Array(d), this.vertexBuffer = null, 
        this.indexBuffer = null, this.lastIndexCount = 0;
        for (var e = 0, f = 0; d > e; e += 6, f += 4) this.indices[e + 0] = f + 0, this.indices[e + 1] = f + 1, 
        this.indices[e + 2] = f + 2, this.indices[e + 3] = f + 0, this.indices[e + 4] = f + 2, 
        this.indices[e + 5] = f + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, 
        this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(a);
    }, b.WebGLFastSpriteBatch.prototype.constructor = b.WebGLFastSpriteBatch, b.WebGLFastSpriteBatch.prototype.setContext = function(a) {
        this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), 
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
    }, b.WebGLFastSpriteBatch.prototype.begin = function(a, b) {
        this.renderSession = b, this.shader = this.renderSession.shaderManager.fastShader, 
        this.matrix = a.worldTransform.toArray(!0), this.start();
    }, b.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush();
    }, b.WebGLFastSpriteBatch.prototype.render = function(a) {
        var b = a.children, c = b[0];
        if (c.texture._uvs) {
            this.currentBaseTexture = c.texture.baseTexture, c.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), 
            this.renderSession.blendModeManager.setBlendMode(c.blendMode));
            for (var d = 0, e = b.length; e > d; d++) this.renderSprite(b[d]);
            this.flush();
        }
    }, b.WebGLFastSpriteBatch.prototype.renderSprite = function(a) {
        if (a.visible && (a.texture.baseTexture === this.currentBaseTexture || (this.flush(), 
        this.currentBaseTexture = a.texture.baseTexture, a.texture._uvs))) {
            var b, c, d, e, f, g, h, i, j = this.vertices;
            if (b = a.texture._uvs, c = a.texture.frame.width, d = a.texture.frame.height, a.texture.trim) {
                var k = a.texture.trim;
                f = k.x - a.anchor.x * k.width, e = f + a.texture.crop.width, h = k.y - a.anchor.y * k.height, 
                g = h + a.texture.crop.height;
            } else e = a.texture.frame.width * (1 - a.anchor.x), f = a.texture.frame.width * -a.anchor.x, 
            g = a.texture.frame.height * (1 - a.anchor.y), h = a.texture.frame.height * -a.anchor.y;
            i = 4 * this.currentBatchSize * this.vertSize, j[i++] = f, j[i++] = h, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x0, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = h, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x1, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = g, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x2, j[i++] = b.y2, j[i++] = a.alpha, j[i++] = f, j[i++] = g, j[i++] = a.position.x, 
            j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, 
            j[i++] = b.x3, j[i++] = b.y3, j[i++] = a.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush();
        }
    }, b.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a = this.gl;
            if (this.currentBaseTexture._glTextures[a.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, a), 
            a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]), this.currentBatchSize > .5 * this.size) a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices); else {
                var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                a.bufferSubData(a.ARRAY_BUFFER, 0, b);
            }
            a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, 
            this.renderSession.drawCount++;
        }
    }, b.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush();
    }, b.WebGLFastSpriteBatch.prototype.start = function() {
        var a = this.gl;
        a.activeTexture(a.TEXTURE0), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = this.renderSession.projection;
        a.uniform2f(this.shader.projectionVector, b.x, b.y), a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var c = 4 * this.vertSize;
        a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, c, 0), a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, c, 8), 
        a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, c, 16), a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, c, 24), 
        a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, c, 28), a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, c, 36);
    }, b.WebGLFilterManager = function() {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0;
    }, b.WebGLFilterManager.prototype.constructor = b.WebGLFilterManager, b.WebGLFilterManager.prototype.setContext = function(a) {
        this.gl = a, this.texturePool = [], this.initShaderBuffers();
    }, b.WebGLFilterManager.prototype.begin = function(a, b) {
        this.renderSession = a, this.defaultShader = a.shaderManager.defaultShader;
        var c = this.renderSession.projection;
        this.width = 2 * c.x, this.height = 2 * -c.y, this.buffer = b;
    }, b.WebGLFilterManager.prototype.pushFilter = function(a) {
        var c = this.gl, d = this.renderSession.projection, e = this.renderSession.offset;
        a._filterArea = a.target.filterArea || a.target.getBounds(), this.filterStack.push(a);
        var f = a.filterPasses[0];
        this.offsetX += a._filterArea.x, this.offsetY += a._filterArea.y;
        var g = this.texturePool.pop();
        g ? g.resize(this.width, this.height) : g = new b.FilterTexture(this.gl, this.width, this.height), 
        c.bindTexture(c.TEXTURE_2D, g.texture);
        var h = a._filterArea, i = f.padding;
        h.x -= i, h.y -= i, h.width += 2 * i, h.height += 2 * i, h.x < 0 && (h.x = 0), h.width > this.width && (h.width = this.width), 
        h.y < 0 && (h.y = 0), h.height > this.height && (h.height = this.height), c.bindFramebuffer(c.FRAMEBUFFER, g.frameBuffer), 
        c.viewport(0, 0, h.width, h.height), d.x = h.width / 2, d.y = -h.height / 2, e.x = -h.x, 
        e.y = -h.y, c.colorMask(!0, !0, !0, !0), c.clearColor(0, 0, 0, 0), c.clear(c.COLOR_BUFFER_BIT), 
        a._glFilterTexture = g;
    }, b.WebGLFilterManager.prototype.popFilter = function() {
        var a = this.gl, c = this.filterStack.pop(), d = c._filterArea, e = c._glFilterTexture, f = this.renderSession.projection, g = this.renderSession.offset;
        if (c.filterPasses.length > 1) {
            a.viewport(0, 0, d.width, d.height), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), 
            this.vertexArray[0] = 0, this.vertexArray[1] = d.height, this.vertexArray[2] = d.width, 
            this.vertexArray[3] = d.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, 
            this.vertexArray[6] = d.width, this.vertexArray[7] = 0, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), 
            a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = d.width / this.width, 
            this.uvArray[5] = d.height / this.height, this.uvArray[6] = d.width / this.width, 
            this.uvArray[7] = d.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
            var h = e, i = this.texturePool.pop();
            i || (i = new b.FilterTexture(this.gl, this.width, this.height)), i.resize(this.width, this.height), 
            a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.clear(a.COLOR_BUFFER_BIT), a.disable(a.BLEND);
            for (var j = 0; j < c.filterPasses.length - 1; j++) {
                var k = c.filterPasses[j];
                a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, h.texture), 
                this.applyFilterPass(k, d, d.width, d.height);
                var l = h;
                h = i, i = l;
            }
            a.enable(a.BLEND), e = h, this.texturePool.push(i);
        }
        var m = c.filterPasses[c.filterPasses.length - 1];
        this.offsetX -= d.x, this.offsetY -= d.y;
        var n = this.width, o = this.height, p = 0, q = 0, r = this.buffer;
        if (0 === this.filterStack.length) a.colorMask(!0, !0, !0, !0); else {
            var s = this.filterStack[this.filterStack.length - 1];
            d = s._filterArea, n = d.width, o = d.height, p = d.x, q = d.y, r = s._glFilterTexture.frameBuffer;
        }
        f.x = n / 2, f.y = -o / 2, g.x = p, g.y = q, d = c._filterArea;
        var t = d.x - p, u = d.y - q;
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = t, this.vertexArray[1] = u + d.height, 
        this.vertexArray[2] = t + d.width, this.vertexArray[3] = u + d.height, this.vertexArray[4] = t, 
        this.vertexArray[5] = u, this.vertexArray[6] = t + d.width, this.vertexArray[7] = u, 
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), 
        this.uvArray[2] = d.width / this.width, this.uvArray[5] = d.height / this.height, 
        this.uvArray[6] = d.width / this.width, this.uvArray[7] = d.height / this.height, 
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray), a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution), 
        a.bindFramebuffer(a.FRAMEBUFFER, r), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e.texture), 
        this.applyFilterPass(m, d, n, o), this.texturePool.push(e), c._glFilterTexture = null;
    }, b.WebGLFilterManager.prototype.applyFilterPass = function(a, c, d, e) {
        var f = this.gl, g = a.shaders[f.id];
        g || (g = new b.PixiShader(f), g.fragmentSrc = a.fragmentSrc, g.uniforms = a.uniforms, 
        g.init(), a.shaders[f.id] = g), this.renderSession.shaderManager.setShader(g), f.uniform2f(g.projectionVector, d / 2, -e / 2), 
        f.uniform2f(g.offsetVector, 0, 0), a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width, 
        a.uniforms.dimensions.value[1] = this.height, a.uniforms.dimensions.value[2] = this.vertexArray[0], 
        a.uniforms.dimensions.value[3] = this.vertexArray[5]), g.syncUniforms(), f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer), 
        f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer), 
        f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer), 
        f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer), 
        f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), this.renderSession.drawCount++;
    }, b.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var a = this.gl;
        this.vertexBuffer = a.createBuffer(), this.uvBuffer = a.createBuffer(), this.colorBuffer = a.createBuffer(), 
        this.indexBuffer = a.createBuffer(), this.vertexArray = new b.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]), 
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW), 
        this.uvArray = new b.Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), 
        a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW), this.colorArray = new b.Float32Array([ 1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215 ]), 
        a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer), a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW), 
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([ 0, 1, 2, 1, 3, 2 ]), a.STATIC_DRAW);
    }, b.WebGLFilterManager.prototype.destroy = function() {
        var a = this.gl;
        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
        for (var b = 0; b < this.texturePool.length; b++) this.texturePool[b].destroy();
        this.texturePool = null, a.deleteBuffer(this.vertexBuffer), a.deleteBuffer(this.uvBuffer), 
        a.deleteBuffer(this.colorBuffer), a.deleteBuffer(this.indexBuffer);
    }, b.FilterTexture = function(a, c, d, e) {
        this.gl = a, this.frameBuffer = a.createFramebuffer(), this.texture = a.createTexture(), 
        e = e || b.scaleModes.DEFAULT, a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), 
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), 
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 
        a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), 
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0), 
        this.renderBuffer = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer), 
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this.renderBuffer), 
        this.resize(c, d);
    }, b.FilterTexture.prototype.constructor = b.FilterTexture, b.FilterTexture.prototype.clear = function() {
        var a = this.gl;
        a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT);
    }, b.FilterTexture.prototype.resize = function(a, b) {
        if (this.width !== a || this.height !== b) {
            this.width = a, this.height = b;
            var c = this.gl;
            c.bindTexture(c.TEXTURE_2D, this.texture), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null), 
            c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b);
        }
    }, b.FilterTexture.prototype.destroy = function() {
        var a = this.gl;
        a.deleteFramebuffer(this.frameBuffer), a.deleteTexture(this.texture), this.frameBuffer = null, 
        this.texture = null;
    }, b.CanvasBuffer = function(a, b) {
        this.width = a, this.height = b, this.canvas = document.createElement("canvas"), 
        this.context = this.canvas.getContext("2d"), this.canvas.width = a, this.canvas.height = b;
    }, b.CanvasBuffer.prototype.constructor = b.CanvasBuffer, b.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height);
    }, b.CanvasBuffer.prototype.resize = function(a, b) {
        this.width = this.canvas.width = a, this.height = this.canvas.height = b;
    }, b.CanvasMaskManager = function() {}, b.CanvasMaskManager.prototype.constructor = b.CanvasMaskManager, 
    b.CanvasMaskManager.prototype.pushMask = function(a, c) {
        var d = c.context;
        d.save();
        var e = a.alpha, f = a.worldTransform, g = c.resolution;
        d.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g), b.CanvasGraphics.renderGraphicsMask(a, d), 
        d.clip(), a.worldAlpha = e;
    }, b.CanvasMaskManager.prototype.popMask = function(a) {
        a.context.restore();
    }, b.CanvasTinter = function() {}, b.CanvasTinter.getTintedTexture = function(a, c) {
        var d = a.texture;
        c = b.CanvasTinter.roundColor(c);
        var e = "#" + ("00000" + (0 | c).toString(16)).substr(-6);
        if (d.tintCache = d.tintCache || {}, d.tintCache[e]) return d.tintCache[e];
        var f = b.CanvasTinter.canvas || document.createElement("canvas");
        if (b.CanvasTinter.tintMethod(d, c, f), b.CanvasTinter.convertTintToImage) {
            var g = new Image();
            g.src = f.toDataURL(), d.tintCache[e] = g;
        } else d.tintCache[e] = f, b.CanvasTinter.canvas = null;
        return f;
    }, b.CanvasTinter.tintWithMultiply = function(a, b, c) {
        var d = c.getContext("2d"), e = a.crop;
        c.width = e.width, c.height = e.height, d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6), 
        d.fillRect(0, 0, e.width, e.height), d.globalCompositeOperation = "multiply", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height), 
        d.globalCompositeOperation = "destination-atop", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
    }, b.CanvasTinter.tintWithOverlay = function(a, b, c) {
        var d = c.getContext("2d"), e = a.crop;
        c.width = e.width, c.height = e.height, d.globalCompositeOperation = "copy", d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6), 
        d.fillRect(0, 0, e.width, e.height), d.globalCompositeOperation = "destination-atop", 
        d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
    }, b.CanvasTinter.tintWithPerPixel = function(a, c, d) {
        var e = d.getContext("2d"), f = a.crop;
        d.width = f.width, d.height = f.height, e.globalCompositeOperation = "copy", e.drawImage(a.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
        for (var g = b.hex2rgb(c), h = g[0], i = g[1], j = g[2], k = e.getImageData(0, 0, f.width, f.height), l = k.data, m = 0; m < l.length; m += 4) l[m + 0] *= h, 
        l[m + 1] *= i, l[m + 2] *= j;
        e.putImageData(k, 0, 0);
    }, b.CanvasTinter.roundColor = function(a) {
        var c = b.CanvasTinter.cacheStepsPerColorChannel, d = b.hex2rgb(a);
        return d[0] = Math.min(255, d[0] / c * c), d[1] = Math.min(255, d[1] / c * c), d[2] = Math.min(255, d[2] / c * c), 
        b.rgb2hex(d);
    }, b.CanvasTinter.cacheStepsPerColorChannel = 8, b.CanvasTinter.convertTintToImage = !1, 
    b.CanvasTinter.canUseMultiply = b.canUseNewCanvasBlendModes(), b.CanvasTinter.tintMethod = b.CanvasTinter.canUseMultiply ? b.CanvasTinter.tintWithMultiply : b.CanvasTinter.tintWithPerPixel, 
    b.CanvasRenderer = function(a, c, d) {
        if (d) for (var e in b.defaultRenderOptions) "undefined" == typeof d[e] && (d[e] = b.defaultRenderOptions[e]); else d = b.defaultRenderOptions;
        b.defaultRenderer || (b.sayHello("Canvas"), b.defaultRenderer = this), this.type = b.CANVAS_RENDERER, 
        this.resolution = d.resolution, this.clearBeforeRender = d.clearBeforeRender, this.transparent = d.transparent, 
        this.autoResize = d.autoResize || !1, this.width = a || 800, this.height = c || 600, 
        this.width *= this.resolution, this.height *= this.resolution, this.view = d.view || document.createElement("canvas"), 
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }), this.refresh = !0, this.view.width = this.width * this.resolution, this.view.height = this.height * this.resolution, 
        this.count = 0, this.maskManager = new b.CanvasMaskManager(), this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: null,
            roundPixels: !1
        }, this.mapBlendModes(), this.resize(a, c), "imageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "imageSmoothingEnabled" : "webkitImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "webkitImageSmoothingEnabled" : "mozImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "mozImageSmoothingEnabled" : "oImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "oImageSmoothingEnabled" : "msImageSmoothingEnabled" in this.context && (this.renderSession.smoothProperty = "msImageSmoothingEnabled");
    }, b.CanvasRenderer.prototype.constructor = b.CanvasRenderer, b.CanvasRenderer.prototype.render = function(a) {
        a.updateTransform(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, 
        this.renderSession.currentBlendMode = b.blendModes.NORMAL, this.context.globalCompositeOperation = b.blendModesCanvas[b.blendModes.NORMAL], 
        navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", 
        this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : (this.context.fillStyle = a.backgroundColorString, 
        this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(a), 
        a.interactive && (a._interactiveEventsAdded || (a._interactiveEventsAdded = !0, 
        a.interactionManager.setTarget(this)));
    }, b.CanvasRenderer.prototype.destroy = function(a) {
        "undefined" == typeof a && (a = !0), a && this.view.parent && this.view.parent.removeChild(this.view), 
        this.view = null, this.context = null, this.maskManager = null, this.renderSession = null;
    }, b.CanvasRenderer.prototype.resize = function(a, b) {
        this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, 
        this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", 
        this.view.style.height = this.height / this.resolution + "px");
    }, b.CanvasRenderer.prototype.renderDisplayObject = function(a, b) {
        this.renderSession.context = b || this.context, this.renderSession.resolution = this.resolution, 
        a._renderCanvas(this.renderSession);
    }, b.CanvasRenderer.prototype.mapBlendModes = function() {
        b.blendModesCanvas || (b.blendModesCanvas = [], b.canUseNewCanvasBlendModes() ? (b.blendModesCanvas[b.blendModes.NORMAL] = "source-over", 
        b.blendModesCanvas[b.blendModes.ADD] = "lighter", b.blendModesCanvas[b.blendModes.MULTIPLY] = "multiply", 
        b.blendModesCanvas[b.blendModes.SCREEN] = "screen", b.blendModesCanvas[b.blendModes.OVERLAY] = "overlay", 
        b.blendModesCanvas[b.blendModes.DARKEN] = "darken", b.blendModesCanvas[b.blendModes.LIGHTEN] = "lighten", 
        b.blendModesCanvas[b.blendModes.COLOR_DODGE] = "color-dodge", b.blendModesCanvas[b.blendModes.COLOR_BURN] = "color-burn", 
        b.blendModesCanvas[b.blendModes.HARD_LIGHT] = "hard-light", b.blendModesCanvas[b.blendModes.SOFT_LIGHT] = "soft-light", 
        b.blendModesCanvas[b.blendModes.DIFFERENCE] = "difference", b.blendModesCanvas[b.blendModes.EXCLUSION] = "exclusion", 
        b.blendModesCanvas[b.blendModes.HUE] = "hue", b.blendModesCanvas[b.blendModes.SATURATION] = "saturation", 
        b.blendModesCanvas[b.blendModes.COLOR] = "color", b.blendModesCanvas[b.blendModes.LUMINOSITY] = "luminosity") : (b.blendModesCanvas[b.blendModes.NORMAL] = "source-over", 
        b.blendModesCanvas[b.blendModes.ADD] = "lighter", b.blendModesCanvas[b.blendModes.MULTIPLY] = "source-over", 
        b.blendModesCanvas[b.blendModes.SCREEN] = "source-over", b.blendModesCanvas[b.blendModes.OVERLAY] = "source-over", 
        b.blendModesCanvas[b.blendModes.DARKEN] = "source-over", b.blendModesCanvas[b.blendModes.LIGHTEN] = "source-over", 
        b.blendModesCanvas[b.blendModes.COLOR_DODGE] = "source-over", b.blendModesCanvas[b.blendModes.COLOR_BURN] = "source-over", 
        b.blendModesCanvas[b.blendModes.HARD_LIGHT] = "source-over", b.blendModesCanvas[b.blendModes.SOFT_LIGHT] = "source-over", 
        b.blendModesCanvas[b.blendModes.DIFFERENCE] = "source-over", b.blendModesCanvas[b.blendModes.EXCLUSION] = "source-over", 
        b.blendModesCanvas[b.blendModes.HUE] = "source-over", b.blendModesCanvas[b.blendModes.SATURATION] = "source-over", 
        b.blendModesCanvas[b.blendModes.COLOR] = "source-over", b.blendModesCanvas[b.blendModes.LUMINOSITY] = "source-over"));
    }, b.CanvasGraphics = function() {}, b.CanvasGraphics.renderGraphics = function(a, c) {
        var d = a.worldAlpha;
        a.dirty && (this.updateGraphicsTint(a), a.dirty = !1);
        for (var e = 0; e < a.graphicsData.length; e++) {
            var f = a.graphicsData[e], g = f.shape, h = f._fillTint, i = f._lineTint;
            if (c.lineWidth = f.lineWidth, f.type === b.Graphics.POLY) {
                c.beginPath();
                var j = g.points;
                c.moveTo(j[0], j[1]);
                for (var k = 1; k < j.length / 2; k++) c.lineTo(j[2 * k], j[2 * k + 1]);
                g.closed && c.lineTo(j[0], j[1]), j[0] === j[j.length - 2] && j[1] === j[j.length - 1] && c.closePath(), 
                f.fill && (c.globalAlpha = f.fillAlpha * d, c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), 
                c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), 
                c.stroke());
            } else if (f.type === b.Graphics.RECT) (f.fillColor || 0 === f.fillColor) && (c.globalAlpha = f.fillAlpha * d, 
            c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), c.fillRect(g.x, g.y, g.width, g.height)), 
            f.lineWidth && (c.globalAlpha = f.lineAlpha * d, c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), 
            c.strokeRect(g.x, g.y, g.width, g.height)); else if (f.type === b.Graphics.CIRC) c.beginPath(), 
            c.arc(g.x, g.y, g.radius, 0, 2 * Math.PI), c.closePath(), f.fill && (c.globalAlpha = f.fillAlpha * d, 
            c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, 
            c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), c.stroke()); else if (f.type === b.Graphics.ELIP) {
                var l = 2 * g.width, m = 2 * g.height, n = g.x - l / 2, o = g.y - m / 2;
                c.beginPath();
                var p = .5522848, q = l / 2 * p, r = m / 2 * p, s = n + l, t = o + m, u = n + l / 2, v = o + m / 2;
                c.moveTo(n, v), c.bezierCurveTo(n, v - r, u - q, o, u, o), c.bezierCurveTo(u + q, o, s, v - r, s, v), 
                c.bezierCurveTo(s, v + r, u + q, t, u, t), c.bezierCurveTo(u - q, t, n, v + r, n, v), 
                c.closePath(), f.fill && (c.globalAlpha = f.fillAlpha * d, c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), 
                c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), 
                c.stroke());
            } else if (f.type === b.Graphics.RREC) {
                var w = g.x, x = g.y, y = g.width, z = g.height, A = g.radius, B = Math.min(y, z) / 2 | 0;
                A = A > B ? B : A, c.beginPath(), c.moveTo(w, x + A), c.lineTo(w, x + z - A), c.quadraticCurveTo(w, x + z, w + A, x + z), 
                c.lineTo(w + y - A, x + z), c.quadraticCurveTo(w + y, x + z, w + y, x + z - A), 
                c.lineTo(w + y, x + A), c.quadraticCurveTo(w + y, x, w + y - A, x), c.lineTo(w + A, x), 
                c.quadraticCurveTo(w, x, w, x + A), c.closePath(), (f.fillColor || 0 === f.fillColor) && (c.globalAlpha = f.fillAlpha * d, 
                c.fillStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), c.fill()), f.lineWidth && (c.globalAlpha = f.lineAlpha * d, 
                c.strokeStyle = "#" + ("00000" + (0 | i).toString(16)).substr(-6), c.stroke());
            }
        }
    }, b.CanvasGraphics.renderGraphicsMask = function(a, c) {
        var d = a.graphicsData.length;
        if (0 !== d) {
            d > 1 && (d = 1, window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object"));
            for (var e = 0; 1 > e; e++) {
                var f = a.graphicsData[e], g = f.shape;
                if (f.type === b.Graphics.POLY) {
                    c.beginPath();
                    var h = g.points;
                    c.moveTo(h[0], h[1]);
                    for (var i = 1; i < h.length / 2; i++) c.lineTo(h[2 * i], h[2 * i + 1]);
                    h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && c.closePath();
                } else if (f.type === b.Graphics.RECT) c.beginPath(), c.rect(g.x, g.y, g.width, g.height), 
                c.closePath(); else if (f.type === b.Graphics.CIRC) c.beginPath(), c.arc(g.x, g.y, g.radius, 0, 2 * Math.PI), 
                c.closePath(); else if (f.type === b.Graphics.ELIP) {
                    var j = 2 * g.width, k = 2 * g.height, l = g.x - j / 2, m = g.y - k / 2;
                    c.beginPath();
                    var n = .5522848, o = j / 2 * n, p = k / 2 * n, q = l + j, r = m + k, s = l + j / 2, t = m + k / 2;
                    c.moveTo(l, t), c.bezierCurveTo(l, t - p, s - o, m, s, m), c.bezierCurveTo(s + o, m, q, t - p, q, t), 
                    c.bezierCurveTo(q, t + p, s + o, r, s, r), c.bezierCurveTo(s - o, r, l, t + p, l, t), 
                    c.closePath();
                } else if (f.type === b.Graphics.RREC) {
                    var u = g.points, v = u[0], w = u[1], x = u[2], y = u[3], z = u[4], A = Math.min(x, y) / 2 | 0;
                    z = z > A ? A : z, c.beginPath(), c.moveTo(v, w + z), c.lineTo(v, w + y - z), c.quadraticCurveTo(v, w + y, v + z, w + y), 
                    c.lineTo(v + x - z, w + y), c.quadraticCurveTo(v + x, w + y, v + x, w + y - z), 
                    c.lineTo(v + x, w + z), c.quadraticCurveTo(v + x, w, v + x - z, w), c.lineTo(v + z, w), 
                    c.quadraticCurveTo(v, w, v, w + z), c.closePath();
                }
            }
        }
    }, b.CanvasGraphics.updateGraphicsTint = function(a) {
        if (16777215 !== a.tint) for (var b = (a.tint >> 16 & 255) / 255, c = (a.tint >> 8 & 255) / 255, d = (255 & a.tint) / 255, e = 0; e < a.graphicsData.length; e++) {
            var f = a.graphicsData[e], g = 0 | f.fillColor, h = 0 | f.lineColor;
            f._fillTint = ((g >> 16 & 255) / 255 * b * 255 << 16) + ((g >> 8 & 255) / 255 * c * 255 << 8) + (255 & g) / 255 * d * 255, 
            f._lineTint = ((h >> 16 & 255) / 255 * b * 255 << 16) + ((h >> 8 & 255) / 255 * c * 255 << 8) + (255 & h) / 255 * d * 255;
        }
    }, b.Graphics = function() {
        b.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, 
        this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = b.blendModes.NORMAL, 
        this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, 
        this._localBounds = new b.Rectangle(0, 0, 1, 1), this.dirty = !0, this.webGLDirty = !1, 
        this.cachedSpriteDirty = !1;
    }, b.Graphics.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Graphics.prototype.constructor = b.Graphics, 
    Object.defineProperty(b.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(a) {
            this._cacheAsBitmap = a, this._cacheAsBitmap ? this._generateCachedSprite() : (this.destroyCachedSprite(), 
            this.dirty = !0);
        }
    }), b.Graphics.prototype.lineStyle = function(a, c, d) {
        if (this.lineWidth = a || 0, this.lineColor = c || 0, this.lineAlpha = void 0 === d ? 1 : d, 
        this.currentPath) {
            if (this.currentPath.shape.points.length) return this.drawShape(new b.Polygon(this.currentPath.shape.points.slice(-2))), 
            this;
            this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, 
            this.currentPath.lineAlpha = this.lineAlpha;
        }
        return this;
    }, b.Graphics.prototype.moveTo = function(a, c) {
        return this.drawShape(new b.Polygon([ a, c ])), this;
    }, b.Graphics.prototype.lineTo = function(a, b) {
        return this.currentPath.shape.points.push(a, b), this.dirty = !0, this;
    }, b.Graphics.prototype.quadraticCurveTo = function(a, b, c, d) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [ 0, 0 ]) : this.moveTo(0, 0);
        var e, f, g = 20, h = this.currentPath.shape.points;
        0 === h.length && this.moveTo(0, 0);
        for (var i = h[h.length - 2], j = h[h.length - 1], k = 0, l = 1; g >= l; l++) k = l / g, 
        e = i + (a - i) * k, f = j + (b - j) * k, h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
        return this.dirty = !0, this;
    }, b.Graphics.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [ 0, 0 ]) : this.moveTo(0, 0);
        for (var g, h, i, j, k, l = 20, m = this.currentPath.shape.points, n = m[m.length - 2], o = m[m.length - 1], p = 0, q = 1; l >= q; q++) p = q / l, 
        g = 1 - p, h = g * g, i = h * g, j = p * p, k = j * p, m.push(i * n + 3 * h * p * a + 3 * g * j * c + k * e, i * o + 3 * h * p * b + 3 * g * j * d + k * f);
        return this.dirty = !0, this;
    }, b.Graphics.prototype.arcTo = function(a, b, c, d, e) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(a, b) : this.moveTo(a, b);
        var f = this.currentPath.shape.points, g = f[f.length - 2], h = f[f.length - 1], i = h - b, j = g - a, k = d - b, l = c - a, m = Math.abs(i * l - j * k);
        if (1e-8 > m || 0 === e) (f[f.length - 2] !== a || f[f.length - 1] !== b) && f.push(a, b); else {
            var n = i * i + j * j, o = k * k + l * l, p = i * k + j * l, q = e * Math.sqrt(n) / m, r = e * Math.sqrt(o) / m, s = q * p / n, t = r * p / o, u = q * l + r * j, v = q * k + r * i, w = j * (r + s), x = i * (r + s), y = l * (q + t), z = k * (q + t), A = Math.atan2(x - v, w - u), B = Math.atan2(z - v, y - u);
            this.arc(u + a, v + b, e, A, B, j * k > l * i);
        }
        return this.dirty = !0, this;
    }, b.Graphics.prototype.arc = function(a, b, c, d, e, f) {
        if (f = f || !1, d === e) return this;
        !f && d >= e ? e += 2 * Math.PI : f && e >= d && (d += 2 * Math.PI);
        var g = f ? -1 * (d - e) : e - d, h = Math.abs(g) / (2 * Math.PI) * 40;
        if (0 === g) return this;
        var i = a + Math.cos(d) * c, j = b + Math.sin(d) * c;
        f && this.filling ? this.moveTo(a, b) : this.moveTo(i, j);
        for (var k = this.currentPath.shape.points, l = g / (2 * h), m = 2 * l, n = Math.cos(l), o = Math.sin(l), p = h - 1, q = p % 1 / p, r = 0; p >= r; r++) {
            var s = r + q * r, t = l + d + m * s, u = Math.cos(t), v = -Math.sin(t);
            k.push((n * u + o * v) * c + a, (n * -v + o * u) * c + b);
        }
        return this.dirty = !0, this;
    }, b.Graphics.prototype.beginFill = function(a, b) {
        return this.filling = !0, this.fillColor = a || 0, this.fillAlpha = void 0 === b ? 1 : b, 
        this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, 
        this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), 
        this;
    }, b.Graphics.prototype.endFill = function() {
        return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this;
    }, b.Graphics.prototype.drawRect = function(a, c, d, e) {
        return this.drawShape(new b.Rectangle(a, c, d, e)), this;
    }, b.Graphics.prototype.drawRoundedRect = function(a, c, d, e, f) {
        return this.drawShape(new b.RoundedRectangle(a, c, d, e, f)), this;
    }, b.Graphics.prototype.drawCircle = function(a, c, d) {
        return this.drawShape(new b.Circle(a, c, d)), this;
    }, b.Graphics.prototype.drawEllipse = function(a, c, d, e) {
        return this.drawShape(new b.Ellipse(a, c, d, e)), this;
    }, b.Graphics.prototype.drawPolygon = function(a) {
        return a instanceof Array || (a = Array.prototype.slice.call(arguments)), this.drawShape(new b.Polygon(a)), 
        this;
    }, b.Graphics.prototype.clear = function() {
        return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this.clearDirty = !0, 
        this.graphicsData = [], this;
    }, b.Graphics.prototype.generateTexture = function(a, c) {
        a = a || 1;
        var d = this.getBounds(), e = new b.CanvasBuffer(d.width * a, d.height * a), f = b.Texture.fromCanvas(e.canvas, c);
        return f.baseTexture.resolution = a, e.context.scale(a, a), e.context.translate(-d.x, -d.y), 
        b.CanvasGraphics.renderGraphics(this, e.context), f;
    }, b.Graphics.prototype._renderWebGL = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), 
            this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), 
            this._cachedSprite.worldAlpha = this.worldAlpha, void b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
            if (a.spriteBatch.stop(), a.blendModeManager.setBlendMode(this.blendMode), this._mask && a.maskManager.pushMask(this._mask, a), 
            this._filters && a.filterManager.pushFilter(this._filterBlock), this.blendMode !== a.spriteBatch.currentBlendMode) {
                a.spriteBatch.currentBlendMode = this.blendMode;
                var c = b.blendModesWebGL[a.spriteBatch.currentBlendMode];
                a.spriteBatch.gl.blendFunc(c[0], c[1]);
            }
            if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), b.WebGLGraphics.renderGraphics(this, a), 
            this.children.length) {
                a.spriteBatch.start();
                for (var d = 0, e = this.children.length; e > d; d++) this.children[d]._renderWebGL(a);
                a.spriteBatch.stop();
            }
            this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this.mask, a), 
            a.drawCount++, a.spriteBatch.start();
        }
    }, b.Graphics.prototype._renderCanvas = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), 
            this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), 
            this._cachedSprite.alpha = this.alpha, void b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
            var c = a.context, d = this.worldTransform;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]), 
            this._mask && a.maskManager.pushMask(this._mask, a);
            var e = a.resolution;
            c.setTransform(d.a * e, d.b * e, d.c * e, d.d * e, d.tx * e, d.ty * e), b.CanvasGraphics.renderGraphics(this, c);
            for (var f = 0, g = this.children.length; g > f; f++) this.children[f]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a);
        }
    }, b.Graphics.prototype.getBounds = function(a) {
        if (this.isMask) return b.EmptyRectangle;
        this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, 
        this.dirty = !1);
        var c = this._localBounds, d = c.x, e = c.width + c.x, f = c.y, g = c.height + c.y, h = a || this.worldTransform, i = h.a, j = h.b, k = h.c, l = h.d, m = h.tx, n = h.ty, o = i * e + k * g + m, p = l * g + j * e + n, q = i * d + k * g + m, r = l * g + j * d + n, s = i * d + k * f + m, t = l * f + j * d + n, u = i * e + k * f + m, v = l * f + j * e + n, w = o, x = p, y = o, z = p;
        return y = y > q ? q : y, y = y > s ? s : y, y = y > u ? u : y, z = z > r ? r : z, 
        z = z > t ? t : z, z = z > v ? v : z, w = q > w ? q : w, w = s > w ? s : w, w = u > w ? u : w, 
        x = r > x ? r : x, x = t > x ? t : x, x = v > x ? v : x, this._bounds.x = y, this._bounds.width = w - y, 
        this._bounds.y = z, this._bounds.height = x - z, this._bounds;
    }, b.Graphics.prototype.updateLocalBounds = function() {
        var a = 1 / 0, c = -(1 / 0), d = 1 / 0, e = -(1 / 0);
        if (this.graphicsData.length) for (var f, g, h, i, j, k, l = 0; l < this.graphicsData.length; l++) {
            var m = this.graphicsData[l], n = m.type, o = m.lineWidth;
            if (f = m.shape, n === b.Graphics.RECT || n === b.Graphics.RREC) h = f.x - o / 2, 
            i = f.y - o / 2, j = f.width + o, k = f.height + o, a = a > h ? h : a, c = h + j > c ? h + j : c, 
            d = d > i ? i : d, e = i + k > e ? i + k : e; else if (n === b.Graphics.CIRC) h = f.x, 
            i = f.y, j = f.radius + o / 2, k = f.radius + o / 2, a = a > h - j ? h - j : a, 
            c = h + j > c ? h + j : c, d = d > i - k ? i - k : d, e = i + k > e ? i + k : e; else if (n === b.Graphics.ELIP) h = f.x, 
            i = f.y, j = f.width + o / 2, k = f.height + o / 2, a = a > h - j ? h - j : a, c = h + j > c ? h + j : c, 
            d = d > i - k ? i - k : d, e = i + k > e ? i + k : e; else {
                g = f.points;
                for (var p = 0; p < g.length; p += 2) h = g[p], i = g[p + 1], a = a > h - o ? h - o : a, 
                c = h + o > c ? h + o : c, d = d > i - o ? i - o : d, e = i + o > e ? i + o : e;
            }
        } else a = 0, c = 0, d = 0, e = 0;
        var q = this.boundsPadding;
        this._localBounds.x = a - q, this._localBounds.width = c - a + 2 * q, this._localBounds.y = d - q, 
        this._localBounds.height = e - d + 2 * q;
    }, b.Graphics.prototype._generateCachedSprite = function() {
        var a = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.buffer.resize(a.width, a.height); else {
            var c = new b.CanvasBuffer(a.width, a.height), d = b.Texture.fromCanvas(c.canvas);
            this._cachedSprite = new b.Sprite(d), this._cachedSprite.buffer = c, this._cachedSprite.worldTransform = this.worldTransform;
        }
        this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), 
        this._cachedSprite.buffer.context.translate(-a.x, -a.y), this.worldAlpha = 1, b.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), 
        this._cachedSprite.alpha = this.alpha;
    }, b.Graphics.prototype.updateCachedSpriteTexture = function() {
        var a = this._cachedSprite, b = a.texture, c = a.buffer.canvas;
        b.baseTexture.width = c.width, b.baseTexture.height = c.height, b.crop.width = b.frame.width = c.width, 
        b.crop.height = b.frame.height = c.height, a._width = c.width, a._height = c.height, 
        b.baseTexture.dirty();
    }, b.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(!0), this._cachedSprite = null;
    }, b.Graphics.prototype.drawShape = function(a) {
        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), 
        this.currentPath = null;
        var c = new b.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, a);
        return this.graphicsData.push(c), c.type === b.Graphics.POLY && (c.shape.closed = this.filling, 
        this.currentPath = c), this.dirty = !0, c;
    }, b.GraphicsData = function(a, b, c, d, e, f, g) {
        this.lineWidth = a, this.lineColor = b, this.lineAlpha = c, this._lineTint = b, 
        this.fillColor = d, this.fillAlpha = e, this._fillTint = d, this.fill = f, this.shape = g, 
        this.type = g.type;
    }, b.Graphics.POLY = 0, b.Graphics.RECT = 1, b.Graphics.CIRC = 2, b.Graphics.ELIP = 3, 
    b.Graphics.RREC = 4, b.Polygon.prototype.type = b.Graphics.POLY, b.Rectangle.prototype.type = b.Graphics.RECT, 
    b.Circle.prototype.type = b.Graphics.CIRC, b.Ellipse.prototype.type = b.Graphics.ELIP, 
    b.RoundedRectangle.prototype.type = b.Graphics.RREC, b.Strip = function(a) {
        b.DisplayObjectContainer.call(this), this.texture = a, this.uvs = new b.Float32Array([ 0, 1, 1, 1, 1, 0, 0, 1 ]), 
        this.vertices = new b.Float32Array([ 0, 0, 100, 0, 100, 100, 0, 100 ]), this.colors = new b.Float32Array([ 1, 1, 1, 1 ]), 
        this.indices = new b.Uint16Array([ 0, 1, 2, 3 ]), this.dirty = !0, this.blendMode = b.blendModes.NORMAL, 
        this.canvasPadding = 0, this.drawMode = b.Strip.DrawModes.TRIANGLE_STRIP;
    }, b.Strip.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Strip.prototype.constructor = b.Strip, 
    b.Strip.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || (a.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(a), 
        a.shaderManager.setShader(a.shaderManager.stripShader), this._renderStrip(a), a.spriteBatch.start());
    }, b.Strip.prototype._initWebGL = function(a) {
        var b = a.gl;
        this._vertexBuffer = b.createBuffer(), this._indexBuffer = b.createBuffer(), this._uvBuffer = b.createBuffer(), 
        this._colorBuffer = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer), 
        b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer), 
        b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer), 
        b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer), 
        b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW);
    }, b.Strip.prototype._renderStrip = function(a) {
        var c = a.gl, d = a.projection, e = a.offset, f = a.shaderManager.stripShader, g = this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? c.TRIANGLE_STRIP : c.TRIANGLES;
        a.blendModeManager.setBlendMode(this.blendMode), c.uniformMatrix3fv(f.translationMatrix, !1, this.worldTransform.toArray(!0)), 
        c.uniform2f(f.projectionVector, d.x, -d.y), c.uniform2f(f.offsetVector, -e.x, -e.y), 
        c.uniform1f(f.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), 
        c.bufferData(c.ARRAY_BUFFER, this.vertices, c.STATIC_DRAW), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), 
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.bufferData(c.ARRAY_BUFFER, this.uvs, c.STATIC_DRAW), 
        c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), c.activeTexture(c.TEXTURE0), 
        this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), 
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, this.indices, c.STATIC_DRAW)) : (c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), 
        c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), 
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), 
        c.activeTexture(c.TEXTURE0), this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), 
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), c.drawElements(g, this.indices.length, c.UNSIGNED_SHORT, 0);
    }, b.Strip.prototype._renderCanvas = function(a) {
        var c = a.context, d = this.worldTransform;
        a.roundPixels ? c.setTransform(d.a, d.b, d.c, d.d, 0 | d.tx, 0 | d.ty) : c.setTransform(d.a, d.b, d.c, d.d, d.tx, d.ty), 
        this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(c) : this._renderCanvasTriangles(c);
    }, b.Strip.prototype._renderCanvasTriangleStrip = function(a) {
        var b = this.vertices, c = this.uvs, d = b.length / 2;
        this.count++;
        for (var e = 0; d - 2 > e; e++) {
            var f = 2 * e;
            this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4);
        }
    }, b.Strip.prototype._renderCanvasTriangles = function(a) {
        var b = this.vertices, c = this.uvs, d = this.indices, e = d.length;
        this.count++;
        for (var f = 0; e > f; f += 3) {
            var g = 2 * d[f], h = 2 * d[f + 1], i = 2 * d[f + 2];
            this._renderCanvasDrawTriangle(a, b, c, g, h, i);
        }
    }, b.Strip.prototype._renderCanvasDrawTriangle = function(a, b, c, d, e, f) {
        var g = this.texture.baseTexture.source, h = this.texture.width, i = this.texture.height, j = b[d], k = b[e], l = b[f], m = b[d + 1], n = b[e + 1], o = b[f + 1], p = c[d] * h, q = c[e] * h, r = c[f] * h, s = c[d + 1] * i, t = c[e + 1] * i, u = c[f + 1] * i;
        if (this.canvasPadding > 0) {
            var v = this.canvasPadding / this.worldTransform.a, w = this.canvasPadding / this.worldTransform.d, x = (j + k + l) / 3, y = (m + n + o) / 3, z = j - x, A = m - y, B = Math.sqrt(z * z + A * A);
            j = x + z / B * (B + v), m = y + A / B * (B + w), z = k - x, A = n - y, B = Math.sqrt(z * z + A * A), 
            k = x + z / B * (B + v), n = y + A / B * (B + w), z = l - x, A = o - y, B = Math.sqrt(z * z + A * A), 
            l = x + z / B * (B + v), o = y + A / B * (B + w);
        }
        a.save(), a.beginPath(), a.moveTo(j, m), a.lineTo(k, n), a.lineTo(l, o), a.closePath(), 
        a.clip();
        var C = p * t + s * r + q * u - t * r - s * q - p * u, D = j * t + s * l + k * u - t * l - s * k - j * u, E = p * k + j * r + q * l - k * r - j * q - p * l, F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u, G = m * t + s * o + n * u - t * o - s * n - m * u, H = p * n + m * r + q * o - n * r - m * q - p * o, I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
        a.transform(D / C, G / C, E / C, H / C, F / C, I / C), a.drawImage(g, 0, 0), a.restore();
    }, b.Strip.prototype.renderStripFlat = function(a) {
        var b = this.context, c = a.vertices, d = c.length / 2;
        this.count++, b.beginPath();
        for (var e = 1; d - 2 > e; e++) {
            var f = 2 * e, g = c[f], h = c[f + 2], i = c[f + 4], j = c[f + 1], k = c[f + 3], l = c[f + 5];
            b.moveTo(g, j), b.lineTo(h, k), b.lineTo(i, l);
        }
        b.fillStyle = "#FF0000", b.fill(), b.closePath();
    }, b.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = !0;
    }, b.Strip.prototype.getBounds = function(a) {
        for (var c = a || this.worldTransform, d = c.a, e = c.b, f = c.c, g = c.d, h = c.tx, i = c.ty, j = -(1 / 0), k = -(1 / 0), l = 1 / 0, m = 1 / 0, n = this.vertices, o = 0, p = n.length; p > o; o += 2) {
            var q = n[o], r = n[o + 1], s = d * q + f * r + h, t = g * r + e * q + i;
            l = l > s ? s : l, m = m > t ? t : m, j = s > j ? s : j, k = t > k ? t : k;
        }
        if (l === -(1 / 0) || k === 1 / 0) return b.EmptyRectangle;
        var u = this._bounds;
        return u.x = l, u.width = j - l, u.y = m, u.height = k - m, this._currentBounds = u, 
        u;
    }, b.Strip.DrawModes = {
        TRIANGLE_STRIP: 0,
        TRIANGLES: 1
    }, b.Rope = function(a, c) {
        b.Strip.call(this, a), this.points = c, this.vertices = new b.Float32Array(4 * c.length), 
        this.uvs = new b.Float32Array(4 * c.length), this.colors = new b.Float32Array(2 * c.length), 
        this.indices = new b.Uint16Array(2 * c.length), this.refresh();
    }, b.Rope.prototype = Object.create(b.Strip.prototype), b.Rope.prototype.constructor = b.Rope, 
    b.Rope.prototype.refresh = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var b = this.uvs, c = a[0], d = this.indices, e = this.colors;
            this.count -= .2, b[0] = 0, b[1] = 0, b[2] = 0, b[3] = 1, e[0] = 1, e[1] = 1, d[0] = 0, 
            d[1] = 1;
            for (var f, g, h, i = a.length, j = 1; i > j; j++) f = a[j], g = 4 * j, h = j / (i - 1), 
            j % 2 ? (b[g] = h, b[g + 1] = 0, b[g + 2] = h, b[g + 3] = 1) : (b[g] = h, b[g + 1] = 0, 
            b[g + 2] = h, b[g + 3] = 1), g = 2 * j, e[g] = 1, e[g + 1] = 1, g = 2 * j, d[g] = g, 
            d[g + 1] = g + 1, c = f;
        }
    }, b.Rope.prototype.updateTransform = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var c, d = a[0], e = {
                x: 0,
                y: 0
            };
            this.count -= .2;
            for (var f, g, h, i, j, k = this.vertices, l = a.length, m = 0; l > m; m++) f = a[m], 
            g = 4 * m, c = m < a.length - 1 ? a[m + 1] : f, e.y = -(c.x - d.x), e.x = c.y - d.y, 
            h = 10 * (1 - m / (l - 1)), h > 1 && (h = 1), i = Math.sqrt(e.x * e.x + e.y * e.y), 
            j = this.texture.height / 2, e.x /= i, e.y /= i, e.x *= j, e.y *= j, k[g] = f.x + e.x, 
            k[g + 1] = f.y + e.y, k[g + 2] = f.x - e.x, k[g + 3] = f.y - e.y, d = f;
            b.DisplayObjectContainer.prototype.updateTransform.call(this);
        }
    }, b.Rope.prototype.setTexture = function(a) {
        this.texture = a;
    }, b.TilingSprite = function(a, c, d) {
        b.Sprite.call(this, a), this._width = c || 100, this._height = d || 100, this.tileScale = new b.Point(1, 1), 
        this.tileScaleOffset = new b.Point(1, 1), this.tilePosition = new b.Point(0, 0), 
        this.renderable = !0, this.tint = 16777215, this.blendMode = b.blendModes.NORMAL;
    }, b.TilingSprite.prototype = Object.create(b.Sprite.prototype), b.TilingSprite.prototype.constructor = b.TilingSprite, 
    Object.defineProperty(b.TilingSprite.prototype, "width", {
        get: function() {
            return this._width;
        },
        set: function(a) {
            this._width = a;
        }
    }), Object.defineProperty(b.TilingSprite.prototype, "height", {
        get: function() {
            return this._height;
        },
        set: function(a) {
            this._height = a;
        }
    }), b.TilingSprite.prototype.setTexture = function(a) {
        this.texture !== a && (this.texture = a, this.refreshTexture = !0, this.cachedTint = 16777215);
    }, b.TilingSprite.prototype._renderWebGL = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha) {
            var b, c;
            for (this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), 
            a.spriteBatch.start()), this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), 
            !this.tilingTexture || this.refreshTexture ? (this.generateTilingTexture(!0), this.tilingTexture && this.tilingTexture.needsUpdate && (a.renderer.updateTexture(this.tilingTexture.baseTexture), 
            this.tilingTexture.needsUpdate = !1)) : a.spriteBatch.renderTilingSprite(this), 
            b = 0, c = this.children.length; c > b; b++) this.children[b]._renderWebGL(a);
            a.spriteBatch.stop(), this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this._mask, a), 
            a.spriteBatch.start();
        }
    }, b.TilingSprite.prototype._renderCanvas = function(a) {
        if (this.visible !== !1 && 0 !== this.alpha) {
            var c = a.context;
            this._mask && a.maskManager.pushMask(this._mask, a), c.globalAlpha = this.worldAlpha;
            var d, e, f = this.worldTransform, g = a.resolution;
            if (c.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g), !this.__tilePattern || this.refreshTexture) {
                if (this.generateTilingTexture(!1), !this.tilingTexture) return;
                this.__tilePattern = c.createPattern(this.tilingTexture.baseTexture.source, "repeat");
            }
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]);
            var h = this.tilePosition, i = this.tileScale;
            for (h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, 
            c.scale(i.x, i.y), c.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), 
            c.fillStyle = this.__tilePattern, c.fillRect(-h.x, -h.y, this._width / i.x, this._height / i.y), 
            c.scale(1 / i.x, 1 / i.y), c.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), 
            this._mask && a.maskManager.popMask(a), d = 0, e = this.children.length; e > d; d++) this.children[d]._renderCanvas(a);
        }
    }, b.TilingSprite.prototype.getBounds = function() {
        var a = this._width, b = this._height, c = a * (1 - this.anchor.x), d = a * -this.anchor.x, e = b * (1 - this.anchor.y), f = b * -this.anchor.y, g = this.worldTransform, h = g.a, i = g.b, j = g.c, k = g.d, l = g.tx, m = g.ty, n = h * d + j * f + l, o = k * f + i * d + m, p = h * c + j * f + l, q = k * f + i * c + m, r = h * c + j * e + l, s = k * e + i * c + m, t = h * d + j * e + l, u = k * e + i * d + m, v = -(1 / 0), w = -(1 / 0), x = 1 / 0, y = 1 / 0;
        x = x > n ? n : x, x = x > p ? p : x, x = x > r ? r : x, x = x > t ? t : x, y = y > o ? o : y, 
        y = y > q ? q : y, y = y > s ? s : y, y = y > u ? u : y, v = n > v ? n : v, v = p > v ? p : v, 
        v = r > v ? r : v, v = t > v ? t : v, w = o > w ? o : w, w = q > w ? q : w, w = s > w ? s : w, 
        w = u > w ? u : w;
        var z = this._bounds;
        return z.x = x, z.width = v - x, z.y = y, z.height = w - y, this._currentBounds = z, 
        z;
    }, b.TilingSprite.prototype.onTextureUpdate = function() {}, b.TilingSprite.prototype.generateTilingTexture = function(a) {
        if (this.texture.baseTexture.hasLoaded) {
            var c, d, e = this.originalTexture || this.texture, f = e.frame, g = f.width !== e.baseTexture.width || f.height !== e.baseTexture.height, h = !1;
            if (a ? (c = b.getNextPowerOfTwo(f.width), d = b.getNextPowerOfTwo(f.height), (f.width !== c || f.height !== d || e.baseTexture.width !== c || e.baseTexture.height || d) && (h = !0)) : g && (e.trim ? (c = e.trim.width, 
            d = e.trim.height) : (c = f.width, d = f.height), h = !0), h) {
                var i;
                this.tilingTexture && this.tilingTexture.isTiling ? (i = this.tilingTexture.canvasBuffer, 
                i.resize(c, d), this.tilingTexture.baseTexture.width = c, this.tilingTexture.baseTexture.height = d, 
                this.tilingTexture.needsUpdate = !0) : (i = new b.CanvasBuffer(c, d), this.tilingTexture = b.Texture.fromCanvas(i.canvas), 
                this.tilingTexture.canvasBuffer = i, this.tilingTexture.isTiling = !0), i.context.drawImage(e.baseTexture.source, e.crop.x, e.crop.y, e.crop.width, e.crop.height, 0, 0, c, d), 
                this.tileScaleOffset.x = f.width / c, this.tileScaleOffset.y = f.height / d;
            } else this.tilingTexture && this.tilingTexture.isTiling && this.tilingTexture.destroy(!0), 
            this.tileScaleOffset.x = 1, this.tileScaleOffset.y = 1, this.tilingTexture = e;
            this.refreshTexture = !1, this.originalTexture = this.texture, this.texture = this.tilingTexture, 
            this.tilingTexture.baseTexture._powerOf2 = !0;
        }
    }, b.TilingSprite.prototype.destroy = function() {
        b.Sprite.prototype.destroy.call(this), this.tileScale = null, this.tileScaleOffset = null, 
        this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), 
        this.tilingTexture = null);
    };
    var c = {
        radDeg: 180 / Math.PI,
        degRad: Math.PI / 180,
        temp: [],
        Float32Array: "undefined" == typeof Float32Array ? Array : Float32Array,
        Uint16Array: "undefined" == typeof Uint16Array ? Array : Uint16Array
    };
    c.BoneData = function(a, b) {
        this.name = a, this.parent = b;
    }, c.BoneData.prototype = {
        length: 0,
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        inheritScale: !0,
        inheritRotation: !0,
        flipX: !1,
        flipY: !1
    }, c.SlotData = function(a, b) {
        this.name = a, this.boneData = b;
    }, c.SlotData.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        attachmentName: null,
        additiveBlending: !1
    }, c.IkConstraintData = function(a) {
        this.name = a, this.bones = [];
    }, c.IkConstraintData.prototype = {
        target: null,
        bendDirection: 1,
        mix: 1
    }, c.Bone = function(a, b, c) {
        this.data = a, this.skeleton = b, this.parent = c, this.setToSetupPose();
    }, c.Bone.yDown = !1, c.Bone.prototype = {
        x: 0,
        y: 0,
        rotation: 0,
        rotationIK: 0,
        scaleX: 1,
        scaleY: 1,
        flipX: !1,
        flipY: !1,
        m00: 0,
        m01: 0,
        worldX: 0,
        m10: 0,
        m11: 0,
        worldY: 0,
        worldRotation: 0,
        worldScaleX: 1,
        worldScaleY: 1,
        worldFlipX: !1,
        worldFlipY: !1,
        updateWorldTransform: function() {
            var a = this.parent;
            if (a) this.worldX = this.x * a.m00 + this.y * a.m01 + a.worldX, this.worldY = this.x * a.m10 + this.y * a.m11 + a.worldY, 
            this.data.inheritScale ? (this.worldScaleX = a.worldScaleX * this.scaleX, this.worldScaleY = a.worldScaleY * this.scaleY) : (this.worldScaleX = this.scaleX, 
            this.worldScaleY = this.scaleY), this.worldRotation = this.data.inheritRotation ? a.worldRotation + this.rotationIK : this.rotationIK, 
            this.worldFlipX = a.worldFlipX != this.flipX, this.worldFlipY = a.worldFlipY != this.flipY; else {
                var b = this.skeleton.flipX, d = this.skeleton.flipY;
                this.worldX = b ? -this.x : this.x, this.worldY = d != c.Bone.yDown ? -this.y : this.y, 
                this.worldScaleX = this.scaleX, this.worldScaleY = this.scaleY, this.worldRotation = this.rotationIK, 
                this.worldFlipX = b != this.flipX, this.worldFlipY = d != this.flipY;
            }
            var e = this.worldRotation * c.degRad, f = Math.cos(e), g = Math.sin(e);
            this.worldFlipX ? (this.m00 = -f * this.worldScaleX, this.m01 = g * this.worldScaleY) : (this.m00 = f * this.worldScaleX, 
            this.m01 = -g * this.worldScaleY), this.worldFlipY != c.Bone.yDown ? (this.m10 = -g * this.worldScaleX, 
            this.m11 = -f * this.worldScaleY) : (this.m10 = g * this.worldScaleX, this.m11 = f * this.worldScaleY);
        },
        setToSetupPose: function() {
            var a = this.data;
            this.x = a.x, this.y = a.y, this.rotation = a.rotation, this.rotationIK = this.rotation, 
            this.scaleX = a.scaleX, this.scaleY = a.scaleY, this.flipX = a.flipX, this.flipY = a.flipY;
        },
        worldToLocal: function(a) {
            var b = a[0] - this.worldX, d = a[1] - this.worldY, e = this.m00, f = this.m10, g = this.m01, h = this.m11;
            this.worldFlipX != (this.worldFlipY != c.Bone.yDown) && (e = -e, h = -h);
            var i = 1 / (e * h - g * f);
            a[0] = b * e * i - d * g * i, a[1] = d * h * i - b * f * i;
        },
        localToWorld: function(a) {
            var b = a[0], c = a[1];
            a[0] = b * this.m00 + c * this.m01 + this.worldX, a[1] = b * this.m10 + c * this.m11 + this.worldY;
        }
    }, c.Slot = function(a, b) {
        this.data = a, this.bone = b, this.setToSetupPose();
    }, c.Slot.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        _attachmentTime: 0,
        attachment: null,
        attachmentVertices: [],
        setAttachment: function(a) {
            this.attachment = a, this._attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0;
        },
        setAttachmentTime: function(a) {
            this._attachmentTime = this.bone.skeleton.time - a;
        },
        getAttachmentTime: function() {
            return this.bone.skeleton.time - this._attachmentTime;
        },
        setToSetupPose: function() {
            var a = this.data;
            this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a;
            for (var b = this.bone.skeleton.data.slots, c = 0, d = b.length; d > c; c++) if (b[c] == a) {
                this.setAttachment(a.attachmentName ? this.bone.skeleton.getAttachmentBySlotIndex(c, a.attachmentName) : null);
                break;
            }
        }
    }, c.IkConstraint = function(a, b) {
        this.data = a, this.mix = a.mix, this.bendDirection = a.bendDirection, this.bones = [];
        for (var c = 0, d = a.bones.length; d > c; c++) this.bones.push(b.findBone(a.bones[c].name));
        this.target = b.findBone(a.target.name);
    }, c.IkConstraint.prototype = {
        apply: function() {
            var a = this.target, b = this.bones;
            switch (b.length) {
              case 1:
                c.IkConstraint.apply1(b[0], a.worldX, a.worldY, this.mix);
                break;

              case 2:
                c.IkConstraint.apply2(b[0], b[1], a.worldX, a.worldY, this.bendDirection, this.mix);
            }
        }
    }, c.IkConstraint.apply1 = function(a, b, d, e) {
        var f = a.data.inheritRotation && a.parent ? a.parent.worldRotation : 0, g = a.rotation, h = Math.atan2(d - a.worldY, b - a.worldX) * c.radDeg - f;
        a.rotationIK = g + (h - g) * e;
    }, c.IkConstraint.apply2 = function(a, b, d, e, f, g) {
        var h = b.rotation, i = a.rotation;
        if (!g) return b.rotationIK = h, void (a.rotationIK = i);
        var j, k, l = c.temp, m = a.parent;
        m ? (l[0] = d, l[1] = e, m.worldToLocal(l), d = (l[0] - a.x) * m.worldScaleX, e = (l[1] - a.y) * m.worldScaleY) : (d -= a.x, 
        e -= a.y), b.parent == a ? (j = b.x, k = b.y) : (l[0] = b.x, l[1] = b.y, b.parent.localToWorld(l), 
        a.worldToLocal(l), j = l[0], k = l[1]);
        var n = j * a.worldScaleX, o = k * a.worldScaleY, p = Math.atan2(o, n), q = Math.sqrt(n * n + o * o), r = b.data.length * b.worldScaleX, s = 2 * q * r;
        if (1e-4 > s) return void (b.rotationIK = h + (Math.atan2(e, d) * c.radDeg - i - h) * g);
        var t = (d * d + e * e - q * q - r * r) / s;
        -1 > t ? t = -1 : t > 1 && (t = 1);
        var u = Math.acos(t) * f, v = q + r * t, w = r * Math.sin(u), x = Math.atan2(e * v - d * w, d * v + e * w), y = (x - p) * c.radDeg - i;
        y > 180 ? y -= 360 : -180 > y && (y += 360), a.rotationIK = i + y * g, y = (u + p) * c.radDeg - h, 
        y > 180 ? y -= 360 : -180 > y && (y += 360), b.rotationIK = h + (y + a.worldRotation - b.parent.worldRotation) * g;
    }, c.Skin = function(a) {
        this.name = a, this.attachments = {};
    }, c.Skin.prototype = {
        addAttachment: function(a, b, c) {
            this.attachments[a + ":" + b] = c;
        },
        getAttachment: function(a, b) {
            return this.attachments[a + ":" + b];
        },
        _attachAll: function(a, b) {
            for (var c in b.attachments) {
                var d = c.indexOf(":"), e = parseInt(c.substring(0, d)), f = c.substring(d + 1), g = a.slots[e];
                if (g.attachment && g.attachment.name == f) {
                    var h = this.getAttachment(e, f);
                    h && g.setAttachment(h);
                }
            }
        }
    }, c.Animation = function(a, b, c) {
        this.name = a, this.timelines = b, this.duration = c;
    }, c.Animation.prototype = {
        apply: function(a, b, c, d, e) {
            d && 0 != this.duration && (c %= this.duration, b %= this.duration);
            for (var f = this.timelines, g = 0, h = f.length; h > g; g++) f[g].apply(a, b, c, e, 1);
        },
        mix: function(a, b, c, d, e, f) {
            d && 0 != this.duration && (c %= this.duration, b %= this.duration);
            for (var g = this.timelines, h = 0, i = g.length; i > h; h++) g[h].apply(a, b, c, e, f);
        }
    }, c.Animation.binarySearch = function(a, b, c) {
        var d = 0, e = Math.floor(a.length / c) - 2;
        if (!e) return c;
        for (var f = e >>> 1; ;) {
            if (a[(f + 1) * c] <= b ? d = f + 1 : e = f, d == e) return (d + 1) * c;
            f = d + e >>> 1;
        }
    }, c.Animation.binarySearch1 = function(a, b) {
        var c = 0, d = a.length - 2;
        if (!d) return 1;
        for (var e = d >>> 1; ;) {
            if (a[e + 1] <= b ? c = e + 1 : d = e, c == d) return c + 1;
            e = c + d >>> 1;
        }
    }, c.Animation.linearSearch = function(a, b, c) {
        for (var d = 0, e = a.length - c; e >= d; d += c) if (a[d] > b) return d;
        return -1;
    }, c.Curves = function(a) {
        this.curves = [];
    }, c.Curves.prototype = {
        setLinear: function(a) {
            this.curves[19 * a] = 0;
        },
        setStepped: function(a) {
            this.curves[19 * a] = 1;
        },
        setCurve: function(a, b, c, d, e) {
            var f = .1, g = f * f, h = g * f, i = 3 * f, j = 3 * g, k = 6 * g, l = 6 * h, m = 2 * -b + d, n = 2 * -c + e, o = 3 * (b - d) + 1, p = 3 * (c - e) + 1, q = b * i + m * j + o * h, r = c * i + n * j + p * h, s = m * k + o * l, t = n * k + p * l, u = o * l, v = p * l, w = 19 * a, x = this.curves;
            x[w++] = 2;
            for (var y = q, z = r, A = w + 19 - 1; A > w; w += 2) x[w] = y, x[w + 1] = z, q += s, 
            r += t, s += u, t += v, y += q, z += r;
        },
        getCurvePercent: function(a, b) {
            b = 0 > b ? 0 : b > 1 ? 1 : b;
            var c = this.curves, d = 19 * a, e = c[d];
            if (0 === e) return b;
            if (1 == e) return 0;
            d++;
            for (var f = 0, g = d, h = d + 19 - 1; h > d; d += 2) if (f = c[d], f >= b) {
                var i, j;
                return d == g ? (i = 0, j = 0) : (i = c[d - 2], j = c[d - 1]), j + (c[d + 1] - j) * (b - i) / (f - i);
            }
            var k = c[d - 1];
            return k + (1 - k) * (b - f) / (1 - f);
        }
    }, c.RotateTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = 2 * a;
    }, c.RotateTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 2;
        },
        setFrame: function(a, b, c) {
            a *= 2, this.frames[a] = b, this.frames[a + 1] = c;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (!(d < g[0])) {
                var h = a.bones[this.boneIndex];
                if (d >= g[g.length - 2]) {
                    for (var i = h.data.rotation + g[g.length - 1] - h.rotation; i > 180; ) i -= 360;
                    for (;-180 > i; ) i += 360;
                    return void (h.rotation += i * f);
                }
                var j = c.Animation.binarySearch(g, d, 2), k = g[j - 1], l = g[j], m = 1 - (d - l) / (g[j - 2] - l);
                m = this.curves.getCurvePercent(j / 2 - 1, m);
                for (var i = g[j + 1] - k; i > 180; ) i -= 360;
                for (;-180 > i; ) i += 360;
                for (i = h.data.rotation + (k + i * m) - h.rotation; i > 180; ) i -= 360;
                for (;-180 > i; ) i += 360;
                h.rotation += i * f;
            }
        }
    }, c.TranslateTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = 3 * a;
    }, c.TranslateTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 3;
        },
        setFrame: function(a, b, c, d) {
            a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (!(d < g[0])) {
                var h = a.bones[this.boneIndex];
                if (d >= g[g.length - 3]) return h.x += (h.data.x + g[g.length - 2] - h.x) * f, 
                void (h.y += (h.data.y + g[g.length - 1] - h.y) * f);
                var i = c.Animation.binarySearch(g, d, 3), j = g[i - 2], k = g[i - 1], l = g[i], m = 1 - (d - l) / (g[i + -3] - l);
                m = this.curves.getCurvePercent(i / 3 - 1, m), h.x += (h.data.x + j + (g[i + 1] - j) * m - h.x) * f, 
                h.y += (h.data.y + k + (g[i + 2] - k) * m - h.y) * f;
            }
        }
    }, c.ScaleTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = 3 * a;
    }, c.ScaleTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 3;
        },
        setFrame: function(a, b, c, d) {
            a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (!(d < g[0])) {
                var h = a.bones[this.boneIndex];
                if (d >= g[g.length - 3]) return h.scaleX += (h.data.scaleX * g[g.length - 2] - h.scaleX) * f, 
                void (h.scaleY += (h.data.scaleY * g[g.length - 1] - h.scaleY) * f);
                var i = c.Animation.binarySearch(g, d, 3), j = g[i - 2], k = g[i - 1], l = g[i], m = 1 - (d - l) / (g[i + -3] - l);
                m = this.curves.getCurvePercent(i / 3 - 1, m), h.scaleX += (h.data.scaleX * (j + (g[i + 1] - j) * m) - h.scaleX) * f, 
                h.scaleY += (h.data.scaleY * (k + (g[i + 2] - k) * m) - h.scaleY) * f;
            }
        }
    }, c.ColorTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = 5 * a;
    }, c.ColorTimeline.prototype = {
        slotIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 5;
        },
        setFrame: function(a, b, c, d, e, f) {
            a *= 5, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d, this.frames[a + 3] = e, 
            this.frames[a + 4] = f;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (!(d < g[0])) {
                var h, i, j, k;
                if (d >= g[g.length - 5]) {
                    var l = g.length - 1;
                    h = g[l - 3], i = g[l - 2], j = g[l - 1], k = g[l];
                } else {
                    var m = c.Animation.binarySearch(g, d, 5), n = g[m - 4], o = g[m - 3], p = g[m - 2], q = g[m - 1], r = g[m], s = 1 - (d - r) / (g[m - 5] - r);
                    s = this.curves.getCurvePercent(m / 5 - 1, s), h = n + (g[m + 1] - n) * s, i = o + (g[m + 2] - o) * s, 
                    j = p + (g[m + 3] - p) * s, k = q + (g[m + 4] - q) * s;
                }
                var t = a.slots[this.slotIndex];
                1 > f ? (t.r += (h - t.r) * f, t.g += (i - t.g) * f, t.b += (j - t.b) * f, t.a += (k - t.a) * f) : (t.r = h, 
                t.g = i, t.b = j, t.a = k);
            }
        }
    }, c.AttachmentTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = a, this.attachmentNames = [], 
        this.attachmentNames.length = a;
    }, c.AttachmentTimeline.prototype = {
        slotIndex: 0,
        getFrameCount: function() {
            return this.frames.length;
        },
        setFrame: function(a, b, c) {
            this.frames[a] = b, this.attachmentNames[a] = c;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (d < g[0]) return void (b > d && this.apply(a, b, Number.MAX_VALUE, null, 0));
            b > d && (b = -1);
            var h = d >= g[g.length - 1] ? g.length - 1 : c.Animation.binarySearch1(g, d) - 1;
            if (!(g[h] < b)) {
                var i = this.attachmentNames[h];
                a.slots[this.slotIndex].setAttachment(i ? a.getAttachmentBySlotIndex(this.slotIndex, i) : null);
            }
        }
    }, c.EventTimeline = function(a) {
        this.frames = [], this.frames.length = a, this.events = [], this.events.length = a;
    }, c.EventTimeline.prototype = {
        getFrameCount: function() {
            return this.frames.length;
        },
        setFrame: function(a, b, c) {
            this.frames[a] = b, this.events[a] = c;
        },
        apply: function(a, b, d, e, f) {
            if (e) {
                var g = this.frames, h = g.length;
                if (b > d) this.apply(a, b, Number.MAX_VALUE, e, f), b = -1; else if (b >= g[h - 1]) return;
                if (!(d < g[0])) {
                    var i;
                    if (b < g[0]) i = 0; else {
                        i = c.Animation.binarySearch1(g, b);
                        for (var j = g[i]; i > 0 && g[i - 1] == j; ) i--;
                    }
                    for (var k = this.events; h > i && d >= g[i]; i++) e.push(k[i]);
                }
            }
        }
    }, c.DrawOrderTimeline = function(a) {
        this.frames = [], this.frames.length = a, this.drawOrders = [], this.drawOrders.length = a;
    }, c.DrawOrderTimeline.prototype = {
        getFrameCount: function() {
            return this.frames.length;
        },
        setFrame: function(a, b, c) {
            this.frames[a] = b, this.drawOrders[a] = c;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (!(d < g[0])) {
                var h;
                h = d >= g[g.length - 1] ? g.length - 1 : c.Animation.binarySearch1(g, d) - 1;
                var i = a.drawOrder, j = (a.slots, this.drawOrders[h]);
                if (j) for (var k = 0, l = j.length; l > k; k++) i[k] = j[k];
            }
        }
    }, c.FfdTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = a, this.frameVertices = [], 
        this.frameVertices.length = a;
    }, c.FfdTimeline.prototype = {
        slotIndex: 0,
        attachment: 0,
        getFrameCount: function() {
            return this.frames.length;
        },
        setFrame: function(a, b, c) {
            this.frames[a] = b, this.frameVertices[a] = c;
        },
        apply: function(a, b, d, e, f) {
            var g = a.slots[this.slotIndex];
            if (g.attachment == this.attachment) {
                var h = this.frames;
                if (!(d < h[0])) {
                    var i = this.frameVertices, j = i[0].length, k = g.attachmentVertices;
                    if (k.length != j && (f = 1), k.length = j, d >= h[h.length - 1]) {
                        var l = i[h.length - 1];
                        if (1 > f) for (var m = 0; j > m; m++) k[m] += (l[m] - k[m]) * f; else for (var m = 0; j > m; m++) k[m] = l[m];
                    } else {
                        var n = c.Animation.binarySearch1(h, d), o = h[n], p = 1 - (d - o) / (h[n - 1] - o);
                        p = this.curves.getCurvePercent(n - 1, 0 > p ? 0 : p > 1 ? 1 : p);
                        var q = i[n - 1], r = i[n];
                        if (1 > f) for (var m = 0; j > m; m++) {
                            var s = q[m];
                            k[m] += (s + (r[m] - s) * p - k[m]) * f;
                        } else for (var m = 0; j > m; m++) {
                            var s = q[m];
                            k[m] = s + (r[m] - s) * p;
                        }
                    }
                }
            }
        }
    }, c.IkConstraintTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = 3 * a;
    }, c.IkConstraintTimeline.prototype = {
        ikConstraintIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 3;
        },
        setFrame: function(a, b, c, d) {
            a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (!(d < g[0])) {
                var h = a.ikConstraints[this.ikConstraintIndex];
                if (d >= g[g.length - 3]) return h.mix += (g[g.length - 2] - h.mix) * f, void (h.bendDirection = g[g.length - 1]);
                var i = c.Animation.binarySearch(g, d, 3), j = g[i + -2], k = g[i], l = 1 - (d - k) / (g[i + -3] - k);
                l = this.curves.getCurvePercent(i / 3 - 1, l);
                var m = j + (g[i + 1] - j) * l;
                h.mix += (m - h.mix) * f, h.bendDirection = g[i + -1];
            }
        }
    }, c.FlipXTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = 2 * a;
    }, c.FlipXTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 2;
        },
        setFrame: function(a, b, c) {
            a *= 2, this.frames[a] = b, this.frames[a + 1] = c ? 1 : 0;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (d < g[0]) return void (b > d && this.apply(a, b, Number.MAX_VALUE, null, 0));
            b > d && (b = -1);
            var h = (d >= g[g.length - 2] ? g.length : c.Animation.binarySearch(g, d, 2)) - 2;
            g[h] < b || (a.bones[this.boneIndex].flipX = 0 != g[h + 1]);
        }
    }, c.FlipYTimeline = function(a) {
        this.curves = new c.Curves(a), this.frames = [], this.frames.length = 2 * a;
    }, c.FlipYTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 2;
        },
        setFrame: function(a, b, c) {
            a *= 2, this.frames[a] = b, this.frames[a + 1] = c ? 1 : 0;
        },
        apply: function(a, b, d, e, f) {
            var g = this.frames;
            if (d < g[0]) return void (b > d && this.apply(a, b, Number.MAX_VALUE, null, 0));
            b > d && (b = -1);
            var h = (d >= g[g.length - 2] ? g.length : c.Animation.binarySearch(g, d, 2)) - 2;
            g[h] < b || (a.bones[this.boneIndex].flipY = 0 != g[h + 1]);
        }
    }, c.SkeletonData = function() {
        this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], 
        this.ikConstraints = [];
    }, c.SkeletonData.prototype = {
        name: null,
        defaultSkin: null,
        width: 0,
        height: 0,
        version: null,
        hash: null,
        findBone: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
            return null;
        },
        findBoneIndex: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return c;
            return -1;
        },
        findSlot: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return slot[c];
            return null;
        },
        findSlotIndex: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return c;
            return -1;
        },
        findSkin: function(a) {
            for (var b = this.skins, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
            return null;
        },
        findEvent: function(a) {
            for (var b = this.events, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
            return null;
        },
        findAnimation: function(a) {
            for (var b = this.animations, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
            return null;
        },
        findIkConstraint: function(a) {
            for (var b = this.ikConstraints, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
            return null;
        }
    }, c.Skeleton = function(a) {
        this.data = a, this.bones = [];
        for (var b = 0, d = a.bones.length; d > b; b++) {
            var e = a.bones[b], f = e.parent ? this.bones[a.bones.indexOf(e.parent)] : null;
            this.bones.push(new c.Bone(e, this, f));
        }
        this.slots = [], this.drawOrder = [];
        for (var b = 0, d = a.slots.length; d > b; b++) {
            var g = a.slots[b], h = this.bones[a.bones.indexOf(g.boneData)], i = new c.Slot(g, h);
            this.slots.push(i), this.drawOrder.push(b);
        }
        this.ikConstraints = [];
        for (var b = 0, d = a.ikConstraints.length; d > b; b++) this.ikConstraints.push(new c.IkConstraint(a.ikConstraints[b], this));
        this.boneCache = [], this.updateCache();
    }, c.Skeleton.prototype = {
        x: 0,
        y: 0,
        skin: null,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        time: 0,
        flipX: !1,
        flipY: !1,
        updateCache: function() {
            var a = this.ikConstraints, b = a.length, c = b + 1, d = this.boneCache;
            d.length > c && (d.length = c);
            for (var e = 0, f = d.length; f > e; e++) d[e].length = 0;
            for (;d.length < c; ) d[d.length] = [];
            var g = d[0], h = this.bones;
            a: for (var e = 0, f = h.length; f > e; e++) {
                var i = h[e], j = i;
                do {
                    for (var k = 0; b > k; k++) for (var l = a[k], m = l.bones[0], n = l.bones[l.bones.length - 1]; ;) {
                        if (j == n) {
                            d[k].push(i), d[k + 1].push(i);
                            continue a;
                        }
                        if (n == m) break;
                        n = n.parent;
                    }
                    j = j.parent;
                } while (j);
                g[g.length] = i;
            }
        },
        updateWorldTransform: function() {
            for (var a = this.bones, b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                d.rotationIK = d.rotation;
            }
            for (var b = 0, e = this.boneCache.length - 1; ;) {
                for (var f = this.boneCache[b], g = 0, h = f.length; h > g; g++) f[g].updateWorldTransform();
                if (b == e) break;
                this.ikConstraints[b].apply(), b++;
            }
        },
        setToSetupPose: function() {
            this.setBonesToSetupPose(), this.setSlotsToSetupPose();
        },
        setBonesToSetupPose: function() {
            for (var a = this.bones, b = 0, c = a.length; c > b; b++) a[b].setToSetupPose();
            for (var d = this.ikConstraints, b = 0, c = d.length; c > b; b++) {
                var e = d[b];
                e.bendDirection = e.data.bendDirection, e.mix = e.data.mix;
            }
        },
        setSlotsToSetupPose: function() {
            for (var a = this.slots, b = 0, c = a.length; c > b; b++) a[b].setToSetupPose(b);
            this.resetDrawOrder();
        },
        getRootBone: function() {
            return this.bones.length ? this.bones[0] : null;
        },
        findBone: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return b[c];
            return null;
        },
        findBoneIndex: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return c;
            return -1;
        },
        findSlot: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return b[c];
            return null;
        },
        findSlotIndex: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return c;
            return -1;
        },
        setSkinByName: function(a) {
            var b = this.data.findSkin(a);
            if (!b) throw "Skin not found: " + a;
            this.setSkin(b);
        },
        setSkin: function(a) {
            if (a) if (this.skin) a._attachAll(this, this.skin); else for (var b = this.slots, c = 0, d = b.length; d > c; c++) {
                var e = b[c], f = e.data.attachmentName;
                if (f) {
                    var g = a.getAttachment(c, f);
                    g && e.setAttachment(g);
                }
            }
            this.skin = a;
        },
        getAttachmentBySlotName: function(a, b) {
            return this.getAttachmentBySlotIndex(this.data.findSlotIndex(a), b);
        },
        getAttachmentBySlotIndex: function(a, b) {
            if (this.skin) {
                var c = this.skin.getAttachment(a, b);
                if (c) return c;
            }
            return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, b) : null;
        },
        setAttachment: function(a, b) {
            for (var c = this.slots, d = 0, e = c.length; e > d; d++) {
                var f = c[d];
                if (f.data.name == a) {
                    var g = null;
                    if (b && (g = this.getAttachmentBySlotIndex(d, b), !g)) throw "Attachment not found: " + b + ", for slot: " + a;
                    return void f.setAttachment(g);
                }
            }
            throw "Slot not found: " + a;
        },
        findIkConstraint: function(a) {
            for (var b = this.ikConstraints, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return b[c];
            return null;
        },
        update: function(a) {
            this.time += a;
        },
        resetDrawOrder: function() {
            for (var a = 0, b = this.drawOrder.length; b > a; a++) this.drawOrder[a] = a;
        }
    }, c.EventData = function(a) {
        this.name = a;
    }, c.EventData.prototype = {
        intValue: 0,
        floatValue: 0,
        stringValue: null
    }, c.Event = function(a) {
        this.data = a;
    }, c.Event.prototype = {
        intValue: 0,
        floatValue: 0,
        stringValue: null
    }, c.AttachmentType = {
        region: 0,
        boundingbox: 1,
        mesh: 2,
        skinnedmesh: 3
    }, c.RegionAttachment = function(a) {
        this.name = a, this.offset = [], this.offset.length = 8, this.uvs = [], this.uvs.length = 8;
    }, c.RegionAttachment.prototype = {
        type: c.AttachmentType.region,
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        width: 0,
        height: 0,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        path: null,
        rendererObject: null,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        setUVs: function(a, b, c, d, e) {
            var f = this.uvs;
            e ? (f[2] = a, f[3] = d, f[4] = a, f[5] = b, f[6] = c, f[7] = b, f[0] = c, f[1] = d) : (f[0] = a, 
            f[1] = d, f[2] = a, f[3] = b, f[4] = c, f[5] = b, f[6] = c, f[7] = d);
        },
        updateOffset: function() {
            var a = this.width / this.regionOriginalWidth * this.scaleX, b = this.height / this.regionOriginalHeight * this.scaleY, d = -this.width / 2 * this.scaleX + this.regionOffsetX * a, e = -this.height / 2 * this.scaleY + this.regionOffsetY * b, f = d + this.regionWidth * a, g = e + this.regionHeight * b, h = this.rotation * c.degRad, i = Math.cos(h), j = Math.sin(h), k = d * i + this.x, l = d * j, m = e * i + this.y, n = e * j, o = f * i + this.x, p = f * j, q = g * i + this.y, r = g * j, s = this.offset;
            s[0] = k - n, s[1] = m + l, s[2] = k - r, s[3] = q + l, s[4] = o - r, s[5] = q + p, 
            s[6] = o - n, s[7] = m + p;
        },
        computeVertices: function(a, b, c, d) {
            a += c.worldX, b += c.worldY;
            var e = c.m00, f = c.m01, g = c.m10, h = c.m11, i = this.offset;
            d[0] = i[0] * e + i[1] * f + a, d[1] = i[0] * g + i[1] * h + b, d[2] = i[2] * e + i[3] * f + a, 
            d[3] = i[2] * g + i[3] * h + b, d[4] = i[4] * e + i[5] * f + a, d[5] = i[4] * g + i[5] * h + b, 
            d[6] = i[6] * e + i[7] * f + a, d[7] = i[6] * g + i[7] * h + b;
        }
    }, c.MeshAttachment = function(a) {
        this.name = a;
    }, c.MeshAttachment.prototype = {
        type: c.AttachmentType.mesh,
        vertices: null,
        uvs: null,
        regionUVs: null,
        triangles: null,
        hullLength: 0,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        path: null,
        rendererObject: null,
        regionU: 0,
        regionV: 0,
        regionU2: 0,
        regionV2: 0,
        regionRotate: !1,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        edges: null,
        width: 0,
        height: 0,
        updateUVs: function() {
            var a = this.regionU2 - this.regionU, b = this.regionV2 - this.regionV, d = this.regionUVs.length;
            if (this.uvs && this.uvs.length == d || (this.uvs = new c.Float32Array(d)), this.regionRotate) for (var e = 0; d > e; e += 2) this.uvs[e] = this.regionU + this.regionUVs[e + 1] * a, 
            this.uvs[e + 1] = this.regionV + b - this.regionUVs[e] * b; else for (var e = 0; d > e; e += 2) this.uvs[e] = this.regionU + this.regionUVs[e] * a, 
            this.uvs[e + 1] = this.regionV + this.regionUVs[e + 1] * b;
        },
        computeWorldVertices: function(a, b, c, d) {
            var e = c.bone;
            a += e.worldX, b += e.worldY;
            var f = e.m00, g = e.m01, h = e.m10, i = e.m11, j = this.vertices, k = j.length;
            c.attachmentVertices.length == k && (j = c.attachmentVertices);
            for (var l = 0; k > l; l += 2) {
                var m = j[l], n = j[l + 1];
                d[l] = m * f + n * g + a, d[l + 1] = m * h + n * i + b;
            }
        }
    }, c.SkinnedMeshAttachment = function(a) {
        this.name = a;
    }, c.SkinnedMeshAttachment.prototype = {
        type: c.AttachmentType.skinnedmesh,
        bones: null,
        weights: null,
        uvs: null,
        regionUVs: null,
        triangles: null,
        hullLength: 0,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        path: null,
        rendererObject: null,
        regionU: 0,
        regionV: 0,
        regionU2: 0,
        regionV2: 0,
        regionRotate: !1,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        edges: null,
        width: 0,
        height: 0,
        updateUVs: function(a, b, d, e, f) {
            var g = this.regionU2 - this.regionU, h = this.regionV2 - this.regionV, i = this.regionUVs.length;
            if (this.uvs && this.uvs.length == i || (this.uvs = new c.Float32Array(i)), this.regionRotate) for (var j = 0; i > j; j += 2) this.uvs[j] = this.regionU + this.regionUVs[j + 1] * g, 
            this.uvs[j + 1] = this.regionV + h - this.regionUVs[j] * h; else for (var j = 0; i > j; j += 2) this.uvs[j] = this.regionU + this.regionUVs[j] * g, 
            this.uvs[j + 1] = this.regionV + this.regionUVs[j + 1] * h;
        },
        computeWorldVertices: function(a, b, c, d) {
            var e, f, g, h, i, j, k, l = c.bone.skeleton.bones, m = this.weights, n = this.bones, o = 0, p = 0, q = 0, r = 0, s = n.length;
            if (c.attachmentVertices.length) for (var t = c.attachmentVertices; s > p; o += 2) {
                for (f = 0, g = 0, e = n[p++] + p; e > p; p++, q += 3, r += 2) h = l[n[p]], i = m[q] + t[r], 
                j = m[q + 1] + t[r + 1], k = m[q + 2], f += (i * h.m00 + j * h.m01 + h.worldX) * k, 
                g += (i * h.m10 + j * h.m11 + h.worldY) * k;
                d[o] = f + a, d[o + 1] = g + b;
            } else for (;s > p; o += 2) {
                for (f = 0, g = 0, e = n[p++] + p; e > p; p++, q += 3) h = l[n[p]], i = m[q], j = m[q + 1], 
                k = m[q + 2], f += (i * h.m00 + j * h.m01 + h.worldX) * k, g += (i * h.m10 + j * h.m11 + h.worldY) * k;
                d[o] = f + a, d[o + 1] = g + b;
            }
        }
    }, c.BoundingBoxAttachment = function(a) {
        this.name = a, this.vertices = [];
    }, c.BoundingBoxAttachment.prototype = {
        type: c.AttachmentType.boundingbox,
        computeWorldVertices: function(a, b, c, d) {
            a += c.worldX, b += c.worldY;
            for (var e = c.m00, f = c.m01, g = c.m10, h = c.m11, i = this.vertices, j = 0, k = i.length; k > j; j += 2) {
                var l = i[j], m = i[j + 1];
                d[j] = l * e + m * f + a, d[j + 1] = l * g + m * h + b;
            }
        }
    }, c.AnimationStateData = function(a) {
        this.skeletonData = a, this.animationToMixTime = {};
    }, c.AnimationStateData.prototype = {
        defaultMix: 0,
        setMixByName: function(a, b, c) {
            var d = this.skeletonData.findAnimation(a);
            if (!d) throw "Animation not found: " + a;
            var e = this.skeletonData.findAnimation(b);
            if (!e) throw "Animation not found: " + b;
            this.setMix(d, e, c);
        },
        setMix: function(a, b, c) {
            this.animationToMixTime[a.name + ":" + b.name] = c;
        },
        getMix: function(a, b) {
            var c = a.name + ":" + b.name;
            return this.animationToMixTime.hasOwnProperty(c) ? this.animationToMixTime[c] : this.defaultMix;
        }
    }, c.TrackEntry = function() {}, c.TrackEntry.prototype = {
        next: null,
        previous: null,
        animation: null,
        loop: !1,
        delay: 0,
        time: 0,
        lastTime: -1,
        endTime: 0,
        timeScale: 1,
        mixTime: 0,
        mixDuration: 0,
        mix: 1,
        onStart: null,
        onEnd: null,
        onComplete: null,
        onEvent: null
    }, c.AnimationState = function(a) {
        this.data = a, this.tracks = [], this.events = [];
    }, c.AnimationState.prototype = {
        onStart: null,
        onEnd: null,
        onComplete: null,
        onEvent: null,
        timeScale: 1,
        update: function(a) {
            a *= this.timeScale;
            for (var b = 0; b < this.tracks.length; b++) {
                var c = this.tracks[b];
                if (c) {
                    if (c.time += a * c.timeScale, c.previous) {
                        var d = a * c.previous.timeScale;
                        c.previous.time += d, c.mixTime += d;
                    }
                    var e = c.next;
                    e ? (e.time = c.lastTime - e.delay, e.time >= 0 && this.setCurrent(b, e)) : !c.loop && c.lastTime >= c.endTime && this.clearTrack(b);
                }
            }
        },
        apply: function(a) {
            a.resetDrawOrder();
            for (var b = 0; b < this.tracks.length; b++) {
                var c = this.tracks[b];
                if (c) {
                    this.events.length = 0;
                    var d = c.time, e = c.lastTime, f = c.endTime, g = c.loop;
                    !g && d > f && (d = f);
                    var h = c.previous;
                    if (h) {
                        var i = h.time;
                        !h.loop && i > h.endTime && (i = h.endTime), h.animation.apply(a, i, i, h.loop, null);
                        var j = c.mixTime / c.mixDuration * c.mix;
                        j >= 1 && (j = 1, c.previous = null), c.animation.mix(a, c.lastTime, d, g, this.events, j);
                    } else 1 == c.mix ? c.animation.apply(a, c.lastTime, d, g, this.events) : c.animation.mix(a, c.lastTime, d, g, this.events, c.mix);
                    for (var k = 0, l = this.events.length; l > k; k++) {
                        var m = this.events[k];
                        c.onEvent && c.onEvent(b, m), this.onEvent && this.onEvent(b, m);
                    }
                    if (g ? e % f > d % f : f > e && d >= f) {
                        var n = Math.floor(d / f);
                        c.onComplete && c.onComplete(b, n), this.onComplete && this.onComplete(b, n);
                    }
                    c.lastTime = c.time;
                }
            }
        },
        clearTracks: function() {
            for (var a = 0, b = this.tracks.length; b > a; a++) this.clearTrack(a);
            this.tracks.length = 0;
        },
        clearTrack: function(a) {
            if (!(a >= this.tracks.length)) {
                var b = this.tracks[a];
                b && (b.onEnd && b.onEnd(a), this.onEnd && this.onEnd(a), this.tracks[a] = null);
            }
        },
        _expandToIndex: function(a) {
            if (a < this.tracks.length) return this.tracks[a];
            for (;a >= this.tracks.length; ) this.tracks.push(null);
            return null;
        },
        setCurrent: function(a, b) {
            var c = this._expandToIndex(a);
            if (c) {
                var d = c.previous;
                c.previous = null, c.onEnd && c.onEnd(a), this.onEnd && this.onEnd(a), b.mixDuration = this.data.getMix(c.animation, b.animation), 
                b.mixDuration > 0 && (b.mixTime = 0, b.previous = d && c.mixTime / c.mixDuration < .5 ? d : c);
            }
            this.tracks[a] = b, b.onStart && b.onStart(a), this.onStart && this.onStart(a);
        },
        setAnimationByName: function(a, b, c) {
            var d = this.data.skeletonData.findAnimation(b);
            if (!d) throw "Animation not found: " + b;
            return this.setAnimation(a, d, c);
        },
        setAnimation: function(a, b, d) {
            var e = new c.TrackEntry();
            return e.animation = b, e.loop = d, e.endTime = b.duration, this.setCurrent(a, e), 
            e;
        },
        addAnimationByName: function(a, b, c, d) {
            var e = this.data.skeletonData.findAnimation(b);
            if (!e) throw "Animation not found: " + b;
            return this.addAnimation(a, e, c, d);
        },
        addAnimation: function(a, b, d, e) {
            var f = new c.TrackEntry();
            f.animation = b, f.loop = d, f.endTime = b.duration;
            var g = this._expandToIndex(a);
            if (g) {
                for (;g.next; ) g = g.next;
                g.next = f;
            } else this.tracks[a] = f;
            return 0 >= e && (g ? e += g.endTime - this.data.getMix(g.animation, b) : e = 0), 
            f.delay = e, f;
        },
        getCurrent: function(a) {
            return a >= this.tracks.length ? null : this.tracks[a];
        }
    }, c.SkeletonJson = function(a) {
        this.attachmentLoader = a;
    }, c.SkeletonJson.prototype = {
        scale: 1,
        readSkeletonData: function(a, b) {
            var d = new c.SkeletonData();
            d.name = b;
            var e = a.skeleton;
            e && (d.hash = e.hash, d.version = e.spine, d.width = e.width || 0, d.height = e.height || 0);
            for (var f = a.bones, g = 0, h = f.length; h > g; g++) {
                var i = f[g], j = null;
                if (i.parent && (j = d.findBone(i.parent), !j)) throw "Parent bone not found: " + i.parent;
                var k = new c.BoneData(i.name, j);
                k.length = (i.length || 0) * this.scale, k.x = (i.x || 0) * this.scale, k.y = (i.y || 0) * this.scale, 
                k.rotation = i.rotation || 0, k.scaleX = i.hasOwnProperty("scaleX") ? i.scaleX : 1, 
                k.scaleY = i.hasOwnProperty("scaleY") ? i.scaleY : 1, k.inheritScale = i.hasOwnProperty("inheritScale") ? i.inheritScale : !0, 
                k.inheritRotation = i.hasOwnProperty("inheritRotation") ? i.inheritRotation : !0, 
                d.bones.push(k);
            }
            var l = a.ik;
            if (l) for (var g = 0, h = l.length; h > g; g++) {
                for (var m = l[g], n = new c.IkConstraintData(m.name), f = m.bones, o = 0, p = f.length; p > o; o++) {
                    var q = d.findBone(f[o]);
                    if (!q) throw "IK bone not found: " + f[o];
                    n.bones.push(q);
                }
                if (n.target = d.findBone(m.target), !n.target) throw "Target bone not found: " + m.target;
                n.bendDirection = !m.hasOwnProperty("bendPositive") || m.bendPositive ? 1 : -1, 
                n.mix = m.hasOwnProperty("mix") ? m.mix : 1, d.ikConstraints.push(n);
            }
            for (var r = a.slots, g = 0, h = r.length; h > g; g++) {
                var s = r[g], k = d.findBone(s.bone);
                if (!k) throw "Slot bone not found: " + s.bone;
                var t = new c.SlotData(s.name, k), u = s.color;
                u && (t.r = this.toColor(u, 0), t.g = this.toColor(u, 1), t.b = this.toColor(u, 2), 
                t.a = this.toColor(u, 3)), t.attachmentName = s.attachment, t.additiveBlending = s.additive && "true" == s.additive, 
                d.slots.push(t);
            }
            var v = a.skins;
            for (var w in v) if (v.hasOwnProperty(w)) {
                var x = v[w], y = new c.Skin(w);
                for (var z in x) if (x.hasOwnProperty(z)) {
                    var A = d.findSlotIndex(z), B = x[z];
                    for (var C in B) if (B.hasOwnProperty(C)) {
                        var D = this.readAttachment(y, C, B[C]);
                        D && y.addAttachment(A, C, D);
                    }
                }
                d.skins.push(y), "default" == y.name && (d.defaultSkin = y);
            }
            var E = a.events;
            for (var F in E) if (E.hasOwnProperty(F)) {
                var G = E[F], H = new c.EventData(F);
                H.intValue = G["int"] || 0, H.floatValue = G["float"] || 0, H.stringValue = G.string || null, 
                d.events.push(H);
            }
            var I = a.animations;
            for (var J in I) I.hasOwnProperty(J) && this.readAnimation(J, I[J], d);
            return d;
        },
        readAttachment: function(a, b, d) {
            b = d.name || b;
            var e = c.AttachmentType[d.type || "region"], f = d.path || b, g = this.scale;
            if (e == c.AttachmentType.region) {
                var h = this.attachmentLoader.newRegionAttachment(a, b, f);
                if (!h) return null;
                h.path = f, h.x = (d.x || 0) * g, h.y = (d.y || 0) * g, h.scaleX = d.hasOwnProperty("scaleX") ? d.scaleX : 1, 
                h.scaleY = d.hasOwnProperty("scaleY") ? d.scaleY : 1, h.rotation = d.rotation || 0, 
                h.width = (d.width || 0) * g, h.height = (d.height || 0) * g;
                var i = d.color;
                return i && (h.r = this.toColor(i, 0), h.g = this.toColor(i, 1), h.b = this.toColor(i, 2), 
                h.a = this.toColor(i, 3)), h.updateOffset(), h;
            }
            if (e == c.AttachmentType.mesh) {
                var j = this.attachmentLoader.newMeshAttachment(a, b, f);
                return j ? (j.path = f, j.vertices = this.getFloatArray(d, "vertices", g), j.triangles = this.getIntArray(d, "triangles"), 
                j.regionUVs = this.getFloatArray(d, "uvs", 1), j.updateUVs(), i = d.color, i && (j.r = this.toColor(i, 0), 
                j.g = this.toColor(i, 1), j.b = this.toColor(i, 2), j.a = this.toColor(i, 3)), j.hullLength = 2 * (d.hull || 0), 
                d.edges && (j.edges = this.getIntArray(d, "edges")), j.width = (d.width || 0) * g, 
                j.height = (d.height || 0) * g, j) : null;
            }
            if (e == c.AttachmentType.skinnedmesh) {
                var j = this.attachmentLoader.newSkinnedMeshAttachment(a, b, f);
                if (!j) return null;
                j.path = f;
                for (var k = this.getFloatArray(d, "uvs", 1), l = this.getFloatArray(d, "vertices", 1), m = [], n = [], o = 0, p = l.length; p > o; ) {
                    var q = 0 | l[o++];
                    n[n.length] = q;
                    for (var r = o + 4 * q; r > o; ) n[n.length] = l[o], m[m.length] = l[o + 1] * g, 
                    m[m.length] = l[o + 2] * g, m[m.length] = l[o + 3], o += 4;
                }
                return j.bones = n, j.weights = m, j.triangles = this.getIntArray(d, "triangles"), 
                j.regionUVs = k, j.updateUVs(), i = d.color, i && (j.r = this.toColor(i, 0), j.g = this.toColor(i, 1), 
                j.b = this.toColor(i, 2), j.a = this.toColor(i, 3)), j.hullLength = 2 * (d.hull || 0), 
                d.edges && (j.edges = this.getIntArray(d, "edges")), j.width = (d.width || 0) * g, 
                j.height = (d.height || 0) * g, j;
            }
            if (e == c.AttachmentType.boundingbox) {
                for (var s = this.attachmentLoader.newBoundingBoxAttachment(a, b), l = d.vertices, o = 0, p = l.length; p > o; o++) s.vertices.push(l[o] * g);
                return s;
            }
            throw "Unknown attachment type: " + e;
        },
        readAnimation: function(a, b, d) {
            var e = [], f = 0, g = b.slots;
            for (var h in g) if (g.hasOwnProperty(h)) {
                var i = g[h], j = d.findSlotIndex(h);
                for (var k in i) if (i.hasOwnProperty(k)) {
                    var l = i[k];
                    if ("color" == k) {
                        var m = new c.ColorTimeline(l.length);
                        m.slotIndex = j;
                        for (var n = 0, o = 0, p = l.length; p > o; o++) {
                            var q = l[o], r = q.color, s = this.toColor(r, 0), t = this.toColor(r, 1), u = this.toColor(r, 2), v = this.toColor(r, 3);
                            m.setFrame(n, q.time, s, t, u, v), this.readCurve(m, n, q), n++;
                        }
                        e.push(m), f = Math.max(f, m.frames[5 * m.getFrameCount() - 5]);
                    } else {
                        if ("attachment" != k) throw "Invalid timeline type for a slot: " + k + " (" + h + ")";
                        var m = new c.AttachmentTimeline(l.length);
                        m.slotIndex = j;
                        for (var n = 0, o = 0, p = l.length; p > o; o++) {
                            var q = l[o];
                            m.setFrame(n++, q.time, q.name);
                        }
                        e.push(m), f = Math.max(f, m.frames[m.getFrameCount() - 1]);
                    }
                }
            }
            var w = b.bones;
            for (var x in w) if (w.hasOwnProperty(x)) {
                var y = d.findBoneIndex(x);
                if (-1 == y) throw "Bone not found: " + x;
                var z = w[x];
                for (var k in z) if (z.hasOwnProperty(k)) {
                    var l = z[k];
                    if ("rotate" == k) {
                        var m = new c.RotateTimeline(l.length);
                        m.boneIndex = y;
                        for (var n = 0, o = 0, p = l.length; p > o; o++) {
                            var q = l[o];
                            m.setFrame(n, q.time, q.angle), this.readCurve(m, n, q), n++;
                        }
                        e.push(m), f = Math.max(f, m.frames[2 * m.getFrameCount() - 2]);
                    } else if ("translate" == k || "scale" == k) {
                        var m, A = 1;
                        "scale" == k ? m = new c.ScaleTimeline(l.length) : (m = new c.TranslateTimeline(l.length), 
                        A = this.scale), m.boneIndex = y;
                        for (var n = 0, o = 0, p = l.length; p > o; o++) {
                            var q = l[o], B = (q.x || 0) * A, C = (q.y || 0) * A;
                            m.setFrame(n, q.time, B, C), this.readCurve(m, n, q), n++;
                        }
                        e.push(m), f = Math.max(f, m.frames[3 * m.getFrameCount() - 3]);
                    } else {
                        if ("flipX" != k && "flipY" != k) throw "Invalid timeline type for a bone: " + k + " (" + x + ")";
                        var B = "flipX" == k, m = B ? new c.FlipXTimeline(l.length) : new c.FlipYTimeline(l.length);
                        m.boneIndex = y;
                        for (var D = B ? "x" : "y", n = 0, o = 0, p = l.length; p > o; o++) {
                            var q = l[o];
                            m.setFrame(n, q.time, q[D] || !1), n++;
                        }
                        e.push(m), f = Math.max(f, m.frames[2 * m.getFrameCount() - 2]);
                    }
                }
            }
            var E = b.ik;
            for (var F in E) if (E.hasOwnProperty(F)) {
                var G = d.findIkConstraint(F), l = E[F], m = new c.IkConstraintTimeline(l.length);
                m.ikConstraintIndex = d.ikConstraints.indexOf(G);
                for (var n = 0, o = 0, p = l.length; p > o; o++) {
                    var q = l[o], H = q.hasOwnProperty("mix") ? q.mix : 1, I = !q.hasOwnProperty("bendPositive") || q.bendPositive ? 1 : -1;
                    m.setFrame(n, q.time, H, I), this.readCurve(m, n, q), n++;
                }
                e.push(m), f = Math.max(f, m.frames[3 * m.getFrameCount() - 3]);
            }
            var J = b.ffd;
            for (var K in J) {
                var L = d.findSkin(K), i = J[K];
                for (h in i) {
                    var j = d.findSlotIndex(h), M = i[h];
                    for (var N in M) {
                        var l = M[N], m = new c.FfdTimeline(l.length), O = L.getAttachment(j, N);
                        if (!O) throw "FFD attachment not found: " + N;
                        m.slotIndex = j, m.attachment = O;
                        var P, Q = O.type == c.AttachmentType.mesh;
                        P = Q ? O.vertices.length : O.weights.length / 3 * 2;
                        for (var n = 0, o = 0, p = l.length; p > o; o++) {
                            var R, q = l[o];
                            if (q.vertices) {
                                var S = q.vertices, R = [];
                                R.length = P;
                                var T = q.offset || 0, U = S.length;
                                if (1 == this.scale) for (var V = 0; U > V; V++) R[V + T] = S[V]; else for (var V = 0; U > V; V++) R[V + T] = S[V] * this.scale;
                                if (Q) for (var W = O.vertices, V = 0, U = R.length; U > V; V++) R[V] += W[V];
                            } else Q ? R = O.vertices : (R = [], R.length = P);
                            m.setFrame(n, q.time, R), this.readCurve(m, n, q), n++;
                        }
                        e[e.length] = m, f = Math.max(f, m.frames[m.getFrameCount() - 1]);
                    }
                }
            }
            var X = b.drawOrder;
            if (X || (X = b.draworder), X) {
                for (var m = new c.DrawOrderTimeline(X.length), Y = d.slots.length, n = 0, o = 0, p = X.length; p > o; o++) {
                    var Z = X[o], $ = null;
                    if (Z.offsets) {
                        $ = [], $.length = Y;
                        for (var V = Y - 1; V >= 0; V--) $[V] = -1;
                        var _ = Z.offsets, aa = [];
                        aa.length = Y - _.length;
                        for (var ba = 0, ca = 0, V = 0, U = _.length; U > V; V++) {
                            var da = _[V], j = d.findSlotIndex(da.slot);
                            if (-1 == j) throw "Slot not found: " + da.slot;
                            for (;ba != j; ) aa[ca++] = ba++;
                            $[ba + da.offset] = ba++;
                        }
                        for (;Y > ba; ) aa[ca++] = ba++;
                        for (var V = Y - 1; V >= 0; V--) -1 == $[V] && ($[V] = aa[--ca]);
                    }
                    m.setFrame(n++, Z.time, $);
                }
                e.push(m), f = Math.max(f, m.frames[m.getFrameCount() - 1]);
            }
            var ea = b.events;
            if (ea) {
                for (var m = new c.EventTimeline(ea.length), n = 0, o = 0, p = ea.length; p > o; o++) {
                    var fa = ea[o], ga = d.findEvent(fa.name);
                    if (!ga) throw "Event not found: " + fa.name;
                    var ha = new c.Event(ga);
                    ha.intValue = fa.hasOwnProperty("int") ? fa["int"] : ga.intValue, ha.floatValue = fa.hasOwnProperty("float") ? fa["float"] : ga.floatValue, 
                    ha.stringValue = fa.hasOwnProperty("string") ? fa.string : ga.stringValue, m.setFrame(n++, fa.time, ha);
                }
                e.push(m), f = Math.max(f, m.frames[m.getFrameCount() - 1]);
            }
            d.animations.push(new c.Animation(a, e, f));
        },
        readCurve: function(a, b, c) {
            var d = c.curve;
            d ? "stepped" == d ? a.curves.setStepped(b) : d instanceof Array && a.curves.setCurve(b, d[0], d[1], d[2], d[3]) : a.curves.setLinear(b);
        },
        toColor: function(a, b) {
            if (8 != a.length) throw "Color hexidecimal length must be 8, recieved: " + a;
            return parseInt(a.substring(2 * b, 2 * b + 2), 16) / 255;
        },
        getFloatArray: function(a, b, d) {
            var e = a[b], f = new c.Float32Array(e.length), g = 0, h = e.length;
            if (1 == d) for (;h > g; g++) f[g] = e[g]; else for (;h > g; g++) f[g] = e[g] * d;
            return f;
        },
        getIntArray: function(a, b) {
            for (var d = a[b], e = new c.Uint16Array(d.length), f = 0, g = d.length; g > f; f++) e[f] = 0 | d[f];
            return e;
        }
    }, c.Atlas = function(a, b) {
        this.textureLoader = b, this.pages = [], this.regions = [];
        var d = new c.AtlasReader(a), e = [];
        e.length = 4;
        for (var f = null; ;) {
            var g = d.readLine();
            if (null === g) break;
            if (g = d.trim(g), g.length) if (f) {
                var h = new c.AtlasRegion();
                h.name = g, h.page = f, h.rotate = "true" == d.readValue(), d.readTuple(e);
                var i = parseInt(e[0]), j = parseInt(e[1]);
                d.readTuple(e);
                var k = parseInt(e[0]), l = parseInt(e[1]);
                h.u = i / f.width, h.v = j / f.height, h.rotate ? (h.u2 = (i + l) / f.width, h.v2 = (j + k) / f.height) : (h.u2 = (i + k) / f.width, 
                h.v2 = (j + l) / f.height), h.x = i, h.y = j, h.width = Math.abs(k), h.height = Math.abs(l), 
                4 == d.readTuple(e) && (h.splits = [ parseInt(e[0]), parseInt(e[1]), parseInt(e[2]), parseInt(e[3]) ], 
                4 == d.readTuple(e) && (h.pads = [ parseInt(e[0]), parseInt(e[1]), parseInt(e[2]), parseInt(e[3]) ], 
                d.readTuple(e))), h.originalWidth = parseInt(e[0]), h.originalHeight = parseInt(e[1]), 
                d.readTuple(e), h.offsetX = parseInt(e[0]), h.offsetY = parseInt(e[1]), h.index = parseInt(d.readValue()), 
                this.regions.push(h);
            } else {
                f = new c.AtlasPage(), f.name = g, 2 == d.readTuple(e) && (f.width = parseInt(e[0]), 
                f.height = parseInt(e[1]), d.readTuple(e)), f.format = c.Atlas.Format[e[0]], d.readTuple(e), 
                f.minFilter = c.Atlas.TextureFilter[e[0]], f.magFilter = c.Atlas.TextureFilter[e[1]];
                var m = d.readValue();
                f.uWrap = c.Atlas.TextureWrap.clampToEdge, f.vWrap = c.Atlas.TextureWrap.clampToEdge, 
                "x" == m ? f.uWrap = c.Atlas.TextureWrap.repeat : "y" == m ? f.vWrap = c.Atlas.TextureWrap.repeat : "xy" == m && (f.uWrap = f.vWrap = c.Atlas.TextureWrap.repeat), 
                b.load(f, g, this), this.pages.push(f);
            } else f = null;
        }
    }, c.Atlas.prototype = {
        findRegion: function(a) {
            for (var b = this.regions, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
            return null;
        },
        dispose: function() {
            for (var a = this.pages, b = 0, c = a.length; c > b; b++) this.textureLoader.unload(a[b].rendererObject);
        },
        updateUVs: function(a) {
            for (var b = this.regions, c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                e.page == a && (e.u = e.x / a.width, e.v = e.y / a.height, e.rotate ? (e.u2 = (e.x + e.height) / a.width, 
                e.v2 = (e.y + e.width) / a.height) : (e.u2 = (e.x + e.width) / a.width, e.v2 = (e.y + e.height) / a.height));
            }
        }
    }, c.Atlas.Format = {
        alpha: 0,
        intensity: 1,
        luminanceAlpha: 2,
        rgb565: 3,
        rgba4444: 4,
        rgb888: 5,
        rgba8888: 6
    }, c.Atlas.TextureFilter = {
        nearest: 0,
        linear: 1,
        mipMap: 2,
        mipMapNearestNearest: 3,
        mipMapLinearNearest: 4,
        mipMapNearestLinear: 5,
        mipMapLinearLinear: 6
    }, c.Atlas.TextureWrap = {
        mirroredRepeat: 0,
        clampToEdge: 1,
        repeat: 2
    }, c.AtlasPage = function() {}, c.AtlasPage.prototype = {
        name: null,
        format: null,
        minFilter: null,
        magFilter: null,
        uWrap: null,
        vWrap: null,
        rendererObject: null,
        width: 0,
        height: 0
    }, c.AtlasRegion = function() {}, c.AtlasRegion.prototype = {
        page: null,
        name: null,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        u: 0,
        v: 0,
        u2: 0,
        v2: 0,
        offsetX: 0,
        offsetY: 0,
        originalWidth: 0,
        originalHeight: 0,
        index: 0,
        rotate: !1,
        splits: null,
        pads: null
    }, c.AtlasReader = function(a) {
        this.lines = a.split(/\r\n|\r|\n/);
    }, c.AtlasReader.prototype = {
        index: 0,
        trim: function(a) {
            return a.replace(/^\s+|\s+$/g, "");
        },
        readLine: function() {
            return this.index >= this.lines.length ? null : this.lines[this.index++];
        },
        readValue: function() {
            var a = this.readLine(), b = a.indexOf(":");
            if (-1 == b) throw "Invalid line: " + a;
            return this.trim(a.substring(b + 1));
        },
        readTuple: function(a) {
            var b = this.readLine(), c = b.indexOf(":");
            if (-1 == c) throw "Invalid line: " + b;
            for (var d = 0, e = c + 1; 3 > d; d++) {
                var f = b.indexOf(",", e);
                if (-1 == f) break;
                a[d] = this.trim(b.substr(e, f - e)), e = f + 1;
            }
            return a[d] = this.trim(b.substring(e)), d + 1;
        }
    }, c.AtlasAttachmentLoader = function(a) {
        this.atlas = a;
    }, c.AtlasAttachmentLoader.prototype = {
        newRegionAttachment: function(a, b, d) {
            var e = this.atlas.findRegion(d);
            if (!e) throw "Region not found in atlas: " + d + " (region attachment: " + b + ")";
            var f = new c.RegionAttachment(b);
            return f.rendererObject = e, f.setUVs(e.u, e.v, e.u2, e.v2, e.rotate), f.regionOffsetX = e.offsetX, 
            f.regionOffsetY = e.offsetY, f.regionWidth = e.width, f.regionHeight = e.height, 
            f.regionOriginalWidth = e.originalWidth, f.regionOriginalHeight = e.originalHeight, 
            f;
        },
        newMeshAttachment: function(a, b, d) {
            var e = this.atlas.findRegion(d);
            if (!e) throw "Region not found in atlas: " + d + " (mesh attachment: " + b + ")";
            var f = new c.MeshAttachment(b);
            return f.rendererObject = e, f.regionU = e.u, f.regionV = e.v, f.regionU2 = e.u2, 
            f.regionV2 = e.v2, f.regionRotate = e.rotate, f.regionOffsetX = e.offsetX, f.regionOffsetY = e.offsetY, 
            f.regionWidth = e.width, f.regionHeight = e.height, f.regionOriginalWidth = e.originalWidth, 
            f.regionOriginalHeight = e.originalHeight, f;
        },
        newSkinnedMeshAttachment: function(a, b, d) {
            var e = this.atlas.findRegion(d);
            if (!e) throw "Region not found in atlas: " + d + " (skinned mesh attachment: " + b + ")";
            var f = new c.SkinnedMeshAttachment(b);
            return f.rendererObject = e, f.regionU = e.u, f.regionV = e.v, f.regionU2 = e.u2, 
            f.regionV2 = e.v2, f.regionRotate = e.rotate, f.regionOffsetX = e.offsetX, f.regionOffsetY = e.offsetY, 
            f.regionWidth = e.width, f.regionHeight = e.height, f.regionOriginalWidth = e.originalWidth, 
            f.regionOriginalHeight = e.originalHeight, f;
        },
        newBoundingBoxAttachment: function(a, b) {
            return new c.BoundingBoxAttachment(b);
        }
    }, c.SkeletonBounds = function() {
        this.polygonPool = [], this.polygons = [], this.boundingBoxes = [];
    }, c.SkeletonBounds.prototype = {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        update: function(a, b) {
            var d = a.slots, e = d.length, f = a.x, g = a.y, h = this.boundingBoxes, i = this.polygonPool, j = this.polygons;
            h.length = 0;
            for (var k = 0, l = j.length; l > k; k++) i.push(j[k]);
            j.length = 0;
            for (var k = 0; e > k; k++) {
                var m = d[k], n = m.attachment;
                if (n.type == c.AttachmentType.boundingbox) {
                    h.push(n);
                    var o, p = i.length;
                    p > 0 ? (o = i[p - 1], i.splice(p - 1, 1)) : o = [], j.push(o), o.length = n.vertices.length, 
                    n.computeWorldVertices(f, g, m.bone, o);
                }
            }
            b && this.aabbCompute();
        },
        aabbCompute: function() {
            for (var a = this.polygons, b = Number.MAX_VALUE, c = Number.MAX_VALUE, d = Number.MIN_VALUE, e = Number.MIN_VALUE, f = 0, g = a.length; g > f; f++) for (var h = a[f], i = 0, j = h.length; j > i; i += 2) {
                var k = h[i], l = h[i + 1];
                b = Math.min(b, k), c = Math.min(c, l), d = Math.max(d, k), e = Math.max(e, l);
            }
            this.minX = b, this.minY = c, this.maxX = d, this.maxY = e;
        },
        aabbContainsPoint: function(a, b) {
            return a >= this.minX && a <= this.maxX && b >= this.minY && b <= this.maxY;
        },
        aabbIntersectsSegment: function(a, b, c, d) {
            var e = this.minX, f = this.minY, g = this.maxX, h = this.maxY;
            if (e >= a && e >= c || f >= b && f >= d || a >= g && c >= g || b >= h && d >= h) return !1;
            var i = (d - b) / (c - a), j = i * (e - a) + b;
            if (j > f && h > j) return !0;
            if (j = i * (g - a) + b, j > f && h > j) return !0;
            var k = (f - b) / i + a;
            return k > e && g > k ? !0 : (k = (h - b) / i + a, k > e && g > k ? !0 : !1);
        },
        aabbIntersectsSkeleton: function(a) {
            return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY;
        },
        containsPoint: function(a, b) {
            for (var c = this.polygons, d = 0, e = c.length; e > d; d++) if (this.polygonContainsPoint(c[d], a, b)) return this.boundingBoxes[d];
            return null;
        },
        intersectsSegment: function(a, b, c, d) {
            for (var e = this.polygons, f = 0, g = e.length; g > f; f++) if (e[f].intersectsSegment(a, b, c, d)) return this.boundingBoxes[f];
            return null;
        },
        polygonContainsPoint: function(a, b, c) {
            for (var d = a.length, e = d - 2, f = !1, g = 0; d > g; g += 2) {
                var h = a[g + 1], i = a[e + 1];
                if (c > h && i >= c || c > i && h >= c) {
                    var j = a[g];
                    j + (c - h) / (i - h) * (a[e] - j) < b && (f = !f);
                }
                e = g;
            }
            return f;
        },
        polygonIntersectsSegment: function(a, b, c, d, e) {
            for (var f = a.length, g = b - d, h = c - e, i = b * e - c * d, j = a[f - 2], k = a[f - 1], l = 0; f > l; l += 2) {
                var m = a[l], n = a[l + 1], o = j * n - k * m, p = j - m, q = k - n, r = g * q - h * p, s = (i * p - g * o) / r;
                if ((s >= j && m >= s || s >= m && j >= s) && (s >= b && d >= s || s >= d && b >= s)) {
                    var t = (i * q - h * o) / r;
                    if ((t >= k && n >= t || t >= n && k >= t) && (t >= c && e >= t || t >= e && c >= t)) return !0;
                }
                j = m, k = n;
            }
            return !1;
        },
        getPolygon: function(a) {
            var b = this.boundingBoxes.indexOf(a);
            return -1 == b ? null : this.polygons[b];
        },
        getWidth: function() {
            return this.maxX - this.minX;
        },
        getHeight: function() {
            return this.maxY - this.minY;
        }
    }, c.Bone.yDown = !0, b.AnimCache = {}, b.SpineTextureLoader = function(a, c) {
        b.EventTarget.call(this), this.basePath = a, this.crossorigin = c, this.loadingCount = 0;
    }, b.SpineTextureLoader.prototype = b.SpineTextureLoader, b.SpineTextureLoader.prototype.load = function(a, c) {
        if (a.rendererObject = b.BaseTexture.fromImage(this.basePath + "/" + c, this.crossorigin), 
        !a.rendererObject.hasLoaded) {
            var d = this;
            ++d.loadingCount, a.rendererObject.addEventListener("loaded", function() {
                --d.loadingCount, d.dispatchEvent({
                    type: "loadedBaseTexture",
                    content: d
                });
            });
        }
    }, b.SpineTextureLoader.prototype.unload = function(a) {
        a.destroy(!0);
    }, b.Spine = function(a) {
        if (b.DisplayObjectContainer.call(this), this.spineData = b.AnimCache[a], !this.spineData) throw new Error("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + a);
        this.skeleton = new c.Skeleton(this.spineData), this.skeleton.updateWorldTransform(), 
        this.stateData = new c.AnimationStateData(this.spineData), this.state = new c.AnimationState(this.stateData), 
        this.slotContainers = [];
        for (var d = 0, e = this.skeleton.slots.length; e > d; d++) {
            var f = this.skeleton.slots[d], g = f.attachment, h = new b.DisplayObjectContainer();
            if (this.slotContainers.push(h), this.addChild(h), g instanceof c.RegionAttachment) {
                var i = g.rendererObject.name, j = this.createSprite(f, g);
                f.currentSprite = j, f.currentSpriteName = i, h.addChild(j);
            } else {
                if (!(g instanceof c.MeshAttachment)) continue;
                var k = this.createMesh(f, g);
                f.currentMesh = k, f.currentMeshName = g.name, h.addChild(k);
            }
        }
        this.autoUpdate = !0;
    }, b.Spine.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Spine.prototype.constructor = b.Spine, 
    Object.defineProperty(b.Spine.prototype, "autoUpdate", {
        get: function() {
            return this.updateTransform === b.Spine.prototype.autoUpdateTransform;
        },
        set: function(a) {
            this.updateTransform = a ? b.Spine.prototype.autoUpdateTransform : b.DisplayObjectContainer.prototype.updateTransform;
        }
    }), b.Spine.prototype.update = function(a) {
        this.state.update(a), this.state.apply(this.skeleton), this.skeleton.updateWorldTransform();
        for (var d = this.skeleton.drawOrder, e = this.skeleton.slots, f = 0, g = d.length; g > f; f++) this.children[f] = this.slotContainers[d[f]];
        for (f = 0, g = e.length; g > f; f++) {
            var h = e[f], i = h.attachment, j = this.slotContainers[f];
            if (i) {
                var k = i.type;
                if (k === c.AttachmentType.region) {
                    if (i.rendererObject && (!h.currentSpriteName || h.currentSpriteName !== i.name)) {
                        var l = i.rendererObject.name;
                        if (void 0 !== h.currentSprite && (h.currentSprite.visible = !1), h.sprites = h.sprites || {}, 
                        void 0 !== h.sprites[l]) h.sprites[l].visible = !0; else {
                            var m = this.createSprite(h, i);
                            j.addChild(m);
                        }
                        h.currentSprite = h.sprites[l], h.currentSpriteName = l;
                    }
                    var n = h.bone;
                    j.position.x = n.worldX + i.x * n.m00 + i.y * n.m01, j.position.y = n.worldY + i.x * n.m10 + i.y * n.m11, 
                    j.scale.x = n.worldScaleX, j.scale.y = n.worldScaleY, j.rotation = -(h.bone.worldRotation * c.degRad), 
                    h.currentSprite.tint = b.rgb2hex([ h.r, h.g, h.b ]);
                } else {
                    if (k !== c.AttachmentType.skinnedmesh) {
                        j.visible = !1;
                        continue;
                    }
                    if (!h.currentMeshName || h.currentMeshName !== i.name) {
                        var o = i.name;
                        if (void 0 !== h.currentMesh && (h.currentMesh.visible = !1), h.meshes = h.meshes || {}, 
                        void 0 !== h.meshes[o]) h.meshes[o].visible = !0; else {
                            var p = this.createMesh(h, i);
                            j.addChild(p);
                        }
                        h.currentMesh = h.meshes[o], h.currentMeshName = o;
                    }
                    i.computeWorldVertices(h.bone.skeleton.x, h.bone.skeleton.y, h, h.currentMesh.vertices);
                }
                j.visible = !0, j.alpha = h.a;
            } else j.visible = !1;
        }
    }, b.Spine.prototype.autoUpdateTransform = function() {
        this.lastTime = this.lastTime || Date.now();
        var a = .001 * (Date.now() - this.lastTime);
        this.lastTime = Date.now(), this.update(a), b.DisplayObjectContainer.prototype.updateTransform.call(this);
    }, b.Spine.prototype.createSprite = function(a, d) {
        var e = d.rendererObject, f = e.page.rendererObject, g = new b.Rectangle(e.x, e.y, e.rotate ? e.height : e.width, e.rotate ? e.width : e.height), h = new b.Texture(f, g), i = new b.Sprite(h), j = e.rotate ? .5 * Math.PI : 0;
        return i.scale.set(e.width / e.originalWidth * d.scaleX, e.height / e.originalHeight * d.scaleY), 
        i.rotation = j - d.rotation * c.degRad, i.anchor.x = i.anchor.y = .5, i.alpha = d.a, 
        a.sprites = a.sprites || {}, a.sprites[e.name] = i, i;
    }, b.Spine.prototype.createMesh = function(a, c) {
        var d = c.rendererObject, e = d.page.rendererObject, f = new b.Texture(e), g = new b.Strip(f);
        return g.drawMode = b.Strip.DrawModes.TRIANGLES, g.canvasPadding = 1.5, g.vertices = new b.Float32Array(c.uvs.length), 
        g.uvs = c.uvs, g.indices = c.triangles, g.alpha = c.a, a.meshes = a.meshes || {}, 
        a.meshes[c.name] = g, g;
    }, b.BaseTextureCache = {}, b.BaseTextureCacheIdGenerator = 0, b.BaseTexture = function(a, c) {
        if (this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = c || b.scaleModes.DEFAULT, 
        this.hasLoaded = !1, this.source = a, this._UID = b._UID++, this.premultipliedAlpha = !0, 
        this._glTextures = [], this.mipmap = !1, this._dirty = [ !0, !0, !0, !0 ], a) {
            if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) this.hasLoaded = !0, 
            this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, 
            this.dirty(); else {
                var d = this;
                this.source.onload = function() {
                    d.hasLoaded = !0, d.width = d.source.naturalWidth || d.source.width, d.height = d.source.naturalHeight || d.source.height, 
                    d.dirty(), d.dispatchEvent({
                        type: "loaded",
                        content: d
                    });
                }, this.source.onerror = function() {
                    d.dispatchEvent({
                        type: "error",
                        content: d
                    });
                };
            }
            this.imageUrl = null, this._powerOf2 = !1;
        }
    }, b.BaseTexture.prototype.constructor = b.BaseTexture, b.EventTarget.mixin(b.BaseTexture.prototype), 
    b.BaseTexture.prototype.destroy = function() {
        this.imageUrl ? (delete b.BaseTextureCache[this.imageUrl], delete b.TextureCache[this.imageUrl], 
        this.imageUrl = null, navigator.isCocoonJS || (this.source.src = "")) : this.source && this.source._pixiId && delete b.BaseTextureCache[this.source._pixiId], 
        this.source = null, this.unloadFromGPU();
    }, b.BaseTexture.prototype.updateSourceImage = function(a) {
        this.hasLoaded = !1, this.source.src = null, this.source.src = a;
    }, b.BaseTexture.prototype.dirty = function() {
        for (var a = 0; a < this._glTextures.length; a++) this._dirty[a] = !0;
    }, b.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var a = this._glTextures.length - 1; a >= 0; a--) {
            var c = this._glTextures[a], d = b.glContexts[a];
            d && c && d.deleteTexture(c);
        }
        this._glTextures.length = 0, this.dirty();
    }, b.BaseTexture.fromImage = function(a, c, d) {
        var e = b.BaseTextureCache[a];
        if (void 0 === c && -1 === a.indexOf("data:") && (c = !0), !e) {
            var f = new Image();
            c && (f.crossOrigin = ""), f.src = a, e = new b.BaseTexture(f, d), e.imageUrl = a, 
            b.BaseTextureCache[a] = e, -1 !== a.indexOf(b.RETINA_PREFIX + ".") && (e.resolution = 2);
        }
        return e;
    }, b.BaseTexture.fromCanvas = function(a, c) {
        a._pixiId || (a._pixiId = "canvas_" + b.TextureCacheIdGenerator++);
        var d = b.BaseTextureCache[a._pixiId];
        return d || (d = new b.BaseTexture(a, c), b.BaseTextureCache[a._pixiId] = d), d;
    }, b.TextureCache = {}, b.FrameCache = {}, b.TextureCacheIdGenerator = 0, b.Texture = function(a, c, d, e) {
        this.noFrame = !1, c || (this.noFrame = !0, c = new b.Rectangle(0, 0, 1, 1)), a instanceof b.Texture && (a = a.baseTexture), 
        this.baseTexture = a, this.frame = c, this.trim = e, this.valid = !1, this.requiresUpdate = !1, 
        this._uvs = null, this.width = 0, this.height = 0, this.crop = d || new b.Rectangle(0, 0, 1, 1), 
        a.hasLoaded ? (this.noFrame && (c = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(c)) : a.addEventListener("loaded", this.onBaseTextureLoaded.bind(this));
    }, b.Texture.prototype.constructor = b.Texture, b.EventTarget.mixin(b.Texture.prototype), 
    b.Texture.prototype.onBaseTextureLoaded = function() {
        var a = this.baseTexture;
        a.removeEventListener("loaded", this.onLoaded), this.noFrame && (this.frame = new b.Rectangle(0, 0, a.width, a.height)), 
        this.setFrame(this.frame), this.dispatchEvent({
            type: "update",
            content: this
        });
    }, b.Texture.prototype.destroy = function(a) {
        a && this.baseTexture.destroy(), this.valid = !1;
    }, b.Texture.prototype.setFrame = function(a) {
        if (this.noFrame = !1, this.frame = a, this.width = a.width, this.height = a.height, 
        this.crop.x = a.x, this.crop.y = a.y, this.crop.width = a.width, this.crop.height = a.height, 
        !this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height)) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
        this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded, 
        this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, 
        this.frame.height = this.trim.height), this.valid && this._updateUvs();
    }, b.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new b.TextureUvs());
        var a = this.crop, c = this.baseTexture.width, d = this.baseTexture.height;
        this._uvs.x0 = a.x / c, this._uvs.y0 = a.y / d, this._uvs.x1 = (a.x + a.width) / c, 
        this._uvs.y1 = a.y / d, this._uvs.x2 = (a.x + a.width) / c, this._uvs.y2 = (a.y + a.height) / d, 
        this._uvs.x3 = a.x / c, this._uvs.y3 = (a.y + a.height) / d;
    }, b.Texture.fromImage = function(a, c, d) {
        var e = b.TextureCache[a];
        return e || (e = new b.Texture(b.BaseTexture.fromImage(a, c, d)), b.TextureCache[a] = e), 
        e;
    }, b.Texture.fromFrame = function(a) {
        var c = b.TextureCache[a];
        if (!c) throw new Error('The frameId "' + a + '" does not exist in the texture cache ');
        return c;
    }, b.Texture.fromCanvas = function(a, c) {
        var d = b.BaseTexture.fromCanvas(a, c);
        return new b.Texture(d);
    }, b.Texture.addTextureToCache = function(a, c) {
        b.TextureCache[c] = a;
    }, b.Texture.removeTextureFromCache = function(a) {
        var c = b.TextureCache[a];
        return delete b.TextureCache[a], delete b.BaseTextureCache[a], c;
    }, b.TextureUvs = function() {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, 
        this.y3 = 0;
    }, b.Texture.emptyTexture = new b.Texture(new b.BaseTexture()), b.RenderTexture = function(a, c, d, e, f) {
        if (this.width = a || 100, this.height = c || 100, this.resolution = f || 1, this.frame = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), 
        this.crop = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), 
        this.baseTexture = new b.BaseTexture(), this.baseTexture.width = this.width * this.resolution, 
        this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], 
        this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = e || b.scaleModes.DEFAULT, 
        this.baseTexture.hasLoaded = !0, b.Texture.call(this, this.baseTexture, new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), 
        this.renderer = d || b.defaultRenderer, this.renderer.type === b.WEBGL_RENDERER) {
            var g = this.renderer.gl;
            this.baseTexture._dirty[g.id] = !1, this.textureBuffer = new b.FilterTexture(g, this.width, this.height, this.baseTexture.scaleMode), 
            this.baseTexture._glTextures[g.id] = this.textureBuffer.texture, this.render = this.renderWebGL, 
            this.projection = new b.Point(.5 * this.width, .5 * -this.height);
        } else this.render = this.renderCanvas, this.textureBuffer = new b.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), 
        this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this._updateUvs();
    }, b.RenderTexture.prototype = Object.create(b.Texture.prototype), b.RenderTexture.prototype.constructor = b.RenderTexture, 
    b.RenderTexture.prototype.resize = function(a, c, d) {
        (a !== this.width || c !== this.height) && (this.valid = a > 0 && c > 0, this.width = a, 
        this.height = c, this.frame.width = this.crop.width = a * this.resolution, this.frame.height = this.crop.height = c * this.resolution, 
        d && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), 
        this.renderer.type === b.WEBGL_RENDERER && (this.projection.x = this.width / 2, 
        this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height));
    }, b.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === b.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), 
        this.textureBuffer.clear());
    }, b.RenderTexture.prototype.renderWebGL = function(a, b, c) {
        if (this.valid) {
            var d = a.worldTransform;
            d.identity(), d.translate(0, 2 * this.projection.y), b && d.append(b), d.scale(1, -1), 
            a.worldAlpha = 1;
            for (var e = a.children, f = 0, g = e.length; g > f; f++) e[f].updateTransform();
            var h = this.renderer.gl;
            h.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), h.bindFramebuffer(h.FRAMEBUFFER, this.textureBuffer.frameBuffer), 
            c && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer), 
            this.renderer.spriteBatch.dirty = !0;
        }
    }, b.RenderTexture.prototype.renderCanvas = function(a, b, c) {
        if (this.valid) {
            var d = a.worldTransform;
            d.identity(), b && d.append(b), a.worldAlpha = 1;
            for (var e = a.children, f = 0, g = e.length; g > f; f++) e[f].updateTransform();
            c && this.textureBuffer.clear();
            var h = this.textureBuffer.context, i = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(a, h), 
            this.renderer.resolution = i;
        }
    }, b.RenderTexture.prototype.getImage = function() {
        var a = new Image();
        return a.src = this.getBase64(), a;
    }, b.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL();
    }, b.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === b.WEBGL_RENDERER) {
            var a = this.renderer.gl, c = this.textureBuffer.width, d = this.textureBuffer.height, e = new Uint8Array(4 * c * d);
            a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer), a.readPixels(0, 0, c, d, a.RGBA, a.UNSIGNED_BYTE, e), 
            a.bindFramebuffer(a.FRAMEBUFFER, null);
            var f = new b.CanvasBuffer(c, d), g = f.context.getImageData(0, 0, c, d);
            return g.data.set(e), f.context.putImageData(g, 0, 0), f.canvas;
        }
        return this.textureBuffer.canvas;
    }, b.RenderTexture.tempMatrix = new b.Matrix(), b.VideoTexture = function(a, c) {
        if (!a) throw new Error("No video source element specified.");
        (a.readyState === a.HAVE_ENOUGH_DATA || a.readyState === a.HAVE_FUTURE_DATA) && a.width && a.height && (a.complete = !0), 
        b.BaseTexture.call(this, a, c), this.autoUpdate = !1, this.updateBound = this._onUpdate.bind(this), 
        a.complete || (this._onCanPlay = this.onCanPlay.bind(this), a.addEventListener("canplay", this._onCanPlay), 
        a.addEventListener("canplaythrough", this._onCanPlay), a.addEventListener("play", this.onPlayStart.bind(this)), 
        a.addEventListener("pause", this.onPlayStop.bind(this)));
    }, b.VideoTexture.prototype = Object.create(b.BaseTexture.prototype), b.VideoTexture.constructor = b.VideoTexture, 
    b.VideoTexture.prototype._onUpdate = function() {
        this.autoUpdate && (window.requestAnimationFrame(this.updateBound), this.dirty());
    }, b.VideoTexture.prototype.onPlayStart = function() {
        this.autoUpdate || (window.requestAnimationFrame(this.updateBound), this.autoUpdate = !0);
    }, b.VideoTexture.prototype.onPlayStop = function() {
        this.autoUpdate = !1;
    }, b.VideoTexture.prototype.onCanPlay = function() {
        "canplaythrough" === event.type && (this.hasLoaded = !0, this.source && (this.source.removeEventListener("canplay", this._onCanPlay), 
        this.source.removeEventListener("canplaythrough", this._onCanPlay), this.width = this.source.videoWidth, 
        this.height = this.source.videoHeight, this.__loaded || (this.__loaded = !0, this.dispatchEvent({
            type: "loaded",
            content: this
        }))));
    }, b.VideoTexture.prototype.destroy = function() {
        this.source && this.source._pixiId && (b.BaseTextureCache[this.source._pixiId] = null, 
        delete b.BaseTextureCache[this.source._pixiId], this.source._pixiId = null, delete this.source._pixiId), 
        b.BaseTexture.prototype.destroy.call(this);
    }, b.VideoTexture.baseTextureFromVideo = function(a, c) {
        a._pixiId || (a._pixiId = "video_" + b.TextureCacheIdGenerator++);
        var d = b.BaseTextureCache[a._pixiId];
        return d || (d = new b.VideoTexture(a, c), b.BaseTextureCache[a._pixiId] = d), d;
    }, b.VideoTexture.textureFromVideo = function(a, c) {
        var d = b.VideoTexture.baseTextureFromVideo(a, c);
        return new b.Texture(d);
    }, b.VideoTexture.fromUrl = function(a, c) {
        var d = document.createElement("video");
        return d.src = a, d.autoPlay = !0, d.play(), b.VideoTexture.textureFromVideo(d, c);
    }, b.AssetLoader = function(a, c) {
        this.assetURLs = a, this.crossorigin = c, this.loadersByType = {
            jpg: b.ImageLoader,
            jpeg: b.ImageLoader,
            png: b.ImageLoader,
            gif: b.ImageLoader,
            webp: b.ImageLoader,
            json: b.JsonLoader,
            atlas: b.AtlasLoader,
            anim: b.SpineLoader,
            xml: b.BitmapFontLoader,
            fnt: b.BitmapFontLoader
        };
    }, b.EventTarget.mixin(b.AssetLoader.prototype), b.AssetLoader.prototype.constructor = b.AssetLoader, 
    b.AssetLoader.prototype._getDataType = function(a) {
        var b = "data:", c = a.slice(0, b.length).toLowerCase();
        if (c === b) {
            var d = a.slice(b.length), e = d.indexOf(",");
            if (-1 === e) return null;
            var f = d.slice(0, e).split(";")[0];
            return f && "text/plain" !== f.toLowerCase() ? f.split("/").pop().toLowerCase() : "txt";
        }
        return null;
    }, b.AssetLoader.prototype.load = function() {
        function a(a) {
            b.onAssetLoaded(a.data.content);
        }
        var b = this;
        this.loadCount = this.assetURLs.length;
        for (var c = 0; c < this.assetURLs.length; c++) {
            var d = this.assetURLs[c], e = this._getDataType(d);
            e || (e = d.split("?").shift().split(".").pop().toLowerCase());
            var f = this.loadersByType[e];
            if (!f) throw new Error(e + " is an unsupported file type");
            var g = new f(d, this.crossorigin);
            g.on("loaded", a), g.load();
        }
    }, b.AssetLoader.prototype.onAssetLoaded = function(a) {
        this.loadCount--, this.emit("onProgress", {
            content: this,
            loader: a,
            loaded: this.assetURLs.length - this.loadCount,
            total: this.assetURLs.length
        }), this.onProgress && this.onProgress(a), this.loadCount || (this.emit("onComplete", {
            content: this
        }), this.onComplete && this.onComplete());
    }, b.JsonLoader = function(a, b) {
        this.url = a, this.crossorigin = b, this.baseUrl = a.replace(/[^\/]*$/, ""), this.loaded = !1;
    }, b.JsonLoader.prototype.constructor = b.JsonLoader, b.EventTarget.mixin(b.JsonLoader.prototype), 
    b.JsonLoader.prototype.load = function() {
        window.XDomainRequest && this.crossorigin ? (this.ajaxRequest = new window.XDomainRequest(), 
        this.ajaxRequest.timeout = 3e3, this.ajaxRequest.onerror = this.onError.bind(this), 
        this.ajaxRequest.ontimeout = this.onError.bind(this), this.ajaxRequest.onprogress = function() {}, 
        this.ajaxRequest.onload = this.onJSONLoaded.bind(this)) : (this.ajaxRequest = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject("Microsoft.XMLHTTP"), 
        this.ajaxRequest.onreadystatechange = this.onReadyStateChanged.bind(this)), this.ajaxRequest.open("GET", this.url, !0), 
        this.ajaxRequest.send();
    }, b.JsonLoader.prototype.onReadyStateChanged = function() {
        4 !== this.ajaxRequest.readyState || 200 !== this.ajaxRequest.status && -1 !== window.location.href.indexOf("http") || this.onJSONLoaded();
    }, b.JsonLoader.prototype.onJSONLoaded = function() {
        if (!this.ajaxRequest.responseText) return void this.onError();
        if (this.json = JSON.parse(this.ajaxRequest.responseText), this.json.frames && this.json.meta && this.json.meta.image) {
            var a = this.json.meta.image;
            -1 === a.indexOf("data:") && (a = this.baseUrl + a);
            var d = new b.ImageLoader(a, this.crossorigin), e = this.json.frames;
            this.texture = d.texture.baseTexture, d.addEventListener("loaded", this.onLoaded.bind(this));
            for (var f in e) {
                var g = e[f].frame;
                if (g) {
                    var h = new b.Rectangle(g.x, g.y, g.w, g.h), i = h.clone(), j = null;
                    if (e[f].trimmed) {
                        var k = e[f].sourceSize, l = e[f].spriteSourceSize;
                        j = new b.Rectangle(l.x, l.y, k.w, k.h);
                    }
                    b.TextureCache[f] = new b.Texture(this.texture, h, i, j);
                }
            }
            d.load();
        } else if (this.json.bones) if (b.AnimCache[this.url]) this.onLoaded(); else {
            var m = this.url.substr(0, this.url.lastIndexOf(".")) + ".atlas", n = new b.JsonLoader(m, this.crossorigin), o = this;
            n.onJSONLoaded = function() {
                if (!this.ajaxRequest.responseText) return void this.onError();
                var a = new b.SpineTextureLoader(this.url.substring(0, this.url.lastIndexOf("/"))), d = new c.Atlas(this.ajaxRequest.responseText, a), e = new c.AtlasAttachmentLoader(d), f = new c.SkeletonJson(e), g = f.readSkeletonData(o.json);
                b.AnimCache[o.url] = g, o.spine = g, o.spineAtlas = d, o.spineAtlasLoader = n, a.loadingCount > 0 ? a.addEventListener("loadedBaseTexture", function(a) {
                    a.content.content.loadingCount <= 0 && o.onLoaded();
                }) : o.onLoaded();
            }, n.load();
        } else this.onLoaded();
    }, b.JsonLoader.prototype.onLoaded = function() {
        this.loaded = !0, this.dispatchEvent({
            type: "loaded",
            content: this
        });
    }, b.JsonLoader.prototype.onError = function() {
        this.dispatchEvent({
            type: "error",
            content: this
        });
    }, b.AtlasLoader = function(a, b) {
        this.url = a, this.baseUrl = a.replace(/[^\/]*$/, ""), this.crossorigin = b, this.loaded = !1;
    }, b.AtlasLoader.constructor = b.AtlasLoader, b.EventTarget.mixin(b.AtlasLoader.prototype), 
    b.AtlasLoader.prototype.load = function() {
        this.ajaxRequest = new b.AjaxRequest(), this.ajaxRequest.onreadystatechange = this.onAtlasLoaded.bind(this), 
        this.ajaxRequest.open("GET", this.url, !0), this.ajaxRequest.overrideMimeType && this.ajaxRequest.overrideMimeType("application/json"), 
        this.ajaxRequest.send(null);
    }, b.AtlasLoader.prototype.onAtlasLoaded = function() {
        if (4 === this.ajaxRequest.readyState) if (200 === this.ajaxRequest.status || -1 === window.location.href.indexOf("http")) {
            this.atlas = {
                meta: {
                    image: []
                },
                frames: []
            };
            var a = this.ajaxRequest.responseText.split(/\r?\n/), c = -3, d = 0, e = null, f = !1, g = 0, h = 0, i = this.onLoaded.bind(this);
            for (g = 0; g < a.length; g++) if (a[g] = a[g].replace(/^\s+|\s+$/g, ""), "" === a[g] && (f = g + 1), 
            a[g].length > 0) {
                if (f === g) this.atlas.meta.image.push(a[g]), d = this.atlas.meta.image.length - 1, 
                this.atlas.frames.push({}), c = -3; else if (c > 0) if (c % 7 === 1) null != e && (this.atlas.frames[d][e.name] = e), 
                e = {
                    name: a[g],
                    frame: {}
                }; else {
                    var j = a[g].split(" ");
                    if (c % 7 === 3) e.frame.x = Number(j[1].replace(",", "")), e.frame.y = Number(j[2]); else if (c % 7 === 4) e.frame.w = Number(j[1].replace(",", "")), 
                    e.frame.h = Number(j[2]); else if (c % 7 === 5) {
                        var k = {
                            x: 0,
                            y: 0,
                            w: Number(j[1].replace(",", "")),
                            h: Number(j[2])
                        };
                        k.w > e.frame.w || k.h > e.frame.h ? (e.trimmed = !0, e.realSize = k) : e.trimmed = !1;
                    }
                }
                c++;
            }
            if (null != e && (this.atlas.frames[d][e.name] = e), this.atlas.meta.image.length > 0) {
                for (this.images = [], h = 0; h < this.atlas.meta.image.length; h++) {
                    var l = this.baseUrl + this.atlas.meta.image[h], m = this.atlas.frames[h];
                    this.images.push(new b.ImageLoader(l, this.crossorigin));
                    for (g in m) {
                        var n = m[g].frame;
                        n && (b.TextureCache[g] = new b.Texture(this.images[h].texture.baseTexture, {
                            x: n.x,
                            y: n.y,
                            width: n.w,
                            height: n.h
                        }), m[g].trimmed && (b.TextureCache[g].realSize = m[g].realSize, b.TextureCache[g].trim.x = 0, 
                        b.TextureCache[g].trim.y = 0));
                    }
                }
                for (this.currentImageId = 0, h = 0; h < this.images.length; h++) this.images[h].on("loaded", i);
                this.images[this.currentImageId].load();
            } else this.onLoaded();
        } else this.onError();
    }, b.AtlasLoader.prototype.onLoaded = function() {
        this.images.length - 1 > this.currentImageId ? (this.currentImageId++, this.images[this.currentImageId].load()) : (this.loaded = !0, 
        this.emit("loaded", {
            content: this
        }));
    }, b.AtlasLoader.prototype.onError = function() {
        this.emit("error", {
            content: this
        });
    }, b.SpriteSheetLoader = function(a, b) {
        this.url = a, this.crossorigin = b, this.baseUrl = a.replace(/[^\/]*$/, ""), this.texture = null, 
        this.frames = {};
    }, b.SpriteSheetLoader.prototype.constructor = b.SpriteSheetLoader, b.EventTarget.mixin(b.SpriteSheetLoader.prototype), 
    b.SpriteSheetLoader.prototype.load = function() {
        var a = this, c = new b.JsonLoader(this.url, this.crossorigin);
        c.on("loaded", function(b) {
            a.json = b.data.content.json, a.onLoaded();
        }), c.load();
    }, b.SpriteSheetLoader.prototype.onLoaded = function() {
        this.emit("loaded", {
            content: this
        });
    }, b.ImageLoader = function(a, c) {
        this.texture = b.Texture.fromImage(a, c), this.frames = [];
    }, b.ImageLoader.prototype.constructor = b.ImageLoader, b.EventTarget.mixin(b.ImageLoader.prototype), 
    b.ImageLoader.prototype.load = function() {
        this.texture.baseTexture.hasLoaded ? this.onLoaded() : this.texture.baseTexture.on("loaded", this.onLoaded.bind(this));
    }, b.ImageLoader.prototype.onLoaded = function() {
        this.emit("loaded", {
            content: this
        });
    }, b.ImageLoader.prototype.loadFramedSpriteSheet = function(a, c, d) {
        this.frames = [];
        for (var e = Math.floor(this.texture.width / a), f = Math.floor(this.texture.height / c), g = 0, h = 0; f > h; h++) for (var i = 0; e > i; i++, 
        g++) {
            var j = new b.Texture(this.texture.baseTexture, {
                x: i * a,
                y: h * c,
                width: a,
                height: c
            });
            this.frames.push(j), d && (b.TextureCache[d + "-" + g] = j);
        }
        this.load();
    }, b.BitmapFontLoader = function(a, b) {
        this.url = a, this.crossorigin = b, this.baseUrl = a.replace(/[^\/]*$/, ""), this.texture = null;
    }, b.BitmapFontLoader.prototype.constructor = b.BitmapFontLoader, b.EventTarget.mixin(b.BitmapFontLoader.prototype), 
    b.BitmapFontLoader.prototype.load = function() {
        this.ajaxRequest = new b.AjaxRequest(), this.ajaxRequest.onreadystatechange = this.onXMLLoaded.bind(this), 
        this.ajaxRequest.open("GET", this.url, !0), this.ajaxRequest.overrideMimeType && this.ajaxRequest.overrideMimeType("application/xml"), 
        this.ajaxRequest.send(null);
    }, b.BitmapFontLoader.prototype.onXMLLoaded = function() {
        if (4 === this.ajaxRequest.readyState && (200 === this.ajaxRequest.status || -1 === window.location.protocol.indexOf("http"))) {
            var a = this.ajaxRequest.responseXML;
            if (!a || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS) if ("function" == typeof window.DOMParser) {
                var c = new DOMParser();
                a = c.parseFromString(this.ajaxRequest.responseText, "text/xml");
            } else {
                var d = document.createElement("div");
                d.innerHTML = this.ajaxRequest.responseText, a = d;
            }
            var e = this.baseUrl + a.getElementsByTagName("page")[0].getAttribute("file"), f = new b.ImageLoader(e, this.crossorigin);
            this.texture = f.texture.baseTexture;
            var g = {}, h = a.getElementsByTagName("info")[0], i = a.getElementsByTagName("common")[0];
            g.font = h.getAttribute("face"), g.size = parseInt(h.getAttribute("size"), 10), 
            g.lineHeight = parseInt(i.getAttribute("lineHeight"), 10), g.chars = {};
            for (var j = a.getElementsByTagName("char"), k = 0; k < j.length; k++) {
                var l = parseInt(j[k].getAttribute("id"), 10), m = new b.Rectangle(parseInt(j[k].getAttribute("x"), 10), parseInt(j[k].getAttribute("y"), 10), parseInt(j[k].getAttribute("width"), 10), parseInt(j[k].getAttribute("height"), 10));
                g.chars[l] = {
                    xOffset: parseInt(j[k].getAttribute("xoffset"), 10),
                    yOffset: parseInt(j[k].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(j[k].getAttribute("xadvance"), 10),
                    kerning: {},
                    texture: b.TextureCache[l] = new b.Texture(this.texture, m)
                };
            }
            var n = a.getElementsByTagName("kerning");
            for (k = 0; k < n.length; k++) {
                var o = parseInt(n[k].getAttribute("first"), 10), p = parseInt(n[k].getAttribute("second"), 10), q = parseInt(n[k].getAttribute("amount"), 10);
                g.chars[p].kerning[o] = q;
            }
            b.BitmapText.fonts[g.font] = g, f.addEventListener("loaded", this.onLoaded.bind(this)), 
            f.load();
        }
    }, b.BitmapFontLoader.prototype.onLoaded = function() {
        this.emit("loaded", {
            content: this
        });
    }, b.SpineLoader = function(a, b) {
        this.url = a, this.crossorigin = b, this.loaded = !1;
    }, b.SpineLoader.prototype.constructor = b.SpineLoader, b.EventTarget.mixin(b.SpineLoader.prototype), 
    b.SpineLoader.prototype.load = function() {
        var a = this, c = new b.JsonLoader(this.url, this.crossorigin);
        c.on("loaded", function(b) {
            a.json = b.data.content.json, a.onLoaded();
        }), c.load();
    }, b.SpineLoader.prototype.onLoaded = function() {
        this.loaded = !0, this.emit("loaded", {
            content: this
        });
    }, b.AbstractFilter = function(a, b) {
        this.passes = [ this ], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = b || {}, 
        this.fragmentSrc = a || [];
    }, b.AbstractFilter.prototype.constructor = b.AbstractFilter, b.AbstractFilter.prototype.syncUniforms = function() {
        for (var a = 0, b = this.shaders.length; b > a; a++) this.shaders[a].dirty = !0;
    }, b.AlphaMaskFilter = function(a) {
        b.AbstractFilter.call(this), this.passes = [ this ], a.baseTexture._powerOf2 = !0, 
        this.uniforms = {
            mask: {
                type: "sampler2D",
                value: a
            },
            mapDimensions: {
                type: "2f",
                value: {
                    x: 1,
                    y: 5112
                }
            },
            dimensions: {
                type: "4fv",
                value: [ 0, 0, 0, 0 ]
            }
        }, a.baseTexture.hasLoaded ? (this.uniforms.mask.value.x = a.width, this.uniforms.mask.value.y = a.height) : (this.boundLoadedFunction = this.onTextureLoaded.bind(this), 
        a.baseTexture.on("loaded", this.boundLoadedFunction)), this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D mask;", "uniform sampler2D uSampler;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   mapCords *= dimensions.xy / mapDimensions;", "   vec4 original =  texture2D(uSampler, vTextureCoord);", "   float maskAlpha =  texture2D(mask, mapCords).r;", "   original *= maskAlpha;", "   gl_FragColor =  original;", "}" ];
    }, b.AlphaMaskFilter.prototype = Object.create(b.AbstractFilter.prototype), b.AlphaMaskFilter.prototype.constructor = b.AlphaMaskFilter, 
    b.AlphaMaskFilter.prototype.onTextureLoaded = function() {
        this.uniforms.mapDimensions.value.x = this.uniforms.mask.value.width, this.uniforms.mapDimensions.value.y = this.uniforms.mask.value.height, 
        this.uniforms.mask.value.baseTexture.off("loaded", this.boundLoadedFunction);
    }, Object.defineProperty(b.AlphaMaskFilter.prototype, "map", {
        get: function() {
            return this.uniforms.mask.value;
        },
        set: function(a) {
            this.uniforms.mask.value = a;
        }
    }), b.ColorMatrixFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            matrix: {
                type: "mat4",
                value: [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform mat4 matrix;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;", "}" ];
    }, b.ColorMatrixFilter.prototype = Object.create(b.AbstractFilter.prototype), b.ColorMatrixFilter.prototype.constructor = b.ColorMatrixFilter, 
    Object.defineProperty(b.ColorMatrixFilter.prototype, "matrix", {
        get: function() {
            return this.uniforms.matrix.value;
        },
        set: function(a) {
            this.uniforms.matrix.value = a;
        }
    }), b.GrayFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            gray: {
                type: "1f",
                value: 1
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float gray;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);", "}" ];
    }, b.GrayFilter.prototype = Object.create(b.AbstractFilter.prototype), b.GrayFilter.prototype.constructor = b.GrayFilter, 
    Object.defineProperty(b.GrayFilter.prototype, "gray", {
        get: function() {
            return this.uniforms.gray.value;
        },
        set: function(a) {
            this.uniforms.gray.value = a;
        }
    }), b.DisplacementFilter = function(a) {
        b.AbstractFilter.call(this), this.passes = [ this ], a.baseTexture._powerOf2 = !0, 
        this.uniforms = {
            displacementMap: {
                type: "sampler2D",
                value: a
            },
            scale: {
                type: "2f",
                value: {
                    x: 30,
                    y: 30
                }
            },
            offset: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            },
            mapDimensions: {
                type: "2f",
                value: {
                    x: 1,
                    y: 5112
                }
            },
            dimensions: {
                type: "4fv",
                value: [ 0, 0, 0, 0 ]
            }
        }, a.baseTexture.hasLoaded ? (this.uniforms.mapDimensions.value.x = a.width, this.uniforms.mapDimensions.value.y = a.height) : (this.boundLoadedFunction = this.onTextureLoaded.bind(this), 
        a.baseTexture.on("loaded", this.boundLoadedFunction)), this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D displacementMap;", "uniform sampler2D uSampler;", "uniform vec2 scale;", "uniform vec2 offset;", "uniform vec4 dimensions;", "uniform vec2 mapDimensions;", "void main(void) {", "   vec2 mapCords = vTextureCoord.xy;", "   mapCords += (dimensions.zw + offset)/ dimensions.xy ;", "   mapCords.y *= -1.0;", "   mapCords.y += 1.0;", "   vec2 matSample = texture2D(displacementMap, mapCords).xy;", "   matSample -= 0.5;", "   matSample *= scale;", "   matSample /= mapDimensions;", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));", "   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);", "   vec2 cord = vTextureCoord;", "}" ];
    }, b.DisplacementFilter.prototype = Object.create(b.AbstractFilter.prototype), b.DisplacementFilter.prototype.constructor = b.DisplacementFilter, 
    b.DisplacementFilter.prototype.onTextureLoaded = function() {
        this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width, 
        this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height, 
        this.uniforms.displacementMap.value.baseTexture.off("loaded", this.boundLoadedFunction);
    }, Object.defineProperty(b.DisplacementFilter.prototype, "map", {
        get: function() {
            return this.uniforms.displacementMap.value;
        },
        set: function(a) {
            this.uniforms.displacementMap.value = a;
        }
    }), Object.defineProperty(b.DisplacementFilter.prototype, "scale", {
        get: function() {
            return this.uniforms.scale.value;
        },
        set: function(a) {
            this.uniforms.scale.value = a;
        }
    }), Object.defineProperty(b.DisplacementFilter.prototype, "offset", {
        get: function() {
            return this.uniforms.offset.value;
        },
        set: function(a) {
            this.uniforms.offset.value = a;
        }
    }), b.PixelateFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            invert: {
                type: "1f",
                value: 0
            },
            dimensions: {
                type: "4fv",
                value: new b.Float32Array([ 1e4, 100, 10, 10 ])
            },
            pixelSize: {
                type: "2f",
                value: {
                    x: 10,
                    y: 10
                }
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 testDim;", "uniform vec4 dimensions;", "uniform vec2 pixelSize;", "uniform sampler2D uSampler;", "void main(void) {", "   vec2 coord = vTextureCoord;", "   vec2 size = dimensions.xy/pixelSize;", "   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;", "   gl_FragColor = texture2D(uSampler, color);", "}" ];
    }, b.PixelateFilter.prototype = Object.create(b.AbstractFilter.prototype), b.PixelateFilter.prototype.constructor = b.PixelateFilter, 
    Object.defineProperty(b.PixelateFilter.prototype, "size", {
        get: function() {
            return this.uniforms.pixelSize.value;
        },
        set: function(a) {
            this.dirty = !0, this.uniforms.pixelSize.value = a;
        }
    }), b.BlurXFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            blur: {
                type: "1f",
                value: 1 / 512
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;", "   gl_FragColor = sum;", "}" ];
    }, b.BlurXFilter.prototype = Object.create(b.AbstractFilter.prototype), b.BlurXFilter.prototype.constructor = b.BlurXFilter, 
    Object.defineProperty(b.BlurXFilter.prototype, "blur", {
        get: function() {
            return this.uniforms.blur.value / (1 / 7e3);
        },
        set: function(a) {
            this.dirty = !0, this.uniforms.blur.value = 1 / 7e3 * a;
        }
    }), b.BlurYFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            blur: {
                type: "1f",
                value: 1 / 512
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "   vec4 sum = vec4(0.0);", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;", "   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;", "   gl_FragColor = sum;", "}" ];
    }, b.BlurYFilter.prototype = Object.create(b.AbstractFilter.prototype), b.BlurYFilter.prototype.constructor = b.BlurYFilter, 
    Object.defineProperty(b.BlurYFilter.prototype, "blur", {
        get: function() {
            return this.uniforms.blur.value / (1 / 7e3);
        },
        set: function(a) {
            this.uniforms.blur.value = 1 / 7e3 * a;
        }
    }), b.BlurFilter = function() {
        this.blurXFilter = new b.BlurXFilter(), this.blurYFilter = new b.BlurYFilter(), 
        this.passes = [ this.blurXFilter, this.blurYFilter ];
    }, b.BlurFilter.prototype = Object.create(b.AbstractFilter.prototype), b.BlurFilter.prototype.constructor = b.BlurFilter, 
    Object.defineProperty(b.BlurFilter.prototype, "blur", {
        get: function() {
            return this.blurXFilter.blur;
        },
        set: function(a) {
            this.blurXFilter.blur = this.blurYFilter.blur = a;
        }
    }), Object.defineProperty(b.BlurFilter.prototype, "blurX", {
        get: function() {
            return this.blurXFilter.blur;
        },
        set: function(a) {
            this.blurXFilter.blur = a;
        }
    }), Object.defineProperty(b.BlurFilter.prototype, "blurY", {
        get: function() {
            return this.blurYFilter.blur;
        },
        set: function(a) {
            this.blurYFilter.blur = a;
        }
    }), b.InvertFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            invert: {
                type: "1f",
                value: 1
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float invert;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);", "}" ];
    }, b.InvertFilter.prototype = Object.create(b.AbstractFilter.prototype), b.InvertFilter.prototype.constructor = b.InvertFilter, 
    Object.defineProperty(b.InvertFilter.prototype, "invert", {
        get: function() {
            return this.uniforms.invert.value;
        },
        set: function(a) {
            this.uniforms.invert.value = a;
        }
    }), b.SepiaFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            sepia: {
                type: "1f",
                value: 1
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float sepia;", "uniform sampler2D uSampler;", "const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);", "}" ];
    }, b.SepiaFilter.prototype = Object.create(b.AbstractFilter.prototype), b.SepiaFilter.prototype.constructor = b.SepiaFilter, 
    Object.defineProperty(b.SepiaFilter.prototype, "sepia", {
        get: function() {
            return this.uniforms.sepia.value;
        },
        set: function(a) {
            this.uniforms.sepia.value = a;
        }
    }), b.TwistFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            radius: {
                type: "1f",
                value: .5
            },
            angle: {
                type: "1f",
                value: 5
            },
            offset: {
                type: "2f",
                value: {
                    x: .5,
                    y: .5
                }
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "uniform float radius;", "uniform float angle;", "uniform vec2 offset;", "void main(void) {", "   vec2 coord = vTextureCoord - offset;", "   float distance = length(coord);", "   if (distance < radius) {", "       float ratio = (radius - distance) / radius;", "       float angleMod = ratio * ratio * angle;", "       float s = sin(angleMod);", "       float c = cos(angleMod);", "       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);", "   }", "   gl_FragColor = texture2D(uSampler, coord+offset);", "}" ];
    }, b.TwistFilter.prototype = Object.create(b.AbstractFilter.prototype), b.TwistFilter.prototype.constructor = b.TwistFilter, 
    Object.defineProperty(b.TwistFilter.prototype, "offset", {
        get: function() {
            return this.uniforms.offset.value;
        },
        set: function(a) {
            this.dirty = !0, this.uniforms.offset.value = a;
        }
    }), Object.defineProperty(b.TwistFilter.prototype, "radius", {
        get: function() {
            return this.uniforms.radius.value;
        },
        set: function(a) {
            this.dirty = !0, this.uniforms.radius.value = a;
        }
    }), Object.defineProperty(b.TwistFilter.prototype, "angle", {
        get: function() {
            return this.uniforms.angle.value;
        },
        set: function(a) {
            this.dirty = !0, this.uniforms.angle.value = a;
        }
    }), b.ColorStepFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            step: {
                type: "1f",
                value: 5
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform float step;", "void main(void) {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   color = floor(color * step) / step;", "   gl_FragColor = color;", "}" ];
    }, b.ColorStepFilter.prototype = Object.create(b.AbstractFilter.prototype), b.ColorStepFilter.prototype.constructor = b.ColorStepFilter, 
    Object.defineProperty(b.ColorStepFilter.prototype, "step", {
        get: function() {
            return this.uniforms.step.value;
        },
        set: function(a) {
            this.uniforms.step.value = a;
        }
    }), b.DotScreenFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            scale: {
                type: "1f",
                value: 1
            },
            angle: {
                type: "1f",
                value: 5
            },
            dimensions: {
                type: "4fv",
                value: [ 0, 0, 0, 0 ]
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "uniform float angle;", "uniform float scale;", "float pattern() {", "   float s = sin(angle), c = cos(angle);", "   vec2 tex = vTextureCoord * dimensions.xy;", "   vec2 point = vec2(", "       c * tex.x - s * tex.y,", "       s * tex.x + c * tex.y", "   ) * scale;", "   return (sin(point.x) * sin(point.y)) * 4.0;", "}", "void main() {", "   vec4 color = texture2D(uSampler, vTextureCoord);", "   float average = (color.r + color.g + color.b) / 3.0;", "   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);", "}" ];
    }, b.DotScreenFilter.prototype = Object.create(b.AbstractFilter.prototype), b.DotScreenFilter.prototype.constructor = b.DotScreenFilter, 
    Object.defineProperty(b.DotScreenFilter.prototype, "scale", {
        get: function() {
            return this.uniforms.scale.value;
        },
        set: function(a) {
            this.dirty = !0, this.uniforms.scale.value = a;
        }
    }), Object.defineProperty(b.DotScreenFilter.prototype, "angle", {
        get: function() {
            return this.uniforms.angle.value;
        },
        set: function(a) {
            this.dirty = !0, this.uniforms.angle.value = a;
        }
    }), b.CrossHatchFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            blur: {
                type: "1f",
                value: 1 / 512
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform float blur;", "uniform sampler2D uSampler;", "void main(void) {", "    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);", "    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);", "    if (lum < 1.00) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.75) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.50) {", "        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "    if (lum < 0.3) {", "        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);", "        }", "    }", "}" ];
    }, b.CrossHatchFilter.prototype = Object.create(b.AbstractFilter.prototype), b.CrossHatchFilter.prototype.constructor = b.CrossHatchFilter, 
    Object.defineProperty(b.CrossHatchFilter.prototype, "blur", {
        get: function() {
            return this.uniforms.blur.value / (1 / 7e3);
        },
        set: function(a) {
            this.uniforms.blur.value = 1 / 7e3 * a;
        }
    }), b.RGBSplitFilter = function() {
        b.AbstractFilter.call(this), this.passes = [ this ], this.uniforms = {
            red: {
                type: "2f",
                value: {
                    x: 20,
                    y: 20
                }
            },
            green: {
                type: "2f",
                value: {
                    x: -20,
                    y: 20
                }
            },
            blue: {
                type: "2f",
                value: {
                    x: 20,
                    y: -20
                }
            },
            dimensions: {
                type: "4fv",
                value: [ 0, 0, 0, 0 ]
            }
        }, this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform vec2 red;", "uniform vec2 green;", "uniform vec2 blue;", "uniform vec4 dimensions;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;", "   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;", "   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;", "   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;", "}" ];
    }, b.RGBSplitFilter.prototype = Object.create(b.AbstractFilter.prototype), b.RGBSplitFilter.prototype.constructor = b.RGBSplitFilter, 
    Object.defineProperty(b.RGBSplitFilter.prototype, "red", {
        get: function() {
            return this.uniforms.red.value;
        },
        set: function(a) {
            this.uniforms.red.value = a;
        }
    }), Object.defineProperty(b.RGBSplitFilter.prototype, "green", {
        get: function() {
            return this.uniforms.green.value;
        },
        set: function(a) {
            this.uniforms.green.value = a;
        }
    }), Object.defineProperty(b.RGBSplitFilter.prototype, "blue", {
        get: function() {
            return this.uniforms.blue.value;
        },
        set: function(a) {
            this.uniforms.blue.value = a;
        }
    }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = b), 
    exports.PIXI = b) : "undefined" != typeof define && define.amd ? define(b) : a.PIXI = b;
}).call(this), this.createjs = this.createjs || {}, function() {
    var a = createjs.PreloadJS = createjs.PreloadJS || {};
    a.version = "0.6.0", a.buildDate = "Thu, 11 Dec 2014 23:32:09 GMT";
}(), this.createjs = this.createjs || {}, createjs.extend = function(a, b) {
    function c() {
        this.constructor = a;
    }
    return c.prototype = b.prototype, a.prototype = new c();
}, this.createjs = this.createjs || {}, createjs.promote = function(a, b) {
    var c = a.prototype, d = Object.getPrototypeOf && Object.getPrototypeOf(c) || c.__proto__;
    if (d) {
        c[(b += "_") + "constructor"] = d.constructor;
        for (var e in d) c.hasOwnProperty(e) && "function" == typeof d[e] && (c[b + e] = d[e]);
    }
    return a;
}, this.createjs = this.createjs || {}, createjs.indexOf = function(a, b) {
    for (var c = 0, d = a.length; d > c; c++) if (b === a[c]) return c;
    return -1;
}, this.createjs = this.createjs || {}, function() {
    createjs.proxy = function(a, b) {
        var c = Array.prototype.slice.call(arguments, 2);
        return function() {
            return a.apply(b, Array.prototype.slice.call(arguments, 0).concat(c));
        };
    };
}(), this.createjs = this.createjs || {}, function() {
    function a() {
        throw "BrowserDetect cannot be instantiated";
    }
    var b = a.agent = window.navigator.userAgent;
    a.isWindowPhone = b.indexOf("IEMobile") > -1 || b.indexOf("Windows Phone") > -1, 
    a.isFirefox = b.indexOf("Firefox") > -1, a.isOpera = null != window.opera, a.isChrome = b.indexOf("Chrome") > -1, 
    a.isIOS = (b.indexOf("iPod") > -1 || b.indexOf("iPhone") > -1 || b.indexOf("iPad") > -1) && !a.isWindowPhone, 
    a.isAndroid = b.indexOf("Android") > -1 && !a.isWindowPhone, a.isBlackberry = b.indexOf("Blackberry") > -1, 
    createjs.BrowserDetect = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.type = a, this.target = null, this.currentTarget = null, this.eventPhase = 0, 
        this.bubbles = !!b, this.cancelable = !!c, this.timeStamp = new Date().getTime(), 
        this.defaultPrevented = !1, this.propagationStopped = !1, this.immediatePropagationStopped = !1, 
        this.removed = !1;
    }
    var b = a.prototype;
    b.preventDefault = function() {
        this.defaultPrevented = this.cancelable && !0;
    }, b.stopPropagation = function() {
        this.propagationStopped = !0;
    }, b.stopImmediatePropagation = function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
    }, b.remove = function() {
        this.removed = !0;
    }, b.clone = function() {
        return new a(this.type, this.bubbles, this.cancelable);
    }, b.set = function(a) {
        for (var b in a) this[b] = a[b];
        return this;
    }, b.toString = function() {
        return "[Event (type=" + this.type + ")]";
    }, createjs.Event = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.Event_constructor("error"), this.title = a, this.message = b, this.data = c;
    }
    var b = createjs.extend(a, createjs.Event);
    b.clone = function() {
        return new createjs.ErrorEvent(this.title, this.message, this.data);
    }, createjs.ErrorEvent = createjs.promote(a, "Event");
}(), this.createjs = this.createjs || {}, function() {
    function a() {
        this._listeners = null, this._captureListeners = null;
    }
    var b = a.prototype;
    a.initialize = function(a) {
        a.addEventListener = b.addEventListener, a.on = b.on, a.removeEventListener = a.off = b.removeEventListener, 
        a.removeAllEventListeners = b.removeAllEventListeners, a.hasEventListener = b.hasEventListener, 
        a.dispatchEvent = b.dispatchEvent, a._dispatchEvent = b._dispatchEvent, a.willTrigger = b.willTrigger;
    }, b.addEventListener = function(a, b, c) {
        var d;
        d = c ? this._captureListeners = this._captureListeners || {} : this._listeners = this._listeners || {};
        var e = d[a];
        return e && this.removeEventListener(a, b, c), e = d[a], e ? e.push(b) : d[a] = [ b ], 
        b;
    }, b.on = function(a, b, c, d, e, f) {
        return b.handleEvent && (c = c || b, b = b.handleEvent), c = c || this, this.addEventListener(a, function(a) {
            b.call(c, a, e), d && a.remove();
        }, f);
    }, b.removeEventListener = function(a, b, c) {
        var d = c ? this._captureListeners : this._listeners;
        if (d) {
            var e = d[a];
            if (e) for (var f = 0, g = e.length; g > f; f++) if (e[f] == b) {
                1 == g ? delete d[a] : e.splice(f, 1);
                break;
            }
        }
    }, b.off = b.removeEventListener, b.removeAllEventListeners = function(a) {
        a ? (this._listeners && delete this._listeners[a], this._captureListeners && delete this._captureListeners[a]) : this._listeners = this._captureListeners = null;
    }, b.dispatchEvent = function(a) {
        if ("string" == typeof a) {
            var b = this._listeners;
            if (!b || !b[a]) return !1;
            a = new createjs.Event(a);
        } else a.target && a.clone && (a = a.clone());
        try {
            a.target = this;
        } catch (c) {}
        if (a.bubbles && this.parent) {
            for (var d = this, e = [ d ]; d.parent; ) e.push(d = d.parent);
            var f, g = e.length;
            for (f = g - 1; f >= 0 && !a.propagationStopped; f--) e[f]._dispatchEvent(a, 1 + (0 == f));
            for (f = 1; g > f && !a.propagationStopped; f++) e[f]._dispatchEvent(a, 3);
        } else this._dispatchEvent(a, 2);
        return a.defaultPrevented;
    }, b.hasEventListener = function(a) {
        var b = this._listeners, c = this._captureListeners;
        return !!(b && b[a] || c && c[a]);
    }, b.willTrigger = function(a) {
        for (var b = this; b; ) {
            if (b.hasEventListener(a)) return !0;
            b = b.parent;
        }
        return !1;
    }, b.toString = function() {
        return "[EventDispatcher]";
    }, b._dispatchEvent = function(a, b) {
        var c, d = 1 == b ? this._captureListeners : this._listeners;
        if (a && d) {
            var e = d[a.type];
            if (!e || !(c = e.length)) return;
            try {
                a.currentTarget = this;
            } catch (f) {}
            try {
                a.eventPhase = b;
            } catch (f) {}
            a.removed = !1, e = e.slice();
            for (var g = 0; c > g && !a.immediatePropagationStopped; g++) {
                var h = e[g];
                h.handleEvent ? h.handleEvent(a) : h(a), a.removed && (this.off(a.type, h, 1 == b), 
                a.removed = !1);
            }
        }
    }, createjs.EventDispatcher = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.Event_constructor("progress"), this.loaded = a, this.total = null == b ? 1 : b, 
        this.progress = 0 == b ? 0 : this.loaded / this.total;
    }
    var b = createjs.extend(a, createjs.Event);
    b.clone = function() {
        return new createjs.ProgressEvent(this.loaded, this.total);
    }, createjs.ProgressEvent = createjs.promote(a, "Event");
}(window), function() {
    function a(b, d) {
        function f(a) {
            if (f[a] !== q) return f[a];
            var b;
            if ("bug-string-char-index" == a) b = "a" != "a"[0]; else if ("json" == a) b = f("json-stringify") && f("json-parse"); else {
                var c, e = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                if ("json-stringify" == a) {
                    var i = d.stringify, k = "function" == typeof i && t;
                    if (k) {
                        (c = function() {
                            return 1;
                        }).toJSON = c;
                        try {
                            k = "0" === i(0) && "0" === i(new g()) && '""' == i(new h()) && i(s) === q && i(q) === q && i() === q && "1" === i(c) && "[1]" == i([ c ]) && "[null]" == i([ q ]) && "null" == i(null) && "[null,null,null]" == i([ q, s, null ]) && i({
                                a: [ c, !0, !1, null, "\x00\b\n\f\r	" ]
                            }) == e && "1" === i(null, c) && "[\n 1,\n 2\n]" == i([ 1, 2 ], null, 1) && '"-271821-04-20T00:00:00.000Z"' == i(new j(-864e13)) && '"+275760-09-13T00:00:00.000Z"' == i(new j(864e13)) && '"-000001-01-01T00:00:00.000Z"' == i(new j(-621987552e5)) && '"1969-12-31T23:59:59.999Z"' == i(new j(-1));
                        } catch (l) {
                            k = !1;
                        }
                    }
                    b = k;
                }
                if ("json-parse" == a) {
                    var m = d.parse;
                    if ("function" == typeof m) try {
                        if (0 === m("0") && !m(!1)) {
                            c = m(e);
                            var n = 5 == c.a.length && 1 === c.a[0];
                            if (n) {
                                try {
                                    n = !m('"	"');
                                } catch (l) {}
                                if (n) try {
                                    n = 1 !== m("01");
                                } catch (l) {}
                                if (n) try {
                                    n = 1 !== m("1.");
                                } catch (l) {}
                            }
                        }
                    } catch (l) {
                        n = !1;
                    }
                    b = n;
                }
            }
            return f[a] = !!b;
        }
        b || (b = e.Object()), d || (d = e.Object());
        var g = b.Number || e.Number, h = b.String || e.String, i = b.Object || e.Object, j = b.Date || e.Date, k = b.SyntaxError || e.SyntaxError, l = b.TypeError || e.TypeError, m = b.Math || e.Math, n = b.JSON || e.JSON;
        "object" == typeof n && n && (d.stringify = n.stringify, d.parse = n.parse);
        var o, p, q, r = i.prototype, s = r.toString, t = new j(-0xc782b5b800cec);
        try {
            t = -109252 == t.getUTCFullYear() && 0 === t.getUTCMonth() && 1 === t.getUTCDate() && 10 == t.getUTCHours() && 37 == t.getUTCMinutes() && 6 == t.getUTCSeconds() && 708 == t.getUTCMilliseconds();
        } catch (u) {}
        if (!f("json")) {
            var v = "[object Function]", w = "[object Date]", x = "[object Number]", y = "[object String]", z = "[object Array]", A = "[object Boolean]", B = f("bug-string-char-index");
            if (!t) var C = m.floor, D = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], E = function(a, b) {
                return D[b] + 365 * (a - 1970) + C((a - 1969 + (b = +(b > 1))) / 4) - C((a - 1901 + b) / 100) + C((a - 1601 + b) / 400);
            };
            if ((o = r.hasOwnProperty) || (o = function(a) {
                var b, c = {};
                return (c.__proto__ = null, c.__proto__ = {
                    toString: 1
                }, c).toString != s ? o = function(a) {
                    var b = this.__proto__, c = a in (this.__proto__ = null, this);
                    return this.__proto__ = b, c;
                } : (b = c.constructor, o = function(a) {
                    var c = (this.constructor || b).prototype;
                    return a in this && !(a in c && this[a] === c[a]);
                }), c = null, o.call(this, a);
            }), p = function(a, b) {
                var d, e, f, g = 0;
                (d = function() {
                    this.valueOf = 0;
                }).prototype.valueOf = 0, e = new d();
                for (f in e) o.call(e, f) && g++;
                return d = e = null, g ? p = 2 == g ? function(a, b) {
                    var c, d = {}, e = s.call(a) == v;
                    for (c in a) e && "prototype" == c || o.call(d, c) || !(d[c] = 1) || !o.call(a, c) || b(c);
                } : function(a, b) {
                    var c, d, e = s.call(a) == v;
                    for (c in a) e && "prototype" == c || !o.call(a, c) || (d = "constructor" === c) || b(c);
                    (d || o.call(a, c = "constructor")) && b(c);
                } : (e = [ "valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor" ], 
                p = function(a, b) {
                    var d, f, g = s.call(a) == v, h = !g && "function" != typeof a.constructor && c[typeof a.hasOwnProperty] && a.hasOwnProperty || o;
                    for (d in a) g && "prototype" == d || !h.call(a, d) || b(d);
                    for (f = e.length; d = e[--f]; h.call(a, d) && b(d)) ;
                }), p(a, b);
            }, !f("json-stringify")) {
                var F = {
                    92: "\\\\",
                    34: '\\"',
                    8: "\\b",
                    12: "\\f",
                    10: "\\n",
                    13: "\\r",
                    9: "\\t"
                }, G = "000000", H = function(a, b) {
                    return (G + (b || 0)).slice(-a);
                }, I = "\\u00", J = function(a) {
                    for (var b = '"', c = 0, d = a.length, e = !B || d > 10, f = e && (B ? a.split("") : a); d > c; c++) {
                        var g = a.charCodeAt(c);
                        switch (g) {
                          case 8:
                          case 9:
                          case 10:
                          case 12:
                          case 13:
                          case 34:
                          case 92:
                            b += F[g];
                            break;

                          default:
                            if (32 > g) {
                                b += I + H(2, g.toString(16));
                                break;
                            }
                            b += e ? f[c] : a.charAt(c);
                        }
                    }
                    return b + '"';
                }, K = function(a, b, c, d, e, f, g) {
                    var h, i, j, k, m, n, r, t, u, v, B, D, F, G, I, L;
                    try {
                        h = b[a];
                    } catch (M) {}
                    if ("object" == typeof h && h) if (i = s.call(h), i != w || o.call(h, "toJSON")) "function" == typeof h.toJSON && (i != x && i != y && i != z || o.call(h, "toJSON")) && (h = h.toJSON(a)); else if (h > -1 / 0 && 1 / 0 > h) {
                        if (E) {
                            for (m = C(h / 864e5), j = C(m / 365.2425) + 1970 - 1; E(j + 1, 0) <= m; j++) ;
                            for (k = C((m - E(j, 0)) / 30.42); E(j, k + 1) <= m; k++) ;
                            m = 1 + m - E(j, k), n = (h % 864e5 + 864e5) % 864e5, r = C(n / 36e5) % 24, t = C(n / 6e4) % 60, 
                            u = C(n / 1e3) % 60, v = n % 1e3;
                        } else j = h.getUTCFullYear(), k = h.getUTCMonth(), m = h.getUTCDate(), r = h.getUTCHours(), 
                        t = h.getUTCMinutes(), u = h.getUTCSeconds(), v = h.getUTCMilliseconds();
                        h = (0 >= j || j >= 1e4 ? (0 > j ? "-" : "+") + H(6, 0 > j ? -j : j) : H(4, j)) + "-" + H(2, k + 1) + "-" + H(2, m) + "T" + H(2, r) + ":" + H(2, t) + ":" + H(2, u) + "." + H(3, v) + "Z";
                    } else h = null;
                    if (c && (h = c.call(b, a, h)), null === h) return "null";
                    if (i = s.call(h), i == A) return "" + h;
                    if (i == x) return h > -1 / 0 && 1 / 0 > h ? "" + h : "null";
                    if (i == y) return J("" + h);
                    if ("object" == typeof h) {
                        for (G = g.length; G--; ) if (g[G] === h) throw l();
                        if (g.push(h), B = [], I = f, f += e, i == z) {
                            for (F = 0, G = h.length; G > F; F++) D = K(F, h, c, d, e, f, g), B.push(D === q ? "null" : D);
                            L = B.length ? e ? "[\n" + f + B.join(",\n" + f) + "\n" + I + "]" : "[" + B.join(",") + "]" : "[]";
                        } else p(d || h, function(a) {
                            var b = K(a, h, c, d, e, f, g);
                            b !== q && B.push(J(a) + ":" + (e ? " " : "") + b);
                        }), L = B.length ? e ? "{\n" + f + B.join(",\n" + f) + "\n" + I + "}" : "{" + B.join(",") + "}" : "{}";
                        return g.pop(), L;
                    }
                };
                d.stringify = function(a, b, d) {
                    var e, f, g, h;
                    if (c[typeof b] && b) if ((h = s.call(b)) == v) f = b; else if (h == z) {
                        g = {};
                        for (var i, j = 0, k = b.length; k > j; i = b[j++], h = s.call(i), (h == y || h == x) && (g[i] = 1)) ;
                    }
                    if (d) if ((h = s.call(d)) == x) {
                        if ((d -= d % 1) > 0) for (e = "", d > 10 && (d = 10); e.length < d; e += " ") ;
                    } else h == y && (e = d.length <= 10 ? d : d.slice(0, 10));
                    return K("", (i = {}, i[""] = a, i), f, g, e, "", []);
                };
            }
            if (!f("json-parse")) {
                var L, M, N = h.fromCharCode, O = {
                    92: "\\",
                    34: '"',
                    47: "/",
                    98: "\b",
                    116: "	",
                    110: "\n",
                    102: "\f",
                    114: "\r"
                }, P = function() {
                    throw L = M = null, k();
                }, Q = function() {
                    for (var a, b, c, d, e, f = M, g = f.length; g > L; ) switch (e = f.charCodeAt(L)) {
                      case 9:
                      case 10:
                      case 13:
                      case 32:
                        L++;
                        break;

                      case 123:
                      case 125:
                      case 91:
                      case 93:
                      case 58:
                      case 44:
                        return a = B ? f.charAt(L) : f[L], L++, a;

                      case 34:
                        for (a = "@", L++; g > L; ) if (e = f.charCodeAt(L), 32 > e) P(); else if (92 == e) switch (e = f.charCodeAt(++L)) {
                          case 92:
                          case 34:
                          case 47:
                          case 98:
                          case 116:
                          case 110:
                          case 102:
                          case 114:
                            a += O[e], L++;
                            break;

                          case 117:
                            for (b = ++L, c = L + 4; c > L; L++) e = f.charCodeAt(L), e >= 48 && 57 >= e || e >= 97 && 102 >= e || e >= 65 && 70 >= e || P();
                            a += N("0x" + f.slice(b, L));
                            break;

                          default:
                            P();
                        } else {
                            if (34 == e) break;
                            for (e = f.charCodeAt(L), b = L; e >= 32 && 92 != e && 34 != e; ) e = f.charCodeAt(++L);
                            a += f.slice(b, L);
                        }
                        if (34 == f.charCodeAt(L)) return L++, a;
                        P();

                      default:
                        if (b = L, 45 == e && (d = !0, e = f.charCodeAt(++L)), e >= 48 && 57 >= e) {
                            for (48 == e && (e = f.charCodeAt(L + 1), e >= 48 && 57 >= e) && P(), d = !1; g > L && (e = f.charCodeAt(L), 
                            e >= 48 && 57 >= e); L++) ;
                            if (46 == f.charCodeAt(L)) {
                                for (c = ++L; g > c && (e = f.charCodeAt(c), e >= 48 && 57 >= e); c++) ;
                                c == L && P(), L = c;
                            }
                            if (e = f.charCodeAt(L), 101 == e || 69 == e) {
                                for (e = f.charCodeAt(++L), (43 == e || 45 == e) && L++, c = L; g > c && (e = f.charCodeAt(c), 
                                e >= 48 && 57 >= e); c++) ;
                                c == L && P(), L = c;
                            }
                            return +f.slice(b, L);
                        }
                        if (d && P(), "true" == f.slice(L, L + 4)) return L += 4, !0;
                        if ("false" == f.slice(L, L + 5)) return L += 5, !1;
                        if ("null" == f.slice(L, L + 4)) return L += 4, null;
                        P();
                    }
                    return "$";
                }, R = function(a) {
                    var b, c;
                    if ("$" == a && P(), "string" == typeof a) {
                        if ("@" == (B ? a.charAt(0) : a[0])) return a.slice(1);
                        if ("[" == a) {
                            for (b = []; a = Q(), "]" != a; c || (c = !0)) c && ("," == a ? (a = Q(), "]" == a && P()) : P()), 
                            "," == a && P(), b.push(R(a));
                            return b;
                        }
                        if ("{" == a) {
                            for (b = {}; a = Q(), "}" != a; c || (c = !0)) c && ("," == a ? (a = Q(), "}" == a && P()) : P()), 
                            ("," == a || "string" != typeof a || "@" != (B ? a.charAt(0) : a[0]) || ":" != Q()) && P(), 
                            b[a.slice(1)] = R(Q());
                            return b;
                        }
                        P();
                    }
                    return a;
                }, S = function(a, b, c) {
                    var d = T(a, b, c);
                    d === q ? delete a[b] : a[b] = d;
                }, T = function(a, b, c) {
                    var d, e = a[b];
                    if ("object" == typeof e && e) if (s.call(e) == z) for (d = e.length; d--; ) S(e, d, c); else p(e, function(a) {
                        S(e, a, c);
                    });
                    return c.call(a, b, e);
                };
                d.parse = function(a, b) {
                    var c, d;
                    return L = 0, M = "" + a, c = R(Q()), "$" != Q() && P(), L = M = null, b && s.call(b) == v ? T((d = {}, 
                    d[""] = c, d), "", b) : c;
                };
            }
        }
        return d.runInContext = a, d;
    }
    var b = "function" == typeof define && define.amd, c = {
        "function": !0,
        object: !0
    }, d = c[typeof exports] && exports && !exports.nodeType && exports, e = c[typeof window] && window || this, f = d && c[typeof module] && module && !module.nodeType && "object" == typeof global && global;
    if (!f || f.global !== f && f.window !== f && f.self !== f || (e = f), d && !b) a(e, d); else {
        var g = e.JSON, h = e.JSON3, i = !1, j = a(e, e.JSON3 = {
            noConflict: function() {
                return i || (i = !0, e.JSON = g, e.JSON3 = h, g = h = null), j;
            }
        });
        e.JSON = {
            parse: j.parse,
            stringify: j.stringify
        };
    }
    b && define(function() {
        return j;
    });
}.call(this), function() {
    var a = {};
    a.parseXML = function(a, b) {
        var c = null;
        try {
            if (window.DOMParser) {
                var d = new DOMParser();
                c = d.parseFromString(a, b);
            } else c = new ActiveXObject("Microsoft.XMLDOM"), c.async = !1, c.loadXML(a);
        } catch (e) {}
        return c;
    }, a.parseJSON = function(a) {
        if (null == a) return null;
        try {
            return JSON.parse(a);
        } catch (b) {
            throw b;
        }
    }, createjs.DataUtils = a;
}(), this.createjs = this.createjs || {}, function() {
    function a() {
        this.src = null, this.type = null, this.id = null, this.maintainOrder = !1, this.callback = null, 
        this.data = null, this.method = createjs.LoadItem.GET, this.values = null, this.headers = null, 
        this.withCredentials = !1, this.mimeType = null, this.crossOrigin = null, this.loadTimeout = 8e3;
    }
    var b = a.prototype = {}, c = a;
    c.create = function(b) {
        if ("string" == typeof b) {
            var d = new a();
            return d.src = b, d;
        }
        if (b instanceof c) return b;
        if (b instanceof Object) return b;
        throw new Error("Type not recognized.");
    }, b.set = function(a) {
        for (var b in a) this[b] = a[b];
        return this;
    }, createjs.LoadItem = c;
}(), function() {
    var a = {};
    a.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i, a.RELATIVE_PATT = /^[./]*?\//i, a.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i, 
    a.parseURI = function(b) {
        var c = {
            absolute: !1,
            relative: !1
        };
        if (null == b) return c;
        var d = b.indexOf("?");
        d > -1 && (b = b.substr(0, d));
        var e;
        return a.ABSOLUTE_PATT.test(b) ? c.absolute = !0 : a.RELATIVE_PATT.test(b) && (c.relative = !0), 
        (e = b.match(a.EXTENSION_PATT)) && (c.extension = e[1].toLowerCase()), c;
    }, a.formatQueryString = function(a, b) {
        if (null == a) throw new Error("You must specify data.");
        var c = [];
        for (var d in a) c.push(d + "=" + escape(a[d]));
        return b && (c = c.concat(b)), c.join("&");
    }, a.buildPath = function(a, b) {
        if (null == b) return a;
        var c = [], d = a.indexOf("?");
        if (-1 != d) {
            var e = a.slice(d + 1);
            c = c.concat(e.split("&"));
        }
        return -1 != d ? a.slice(0, d) + "?" + this._formatQueryString(b, c) : a + "?" + this._formatQueryString(b, c);
    }, a.isCrossDomain = function(a) {
        var b = document.createElement("a");
        b.href = a.src;
        var c = document.createElement("a");
        c.href = location.href;
        var d = "" != b.hostname && (b.port != c.port || b.protocol != c.protocol || b.hostname != c.hostname);
        return d;
    }, a.isLocal = function(a) {
        var b = document.createElement("a");
        return b.href = a.src, "" == b.hostname && "file:" == b.protocol;
    }, a.isBinary = function(a) {
        switch (a) {
          case createjs.AbstractLoader.IMAGE:
          case createjs.AbstractLoader.BINARY:
            return !0;

          default:
            return !1;
        }
    }, a.isImageTag = function(a) {
        return a instanceof HTMLImageElement;
    }, a.isAudioTag = function(a) {
        return window.HTMLAudioElement ? a instanceof HTMLAudioElement : !1;
    }, a.isVideoTag = function(a) {
        return window.HTMLVideoElement ? a instanceof HTMLVideoElement : void 0;
    }, a.isText = function(a) {
        switch (a) {
          case createjs.AbstractLoader.TEXT:
          case createjs.AbstractLoader.JSON:
          case createjs.AbstractLoader.MANIFEST:
          case createjs.AbstractLoader.XML:
          case createjs.AbstractLoader.CSS:
          case createjs.AbstractLoader.SVG:
          case createjs.AbstractLoader.JAVASCRIPT:
            return !0;

          default:
            return !1;
        }
    }, a.getTypeByExtension = function(a) {
        if (null == a) return createjs.AbstractLoader.TEXT;
        switch (a.toLowerCase()) {
          case "jpeg":
          case "jpg":
          case "gif":
          case "png":
          case "webp":
          case "bmp":
            return createjs.AbstractLoader.IMAGE;

          case "ogg":
          case "mp3":
          case "webm":
            return createjs.AbstractLoader.SOUND;

          case "mp4":
          case "webm":
          case "ts":
            return createjs.AbstractLoader.VIDEO;

          case "json":
            return createjs.AbstractLoader.JSON;

          case "xml":
            return createjs.AbstractLoader.XML;

          case "css":
            return createjs.AbstractLoader.CSS;

          case "js":
            return createjs.AbstractLoader.JAVASCRIPT;

          case "svg":
            return createjs.AbstractLoader.SVG;

          default:
            return createjs.AbstractLoader.TEXT;
        }
    }, createjs.RequestUtils = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.EventDispatcher_constructor(), this.loaded = !1, this.canceled = !1, this.progress = 0, 
        this.type = c, this.resultFormatter = null, this._item = a ? createjs.LoadItem.create(a) : null, 
        this._preferXHR = b, this._result = null, this._rawResult = null, this._loadedItems = null, 
        this._tagSrcAttribute = null, this._tag = null;
    }
    var b = createjs.extend(a, createjs.EventDispatcher), c = a;
    c.POST = "POST", c.GET = "GET", c.BINARY = "binary", c.CSS = "css", c.IMAGE = "image", 
    c.JAVASCRIPT = "javascript", c.JSON = "json", c.JSONP = "jsonp", c.MANIFEST = "manifest", 
    c.SOUND = "sound", c.VIDEO = "video", c.SPRITESHEET = "spritesheet", c.SVG = "svg", 
    c.TEXT = "text", c.XML = "xml", b.getItem = function() {
        return this._item;
    }, b.getResult = function(a) {
        return a ? this._rawResult : this._result;
    }, b.getTag = function() {
        return this._tag;
    }, b.setTag = function(a) {
        this._tag = a;
    }, b.load = function() {
        this._createRequest(), this._request.on("complete", this, this), this._request.on("progress", this, this), 
        this._request.on("loadStart", this, this), this._request.on("abort", this, this), 
        this._request.on("timeout", this, this), this._request.on("error", this, this);
        var a = new createjs.Event("initialize");
        a.loader = this._request, this.dispatchEvent(a), this._request.load();
    }, b.cancel = function() {
        this.canceled = !0, this.destroy();
    }, b.destroy = function() {
        this._request && (this._request.removeAllEventListeners(), this._request.destroy()), 
        this._request = null, this._item = null, this._rawResult = null, this._result = null, 
        this._loadItems = null, this.removeAllEventListeners();
    }, b.getLoadedItems = function() {
        return this._loadedItems;
    }, b._createRequest = function() {
        this._request = this._preferXHR ? new createjs.XHRRequest(this._item) : new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
    }, b._createTag = function() {
        return null;
    }, b._sendLoadStart = function() {
        this._isCanceled() || this.dispatchEvent("loadstart");
    }, b._sendProgress = function(a) {
        if (!this._isCanceled()) {
            var b = null;
            "number" == typeof a ? (this.progress = a, b = new createjs.ProgressEvent(this.progress)) : (b = a, 
            this.progress = a.loaded / a.total, b.progress = this.progress, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0)), 
            this.hasEventListener("progress") && this.dispatchEvent(b);
        }
    }, b._sendComplete = function() {
        if (!this._isCanceled()) {
            this.loaded = !0;
            var a = new createjs.Event("complete");
            a.rawResult = this._rawResult, null != this._result && (a.result = this._result), 
            this.dispatchEvent(a);
        }
    }, b._sendError = function(a) {
        !this._isCanceled() && this.hasEventListener("error") && (null == a && (a = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY")), 
        this.dispatchEvent(a));
    }, b._isCanceled = function() {
        return null == window.createjs || this.canceled ? !0 : !1;
    }, b.resultFormatter = null, b.handleEvent = function(a) {
        switch (a.type) {
          case "complete":
            this._rawResult = a.target._response;
            var b = this.resultFormatter && this.resultFormatter(this), c = this;
            b instanceof Function ? b(function(a) {
                c._result = a, c._sendComplete();
            }) : (this._result = b || this._rawResult, this._sendComplete());
            break;

          case "progress":
            this._sendProgress(a);
            break;

          case "error":
            this._sendError(a);
            break;

          case "loadstart":
            this._sendLoadStart();
            break;

          case "abort":
          case "timeout":
            this._isCanceled() || this.dispatchEvent(a.type);
        }
    }, b.buildPath = function(a, b) {
        return createjs.RequestUtils.buildPath(a, b);
    }, b.toString = function() {
        return "[PreloadJS AbstractLoader]";
    }, createjs.AbstractLoader = createjs.promote(a, "EventDispatcher");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractLoader_constructor(a, b, c), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "src";
    }
    var b = createjs.extend(a, createjs.AbstractLoader);
    b.load = function() {
        this._tag || (this._tag = this._createTag(this._item.src)), this._tag.preload = "auto", 
        this._tag.load(), this.AbstractLoader_load();
    }, b._createTag = function() {}, b._createRequest = function() {
        this._request = this._preferXHR ? new createjs.XHRRequest(this._item) : new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
    }, b._formatResult = function(a) {
        return this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler), 
        this._tag.onstalled = null, this._preferXHR && (a.getTag().src = a.getResult(!0)), 
        a.getTag();
    }, createjs.AbstractMediaLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    var a = function(a) {
        this._item = a;
    }, b = createjs.extend(a, createjs.EventDispatcher);
    b.load = function() {}, b.destroy = function() {}, b.cancel = function() {}, createjs.AbstractRequest = createjs.promote(a, "EventDispatcher");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractRequest_constructor(a), this._tag = b, this._tagSrcAttribute = c, this._loadedHandler = createjs.proxy(this._handleTagComplete, this), 
        this._addedToDOM = !1, this._startTagVisibility = null;
    }
    var b = createjs.extend(a, createjs.AbstractRequest);
    b.load = function() {
        null == this._tag.parentNode && (window.document.body.appendChild(this._tag), this._addedToDOM = !0), 
        this._tag.onload = createjs.proxy(this._handleTagComplete, this), this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
        var a = new createjs.Event("initialize");
        a.loader = this._tag, this.dispatchEvent(a), this._hideTag(), this._tag[this._tagSrcAttribute] = this._item.src;
    }, b.destroy = function() {
        this._clean(), this._tag = null, this.AbstractRequest_destroy();
    }, b._handleReadyStateChange = function() {
        clearTimeout(this._loadTimeout);
        var a = this._tag;
        ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete();
    }, b._handleTagComplete = function() {
        this._rawResult = this._tag, this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult, 
        this._clean(), this._showTag(), this.dispatchEvent("complete");
    }, b._clean = function() {
        this._tag.onload = null, this._tag.onreadystatechange = null, this._addedToDOM && null != this._tag.parentNode && this._tag.parentNode.removeChild(this._tag);
    }, b._hideTag = function() {
        this._startTagVisibility = this._tag.style.visibility, this._tag.style.visibility = "hidden";
    }, b._showTag = function() {
        this._tag.style.visibility = this._startTagVisibility;
    }, b._handleStalled = function() {}, createjs.TagRequest = createjs.promote(a, "AbstractRequest");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractRequest_constructor(a), this._tag = b, this._tagSrcAttribute = c, this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
    }
    var b = createjs.extend(a, createjs.TagRequest);
    b.load = function() {
        this._tag.onstalled = createjs.proxy(this._handleStalled, this), this._tag.onprogress = createjs.proxy(this._handleProgress, this), 
        this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, !1), 
        this.TagRequest_load();
    }, b._handleReadyStateChange = function() {
        clearTimeout(this._loadTimeout);
        var a = this._tag;
        ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete();
    }, b._handleStalled = function() {}, b._handleProgress = function(a) {
        if (a && !(a.loaded > 0 && 0 == a.total)) {
            var b = new createjs.ProgressEvent(a.loaded, a.total);
            this.dispatchEvent(b);
        }
    }, b._clean = function() {
        this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler), 
        this._tag.onstalled = null, this._tag.onprogress = null, this.TagRequest__clean();
    }, createjs.MediaTagRequest = createjs.promote(a, "TagRequest");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractRequest_constructor(a), this._request = null, this._loadTimeout = null, 
        this._xhrLevel = 1, this._response = null, this._rawResponse = null, this._canceled = !1, 
        this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this), this._handleProgressProxy = createjs.proxy(this._handleProgress, this), 
        this._handleAbortProxy = createjs.proxy(this._handleAbort, this), this._handleErrorProxy = createjs.proxy(this._handleError, this), 
        this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this), this._handleLoadProxy = createjs.proxy(this._handleLoad, this), 
        this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this), 
        !this._createXHR(a);
    }
    var b = createjs.extend(a, createjs.AbstractRequest);
    a.ACTIVEX_VERSIONS = [ "Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP" ], 
    b.getResult = function(a) {
        return a && this._rawResponse ? this._rawResponse : this._response;
    }, b.cancel = function() {
        this.canceled = !0, this._clean(), this._request.abort();
    }, b.load = function() {
        if (null == this._request) return void this._handleError();
        this._request.addEventListener("loadstart", this._handleLoadStartProxy, !1), this._request.addEventListener("progress", this._handleProgressProxy, !1), 
        this._request.addEventListener("abort", this._handleAbortProxy, !1), this._request.addEventListener("error", this._handleErrorProxy, !1), 
        this._request.addEventListener("timeout", this._handleTimeoutProxy, !1), this._request.addEventListener("load", this._handleLoadProxy, !1), 
        this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, !1), 
        1 == this._xhrLevel && (this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout));
        try {
            this._item.values && this._item.method != createjs.AbstractLoader.GET ? this._item.method == createjs.AbstractLoader.POST && this._request.send(createjs.RequestUtils.formatQueryString(this._item.values)) : this._request.send();
        } catch (a) {
            this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, a));
        }
    }, b.setResponseType = function(a) {
        this._request.responseType = a;
    }, b.getAllResponseHeaders = function() {
        return this._request.getAllResponseHeaders instanceof Function ? this._request.getAllResponseHeaders() : null;
    }, b.getResponseHeader = function(a) {
        return this._request.getResponseHeader instanceof Function ? this._request.getResponseHeader(a) : null;
    }, b._handleProgress = function(a) {
        if (a && !(a.loaded > 0 && 0 == a.total)) {
            var b = new createjs.ProgressEvent(a.loaded, a.total);
            this.dispatchEvent(b);
        }
    }, b._handleLoadStart = function() {
        clearTimeout(this._loadTimeout), this.dispatchEvent("loadstart");
    }, b._handleAbort = function(a) {
        this._clean(), this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, a));
    }, b._handleError = function(a) {
        this._clean(), this.dispatchEvent(new createjs.ErrorEvent(a.message));
    }, b._handleReadyStateChange = function() {
        4 == this._request.readyState && this._handleLoad();
    }, b._handleLoad = function() {
        if (!this.loaded) {
            this.loaded = !0;
            var a = this._checkError();
            if (a) return void this._handleError(a);
            this._response = this._getResponse(), this._clean(), this.dispatchEvent(new createjs.Event("complete"));
        }
    }, b._handleTimeout = function(a) {
        this._clean(), this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, a));
    }, b._checkError = function() {
        var a = parseInt(this._request.status);
        switch (a) {
          case 404:
          case 0:
            return new Error(a);
        }
        return null;
    }, b._getResponse = function() {
        if (null != this._response) return this._response;
        if (null != this._request.response) return this._request.response;
        try {
            if (null != this._request.responseText) return this._request.responseText;
        } catch (a) {}
        try {
            if (null != this._request.responseXML) return this._request.responseXML;
        } catch (a) {}
        return null;
    }, b._createXHR = function(a) {
        var b = createjs.RequestUtils.isCrossDomain(a), c = {}, d = null;
        if (window.XMLHttpRequest) d = new XMLHttpRequest(), b && void 0 === d.withCredentials && window.XDomainRequest && (d = new XDomainRequest()); else {
            for (var e = 0, f = s.ACTIVEX_VERSIONS.length; f > e; e++) {
                s.ACTIVEX_VERSIONS[e];
                try {
                    d = new ActiveXObject(axVersions);
                    break;
                } catch (g) {}
            }
            if (null == d) return !1;
        }
        a.mimeType && d.overrideMimeType && d.overrideMimeType(a.mimeType), this._xhrLevel = "string" == typeof d.responseType ? 2 : 1;
        var h = null;
        if (h = a.method == createjs.AbstractLoader.GET ? createjs.RequestUtils.buildPath(a.src, a.values) : a.src, 
        d.open(a.method || createjs.AbstractLoader.GET, h, !0), b && d instanceof XMLHttpRequest && 1 == this._xhrLevel && (c.Origin = location.origin), 
        a.values && a.method == createjs.AbstractLoader.POST && (c["Content-Type"] = "application/x-www-form-urlencoded"), 
        b || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest"), a.headers) for (var i in a.headers) c[i] = a.headers[i];
        for (i in c) d.setRequestHeader(i, c[i]);
        return d instanceof XMLHttpRequest && void 0 !== a.withCredentials && (d.withCredentials = a.withCredentials), 
        this._request = d, !0;
    }, b._clean = function() {
        clearTimeout(this._loadTimeout), this._request.removeEventListener("loadstart", this._handleLoadStartProxy), 
        this._request.removeEventListener("progress", this._handleProgressProxy), this._request.removeEventListener("abort", this._handleAbortProxy), 
        this._request.removeEventListener("error", this._handleErrorProxy), this._request.removeEventListener("timeout", this._handleTimeoutProxy), 
        this._request.removeEventListener("load", this._handleLoadProxy), this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
    }, b.toString = function() {
        return "[PreloadJS XHRRequest]";
    }, createjs.XHRRequest = createjs.promote(a, "AbstractRequest");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractLoader_constructor(), this.init(a, b, c);
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    b.init = function(a, b, c) {
        this.useXHR = !0, this.preferXHR = !0, this._preferXHR = !0, this.setPreferXHR(a), 
        this.stopOnError = !1, this.maintainScriptOrder = !0, this.next = null, this._paused = !1, 
        this._basePath = b, this._crossOrigin = c, this._typeCallbacks = {}, this._extensionCallbacks = {}, 
        this._loadStartWasDispatched = !1, this._maxConnections = 1, this._currentlyLoadingScript = null, 
        this._currentLoads = [], this._loadQueue = [], this._loadQueueBackup = [], this._loadItemsById = {}, 
        this._loadItemsBySrc = {}, this._loadedResults = {}, this._loadedRawResults = {}, 
        this._numItems = 0, this._numItemsLoaded = 0, this._scriptOrder = [], this._loadedScripts = [], 
        this._lastProgress = NaN, this._availableLoaders = [ createjs.ImageLoader, createjs.JavaScriptLoader, createjs.CSSLoader, createjs.JSONLoader, createjs.JSONPLoader, createjs.SoundLoader, createjs.ManifestLoader, createjs.SpriteSheetLoader, createjs.XMLLoader, createjs.SVGLoader, createjs.BinaryLoader, createjs.VideoLoader, createjs.TextLoader ], 
        this._defaultLoaderLength = this._availableLoaders.length;
    }, c.loadTimeout = 8e3, c.LOAD_TIMEOUT = 0, c.BINARY = createjs.AbstractLoader.BINARY, 
    c.CSS = createjs.AbstractLoader.CSS, c.IMAGE = createjs.AbstractLoader.IMAGE, c.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT, 
    c.JSON = createjs.AbstractLoader.JSON, c.JSONP = createjs.AbstractLoader.JSONP, 
    c.MANIFEST = createjs.AbstractLoader.MANIFEST, c.SOUND = createjs.AbstractLoader.SOUND, 
    c.VIDEO = createjs.AbstractLoader.VIDEO, c.SVG = createjs.AbstractLoader.SVG, c.TEXT = createjs.AbstractLoader.TEXT, 
    c.XML = createjs.AbstractLoader.XML, c.POST = createjs.AbstractLoader.POST, c.GET = createjs.AbstractLoader.GET, 
    b.registerLoader = function(a) {
        if (!a || !a.canLoadItem) throw new Error("loader is of an incorrect type.");
        if (-1 != this._availableLoaders.indexOf(a)) throw new Error("loader already exists.");
        this._availableLoaders.unshift(a);
    }, b.unregisterLoader = function(a) {
        var b = this._availableLoaders.indexOf(a);
        -1 != b && b < this._defaultLoaderLength - 1 && this._availableLoaders.splice(b, 1);
    }, b.setUseXHR = function(a) {
        return this.setPreferXHR(a);
    }, b.setPreferXHR = function(a) {
        return this.preferXHR = 0 != a && null != window.XMLHttpRequest, this.preferXHR;
    }, b.removeAll = function() {
        this.remove();
    }, b.remove = function(a) {
        var b = null;
        if (!a || a instanceof Array) {
            if (a) b = a; else if (arguments.length > 0) return;
        } else b = [ a ];
        var c = !1;
        if (b) {
            for (;b.length; ) {
                var d = b.pop(), e = this.getResult(d);
                for (f = this._loadQueue.length - 1; f >= 0; f--) if (g = this._loadQueue[f].getItem(), 
                g.id == d || g.src == d) {
                    this._loadQueue.splice(f, 1)[0].cancel();
                    break;
                }
                for (f = this._loadQueueBackup.length - 1; f >= 0; f--) if (g = this._loadQueueBackup[f].getItem(), 
                g.id == d || g.src == d) {
                    this._loadQueueBackup.splice(f, 1)[0].cancel();
                    break;
                }
                if (e) delete this._loadItemsById[e.id], delete this._loadItemsBySrc[e.src], this._disposeItem(e); else for (var f = this._currentLoads.length - 1; f >= 0; f--) {
                    var g = this._currentLoads[f].getItem();
                    if (g.id == d || g.src == d) {
                        this._currentLoads.splice(f, 1)[0].cancel(), c = !0;
                        break;
                    }
                }
            }
            c && this._loadNext();
        } else {
            this.close();
            for (var h in this._loadItemsById) this._disposeItem(this._loadItemsById[h]);
            this.init(this.preferXHR, this._basePath);
        }
    }, b.reset = function() {
        this.close();
        for (var a in this._loadItemsById) this._disposeItem(this._loadItemsById[a]);
        for (var b = [], c = 0, d = this._loadQueueBackup.length; d > c; c++) b.push(this._loadQueueBackup[c].getItem());
        this.loadManifest(b, !1);
    }, b.installPlugin = function(a) {
        if (null != a && null != a.getPreloadHandlers) {
            var b = a.getPreloadHandlers();
            if (b.scope = a, null != b.types) for (var c = 0, d = b.types.length; d > c; c++) this._typeCallbacks[b.types[c]] = b;
            if (null != b.extensions) for (c = 0, d = b.extensions.length; d > c; c++) this._extensionCallbacks[b.extensions[c]] = b;
        }
    }, b.setMaxConnections = function(a) {
        this._maxConnections = a, !this._paused && this._loadQueue.length > 0 && this._loadNext();
    }, b.loadFile = function(a, b, c) {
        if (null == a) {
            var d = new createjs.ErrorEvent("PRELOAD_NO_FILE");
            return void this._sendError(d);
        }
        this._addItem(a, null, c), this.setPaused(b !== !1 ? !1 : !0);
    }, b.loadManifest = function(a, b, d) {
        var e = null, f = null;
        if (a instanceof Array) {
            if (0 == a.length) {
                var g = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
                return void this._sendError(g);
            }
            e = a;
        } else if ("string" == typeof a) e = [ {
            src: a,
            type: c.MANIFEST
        } ]; else {
            if ("object" != typeof a) {
                var g = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
                return void this._sendError(g);
            }
            if (void 0 !== a.src) {
                if (null == a.type) a.type = c.MANIFEST; else if (a.type != c.MANIFEST) {
                    var g = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
                    this._sendError(g);
                }
                e = [ a ];
            } else void 0 !== a.manifest && (e = a.manifest, f = a.path);
        }
        for (var h = 0, i = e.length; i > h; h++) this._addItem(e[h], f, d);
        this.setPaused(b !== !1 ? !1 : !0);
    }, b.load = function() {
        this.setPaused(!1);
    }, b.getItem = function(a) {
        return this._loadItemsById[a] || this._loadItemsBySrc[a];
    }, b.getResult = function(a, b) {
        var c = this._loadItemsById[a] || this._loadItemsBySrc[a];
        if (null == c) return null;
        var d = c.id;
        return b && this._loadedRawResults[d] ? this._loadedRawResults[d] : this._loadedResults[d];
    }, b.getItems = function(a) {
        for (var b = [], c = 0, d = this._loadQueueBackup.length; d > c; c++) {
            var e = this._loadQueueBackup[c], f = e.getItem();
            (a !== !0 || e.loaded) && b.push({
                item: f,
                result: this.getResult(f.id),
                rawResult: this.getResult(f.id, !0)
            });
        }
        return b;
    }, b.setPaused = function(a) {
        this._paused = a, this._paused || this._loadNext();
    }, b.close = function() {
        for (;this._currentLoads.length; ) this._currentLoads.pop().cancel();
        this._scriptOrder.length = 0, this._loadedScripts.length = 0, this.loadStartWasDispatched = !1, 
        this._itemCount = 0, this._lastProgress = NaN;
    }, b._addItem = function(a, b, c) {
        var d = this._createLoadItem(a, b, c);
        if (null != d) {
            var e = this._createLoader(d);
            null != e && (d._loader = e, this._loadQueue.push(e), this._loadQueueBackup.push(e), 
            this._numItems++, this._updateProgress(), (this.maintainScriptOrder && d.type == createjs.LoadQueue.JAVASCRIPT || d.maintainOrder === !0) && (this._scriptOrder.push(d), 
            this._loadedScripts.push(null)));
        }
    }, b._createLoadItem = function(a, b, d) {
        var e = createjs.LoadItem.create(a);
        if (null == e) return null;
        var f = createjs.RequestUtils.parseURI(e.src);
        f.extension && (e.ext = f.extension), null == e.type && (e.type = createjs.RequestUtils.getTypeByExtension(e.ext));
        var g = "", h = d || this._basePath, i = e.src;
        if (!f.absolute && !f.relative) if (b) {
            g = b;
            var j = createjs.RequestUtils.parseURI(b);
            i = b + i, null == h || j.absolute || j.relative || (g = h + g);
        } else null != h && (g = h);
        e.src = g + e.src, e.path = g, (void 0 === e.id || null === e.id || "" === e.id) && (e.id = i);
        var k = this._typeCallbacks[e.type] || this._extensionCallbacks[e.ext];
        if (k) {
            var l = k.callback.call(k.scope, e, this);
            if (l === !1) return null;
            l === !0 || null != l && (e._loader = l), f = createjs.RequestUtils.parseURI(e.src), 
            null != f.extension && (e.ext = f.extension);
        }
        return this._loadItemsById[e.id] = e, this._loadItemsBySrc[e.src] = e, null == e.loadTimeout && (e.loadTimeout = c.loadTimeout), 
        null == e.crossOrigin && (e.crossOrigin = this._crossOrigin), e;
    }, b._createLoader = function(a) {
        if (null != a._loader) return a._loader;
        for (var b = this.preferXHR, c = 0; c < this._availableLoaders.length; c++) {
            var d = this._availableLoaders[c];
            if (d && d.canLoadItem(a)) return new d(a, b);
        }
        return null;
    }, b._loadNext = function() {
        if (!this._paused) {
            this._loadStartWasDispatched || (this._sendLoadStart(), this._loadStartWasDispatched = !0), 
            this._numItems == this._numItemsLoaded ? (this.loaded = !0, this._sendComplete(), 
            this.next && this.next.load && this.next.load()) : this.loaded = !1;
            for (var a = 0; a < this._loadQueue.length && !(this._currentLoads.length >= this._maxConnections); a++) {
                var b = this._loadQueue[a];
                this._canStartLoad(b) && (this._loadQueue.splice(a, 1), a--, this._loadItem(b));
            }
        }
    }, b._loadItem = function(a) {
        a.on("fileload", this._handleFileLoad, this), a.on("progress", this._handleProgress, this), 
        a.on("complete", this._handleFileComplete, this), a.on("error", this._handleError, this), 
        a.on("fileerror", this._handleFileError, this), this._currentLoads.push(a), this._sendFileStart(a.getItem()), 
        a.load();
    }, b._handleFileLoad = function(a) {
        a.target = null, this.dispatchEvent(a);
    }, b._handleFileError = function(a) {
        var b = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, a.item);
        this._sendError(b);
    }, b._handleError = function(a) {
        var b = a.target;
        this._numItemsLoaded++, this._finishOrderedItem(b, !0), this._updateProgress();
        var c = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, b.getItem());
        this._sendError(c), this.stopOnError || (this._removeLoadItem(b), this._loadNext());
    }, b._handleFileComplete = function(a) {
        var b = a.target, c = b.getItem(), d = b.getResult();
        this._loadedResults[c.id] = d;
        var e = b.getResult(!0);
        null != e && e !== d && (this._loadedRawResults[c.id] = e), this._saveLoadedItems(b), 
        this._removeLoadItem(b), this._finishOrderedItem(b) || this._processFinishedLoad(c, b);
    }, b._saveLoadedItems = function(a) {
        var b = a.getLoadedItems();
        if (null !== b) for (var c = 0; c < b.length; c++) {
            var d = b[c].item;
            this._loadItemsBySrc[d.src] = d, this._loadItemsById[d.id] = d, this._loadedResults[d.id] = b[c].result, 
            this._loadedRawResults[d.id] = b[c].rawResult;
        }
    }, b._finishOrderedItem = function(a, b) {
        var c = a.getItem();
        if (this.maintainScriptOrder && c.type == createjs.LoadQueue.JAVASCRIPT || c.maintainOrder) {
            a instanceof createjs.JavaScriptLoader && (this._currentlyLoadingScript = !1);
            var d = createjs.indexOf(this._scriptOrder, c);
            return -1 == d ? !1 : (this._loadedScripts[d] = b === !0 ? !0 : c, this._checkScriptLoadOrder(), 
            !0);
        }
        return !1;
    }, b._checkScriptLoadOrder = function() {
        for (var a = this._loadedScripts.length, b = 0; a > b; b++) {
            var c = this._loadedScripts[b];
            if (null === c) break;
            if (c !== !0) {
                var d = this._loadedResults[c.id];
                c.type == createjs.LoadQueue.JAVASCRIPT && (document.body || document.getElementsByTagName("body")[0]).appendChild(d);
                var e = c._loader;
                this._processFinishedLoad(c, e), this._loadedScripts[b] = !0;
            }
        }
    }, b._processFinishedLoad = function(a, b) {
        this._numItemsLoaded++, this._updateProgress(), this._sendFileComplete(a, b), this._loadNext();
    }, b._canStartLoad = function(a) {
        if (!this.maintainScriptOrder || a.preferXHR) return !0;
        var b = a.getItem();
        if (b.type != createjs.LoadQueue.JAVASCRIPT) return !0;
        if (this._currentlyLoadingScript) return !1;
        for (var c = this._scriptOrder.indexOf(b), d = 0; c > d; ) {
            var e = this._loadedScripts[d];
            if (null == e) return !1;
            d++;
        }
        return this._currentlyLoadingScript = !0, !0;
    }, b._removeLoadItem = function(a) {
        var b = a.getItem();
        delete b._loader;
        for (var c = this._currentLoads.length, d = 0; c > d; d++) if (this._currentLoads[d] == a) {
            this._currentLoads.splice(d, 1);
            break;
        }
    }, b._handleProgress = function(a) {
        var b = a.target;
        this._sendFileProgress(b.getItem(), b.progress), this._updateProgress();
    }, b._updateProgress = function() {
        var a = this._numItemsLoaded / this._numItems, b = this._numItems - this._numItemsLoaded;
        if (b > 0) {
            for (var c = 0, d = 0, e = this._currentLoads.length; e > d; d++) c += this._currentLoads[d].progress;
            a += c / b * (b / this._numItems);
        }
        this._lastProgress != a && (this._sendProgress(a), this._lastProgress = a);
    }, b._disposeItem = function(a) {
        delete this._loadedResults[a.id], delete this._loadedRawResults[a.id], delete this._loadItemsById[a.id], 
        delete this._loadItemsBySrc[a.src];
    }, b._sendFileProgress = function(a, b) {
        if (this._isCanceled()) return void this._cleanUp();
        if (this.hasEventListener("fileprogress")) {
            var c = new createjs.Event("fileprogress");
            c.progress = b, c.loaded = b, c.total = 1, c.item = a, this.dispatchEvent(c);
        }
    }, b._sendFileComplete = function(a, b) {
        if (!this._isCanceled()) {
            var c = new createjs.Event("fileload");
            c.loader = b, c.item = a, c.result = this._loadedResults[a.id], c.rawResult = this._loadedRawResults[a.id], 
            a.completeHandler && a.completeHandler(c), this.hasEventListener("fileload") && this.dispatchEvent(c);
        }
    }, b._sendFileStart = function(a) {
        var b = new createjs.Event("filestart");
        b.item = a, this.hasEventListener("filestart") && this.dispatchEvent(b);
    }, b.toString = function() {
        return "[PreloadJS LoadQueue]";
    }, createjs.LoadQueue = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.TEXT);
    }
    var b = (createjs.extend(a, createjs.AbstractLoader), a);
    b.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.TEXT;
    }, createjs.TextLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.BINARY), this.on("initialize", this._updateXHR, this);
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.BINARY;
    }, b._updateXHR = function(a) {
        a.loader.setResponseType("arraybuffer");
    }, createjs.BinaryLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.CSS), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "href", this._tag = document.createElement(b ? "style" : "link"), 
        this._tag.rel = "stylesheet", this._tag.type = "text/css";
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.CSS;
    }, b._formatResult = function(a) {
        if (this._preferXHR) {
            var b = a.getTag(), c = document.getElementsByTagName("head")[0];
            if (c.appendChild(b), b.styleSheet) b.styleSheet.cssText = a.getResult(!0); else {
                var d = document.createTextNode(a.getResult(!0));
                b.appendChild(d);
            }
        } else b = this._tag;
        return b;
    }, createjs.CSSLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.IMAGE), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "src", createjs.RequestUtils.isImageTag(a) ? this._tag = a : createjs.RequestUtils.isImageTag(a.src) ? this._tag = a.src : createjs.RequestUtils.isImageTag(a.tag) && (this._tag = a.tag), 
        null != this._tag ? this._preferXHR = !1 : this._tag = document.createElement("img"), 
        this.on("initialize", this._updateXHR, this);
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.IMAGE;
    }, b.load = function() {
        if ("" != this._tag.src && this._tag.complete) return void this._sendComplete();
        var a = this._item.crossOrigin;
        1 == a && (a = "Anonymous"), null == a || createjs.RequestUtils.isLocal(this._item.src) || (this._tag.crossOrigin = a), 
        this.AbstractLoader_load();
    }, b._updateXHR = function(a) {
        a.loader.mimeType = "text/plain; charset=x-user-defined-binary", a.loader.setResponseType && a.loader.setResponseType("blob");
    }, b._formatResult = function(a) {
        var b = this;
        return function(c) {
            var d = b._tag, e = window.URL || window.webkitURL;
            if (b._preferXHR) if (e) {
                var f = e.createObjectURL(a.getResult(!0));
                d.src = f, d.onload = function() {
                    e.revokeObjectURL(b.src);
                };
            } else d.src = a.getItem().src;
            d.complete ? c(d) : d.onload = function() {
                c(this);
            };
        };
    }, createjs.ImageLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.JAVASCRIPT), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "src", this.setTag(document.createElement("script"));
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.JAVASCRIPT;
    }, b._formatResult = function(a) {
        var b = a.getTag();
        return this._preferXHR && (b.text = a.getResult(!0)), b;
    }, createjs.JavaScriptLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.JSON), this.resultFormatter = this._formatResult;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.JSON && !a._loadAsJSONP;
    }, b._formatResult = function(a) {
        var b = null;
        try {
            b = createjs.DataUtils.parseJSON(a.getResult(!0));
        } catch (c) {
            var d = new createjs.ErrorEvent("JSON_FORMAT", null, c);
            return this._sendError(d), c;
        }
        return b;
    }, createjs.JSONLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !1, createjs.AbstractLoader.JSONP), this.setTag(document.createElement("script")), 
        this.getTag().type = "text/javascript";
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.JSONP || a._loadAsJSONP;
    }, b.cancel = function() {
        this.AbstractLoader_cancel(), this._dispose();
    }, b.load = function() {
        if (null == this._item.callback) throw new Error("callback is required for loading JSONP requests.");
        if (null != window[this._item.callback]) throw new Error("JSONP callback '" + this._item.callback + "' already exists on window. You need to specify a different callback or re-name the current one.");
        window[this._item.callback] = createjs.proxy(this._handleLoad, this), window.document.body.appendChild(this._tag), 
        this._tag.src = this._item.src;
    }, b._handleLoad = function(a) {
        this._result = this._rawResult = a, this._sendComplete(), this._dispose();
    }, b._dispose = function() {
        window.document.body.removeChild(this._tag), delete window[this._item.callback];
    }, createjs.JSONPLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, null, createjs.AbstractLoader.MANIFEST), this._manifestQueue = null;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.MANIFEST_PROGRESS = .25, c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.MANIFEST;
    }, b.load = function() {
        this.AbstractLoader_load();
    }, b._createRequest = function() {
        var a = this._item.callback;
        this._request = null != a ? new createjs.JSONPLoader(this._item) : new createjs.JSONLoader(this._item);
    }, b.handleEvent = function(a) {
        switch (a.type) {
          case "complete":
            return this._rawResult = a.target.getResult(!0), this._result = a.target.getResult(), 
            this._sendProgress(c.MANIFEST_PROGRESS), void this._loadManifest(this._result);

          case "progress":
            return a.loaded *= c.MANIFEST_PROGRESS, this.progress = a.loaded / a.total, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0), 
            void this._sendProgress(a);
        }
        this.AbstractLoader_handleEvent(a);
    }, b.destroy = function() {
        this.AbstractLoader_destroy(), this._manifestQueue.close();
    }, b._loadManifest = function(a) {
        if (a && a.manifest) {
            var b = this._manifestQueue = new createjs.LoadQueue();
            b.on("fileload", this._handleManifestFileLoad, this), b.on("progress", this._handleManifestProgress, this), 
            b.on("complete", this._handleManifestComplete, this, !0), b.on("error", this._handleManifestError, this, !0), 
            b.loadManifest(a);
        } else this._sendComplete();
    }, b._handleManifestFileLoad = function(a) {
        a.target = null, this.dispatchEvent(a);
    }, b._handleManifestComplete = function() {
        this._loadedItems = this._manifestQueue.getItems(!0), this._sendComplete();
    }, b._handleManifestProgress = function(a) {
        this.progress = a.progress * (1 - c.MANIFEST_PROGRESS) + c.MANIFEST_PROGRESS, this._sendProgress(this.progress);
    }, b._handleManifestError = function(a) {
        var b = new createjs.Event("fileerror");
        b.item = a.data, this.dispatchEvent(b);
    }, createjs.ManifestLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractMediaLoader_constructor(a, b, createjs.AbstractLoader.SOUND), createjs.RequestUtils.isAudioTag(a) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.src) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.tag) && (this._tag = createjs.RequestUtils.isAudioTag(a) ? a : a.src), 
        null != this._tag && (this._preferXHR = !1);
    }
    var b = createjs.extend(a, createjs.AbstractMediaLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.SOUND;
    }, b._createTag = function(a) {
        var b = document.createElement("audio");
        return b.autoplay = !1, b.preload = "none", b.src = a, b;
    }, createjs.SoundLoader = createjs.promote(a, "AbstractMediaLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractMediaLoader_constructor(a, b, createjs.AbstractLoader.VIDEO), createjs.RequestUtils.isVideoTag(a) || createjs.RequestUtils.isVideoTag(a.src) ? (this.setTag(createjs.RequestUtils.isVideoTag(a) ? a : a.src), 
        this._preferXHR = !1) : this.setTag(this._createTag());
    }
    var b = createjs.extend(a, createjs.AbstractMediaLoader), c = a;
    b._createTag = function() {
        return document.createElement("video");
    }, c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.VIDEO;
    }, createjs.VideoLoader = createjs.promote(a, "AbstractMediaLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, null, createjs.AbstractLoader.SPRITESHEET), this._manifestQueue = null;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.SPRITESHEET_PROGRESS = .25, c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.SPRITESHEET;
    }, b.destroy = function() {
        this.AbstractLoader_destroy, this._manifestQueue.close();
    }, b._createRequest = function() {
        var a = this._item.callback;
        this._request = null != a && a instanceof Function ? new createjs.JSONPLoader(this._item) : new createjs.JSONLoader(this._item);
    }, b.handleEvent = function(a) {
        switch (a.type) {
          case "complete":
            return this._rawResult = a.target.getResult(!0), this._result = a.target.getResult(), 
            this._sendProgress(c.SPRITESHEET_PROGRESS), void this._loadManifest(this._result);

          case "progress":
            return a.loaded *= c.SPRITESHEET_PROGRESS, this.progress = a.loaded / a.total, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0), 
            void this._sendProgress(a);
        }
        this.AbstractLoader_handleEvent(a);
    }, b._loadManifest = function(a) {
        if (a && a.images) {
            var b = this._manifestQueue = new createjs.LoadQueue();
            b.on("complete", this._handleManifestComplete, this, !0), b.on("fileload", this._handleManifestFileLoad, this), 
            b.on("progress", this._handleManifestProgress, this), b.on("error", this._handleManifestError, this, !0), 
            b.loadManifest(a.images);
        }
    }, b._handleManifestFileLoad = function(a) {
        var b = a.result;
        if (null != b) {
            var c = this.getResult().images, d = c.indexOf(a.item.src);
            c[d] = b;
        }
    }, b._handleManifestComplete = function() {
        this._result = new createjs.SpriteSheet(this._result), this._loadedItems = this._manifestQueue.getItems(!0), 
        this._sendComplete();
    }, b._handleManifestProgress = function(a) {
        this.progress = a.progress * (1 - c.SPRITESHEET_PROGRESS) + c.SPRITESHEET_PROGRESS, 
        this._sendProgress(this.progress);
    }, b._handleManifestError = function(a) {
        var b = new createjs.Event("fileerror");
        b.item = a.data, this.dispatchEvent(b);
    }, createjs.SpriteSheetLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.SVG), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "data", b ? this.setTag(document.createElement("svg")) : (this.setTag(document.createElement("object")), 
        this.getTag().type = "image/svg+xml"), this.getTag().style.visibility = "hidden";
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.SVG;
    }, b._formatResult = function(a) {
        var b = createjs.DataUtils.parseXML(a.getResult(!0), "text/xml"), c = a.getTag();
        return !this._preferXHR && document.body.contains(c) && document.body.removeChild(c), 
        null != b.documentElement ? (c.appendChild(b.documentElement), c.style.visibility = "visible", 
        c) : b;
    }, createjs.SVGLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.XML), this.resultFormatter = this._formatResult;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.XML;
    }, b._formatResult = function(a) {
        return createjs.DataUtils.parseXML(a.getResult(!0), "text/xml");
    }, createjs.XMLLoader = createjs.promote(a, "AbstractLoader");
}(), function(a) {
    function b(a, b, c, d, e) {
        this._listener = b, this._isOnce = c, this.context = d, this._signal = a, this._priority = e || 0;
    }
    function c(a, b) {
        if ("function" != typeof a) throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
    }
    function d() {
        this._bindings = [], this._prevParams = null;
        var a = this;
        this.dispatch = function() {
            d.prototype.dispatch.apply(a, arguments);
        };
    }
    b.prototype = {
        active: !0,
        params: null,
        execute: function(a) {
            var b, c;
            return this.active && this._listener && (c = this.params ? this.params.concat(a) : a, 
            b = this._listener.apply(this.context, c), this._isOnce && this.detach()), b;
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function() {
            return !!this._signal && !!this._listener;
        },
        isOnce: function() {
            return this._isOnce;
        },
        getListener: function() {
            return this._listener;
        },
        getSignal: function() {
            return this._signal;
        },
        _destroy: function() {
            delete this._signal, delete this._listener, delete this.context;
        },
        toString: function() {
            return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
    }, d.prototype = {
        VERSION: "1.0.0",
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _registerListener: function(a, c, d, e) {
            var f, g = this._indexOfListener(a, d);
            if (-1 !== g) {
                if (f = this._bindings[g], f.isOnce() !== c) throw new Error("You cannot add" + (c ? "" : "Once") + "() then add" + (c ? "Once" : "") + "() the same listener without removing the relationship first.");
            } else f = new b(this, a, c, d, e), this._addBinding(f);
            return this.memorize && this._prevParams && f.execute(this._prevParams), f;
        },
        _addBinding: function(a) {
            var b = this._bindings.length;
            do --b; while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
            this._bindings.splice(b + 1, 0, a);
        },
        _indexOfListener: function(a, b) {
            for (var c, d = this._bindings.length; d--; ) if (c = this._bindings[d], c._listener === a && c.context === b) return d;
            return -1;
        },
        has: function(a, b) {
            return -1 !== this._indexOfListener(a, b);
        },
        add: function(a, b, d) {
            return c(a, "add"), this._registerListener(a, !1, b, d);
        },
        addOnce: function(a, b, d) {
            return c(a, "addOnce"), this._registerListener(a, !0, b, d);
        },
        remove: function(a, b) {
            c(a, "remove");
            var d = this._indexOfListener(a, b);
            return -1 !== d && (this._bindings[d]._destroy(), this._bindings.splice(d, 1)), 
            a;
        },
        removeAll: function() {
            for (var a = this._bindings.length; a--; ) this._bindings[a]._destroy();
            this._bindings.length = 0;
        },
        getNumListeners: function() {
            return this._bindings.length;
        },
        halt: function() {
            this._shouldPropagate = !1;
        },
        dispatch: function(a) {
            if (this.active) {
                var b, c = Array.prototype.slice.call(arguments), d = this._bindings.length;
                if (this.memorize && (this._prevParams = c), d) {
                    b = this._bindings.slice(), this._shouldPropagate = !0;
                    do d--; while (b[d] && this._shouldPropagate && b[d].execute(c) !== !1);
                }
            }
        },
        forget: function() {
            this._prevParams = null;
        },
        dispose: function() {
            this.removeAll(), delete this._bindings, delete this._prevParams;
        },
        toString: function() {
            return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
    };
    var e = d;
    e.Signal = d, "function" == typeof define && define.amd ? define(function() {
        return e;
    }) : "undefined" != typeof module && module.exports ? module.exports = e : a.signals = e;
}(this);

var Stats = function() {
    var a = Date.now(), b = a, c = 0, d = 1 / 0, e = 0, f = 0, g = 1 / 0, h = 0, i = 0, j = 0, k = document.createElement("div");
    k.id = "stats", k.addEventListener("mousedown", function(a) {
        a.preventDefault(), s(++j % 2);
    }, !1), k.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var l = document.createElement("div");
    l.id = "fps", l.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002", 
    k.appendChild(l);
    var m = document.createElement("div");
    m.id = "fpsText", m.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    m.innerHTML = "FPS", l.appendChild(m);
    var n = document.createElement("div");
    for (n.id = "fpsGraph", n.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff", 
    l.appendChild(n); 74 > n.children.length; ) {
        var o = document.createElement("span");
        o.style.cssText = "width:1px;height:30px;float:left;background-color:#113", n.appendChild(o);
    }
    var p = document.createElement("div");
    p.id = "ms", p.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none", 
    k.appendChild(p);
    var q = document.createElement("div");
    q.id = "msText", q.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    q.innerHTML = "MS", p.appendChild(q);
    var r = document.createElement("div");
    for (r.id = "msGraph", r.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0", 
    p.appendChild(r); 74 > r.children.length; ) o = document.createElement("span"), 
    o.style.cssText = "width:1px;height:30px;float:left;background-color:#131", r.appendChild(o);
    var s = function(a) {
        switch (j = a) {
          case 0:
            l.style.display = "block", p.style.display = "none";
            break;

          case 1:
            l.style.display = "none", p.style.display = "block";
        }
    };
    return {
        REVISION: 12,
        domElement: k,
        setMode: s,
        begin: function() {
            a = Date.now();
        },
        end: function() {
            var j = Date.now();
            c = j - a, d = Math.min(d, c), e = Math.max(e, c), q.textContent = c + " MS (" + d + "-" + e + ")";
            var k = Math.min(30, 30 - 30 * (c / 200));
            return r.appendChild(r.firstChild).style.height = k + "px", i++, j > b + 1e3 && (f = Math.round(1e3 * i / (j - b)), 
            g = Math.min(g, f), h = Math.max(h, f), m.textContent = f + " FPS (" + g + "-" + h + ")", 
            k = Math.min(30, 30 - 30 * (f / 100)), n.appendChild(n.firstChild).style.height = k + "px", 
            b = j, i = 0), j;
        },
        update: function() {
            a = this.end();
        }
    };
};

"object" == typeof module && (module.exports = Stats);

var THREE = {
    REVISION: "71"
};

"object" == typeof module && (module.exports = THREE), void 0 === Math.sign && (Math.sign = function(a) {
    return 0 > a ? -1 : a > 0 ? 1 : +a;
}), THREE.log = function() {
    console.log.apply(console, arguments);
}, THREE.warn = function() {
    console.warn.apply(console, arguments);
}, THREE.error = function() {
    console.error.apply(console, arguments);
}, THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
}, THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, 
THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, 
THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, 
THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, 
THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, 
THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, 
THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, 
THREE.ReverseSubtractEquation = 102, THREE.MinEquation = 103, THREE.MaxEquation = 104, 
THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, 
THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, 
THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, 
THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, 
THREE.AddOperation = 2, THREE.UVMapping = 300, THREE.CubeReflectionMapping = 301, 
THREE.CubeRefractionMapping = 302, THREE.EquirectangularReflectionMapping = 303, 
THREE.EquirectangularRefractionMapping = 304, THREE.SphericalReflectionMapping = 305, 
THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, 
THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, 
THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, 
THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, 
THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.HalfFloatType = 1025, 
THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, 
THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, 
THREE.LuminanceAlphaFormat = 1023, THREE.RGBEFormat = THREE.RGBAFormat, THREE.RGB_S3TC_DXT1_Format = 2001, 
THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, 
THREE.RGB_PVRTC_4BPPV1_Format = 2100, THREE.RGB_PVRTC_2BPPV1_Format = 2101, THREE.RGBA_PVRTC_4BPPV1_Format = 2102, 
THREE.RGBA_PVRTC_2BPPV1_Format = 2103, THREE.Projector = function() {
    THREE.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), 
    this.projectVector = function(a, b) {
        THREE.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b);
    }, this.unprojectVector = function(a, b) {
        THREE.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), a.unproject(b);
    }, this.pickingRay = function(a, b) {
        THREE.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
}, THREE.CanvasRenderer = function() {
    THREE.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), 
    this.domElement = document.createElement("canvas"), this.clear = function() {}, 
    this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {};
}, THREE.Color = function(a) {
    return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a);
}, THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
        return a instanceof THREE.Color ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), 
        this;
    },
    setHex: function(a) {
        return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, 
        this.b = (255 & a) / 255, this;
    },
    setRGB: function(a, b, c) {
        return this.r = a, this.g = b, this.b = c, this;
    },
    setHSL: function(a, b, c) {
        if (0 === b) this.r = this.g = this.b = c; else {
            var d = function(a, b, c) {
                return 0 > c && (c += 1), c > 1 && (c -= 1), 1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + 6 * (b - a) * (2 / 3 - c) : a;
            };
            b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = d(c, b, a + 1 / 3), 
            this.g = d(c, b, a), this.b = d(c, b, a - 1 / 3);
        }
        return this;
    },
    setStyle: function(a) {
        return /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a) ? (a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), 
        this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, 
        this.b = Math.min(255, parseInt(a[3], 10)) / 255, this) : /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a) ? (a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), 
        this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, 
        this.b = Math.min(100, parseInt(a[3], 10)) / 100, this) : /^\#([0-9a-f]{6})$/i.test(a) ? (a = /^\#([0-9a-f]{6})$/i.exec(a), 
        this.setHex(parseInt(a[1], 16)), this) : /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a) ? (a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), 
        this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this) : /^(\w+)$/i.test(a) ? (this.setHex(THREE.ColorKeywords[a]), 
        this) : void 0;
    },
    copy: function(a) {
        return this.r = a.r, this.g = a.g, this.b = a.b, this;
    },
    copyGammaToLinear: function(a, b) {
        return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), 
        this.b = Math.pow(a.b, b), this;
    },
    copyLinearToGamma: function(a, b) {
        void 0 === b && (b = 2);
        var c = b > 0 ? 1 / b : 1;
        return this.r = Math.pow(a.r, c), this.g = Math.pow(a.g, c), this.b = Math.pow(a.b, c), 
        this;
    },
    convertGammaToLinear: function() {
        var a = this.r, b = this.g, c = this.b;
        return this.r = a * a, this.g = b * b, this.b = c * c, this;
    },
    convertLinearToGamma: function() {
        return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), 
        this;
    },
    getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(a) {
        a = a || {
            h: 0,
            s: 0,
            l: 0
        };
        var b, c = this.r, d = this.g, e = this.b, f = Math.max(c, d, e), g = Math.min(c, d, e), h = (g + f) / 2;
        if (g === f) g = b = 0; else {
            var i = f - g, g = .5 >= h ? i / (f + g) : i / (2 - f - g);
            switch (f) {
              case c:
                b = (d - e) / i + (e > d ? 6 : 0);
                break;

              case d:
                b = (e - c) / i + 2;
                break;

              case e:
                b = (c - d) / i + 4;
            }
            b /= 6;
        }
        return a.h = b, a.s = g, a.l = h, a;
    },
    getStyle: function() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function(a, b, c) {
        var d = this.getHSL();
        return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this;
    },
    add: function(a) {
        return this.r += a.r, this.g += a.g, this.b += a.b, this;
    },
    addColors: function(a, b) {
        return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this;
    },
    addScalar: function(a) {
        return this.r += a, this.g += a, this.b += a, this;
    },
    multiply: function(a) {
        return this.r *= a.r, this.g *= a.g, this.b *= a.b, this;
    },
    multiplyScalar: function(a) {
        return this.r *= a, this.g *= a, this.b *= a, this;
    },
    lerp: function(a, b) {
        return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, 
        this;
    },
    equals: function(a) {
        return a.r === this.r && a.g === this.g && a.b === this.b;
    },
    fromArray: function(a) {
        return this.r = a[0], this.g = a[1], this.b = a[2], this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, 
        a[b + 2] = this.b, a;
    },
    clone: function() {
        return new THREE.Color().setRGB(this.r, this.g, this.b);
    }
}, THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, THREE.Quaternion = function(a, b, c, d) {
    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1;
}, THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    _x: 0,
    _y: 0,
    _z: 0,
    _w: 0,
    get x() {
        return this._x;
    },
    set x(a) {
        this._x = a, this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(a) {
        this._y = a, this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(a) {
        this._z = a, this.onChangeCallback();
    },
    get w() {
        return this._w;
    },
    set w(a) {
        this._w = a, this.onChangeCallback();
    },
    set: function(a, b, c, d) {
        return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), 
        this;
    },
    copy: function(a) {
        return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), 
        this;
    },
    setFromEuler: function(a, b) {
        if (!1 == a instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2);
        return "XYZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, 
        this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === a.order ? (this._x = f * d * e + c * g * h, 
        this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === a.order ? (this._x = f * d * e - c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === a.order ? (this._x = f * d * e - c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === a.order ? (this._x = f * d * e + c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === a.order && (this._x = f * d * e - c * g * h, 
        this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h), 
        !1 !== b && this.onChangeCallback(), this;
    },
    setFromAxisAngle: function(a, b) {
        var c = b / 2, d = Math.sin(c);
        return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), 
        this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(a) {
        var b = a.elements, c = b[0];
        a = b[4];
        var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], i = b[6], b = b[10], j = c + f + b;
        return j > 0 ? (c = .5 / Math.sqrt(j + 1), this._w = .25 / c, this._x = (i - g) * c, 
        this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), 
        this._w = (i - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), 
        this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), 
        this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + i) / c, this._z = .25 * c), 
        this.onChangeCallback(), this;
    },
    setFromUnitVectors: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector3()), b = c.dot(d) + 1, 1e-6 > b ? (b = 0, 
            Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d), 
            this._x = a.x, this._y = a.y, this._z = a.z, this._w = b, this.normalize(), this;
        };
    }(),
    inverse: function() {
        return this.conjugate().normalize(), this;
    },
    conjugate: function() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
    },
    dot: function(a) {
        return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
        var a = this.length();
        return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, 
        this._y *= a, this._z *= a, this._w *= a), this.onChangeCallback(), this;
    },
    multiply: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), 
        this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
    },
    multiplyQuaternions: function(a, b) {
        var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, i = b._z, j = b._w;
        return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, 
        this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, 
        this.onChangeCallback(), this;
    },
    multiplyVector3: function(a) {
        return THREE.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), 
        a.applyQuaternion(this);
    },
    slerp: function(a, b) {
        if (0 === b) return this;
        if (1 === b) return this.copy(a);
        var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
        if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, 
        g = -g) : this.copy(a), g >= 1) return this._w = f, this._x = c, this._y = d, this._z = e, 
        this;
        var h = Math.acos(g), i = Math.sqrt(1 - g * g);
        return .001 > Math.abs(i) ? (this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), 
        this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this) : (g = Math.sin((1 - b) * h) / i, 
        h = Math.sin(b * h) / i, this._w = f * g + this._w * h, this._x = c * g + this._x * h, 
        this._y = d * g + this._y * h, this._z = e * g + this._z * h, this.onChangeCallback(), 
        this);
    },
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], 
        this._w = a[b + 3], this.onChangeCallback(), this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, 
        a[b + 2] = this._z, a[b + 3] = this._w, a;
    },
    onChange: function(a) {
        return this.onChangeCallback = a, this;
    },
    onChangeCallback: function() {},
    clone: function() {
        return new THREE.Quaternion(this._x, this._y, this._z, this._w);
    }
}, THREE.Quaternion.slerp = function(a, b, c, d) {
    return c.copy(a).slerp(b, d);
}, THREE.Vector2 = function(a, b) {
    this.x = a || 0, this.y = b || 0;
}, THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    set: function(a, b) {
        return this.x = a, this.y = b, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this;
    },
    add: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this);
    },
    subScalar: function(a) {
        return this.x -= a, this.y -= a, this;
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this;
    },
    multiply: function(a) {
        return this.x *= a.x, this.y *= a.y, this;
    },
    multiplyScalar: function(a) {
        return this.x *= a, this.y *= a, this;
    },
    divide: function(a) {
        return this.x /= a.x, this.y /= a.y, this;
    },
    divideScalar: function(a) {
        return 0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0, this;
    },
    min: function(a) {
        return this.x > a.x && (this.x = a.x), this.y > a.y && (this.y = a.y), this;
    },
    max: function(a) {
        return this.x < a.x && (this.x = a.x), this.y < a.y && (this.y = a.y), this;
    },
    clamp: function(a, b) {
        return this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x), this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y), 
        this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector2(), b = new THREE.Vector2()), a.set(c, c), 
            b.set(d, d), this.clamp(a, b);
        };
    }(),
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x;
        return a = this.y - a.y, b * b + a * a;
    },
    setLength: function(a) {
        var b = this.length();
        return 0 !== b && a !== b && this.multiplyScalar(a / b), this;
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this;
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a), this;
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this;
    },
    clone: function() {
        return new THREE.Vector2(this.x, this.y);
    }
}, THREE.Vector3 = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0;
}, THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function(a, b, c) {
        return this.x = a, this.y = b, this.z = c, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setZ: function(a) {
        return this.z = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          case 2:
            this.z = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this.z = a.z, this;
    },
    add: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this.z += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this);
    },
    subScalar: function(a) {
        return this.x -= a, this.y -= a, this.z -= a, this;
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
    },
    multiply: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), 
        this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this);
    },
    multiplyScalar: function(a) {
        return this.x *= a, this.y *= a, this.z *= a, this;
    },
    multiplyVectors: function(a, b) {
        return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
    },
    applyEuler: function() {
        var a;
        return function(b) {
            return !1 == b instanceof THREE.Euler && THREE.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), 
            void 0 === a && (a = new THREE.Quaternion()), this.applyQuaternion(a.setFromEuler(b)), 
            this;
        };
    }(),
    applyAxisAngle: function() {
        var a;
        return function(b, c) {
            return void 0 === a && (a = new THREE.Quaternion()), this.applyQuaternion(a.setFromAxisAngle(b, c)), 
            this;
        };
    }(),
    applyMatrix3: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[3] * c + a[6] * d, this.y = a[1] * b + a[4] * c + a[7] * d, 
        this.z = a[2] * b + a[5] * c + a[8] * d, this;
    },
    applyMatrix4: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12], this.y = a[1] * b + a[5] * c + a[9] * d + a[13], 
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14], this;
    },
    applyProjection: function(a) {
        var b = this.x, c = this.y, d = this.z;
        a = a.elements;
        var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
        return this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e, this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e, 
        this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e, this;
    },
    applyQuaternion: function(a) {
        var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
        a = a.w;
        var h = a * b + f * d - g * c, i = a * c + g * b - e * d, j = a * d + e * c - f * b, b = -e * b - f * c - g * d;
        return this.x = h * a + b * -e + i * -g - j * -f, this.y = i * a + b * -f + j * -e - h * -g, 
        this.z = j * a + b * -g + h * -f - i * -e, this;
    },
    project: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), 
            this.applyProjection(a);
        };
    }(),
    unproject: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), 
            this.applyProjection(a);
        };
    }(),
    transformDirection: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d, this.y = a[1] * b + a[5] * c + a[9] * d, 
        this.z = a[2] * b + a[6] * c + a[10] * d, this.normalize(), this;
    },
    divide: function(a) {
        return this.x /= a.x, this.y /= a.y, this.z /= a.z, this;
    },
    divideScalar: function(a) {
        return 0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0, 
        this;
    },
    min: function(a) {
        return this.x > a.x && (this.x = a.x), this.y > a.y && (this.y = a.y), this.z > a.z && (this.z = a.z), 
        this;
    },
    max: function(a) {
        return this.x < a.x && (this.x = a.x), this.y < a.y && (this.y = a.y), this.z < a.z && (this.z = a.z), 
        this;
    },
    clamp: function(a, b) {
        return this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x), this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y), 
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z), this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3()), a.set(c, c, c), 
            b.set(d, d, d), this.clamp(a, b);
        };
    }(),
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
        this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
        this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
        this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(a) {
        var b = this.length();
        return 0 !== b && a !== b && this.multiplyScalar(a / b), this;
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
        this;
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a), this;
    },
    cross: function(a, b) {
        if (void 0 !== b) return THREE.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), 
        this.crossVectors(a, b);
        var c = this.x, d = this.y, e = this.z;
        return this.x = d * a.z - e * a.y, this.y = e * a.x - c * a.z, this.z = c * a.y - d * a.x, 
        this;
    },
    crossVectors: function(a, b) {
        var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
        return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this;
    },
    projectOnVector: function() {
        var a, b;
        return function(c) {
            return void 0 === a && (a = new THREE.Vector3()), a.copy(c).normalize(), b = this.dot(a), 
            this.copy(a).multiplyScalar(b);
        };
    }(),
    projectOnPlane: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Vector3()), a.copy(this).projectOnVector(b), 
            this.sub(a);
        };
    }(),
    reflect: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Vector3()), this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
        };
    }(),
    angleTo: function(a) {
        return a = this.dot(a) / (this.length() * a.length()), Math.acos(THREE.Math.clamp(a, -1, 1));
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x, c = this.y - a.y;
        return a = this.z - a.z, b * b + c * c + a * a;
    },
    setEulerFromRotationMatrix: function(a, b) {
        THREE.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function(a, b) {
        THREE.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(a) {
        return THREE.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), 
        this.setFromMatrixPosition(a);
    },
    getScaleFromMatrix: function(a) {
        return THREE.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), 
        this.setFromMatrixScale(a);
    },
    getColumnFromMatrix: function(a, b) {
        return THREE.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), 
        this.setFromMatrixColumn(a, b);
    },
    setFromMatrixPosition: function(a) {
        return this.x = a.elements[12], this.y = a.elements[13], this.z = a.elements[14], 
        this;
    },
    setFromMatrixScale: function(a) {
        var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(), c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
        return a = this.set(a.elements[8], a.elements[9], a.elements[10]).length(), this.x = b, 
        this.y = c, this.z = a, this;
    },
    setFromMatrixColumn: function(a, b) {
        var c = 4 * a, d = b.elements;
        return this.x = d[c], this.y = d[c + 1], this.z = d[c + 2], this;
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
        this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a[b + 2] = this.z, a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this.z = a.array[b + 2], this;
    },
    clone: function() {
        return new THREE.Vector3(this.x, this.y, this.z);
    }
}, THREE.Vector4 = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1;
}, THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function(a, b, c, d) {
        return this.x = a, this.y = b, this.z = c, this.w = d, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setZ: function(a) {
        return this.z = a, this;
    },
    setW: function(a) {
        return this.w = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          case 2:
            this.z = b;
            break;

          case 3:
            this.w = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          case 3:
            return this.w;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, 
        this;
    },
    add: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, 
        this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this.z += a, this.w += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, 
        this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, 
        this);
    },
    subScalar: function(a) {
        return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this;
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, 
        this;
    },
    multiplyScalar: function(a) {
        return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this;
    },
    applyMatrix4: function(a) {
        var b = this.x, c = this.y, d = this.z, e = this.w;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e, this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e, 
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e, this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e, 
        this;
    },
    divideScalar: function(a) {
        return 0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, 
        this.w = 1), this;
    },
    setAxisAngleFromQuaternion: function(a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, 
        this.z = a.z / b), this;
    },
    setAxisAngleFromRotationMatrix: function(a) {
        var b, c, d;
        a = a.elements;
        var e = a[0];
        d = a[4];
        var f = a[8], g = a[1], h = a[5], i = a[9];
        c = a[2], b = a[6];
        var j = a[10];
        return .01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(i - b) ? .1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(i + b) && .1 > Math.abs(e + h + j - 3) ? (this.set(1, 0, 0, 0), 
        this) : (a = Math.PI, e = (e + 1) / 2, h = (h + 1) / 2, j = (j + 1) / 2, d = (d + g) / 4, 
        f = (f + c) / 4, i = (i + b) / 4, e > h && e > j ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), 
        c = d / b, d = f / b) : h > j ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), 
        b = d / c, d = i / c) : .01 > j ? (c = b = .707106781, d = 0) : (d = Math.sqrt(j), 
        b = f / d, c = i / d), this.set(b, c, d, a), this) : (a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (g - d) * (g - d)), 
        .001 > Math.abs(a) && (a = 1), this.x = (b - i) / a, this.y = (f - c) / a, this.z = (g - d) / a, 
        this.w = Math.acos((e + h + j - 1) / 2), this);
    },
    min: function(a) {
        return this.x > a.x && (this.x = a.x), this.y > a.y && (this.y = a.y), this.z > a.z && (this.z = a.z), 
        this.w > a.w && (this.w = a.w), this;
    },
    max: function(a) {
        return this.x < a.x && (this.x = a.x), this.y < a.y && (this.y = a.y), this.z < a.z && (this.z = a.z), 
        this.w < a.w && (this.w = a.w), this;
    },
    clamp: function(a, b) {
        return this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x), this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y), 
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z), this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w), 
        this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector4(), b = new THREE.Vector4()), a.set(c, c, c, c), 
            b.set(d, d, d, d), this.clamp(a, b);
        };
    }(),
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
        this.w = Math.floor(this.w), this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
        this.w = Math.ceil(this.w), this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
        this.w = Math.round(this.w), this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), 
        this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(a) {
        var b = this.length();
        return 0 !== b && a !== b && this.multiplyScalar(a / b), this;
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
        this.w += (a.w - this.w) * b, this;
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a), this;
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
        this.w = a[b + 3], this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a[b + 2] = this.z, a[b + 3] = this.w, a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this.z = a.array[b + 2], this.w = a.array[b + 3], this;
    },
    clone: function() {
        return new THREE.Vector4(this.x, this.y, this.z, this.w);
    }
}, THREE.Euler = function(a, b, c, d) {
    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || THREE.Euler.DefaultOrder;
}, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", 
THREE.Euler.prototype = {
    constructor: THREE.Euler,
    _x: 0,
    _y: 0,
    _z: 0,
    _order: THREE.Euler.DefaultOrder,
    get x() {
        return this._x;
    },
    set x(a) {
        this._x = a, this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(a) {
        this._y = a, this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(a) {
        this._z = a, this.onChangeCallback();
    },
    get order() {
        return this._order;
    },
    set order(a) {
        this._order = a, this.onChangeCallback();
    },
    set: function(a, b, c, d) {
        return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), 
        this;
    },
    copy: function(a) {
        return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), 
        this;
    },
    setFromRotationMatrix: function(a, b, c) {
        var d = THREE.Math.clamp, e = a.elements;
        a = e[0];
        var f = e[4], g = e[8], h = e[1], i = e[5], j = e[9], k = e[2], l = e[6], e = e[10];
        return b = b || this._order, "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-j, e), 
        this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(j, -1, 1)), 
        .99999 > Math.abs(j) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, a), 
        this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(-k, e), 
        this._z = Math.atan2(-f, i)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), 
        .99999 > Math.abs(k) ? (this._x = Math.atan2(l, e), this._z = Math.atan2(h, a)) : (this._x = 0, 
        this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), 
        .99999 > Math.abs(h) ? (this._x = Math.atan2(-j, i), this._y = Math.atan2(-k, a)) : (this._x = 0, 
        this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), 
        .99999 > Math.abs(f) ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-j, e), 
        this._y = 0)) : THREE.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), 
        this._order = b, !1 !== c && this.onChangeCallback(), this;
    },
    setFromQuaternion: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationFromQuaternion(b), 
            this.setFromRotationMatrix(a, c, d), this;
        };
    }(),
    setFromVector3: function(a, b) {
        return this.set(a.x, a.y, a.z, b || this._order);
    },
    reorder: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            a.setFromEuler(this), this.setFromQuaternion(a, b);
        };
    }(),
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
    },
    fromArray: function(a) {
        return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), 
        this.onChangeCallback(), this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, 
        a[b + 2] = this._z, a[b + 3] = this._order, a;
    },
    toVector3: function(a) {
        return a ? a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z);
    },
    onChange: function(a) {
        return this.onChangeCallback = a, this;
    },
    onChangeCallback: function() {},
    clone: function() {
        return new THREE.Euler(this._x, this._y, this._z, this._order);
    }
}, THREE.Line3 = function(a, b) {
    this.start = void 0 !== a ? a : new THREE.Vector3(), this.end = void 0 !== b ? b : new THREE.Vector3();
}, THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function(a, b) {
        return this.start.copy(a), this.end.copy(b), this;
    },
    copy: function(a) {
        return this.start.copy(a.start), this.end.copy(a.end), this;
    },
    center: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(.5);
    },
    delta: function(a) {
        return (a || new THREE.Vector3()).subVectors(this.end, this.start);
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end);
    },
    distance: function() {
        return this.start.distanceTo(this.end);
    },
    at: function(a, b) {
        var c = b || new THREE.Vector3();
        return this.delta(c).multiplyScalar(a).add(this.start);
    },
    closestPointToPointParameter: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c, d) {
            a.subVectors(c, this.start), b.subVectors(this.end, this.start);
            var e = b.dot(b), e = b.dot(a) / e;
            return d && (e = THREE.Math.clamp(e, 0, 1)), e;
        };
    }(),
    closestPointToPoint: function(a, b, c) {
        return a = this.closestPointToPointParameter(a, b), c = c || new THREE.Vector3(), 
        this.delta(c).multiplyScalar(a).add(this.start);
    },
    applyMatrix4: function(a) {
        return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this;
    },
    equals: function(a) {
        return a.start.equals(this.start) && a.end.equals(this.end);
    },
    clone: function() {
        return new THREE.Line3().copy(this);
    }
}, THREE.Box2 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new THREE.Vector2(-(1 / 0), -(1 / 0));
}, THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function(a, b) {
        return this.min.copy(a), this.max.copy(b), this;
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; c > b; b++) this.expandByPoint(a[b]);
        return this;
    },
    setFromCenterAndSize: function() {
        var a = new THREE.Vector2();
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;
        };
    }(),
    copy: function(a) {
        return this.min.copy(a.min), this.max.copy(a.max), this;
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this;
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    center: function(a) {
        return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(a) {
        return (a || new THREE.Vector2()).subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
        return this.min.min(a), this.max.max(a), this;
    },
    expandByVector: function(a) {
        return this.min.sub(a), this.max.add(a), this;
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a), this.max.addScalar(a), this;
    },
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1;
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector2()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
    },
    isIntersectionBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector2();
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
        };
    }(),
    intersect: function(a) {
        return this.min.max(a.min), this.max.min(a.max), this;
    },
    union: function(a) {
        return this.min.min(a.min), this.max.max(a.max), this;
    },
    translate: function(a) {
        return this.min.add(a), this.max.add(a), this;
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max);
    },
    clone: function() {
        return new THREE.Box2().copy(this);
    }
}, THREE.Box3 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new THREE.Vector3(-(1 / 0), -(1 / 0), -(1 / 0));
}, THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function(a, b) {
        return this.min.copy(a), this.max.copy(b), this;
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; c > b; b++) this.expandByPoint(a[b]);
        return this;
    },
    setFromCenterAndSize: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;
        };
    }(),
    setFromObject: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = this;
            return b.updateMatrixWorld(!0), this.makeEmpty(), b.traverse(function(b) {
                var d = b.geometry;
                if (void 0 !== d) if (d instanceof THREE.Geometry) for (var e = d.vertices, d = 0, f = e.length; f > d; d++) a.copy(e[d]), 
                a.applyMatrix4(b.matrixWorld), c.expandByPoint(a); else if (d instanceof THREE.BufferGeometry && void 0 !== d.attributes.position) for (e = d.attributes.position.array, 
                d = 0, f = e.length; f > d; d += 3) a.set(e[d], e[d + 1], e[d + 2]), a.applyMatrix4(b.matrixWorld), 
                c.expandByPoint(a);
            }), this;
        };
    }(),
    copy: function(a) {
        return this.min.copy(a.min), this.max.copy(a.max), this;
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), 
        this;
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    center: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(a) {
        return (a || new THREE.Vector3()).subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
        return this.min.min(a), this.max.max(a), this;
    },
    expandByVector: function(a) {
        return this.min.sub(a), this.max.add(a), this;
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a), this.max.addScalar(a), this;
    },
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1;
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector3()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
    },
    isIntersectionBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
        };
    }(),
    getBoundingSphere: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return b = b || new THREE.Sphere(), b.center = this.center(), b.radius = .5 * this.size(a).length(), 
            b;
        };
    }(),
    intersect: function(a) {
        return this.min.max(a.min), this.max.min(a.max), this;
    },
    union: function(a) {
        return this.min.min(a.min), this.max.max(a.max), this;
    },
    applyMatrix4: function() {
        var a = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
        return function(b) {
            return a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), 
            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), 
            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), 
            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), 
            this.makeEmpty(), this.setFromPoints(a), this;
        };
    }(),
    translate: function(a) {
        return this.min.add(a), this.max.add(a), this;
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max);
    },
    clone: function() {
        return new THREE.Box3().copy(this);
    }
}, THREE.Matrix3 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 0 < arguments.length && THREE.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}, THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function(a, b, c, d, e, f, g, h, i) {
        var j = this.elements;
        return j[0] = a, j[3] = b, j[6] = c, j[1] = d, j[4] = e, j[7] = f, j[2] = g, j[5] = h, 
        j[8] = i, this;
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    copy: function(a) {
        return a = a.elements, this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]), 
        this;
    },
    multiplyVector3: function(a) {
        return THREE.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), 
        a.applyMatrix3(this);
    },
    multiplyVector3Array: function(a) {
        return THREE.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
        this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
        var a = new THREE.Vector3();
        return function(b, c, d) {
            void 0 === c && (c = 0), void 0 === d && (d = b.length);
            for (var e = 0; d > e; e += 3, c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], 
            a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b;
        };
    }(),
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, 
        b[5] *= a, b[8] *= a, this;
    },
    determinant: function() {
        var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], a = a[8];
        return b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h;
    },
    getInverse: function(a, b) {
        var c = a.elements, d = this.elements;
        if (d[0] = c[10] * c[5] - c[6] * c[9], d[1] = -c[10] * c[1] + c[2] * c[9], d[2] = c[6] * c[1] - c[2] * c[5], 
        d[3] = -c[10] * c[4] + c[6] * c[8], d[4] = c[10] * c[0] - c[2] * c[8], d[5] = -c[6] * c[0] + c[2] * c[4], 
        d[6] = c[9] * c[4] - c[5] * c[8], d[7] = -c[9] * c[0] + c[1] * c[8], d[8] = c[5] * c[0] - c[1] * c[4], 
        c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6], 0 === c) {
            if (b) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            return THREE.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), 
            this.identity(), this;
        }
        return this.multiplyScalar(1 / c), this;
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], 
        b[5] = b[7], b[7] = a, this;
    },
    flattenToArrayOffset: function(a, b) {
        var c = this.elements;
        return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
        a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a;
    },
    getNormalMatrix: function(a) {
        return this.getInverse(a).transpose(), this;
    },
    transposeIntoArray: function(a) {
        var b = this.elements;
        return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], 
        a[6] = b[2], a[7] = b[5], a[8] = b[8], this;
    },
    fromArray: function(a) {
        return this.elements.set(a), this;
    },
    toArray: function() {
        var a = this.elements;
        return [ a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8] ];
    },
    clone: function() {
        return new THREE.Matrix3().fromArray(this.elements);
    }
}, THREE.Matrix4 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
    0 < arguments.length && THREE.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}, THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        var q = this.elements;
        return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, 
        q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, 
        this;
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    copy: function(a) {
        return this.elements.set(a.elements), this;
    },
    extractPosition: function(a) {
        return THREE.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), 
        this.copyPosition(a);
    },
    copyPosition: function(a) {
        var b = this.elements;
        return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this;
    },
    extractBasis: function(a, b, c) {
        var d = this.elements;
        return a.set(d[0], d[1], d[2]), b.set(d[4], d[5], d[6]), c.set(d[8], d[9], d[10]), 
        this;
    },
    makeBasis: function(a, b, c) {
        return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), 
        this;
    },
    extractRotation: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = this.elements;
            b = b.elements;
            var d = 1 / a.set(b[0], b[1], b[2]).length(), e = 1 / a.set(b[4], b[5], b[6]).length(), f = 1 / a.set(b[8], b[9], b[10]).length();
            return c[0] = b[0] * d, c[1] = b[1] * d, c[2] = b[2] * d, c[4] = b[4] * e, c[5] = b[5] * e, 
            c[6] = b[6] * e, c[8] = b[8] * f, c[9] = b[9] * f, c[10] = b[10] * f, this;
        };
    }(),
    makeRotationFromEuler: function(a) {
        !1 == a instanceof THREE.Euler && THREE.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
        if ("XYZ" === a.order) {
            a = f * h;
            var i = f * e, j = c * h, k = c * e;
            b[0] = g * h, b[4] = -g * e, b[8] = d, b[1] = i + j * d, b[5] = a - k * d, b[9] = -c * g, 
            b[2] = k - a * d, b[6] = j + i * d, b[10] = f * g;
        } else "YXZ" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a + k * c, 
        b[4] = j * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = i * c - j, 
        b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, i = g * e, j = d * h, 
        k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = j + i * c, b[1] = i + j * c, 
        b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, 
        i = f * e, j = c * h, k = c * e, b[0] = g * h, b[4] = j * d - i, b[8] = a * d + k, 
        b[1] = g * e, b[5] = k * d + a, b[9] = i * d - j, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, 
        i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = j * e + i, 
        b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = i * e + j, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, 
        i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, 
        b[5] = f * h, b[9] = i * e - j, b[2] = j * e - i, b[6] = c * h, b[10] = k * e + a);
        return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, 
        this;
    },
    setRotationFromQuaternion: function(a) {
        return THREE.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), 
        this.makeRotationFromQuaternion(a);
    },
    makeRotationFromQuaternion: function(a) {
        var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, i = e + e;
        a = c * g;
        var j = c * h, c = c * i, k = d * h, d = d * i, e = e * i, g = f * g, h = f * h, f = f * i;
        return b[0] = 1 - (k + e), b[4] = j - f, b[8] = c + h, b[1] = j + f, b[5] = 1 - (a + e), 
        b[9] = d - g, b[2] = c - h, b[6] = d + g, b[10] = 1 - (a + k), b[3] = 0, b[7] = 0, 
        b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;
    },
    lookAt: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
        return function(d, e, f) {
            var g = this.elements;
            return c.subVectors(d, e).normalize(), 0 === c.length() && (c.z = 1), a.crossVectors(f, c).normalize(), 
            0 === a.length() && (c.x += 1e-4, a.crossVectors(f, c).normalize()), b.crossVectors(c, a), 
            g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, 
            g[6] = b.z, g[10] = c.z, this;
        };
    }(),
    multiply: function(a, b) {
        return void 0 !== b ? (THREE.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), 
        this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
    },
    multiplyMatrices: function(a, b) {
        var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], i = c[12], j = c[1], k = c[5], l = c[9], m = c[13], n = c[2], o = c[6], p = c[10], q = c[14], r = c[3], s = c[7], t = c[11], c = c[15], u = d[0], v = d[4], w = d[8], x = d[12], y = d[1], z = d[5], A = d[9], B = d[13], C = d[2], D = d[6], E = d[10], F = d[14], G = d[3], H = d[7], I = d[11], d = d[15];
        return e[0] = f * u + g * y + h * C + i * G, e[4] = f * v + g * z + h * D + i * H, 
        e[8] = f * w + g * A + h * E + i * I, e[12] = f * x + g * B + h * F + i * d, e[1] = j * u + k * y + l * C + m * G, 
        e[5] = j * v + k * z + l * D + m * H, e[9] = j * w + k * A + l * E + m * I, e[13] = j * x + k * B + l * F + m * d, 
        e[2] = n * u + o * y + p * C + q * G, e[6] = n * v + o * z + p * D + q * H, e[10] = n * w + o * A + p * E + q * I, 
        e[14] = n * x + o * B + p * F + q * d, e[3] = r * u + s * y + t * C + c * G, e[7] = r * v + s * z + t * D + c * H, 
        e[11] = r * w + s * A + t * E + c * I, e[15] = r * x + s * B + t * F + c * d, this;
    },
    multiplyToArray: function(a, b, c) {
        var d = this.elements;
        return this.multiplyMatrices(a, b), c[0] = d[0], c[1] = d[1], c[2] = d[2], c[3] = d[3], 
        c[4] = d[4], c[5] = d[5], c[6] = d[6], c[7] = d[7], c[8] = d[8], c[9] = d[9], c[10] = d[10], 
        c[11] = d[11], c[12] = d[12], c[13] = d[13], c[14] = d[14], c[15] = d[15], this;
    },
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, 
        b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, 
        b[11] *= a, b[15] *= a, this;
    },
    multiplyVector3: function(a) {
        return THREE.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), 
        a.applyProjection(this);
    },
    multiplyVector4: function(a) {
        return THREE.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
        a.applyMatrix4(this);
    },
    multiplyVector3Array: function(a) {
        return THREE.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
        this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
        var a = new THREE.Vector3();
        return function(b, c, d) {
            void 0 === c && (c = 0), void 0 === d && (d = b.length);
            for (var e = 0; d > e; e += 3, c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], 
            a.applyMatrix4(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b;
        };
    }(),
    rotateAxis: function(a) {
        THREE.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), 
        a.transformDirection(this);
    },
    crossVector: function(a) {
        return THREE.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
        a.applyMatrix4(this);
    },
    determinant: function() {
        var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], i = a[13], j = a[2], k = a[6], l = a[10], m = a[14];
        return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j);
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], 
        b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], 
        b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this;
    },
    flattenToArrayOffset: function(a, b) {
        var c = this.elements;
        return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
        a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], 
        a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], 
        a[b + 15] = c[15], a;
    },
    getPosition: function() {
        var a = new THREE.Vector3();
        return function() {
            THREE.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
            var b = this.elements;
            return a.set(b[12], b[13], b[14]);
        };
    }(),
    setPosition: function(a) {
        var b = this.elements;
        return b[12] = a.x, b[13] = a.y, b[14] = a.z, this;
    },
    getInverse: function(a, b) {
        var c = this.elements, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[12], i = d[1], j = d[5], k = d[9], l = d[13], m = d[2], n = d[6], o = d[10], p = d[14], q = d[3], r = d[7], s = d[11], d = d[15];
        if (c[0] = k * p * r - l * o * r + l * n * s - j * p * s - k * n * d + j * o * d, 
        c[4] = h * o * r - g * p * r - h * n * s + f * p * s + g * n * d - f * o * d, c[8] = g * l * r - h * k * r + h * j * s - f * l * s - g * j * d + f * k * d, 
        c[12] = h * k * n - g * l * n - h * j * o + f * l * o + g * j * p - f * k * p, c[1] = l * o * q - k * p * q - l * m * s + i * p * s + k * m * d - i * o * d, 
        c[5] = g * p * q - h * o * q + h * m * s - e * p * s - g * m * d + e * o * d, c[9] = h * k * q - g * l * q - h * i * s + e * l * s + g * i * d - e * k * d, 
        c[13] = g * l * m - h * k * m + h * i * o - e * l * o - g * i * p + e * k * p, c[2] = j * p * q - l * n * q + l * m * r - i * p * r - j * m * d + i * n * d, 
        c[6] = h * n * q - f * p * q - h * m * r + e * p * r + f * m * d - e * n * d, c[10] = f * l * q - h * j * q + h * i * r - e * l * r - f * i * d + e * j * d, 
        c[14] = h * j * m - f * l * m - h * i * n + e * l * n + f * i * p - e * j * p, c[3] = k * n * q - j * o * q - k * m * r + i * o * r + j * m * s - i * n * s, 
        c[7] = f * o * q - g * n * q + g * m * r - e * o * r - f * m * s + e * n * s, c[11] = g * j * q - f * k * q - g * i * r + e * k * r + f * i * s - e * j * s, 
        c[15] = f * k * m - g * j * m + g * i * n - e * k * n - f * i * o + e * j * o, c = e * c[0] + i * c[4] + m * c[8] + q * c[12], 
        0 == c) {
            if (b) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
            return THREE.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), 
            this.identity(), this;
        }
        return this.multiplyScalar(1 / c), this;
    },
    translate: function(a) {
        THREE.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function(a) {
        THREE.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function(a) {
        THREE.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function(a) {
        THREE.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function(a, b) {
        THREE.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    scale: function(a) {
        var b = this.elements, c = a.x, d = a.y;
        return a = a.z, b[0] *= c, b[4] *= d, b[8] *= a, b[1] *= c, b[5] *= d, b[9] *= a, 
        b[2] *= c, b[6] *= d, b[10] *= a, b[3] *= c, b[7] *= d, b[11] *= a, this;
    },
    getMaxScaleOnAxis: function() {
        var a = this.elements;
        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));
    },
    makeTranslation: function(a, b, c) {
        return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this;
    },
    makeRotationX: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationY: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationZ: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationAxis: function(a, b) {
        var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, i = e * f, j = e * g;
        return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), 
        this;
    },
    makeScale: function(a, b, c) {
        return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this;
    },
    compose: function(a, b, c) {
        return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this;
    },
    decompose: function() {
        var a = new THREE.Vector3(), b = new THREE.Matrix4();
        return function(c, d, e) {
            var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), i = a.set(f[8], f[9], f[10]).length();
            0 > this.determinant() && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.elements.set(this.elements), 
            c = 1 / g;
            var f = 1 / h, j = 1 / i;
            return b.elements[0] *= c, b.elements[1] *= c, b.elements[2] *= c, b.elements[4] *= f, 
            b.elements[5] *= f, b.elements[6] *= f, b.elements[8] *= j, b.elements[9] *= j, 
            b.elements[10] *= j, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this;
        };
    }(),
    makeFrustum: function(a, b, c, d, e, f) {
        var g = this.elements;
        return g[0] = 2 * e / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, 
        g[5] = 2 * e / (d - c), g[9] = (d + c) / (d - c), g[13] = 0, g[2] = 0, g[6] = 0, 
        g[10] = -(f + e) / (f - e), g[14] = -2 * f * e / (f - e), g[3] = 0, g[7] = 0, g[11] = -1, 
        g[15] = 0, this;
    },
    makePerspective: function(a, b, c, d) {
        a = c * Math.tan(THREE.Math.degToRad(.5 * a));
        var e = -a;
        return this.makeFrustum(e * b, a * b, e, a, c, d);
    },
    makeOrthographic: function(a, b, c, d, e, f) {
        var g = this.elements, h = b - a, i = c - d, j = f - e;
        return g[0] = 2 / h, g[4] = 0, g[8] = 0, g[12] = -((b + a) / h), g[1] = 0, g[5] = 2 / i, 
        g[9] = 0, g[13] = -((c + d) / i), g[2] = 0, g[6] = 0, g[10] = -2 / j, g[14] = -((f + e) / j), 
        g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this;
    },
    fromArray: function(a) {
        return this.elements.set(a), this;
    },
    toArray: function() {
        var a = this.elements;
        return [ a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15] ];
    },
    clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
    }
}, THREE.Ray = function(a, b) {
    this.origin = void 0 !== a ? a : new THREE.Vector3(), this.direction = void 0 !== b ? b : new THREE.Vector3();
}, THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function(a, b) {
        return this.origin.copy(a), this.direction.copy(b), this;
    },
    copy: function(a) {
        return this.origin.copy(a.origin), this.direction.copy(a.direction), this;
    },
    at: function(a, b) {
        return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);
    },
    recast: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return this.origin.copy(this.at(b, a)), this;
        };
    }(),
    closestPointToPoint: function(a, b) {
        var c = b || new THREE.Vector3();
        c.subVectors(a, this.origin);
        var d = c.dot(this.direction);
        return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            return 0 > c ? this.origin.distanceTo(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), 
            a.distanceTo(b));
        };
    }(),
    distanceSqToSegment: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
        return function(d, e, f, g) {
            a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
            var h, i = .5 * d.distanceTo(e), j = -this.direction.dot(b), k = c.dot(this.direction), l = -c.dot(b), m = c.lengthSq(), n = Math.abs(1 - j * j);
            return n > 0 ? (d = j * l - k, e = j * k - l, h = i * n, d >= 0 ? e >= -h ? h >= e ? (i = 1 / n, 
            d *= i, e *= i, j = d * (d + j * e + 2 * k) + e * (j * d + e + 2 * l) + m) : (e = i, 
            d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : (e = -i, d = Math.max(0, -(j * e + k)), 
            j = -d * d + e * (e + 2 * l) + m) : -h >= e ? (d = Math.max(0, -(-j * i + k)), e = d > 0 ? -i : Math.min(Math.max(-i, -l), i), 
            j = -d * d + e * (e + 2 * l) + m) : h >= e ? (d = 0, e = Math.min(Math.max(-i, -l), i), 
            j = e * (e + 2 * l) + m) : (d = Math.max(0, -(j * i + k)), e = d > 0 ? i : Math.min(Math.max(-i, -l), i), 
            j = -d * d + e * (e + 2 * l) + m)) : (e = j > 0 ? -i : i, d = Math.max(0, -(j * e + k)), 
            j = -d * d + e * (e + 2 * l) + m), f && f.copy(this.direction).multiplyScalar(d).add(this.origin), 
            g && g.copy(b).multiplyScalar(e).add(a), j;
        };
    }(),
    isIntersectionSphere: function(a) {
        return this.distanceToPoint(a.center) <= a.radius;
    },
    intersectSphere: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            a.subVectors(b.center, this.origin);
            var d = a.dot(this.direction), e = a.dot(a) - d * d, f = b.radius * b.radius;
            return e > f ? null : (f = Math.sqrt(f - e), e = d - f, d += f, 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c));
        };
    }(),
    isIntersectionPlane: function(a) {
        var b = a.distanceToPoint(this.origin);
        return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
    },
    distanceToPlane: function(a) {
        var b = a.normal.dot(this.direction);
        return 0 == b ? 0 == a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b, 
        a >= 0 ? a : null);
    },
    intersectPlane: function(a, b) {
        var c = this.distanceToPlane(a);
        return null === c ? null : this.at(c, b);
    },
    isIntersectionBox: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return null !== this.intersectBox(b, a);
        };
    }(),
    intersectBox: function(a, b) {
        var c, d, e, f, g;
        d = 1 / this.direction.x, f = 1 / this.direction.y, g = 1 / this.direction.z;
        var h = this.origin;
        return d >= 0 ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, 
        d *= a.min.x - h.x), f >= 0 ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, 
        f *= a.min.y - h.y), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (d > f || d !== d) && (d = f), 
        g >= 0 ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, 
        g *= a.min.z - h.z), c > g || e > d ? null : ((e > c || c !== c) && (c = e), (d > g || d !== d) && (d = g), 
        0 > d ? null : this.at(c >= 0 ? c : d, b)));
    },
    intersectTriangle: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Vector3();
        return function(e, f, g, h, i) {
            if (b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c), f = this.direction.dot(d), 
            f > 0) {
                if (h) return null;
                h = 1;
            } else {
                if (!(0 > f)) return null;
                h = -1, f = -f;
            }
            return a.subVectors(this.origin, e), e = h * this.direction.dot(c.crossVectors(a, c)), 
            0 > e ? null : (g = h * this.direction.dot(b.cross(a)), 0 > g || e + g > f ? null : (e = -h * a.dot(d), 
            0 > e ? null : this.at(e / f, i)));
        };
    }(),
    applyMatrix4: function(a) {
        return this.direction.add(this.origin).applyMatrix4(a), this.origin.applyMatrix4(a), 
        this.direction.sub(this.origin), this.direction.normalize(), this;
    },
    equals: function(a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction);
    },
    clone: function() {
        return new THREE.Ray().copy(this);
    }
}, THREE.Sphere = function(a, b) {
    this.center = void 0 !== a ? a : new THREE.Vector3(), this.radius = void 0 !== b ? b : 0;
}, THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function(a, b) {
        return this.center.copy(a), this.radius = b, this;
    },
    setFromPoints: function() {
        var a = new THREE.Box3();
        return function(b, c) {
            var d = this.center;
            void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
            for (var e = 0, f = 0, g = b.length; g > f; f++) e = Math.max(e, d.distanceToSquared(b[f]));
            return this.radius = Math.sqrt(e), this;
        };
    }(),
    copy: function(a) {
        return this.center.copy(a.center), this.radius = a.radius, this;
    },
    empty: function() {
        return 0 >= this.radius;
    },
    containsPoint: function(a) {
        return a.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(a) {
        return a.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b;
    },
    clampPoint: function(a, b) {
        var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3();
        return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), 
        d.multiplyScalar(this.radius).add(this.center)), d;
    },
    getBoundingBox: function(a) {
        return a = a || new THREE.Box3(), a.set(this.center, this.center), a.expandByScalar(this.radius), 
        a;
    },
    applyMatrix4: function(a) {
        return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this;
    },
    translate: function(a) {
        return this.center.add(a), this;
    },
    equals: function(a) {
        return a.center.equals(this.center) && a.radius === this.radius;
    },
    clone: function() {
        return new THREE.Sphere().copy(this);
    }
}, THREE.Frustum = function(a, b, c, d, e, f) {
    this.planes = [ void 0 !== a ? a : new THREE.Plane(), void 0 !== b ? b : new THREE.Plane(), void 0 !== c ? c : new THREE.Plane(), void 0 !== d ? d : new THREE.Plane(), void 0 !== e ? e : new THREE.Plane(), void 0 !== f ? f : new THREE.Plane() ];
}, THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function(a, b, c, d, e, f) {
        var g = this.planes;
        return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), 
        this;
    },
    copy: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
        return this;
    },
    setFromMatrix: function(a) {
        var b = this.planes, c = a.elements;
        a = c[0];
        var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], i = c[6], j = c[7], k = c[8], l = c[9], m = c[10], n = c[11], o = c[12], p = c[13], q = c[14], c = c[15];
        return b[0].setComponents(f - a, j - g, n - k, c - o).normalize(), b[1].setComponents(f + a, j + g, n + k, c + o).normalize(), 
        b[2].setComponents(f + d, j + h, n + l, c + p).normalize(), b[3].setComponents(f - d, j - h, n - l, c - p).normalize(), 
        b[4].setComponents(f - e, j - i, n - m, c - q).normalize(), b[5].setComponents(f + e, j + i, n + m, c + q).normalize(), 
        this;
    },
    intersectsObject: function() {
        var a = new THREE.Sphere();
        return function(b) {
            var c = b.geometry;
            return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere), 
            a.applyMatrix4(b.matrixWorld), this.intersectsSphere(a);
        };
    }(),
    intersectsSphere: function(a) {
        var b = this.planes, c = a.center;
        a = -a.radius;
        for (var d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return !1;
        return !0;
    },
    intersectsBox: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c) {
            for (var d = this.planes, e = 0; 6 > e; e++) {
                var f = d[e];
                a.x = 0 < f.normal.x ? c.min.x : c.max.x, b.x = 0 < f.normal.x ? c.max.x : c.min.x, 
                a.y = 0 < f.normal.y ? c.min.y : c.max.y, b.y = 0 < f.normal.y ? c.max.y : c.min.y, 
                a.z = 0 < f.normal.z ? c.min.z : c.max.z, b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
                if (0 > g && 0 > f) return !1;
            }
            return !0;
        };
    }(),
    containsPoint: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++) if (0 > b[c].distanceToPoint(a)) return !1;
        return !0;
    },
    clone: function() {
        return new THREE.Frustum().copy(this);
    }
}, THREE.Plane = function(a, b) {
    this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== b ? b : 0;
}, THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function(a, b) {
        return this.normal.copy(a), this.constant = b, this;
    },
    setComponents: function(a, b, c, d) {
        return this.normal.set(a, b, c), this.constant = d, this;
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
        return this.normal.copy(a), this.constant = -b.dot(this.normal), this;
    },
    setFromCoplanarPoints: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c, d, e) {
            return d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(), this.setFromNormalAndCoplanarPoint(d, c), 
            this;
        };
    }(),
    copy: function(a) {
        return this.normal.copy(a.normal), this.constant = a.constant, this;
    },
    normalize: function() {
        var a = 1 / this.normal.length();
        return this.normal.multiplyScalar(a), this.constant *= a, this;
    },
    negate: function() {
        return this.constant *= -1, this.normal.negate(), this;
    },
    distanceToPoint: function(a) {
        return this.normal.dot(a) + this.constant;
    },
    distanceToSphere: function(a) {
        return this.distanceToPoint(a.center) - a.radius;
    },
    projectPoint: function(a, b) {
        return this.orthoPoint(a, b).sub(a).negate();
    },
    orthoPoint: function(a, b) {
        var c = this.distanceToPoint(a);
        return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);
    },
    isIntersectionLine: function(a) {
        var b = this.distanceToPoint(a.start);
        return a = this.distanceToPoint(a.end), 0 > b && a > 0 || 0 > a && b > 0;
    },
    intersectLine: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            var d = c || new THREE.Vector3(), e = b.delta(a), f = this.normal.dot(e);
            return 0 != f ? (f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || f > 1 ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)) : 0 == this.distanceToPoint(b.start) ? d.copy(b.start) : void 0;
        };
    }(),
    coplanarPoint: function(a) {
        return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Matrix3();
        return function(d, e) {
            var f = e || c.getNormalMatrix(d), f = a.copy(this.normal).applyMatrix3(f), g = this.coplanarPoint(b);
            return g.applyMatrix4(d), this.setFromNormalAndCoplanarPoint(f, g), this;
        };
    }(),
    translate: function(a) {
        return this.constant -= a.dot(this.normal), this;
    },
    equals: function(a) {
        return a.normal.equals(this.normal) && a.constant == this.constant;
    },
    clone: function() {
        return new THREE.Plane().copy(this);
    }
}, THREE.Math = {
    generateUUID: function() {
        var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), c = Array(36), d = 0;
        return function() {
            for (var e = 0; 36 > e; e++) 8 == e || 13 == e || 18 == e || 23 == e ? c[e] = "-" : 14 == e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), 
            a = 15 & d, d >>= 4, c[e] = b[19 == e ? 3 & a | 8 : a]);
            return c.join("");
        };
    }(),
    clamp: function(a, b, c) {
        return b > a ? b : a > c ? c : a;
    },
    clampBottom: function(a, b) {
        return b > a ? b : a;
    },
    mapLinear: function(a, b, c, d, e) {
        return d + (a - b) * (e - d) / (c - b);
    },
    smoothstep: function(a, b, c) {
        return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a));
    },
    smootherstep: function(a, b, c) {
        return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10));
    },
    random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
    },
    randInt: function(a, b) {
        return Math.floor(this.randFloat(a, b));
    },
    randFloat: function(a, b) {
        return a + Math.random() * (b - a);
    },
    randFloatSpread: function(a) {
        return a * (.5 - Math.random());
    },
    degToRad: function() {
        var a = Math.PI / 180;
        return function(b) {
            return b * a;
        };
    }(),
    radToDeg: function() {
        var a = 180 / Math.PI;
        return function(b) {
            return b * a;
        };
    }(),
    isPowerOfTwo: function(a) {
        return 0 === (a & a - 1) && 0 !== a;
    },
    nextPowerOfTwo: function(a) {
        return a--, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, a++, 
        a;
    }
}, THREE.Spline = function(a) {
    function b(a, b, c, d, e, f, g) {
        return a = .5 * (c - a), d = .5 * (d - b), (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
    }
    this.points = a;
    var c, d, e, f, g, h, i, j, k, l = [], m = {
        x: 0,
        y: 0,
        z: 0
    };
    this.initFromArray = function(a) {
        this.points = [];
        for (var b = 0; b < a.length; b++) this.points[b] = {
            x: a[b][0],
            y: a[b][1],
            z: a[b][2]
        };
    }, this.getPoint = function(a) {
        return c = (this.points.length - 1) * a, d = Math.floor(c), e = c - d, l[0] = 0 === d ? d : d - 1, 
        l[1] = d, l[2] = d > this.points.length - 2 ? this.points.length - 1 : d + 1, l[3] = d > this.points.length - 3 ? this.points.length - 1 : d + 2, 
        h = this.points[l[0]], i = this.points[l[1]], j = this.points[l[2]], k = this.points[l[3]], 
        f = e * e, g = e * f, m.x = b(h.x, i.x, j.x, k.x, e, f, g), m.y = b(h.y, i.y, j.y, k.y, e, f, g), 
        m.z = b(h.z, i.z, j.z, k.z, e, f, g), m;
    }, this.getControlPointsArray = function() {
        var a, b, c = this.points.length, d = [];
        for (a = 0; c > a; a++) b = this.points[a], d[a] = [ b.x, b.y, b.z ];
        return d;
    }, this.getLength = function(a) {
        var b, c, d, e = b = b = 0, f = new THREE.Vector3(), g = new THREE.Vector3(), h = [], i = 0;
        for (h[0] = 0, a || (a = 100), c = this.points.length * a, f.copy(this.points[0]), 
        a = 1; c > a; a++) b = a / c, d = this.getPoint(b), g.copy(d), i += g.distanceTo(f), 
        f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = i, 
        e = b);
        return h[h.length] = i, {
            chunks: h,
            total: i
        };
    }, this.reparametrizeByArcLength = function(a) {
        var b, c, d, e, f, g, h = [], i = new THREE.Vector3(), j = this.getLength();
        for (h.push(i.copy(this.points[0]).clone()), b = 1; b < this.points.length; b++) {
            for (c = j.chunks[b] - j.chunks[b - 1], g = Math.ceil(a * c / j.total), e = (b - 1) / (this.points.length - 1), 
            f = b / (this.points.length - 1), c = 1; g - 1 > c; c++) d = e + 1 / g * c * (f - e), 
            d = this.getPoint(d), h.push(i.copy(d).clone());
            h.push(i.copy(this.points[b]).clone());
        }
        this.points = h;
    };
}, THREE.Triangle = function(a, b, c) {
    this.a = void 0 !== a ? a : new THREE.Vector3(), this.b = void 0 !== b ? b : new THREE.Vector3(), 
    this.c = void 0 !== c ? c : new THREE.Vector3();
}, THREE.Triangle.normal = function() {
    var a = new THREE.Vector3();
    return function(b, c, d, e) {
        return e = e || new THREE.Vector3(), e.subVectors(d, c), a.subVectors(b, c), e.cross(a), 
        b = e.lengthSq(), b > 0 ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
    };
}(), THREE.Triangle.barycoordFromPoint = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function(d, e, f, g, h) {
        a.subVectors(g, e), b.subVectors(f, e), c.subVectors(d, e), d = a.dot(a), e = a.dot(b), 
        f = a.dot(c);
        var i = b.dot(b);
        g = b.dot(c);
        var j = d * i - e * e;
        return h = h || new THREE.Vector3(), 0 == j ? h.set(-2, -1, -1) : (j = 1 / j, i = (i * f - e * g) * j, 
        d = (d * g - e * f) * j, h.set(1 - i - d, d, i));
    };
}(), THREE.Triangle.containsPoint = function() {
    var a = new THREE.Vector3();
    return function(b, c, d, e) {
        return b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a), 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;
    };
}(), THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function(a, b, c) {
        return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
    },
    setFromPointsAndIndices: function(a, b, c, d) {
        return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this;
    },
    copy: function(a) {
        return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this;
    },
    area: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function() {
            return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length();
        };
    }(),
    midpoint: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    normal: function(a) {
        return THREE.Triangle.normal(this.a, this.b, this.c, a);
    },
    plane: function(a) {
        return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
    },
    barycoordFromPoint: function(a, b) {
        return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);
    },
    containsPoint: function(a) {
        return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
    },
    equals: function(a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
    },
    clone: function() {
        return new THREE.Triangle().copy(this);
    }
}, THREE.Clock = function(a) {
    this.autoStart = void 0 !== a ? a : !0, this.elapsedTime = this.oldTime = this.startTime = 0, 
    this.running = !1;
}, THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function() {
        this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), 
        this.running = !0;
    },
    stop: function() {
        this.getElapsedTime(), this.running = !1;
    },
    getElapsedTime: function() {
        return this.getDelta(), this.elapsedTime;
    },
    getDelta: function() {
        var a = 0;
        if (this.autoStart && !this.running && this.start(), this.running) {
            var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), a = .001 * (b - this.oldTime);
            this.oldTime = b, this.elapsedTime += a;
        }
        return a;
    }
}, THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function(a) {
        a.addEventListener = THREE.EventDispatcher.prototype.addEventListener, a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, 
        a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
    },
    addEventListener: function(a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b);
    },
    hasEventListener: function(a, b) {
        if (void 0 === this._listeners) return !1;
        var c = this._listeners;
        return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c) {
                var d = c.indexOf(b);
                -1 !== d && c.splice(d, 1);
            }
        }
    },
    dispatchEvent: function(a) {
        if (void 0 !== this._listeners) {
            var b = this._listeners[a.type];
            if (void 0 !== b) {
                a.target = this;
                for (var c = [], d = b.length, e = 0; d > e; e++) c[e] = b[e];
                for (e = 0; d > e; e++) c[e].call(this, a);
            }
        }
    }
}, function(a) {
    a.Raycaster = function(b, c, d, e) {
        this.ray = new a.Ray(b, c), this.near = d || 0, this.far = e || 1 / 0, this.params = {
            Sprite: {},
            Mesh: {},
            PointCloud: {
                threshold: 1
            },
            LOD: {},
            Line: {}
        };
    };
    var b = function(a, b) {
        return a.distance - b.distance;
    }, c = function(a, b, d, e) {
        if (a.raycast(b, d), !0 === e) {
            a = a.children, e = 0;
            for (var f = a.length; f > e; e++) c(a[e], b, d, !0);
        }
    };
    a.Raycaster.prototype = {
        constructor: a.Raycaster,
        precision: 1e-4,
        linePrecision: 1,
        set: function(a, b) {
            this.ray.set(a, b);
        },
        setFromCamera: function(b, c) {
            c instanceof a.PerspectiveCamera ? (this.ray.origin.copy(c.position), this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(c.position).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), 
            this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : a.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function(a, d) {
            var e = [];
            return c(a, this, e, d), e.sort(b), e;
        },
        intersectObjects: function(d, e) {
            var f = [];
            if (!1 == d instanceof Array) return a.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), 
            f;
            for (var g = 0, h = d.length; h > g; g++) c(d[g], this, f, e);
            return f.sort(b), f;
        }
    };
}(THREE), THREE.Object3D = function() {
    Object.defineProperty(this, "id", {
        value: THREE.Object3DIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Object3D", 
    this.parent = void 0, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
    var a = new THREE.Vector3(), b = new THREE.Euler(), c = new THREE.Quaternion(), d = new THREE.Vector3(1, 1, 1);
    b.onChange(function() {
        c.setFromEuler(b, !1);
    }), c.onChange(function() {
        b.setFromQuaternion(c, void 0, !1);
    }), Object.defineProperties(this, {
        position: {
            enumerable: !0,
            value: a
        },
        rotation: {
            enumerable: !0,
            value: b
        },
        quaternion: {
            enumerable: !0,
            value: c
        },
        scale: {
            enumerable: !0,
            value: d
        }
    }), this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4(), this.matrixWorld = new THREE.Matrix4(), 
    this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, 
    this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, 
    this.userData = {};
}, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get eulerOrder() {
        return THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), 
        this.rotation.order;
    },
    set eulerOrder(a) {
        THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order = a;
    },
    get useQuaternion() {
        THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set useQuaternion(a) {
        THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    applyMatrix: function(a) {
        this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    setRotationFromAxisAngle: function(a, b) {
        this.quaternion.setFromAxisAngle(a, b);
    },
    setRotationFromEuler: function(a) {
        this.quaternion.setFromEuler(a, !0);
    },
    setRotationFromMatrix: function(a) {
        this.quaternion.setFromRotationMatrix(a);
    },
    setRotationFromQuaternion: function(a) {
        this.quaternion.copy(a);
    },
    rotateOnAxis: function() {
        var a = new THREE.Quaternion();
        return function(b, c) {
            return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this;
        };
    }(),
    rotateX: function() {
        var a = new THREE.Vector3(1, 0, 0);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    rotateY: function() {
        var a = new THREE.Vector3(0, 1, 0);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    rotateZ: function() {
        var a = new THREE.Vector3(0, 0, 1);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    translateOnAxis: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), 
            this;
        };
    }(),
    translate: function(a, b) {
        return THREE.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), 
        this.translateOnAxis(b, a);
    },
    translateX: function() {
        var a = new THREE.Vector3(1, 0, 0);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    translateY: function() {
        var a = new THREE.Vector3(0, 1, 0);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    translateZ: function() {
        var a = new THREE.Vector3(0, 0, 1);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    localToWorld: function(a) {
        return a.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
        var a = new THREE.Matrix4();
        return function(b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld));
        };
    }(),
    lookAt: function() {
        var a = new THREE.Matrix4();
        return function(b) {
            a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a);
        };
    }(),
    add: function(a) {
        if (1 < arguments.length) {
            for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
            return this;
        }
        return a === this ? (THREE.error("THREE.Object3D.add: object can't be added as a child of itself.", a), 
        this) : (a instanceof THREE.Object3D ? (void 0 !== a.parent && a.parent.remove(a), 
        a.parent = this, a.dispatchEvent({
            type: "added"
        }), this.children.push(a)) : THREE.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), 
        this);
    },
    remove: function(a) {
        if (1 < arguments.length) for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
        b = this.children.indexOf(a), -1 !== b && (a.parent = void 0, a.dispatchEvent({
            type: "removed"
        }), this.children.splice(b, 1));
    },
    getChildByName: function(a) {
        return THREE.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), 
        this.getObjectByName(a);
    },
    getObjectById: function(a) {
        return this.getObjectByProperty("id", a);
    },
    getObjectByName: function(a) {
        return this.getObjectByProperty("name", a);
    },
    getObjectByProperty: function(a, b) {
        if (this[a] === b) return this;
        for (var c = 0, d = this.children.length; d > c; c++) {
            var e = this.children[c].getObjectByProperty(a, b);
            if (void 0 !== e) return e;
        }
    },
    getWorldPosition: function(a) {
        return a = a || new THREE.Vector3(), this.updateMatrixWorld(!0), a.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c) {
            return c = c || new THREE.Quaternion(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, c, b), 
            c;
        };
    }(),
    getWorldRotation: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            return b = b || new THREE.Euler(), this.getWorldQuaternion(a), b.setFromQuaternion(a, this.rotation.order, !1);
        };
    }(),
    getWorldScale: function() {
        var a = new THREE.Vector3(), b = new THREE.Quaternion();
        return function(c) {
            return c = c || new THREE.Vector3(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, c), 
            c;
        };
    }(),
    getWorldDirection: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            return b = b || new THREE.Vector3(), this.getWorldQuaternion(a), b.set(0, 0, 1).applyQuaternion(a);
        };
    }(),
    raycast: function() {},
    traverse: function(a) {
        a(this);
        for (var b = 0, c = this.children.length; c > b; b++) this.children[b].traverse(a);
    },
    traverseVisible: function(a) {
        if (!1 !== this.visible) {
            a(this);
            for (var b = 0, c = this.children.length; c > b; b++) this.children[b].traverseVisible(a);
        }
    },
    traverseAncestors: function(a) {
        this.parent && (a(this.parent), this.parent.traverseAncestors(a));
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(a) {
        !0 === this.matrixAutoUpdate && this.updateMatrix(), (!0 === this.matrixWorldNeedsUpdate || !0 === a) && (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
        this.matrixWorldNeedsUpdate = !1, a = !0);
        for (var b = 0, c = this.children.length; c > b; b++) this.children[b].updateMatrixWorld(a);
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.3,
                type: "Object",
                generator: "ObjectExporter"
            }
        }, b = {}, c = {}, d = function(b) {
            if (void 0 === a.materials && (a.materials = []), void 0 === c[b.uuid]) {
                var d = b.toJSON();
                delete d.metadata, c[b.uuid] = d, a.materials.push(d);
            }
            return b.uuid;
        }, e = function(c) {
            var f = {};
            if (f.uuid = c.uuid, f.type = c.type, "" !== c.name && (f.name = c.name), "{}" !== JSON.stringify(c.userData) && (f.userData = c.userData), 
            !0 !== c.visible && (f.visible = c.visible), c instanceof THREE.PerspectiveCamera) f.fov = c.fov, 
            f.aspect = c.aspect, f.near = c.near, f.far = c.far; else if (c instanceof THREE.OrthographicCamera) f.left = c.left, 
            f.right = c.right, f.top = c.top, f.bottom = c.bottom, f.near = c.near, f.far = c.far; else if (c instanceof THREE.AmbientLight) f.color = c.color.getHex(); else if (c instanceof THREE.DirectionalLight) f.color = c.color.getHex(), 
            f.intensity = c.intensity; else if (c instanceof THREE.PointLight) f.color = c.color.getHex(), 
            f.intensity = c.intensity, f.distance = c.distance, f.decay = c.decay; else if (c instanceof THREE.SpotLight) f.color = c.color.getHex(), 
            f.intensity = c.intensity, f.distance = c.distance, f.angle = c.angle, f.exponent = c.exponent, 
            f.decay = c.decay; else if (c instanceof THREE.HemisphereLight) f.color = c.color.getHex(), 
            f.groundColor = c.groundColor.getHex(); else if (c instanceof THREE.Mesh || c instanceof THREE.Line || c instanceof THREE.PointCloud) {
                var g = c.geometry;
                if (void 0 === a.geometries && (a.geometries = []), void 0 === b[g.uuid]) {
                    var h = g.toJSON();
                    delete h.metadata, b[g.uuid] = h, a.geometries.push(h);
                }
                f.geometry = g.uuid, f.material = d(c.material), c instanceof THREE.Line && (f.mode = c.mode);
            } else c instanceof THREE.Sprite && (f.material = d(c.material));
            if (f.matrix = c.matrix.toArray(), 0 < c.children.length) for (f.children = [], 
            g = 0; g < c.children.length; g++) f.children.push(e(c.children[g]));
            return f;
        };
        return a.object = e(this), a;
    },
    clone: function(a, b) {
        if (void 0 === a && (a = new THREE.Object3D()), void 0 === b && (b = !0), a.name = this.name, 
        a.up.copy(this.up), a.position.copy(this.position), a.quaternion.copy(this.quaternion), 
        a.scale.copy(this.scale), a.rotationAutoUpdate = this.rotationAutoUpdate, a.matrix.copy(this.matrix), 
        a.matrixWorld.copy(this.matrixWorld), a.matrixAutoUpdate = this.matrixAutoUpdate, 
        a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, a.visible = this.visible, 
        a.castShadow = this.castShadow, a.receiveShadow = this.receiveShadow, a.frustumCulled = this.frustumCulled, 
        a.userData = JSON.parse(JSON.stringify(this.userData)), !0 === b) for (var c = 0; c < this.children.length; c++) a.add(this.children[c].clone());
        return a;
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, 
THREE.Face3 = function(a, b, c, d, e, f) {
    this.a = a, this.b = b, this.c = c, this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3(), 
    this.vertexNormals = d instanceof Array ? d : [], this.color = e instanceof THREE.Color ? e : new THREE.Color(), 
    this.vertexColors = e instanceof Array ? e : [], this.vertexTangents = [], this.materialIndex = void 0 !== f ? f : 0;
}, THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function() {
        var a = new THREE.Face3(this.a, this.b, this.c);
        a.normal.copy(this.normal), a.color.copy(this.color), a.materialIndex = this.materialIndex;
        for (var b = 0, c = this.vertexNormals.length; c > b; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();
        for (b = 0, c = this.vertexColors.length; c > b; b++) a.vertexColors[b] = this.vertexColors[b].clone();
        for (b = 0, c = this.vertexTangents.length; c > b; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();
        return a;
    }
}, THREE.Face4 = function(a, b, c, d, e, f, g) {
    return THREE.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), 
    new THREE.Face3(a, b, c, e, f, g);
}, THREE.BufferAttribute = function(a, b) {
    this.array = a, this.itemSize = b, this.needsUpdate = !1;
}, THREE.BufferAttribute.prototype = {
    constructor: THREE.BufferAttribute,
    get length() {
        return this.array.length;
    },
    copyAt: function(a, b, c) {
        a *= this.itemSize, c *= b.itemSize;
        for (var d = 0, e = this.itemSize; e > d; d++) this.array[a + d] = b.array[c + d];
        return this;
    },
    set: function(a, b) {
        return void 0 === b && (b = 0), this.array.set(a, b), this;
    },
    setX: function(a, b) {
        return this.array[a * this.itemSize] = b, this;
    },
    setY: function(a, b) {
        return this.array[a * this.itemSize + 1] = b, this;
    },
    setZ: function(a, b) {
        return this.array[a * this.itemSize + 2] = b, this;
    },
    setXY: function(a, b, c) {
        return a *= this.itemSize, this.array[a] = b, this.array[a + 1] = c, this;
    },
    setXYZ: function(a, b, c, d) {
        return a *= this.itemSize, this.array[a] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
        this;
    },
    setXYZW: function(a, b, c, d, e) {
        return a *= this.itemSize, this.array[a] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
        this.array[a + 3] = e, this;
    },
    clone: function() {
        return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize);
    }
}, THREE.Int8Attribute = function(a, b) {
    return THREE.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint8Attribute = function(a, b) {
    return THREE.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint8ClampedAttribute = function(a, b) {
    return THREE.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Int16Attribute = function(a, b) {
    return THREE.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint16Attribute = function(a, b) {
    return THREE.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Int32Attribute = function(a, b) {
    return THREE.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint32Attribute = function(a, b) {
    return THREE.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Float32Attribute = function(a, b) {
    return THREE.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Float64Attribute = function(a, b) {
    return THREE.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.DynamicBufferAttribute = function(a, b) {
    THREE.BufferAttribute.call(this, a, b), this.updateRange = {
        offset: 0,
        count: -1
    };
}, THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype), 
THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute, 
THREE.DynamicBufferAttribute.prototype.clone = function() {
    return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize);
}, THREE.BufferGeometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", 
    this.attributes = {}, this.attributesKeys = [], this.offsets = this.drawcalls = [], 
    this.boundingSphere = this.boundingBox = null;
}, THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    addAttribute: function(a, b, c) {
        !1 == b instanceof THREE.BufferAttribute ? (THREE.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), 
        this.attributes[a] = {
            array: b,
            itemSize: c
        }) : (this.attributes[a] = b, this.attributesKeys = Object.keys(this.attributes));
    },
    getAttribute: function(a) {
        return this.attributes[a];
    },
    addDrawCall: function(a, b, c) {
        this.drawcalls.push({
            start: a,
            count: b,
            index: void 0 !== c ? c : 0
        });
    },
    applyMatrix: function(a) {
        var b = this.attributes.position;
        void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0), b = this.attributes.normal, 
        void 0 !== b && (new THREE.Matrix3().getNormalMatrix(a).applyToVector3Array(b.array), 
        b.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere();
    },
    center: function() {
        this.computeBoundingBox();
        var a = this.boundingBox.center().negate();
        return this.applyMatrix(new THREE.Matrix4().setPosition(a)), a;
    },
    fromGeometry: function(a, b) {
        b = b || {
            vertexColors: THREE.NoColors
        };
        var c = a.vertices, d = a.faces, e = a.faceVertexUvs, f = b.vertexColors, g = 0 < e[0].length, h = 3 == d[0].vertexNormals.length, i = new Float32Array(9 * d.length);
        this.addAttribute("position", new THREE.BufferAttribute(i, 3));
        var j = new Float32Array(9 * d.length);
        if (this.addAttribute("normal", new THREE.BufferAttribute(j, 3)), f !== THREE.NoColors) {
            var k = new Float32Array(9 * d.length);
            this.addAttribute("color", new THREE.BufferAttribute(k, 3));
        }
        if (!0 === g) {
            var l = new Float32Array(6 * d.length);
            this.addAttribute("uv", new THREE.BufferAttribute(l, 2));
        }
        for (var m = 0, n = 0, o = 0; m < d.length; m++, n += 6, o += 9) {
            var p = d[m], q = c[p.a], r = c[p.b], s = c[p.c];
            i[o] = q.x, i[o + 1] = q.y, i[o + 2] = q.z, i[o + 3] = r.x, i[o + 4] = r.y, i[o + 5] = r.z, 
            i[o + 6] = s.x, i[o + 7] = s.y, i[o + 8] = s.z, !0 === h ? (q = p.vertexNormals[0], 
            r = p.vertexNormals[1], s = p.vertexNormals[2], j[o] = q.x, j[o + 1] = q.y, j[o + 2] = q.z, 
            j[o + 3] = r.x, j[o + 4] = r.y, j[o + 5] = r.z, j[o + 6] = s.x, j[o + 7] = s.y, 
            j[o + 8] = s.z) : (q = p.normal, j[o] = q.x, j[o + 1] = q.y, j[o + 2] = q.z, j[o + 3] = q.x, 
            j[o + 4] = q.y, j[o + 5] = q.z, j[o + 6] = q.x, j[o + 7] = q.y, j[o + 8] = q.z), 
            f === THREE.FaceColors ? (p = p.color, k[o] = p.r, k[o + 1] = p.g, k[o + 2] = p.b, 
            k[o + 3] = p.r, k[o + 4] = p.g, k[o + 5] = p.b, k[o + 6] = p.r, k[o + 7] = p.g, 
            k[o + 8] = p.b) : f === THREE.VertexColors && (q = p.vertexColors[0], r = p.vertexColors[1], 
            p = p.vertexColors[2], k[o] = q.r, k[o + 1] = q.g, k[o + 2] = q.b, k[o + 3] = r.r, 
            k[o + 4] = r.g, k[o + 5] = r.b, k[o + 6] = p.r, k[o + 7] = p.g, k[o + 8] = p.b), 
            !0 === g && (p = e[0][m][0], q = e[0][m][1], r = e[0][m][2], l[n] = p.x, l[n + 1] = p.y, 
            l[n + 2] = q.x, l[n + 3] = q.y, l[n + 4] = r.x, l[n + 5] = r.y);
        }
        return this.computeBoundingSphere(), this;
    },
    computeBoundingBox: function() {
        var a = new THREE.Vector3();
        return function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3());
            var b = this.attributes.position.array;
            if (b) {
                var c = this.boundingBox;
                c.makeEmpty();
                for (var d = 0, e = b.length; e > d; d += 3) a.set(b[d], b[d + 1], b[d + 2]), c.expandByPoint(a);
            }
            (void 0 === b || 0 === b.length) && (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), 
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.');
        };
    }(),
    computeBoundingSphere: function() {
        var a = new THREE.Box3(), b = new THREE.Vector3();
        return function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
            var c = this.attributes.position.array;
            if (c) {
                a.makeEmpty();
                for (var d = this.boundingSphere.center, e = 0, f = c.length; f > e; e += 3) b.set(c[e], c[e + 1], c[e + 2]), 
                a.expandByPoint(b);
                a.center(d);
                for (var g = 0, e = 0, f = c.length; f > e; e += 3) b.set(c[e], c[e + 1], c[e + 2]), 
                g = Math.max(g, d.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(g), isNaN(this.boundingSphere.radius) && THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');
            }
        };
    }(),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        var a = this.attributes;
        if (a.position) {
            var b = a.position.array;
            if (void 0 === a.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(b.length), 3)); else for (var c = a.normal.array, d = 0, e = c.length; e > d; d++) c[d] = 0;
            var f, g, h, c = a.normal.array, i = new THREE.Vector3(), j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3(), m = new THREE.Vector3();
            if (a.index) for (var n = a.index.array, o = 0 < this.offsets.length ? this.offsets : [ {
                start: 0,
                count: n.length,
                index: 0
            } ], p = 0, q = o.length; q > p; ++p) {
                e = o[p].start, f = o[p].count;
                for (var r = o[p].index, d = e, e = e + f; e > d; d += 3) f = 3 * (r + n[d]), g = 3 * (r + n[d + 1]), 
                h = 3 * (r + n[d + 2]), i.fromArray(b, f), j.fromArray(b, g), k.fromArray(b, h), 
                l.subVectors(k, j), m.subVectors(i, j), l.cross(m), c[f] += l.x, c[f + 1] += l.y, 
                c[f + 2] += l.z, c[g] += l.x, c[g + 1] += l.y, c[g + 2] += l.z, c[h] += l.x, c[h + 1] += l.y, 
                c[h + 2] += l.z;
            } else for (d = 0, e = b.length; e > d; d += 9) i.fromArray(b, d), j.fromArray(b, d + 3), 
            k.fromArray(b, d + 6), l.subVectors(k, j), m.subVectors(i, j), l.cross(m), c[d] = l.x, 
            c[d + 1] = l.y, c[d + 2] = l.z, c[d + 3] = l.x, c[d + 4] = l.y, c[d + 5] = l.z, 
            c[d + 6] = l.x, c[d + 7] = l.y, c[d + 8] = l.z;
            this.normalizeNormals(), a.normal.needsUpdate = !0;
        }
    },
    computeTangents: function() {
        function a(a, b, c) {
            B.fromArray(d, 3 * a), C.fromArray(d, 3 * b), D.fromArray(d, 3 * c), E.fromArray(f, 2 * a), 
            F.fromArray(f, 2 * b), G.fromArray(f, 2 * c), l = C.x - B.x, m = D.x - B.x, n = C.y - B.y, 
            o = D.y - B.y, p = C.z - B.z, q = D.z - B.z, r = F.x - E.x, s = G.x - E.x, t = F.y - E.y, 
            u = G.y - E.y, v = 1 / (r * u - s * t), H.set((u * l - t * m) * v, (u * n - t * o) * v, (u * p - t * q) * v), 
            I.set((r * m - s * l) * v, (r * o - s * n) * v, (r * q - s * p) * v), i[a].add(H), 
            i[b].add(H), i[c].add(H), j[a].add(I), j[b].add(I), j[c].add(I);
        }
        function b(a) {
            Q.fromArray(e, 3 * a), R.copy(Q), M = i[a], O.copy(M), O.sub(Q.multiplyScalar(Q.dot(M))).normalize(), 
            P.crossVectors(R, M), N = P.dot(j[a]), L = 0 > N ? -1 : 1, h[4 * a] = O.x, h[4 * a + 1] = O.y, 
            h[4 * a + 2] = O.z, h[4 * a + 3] = L;
        }
        if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) THREE.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()"); else {
            var c = this.attributes.index.array, d = this.attributes.position.array, e = this.attributes.normal.array, f = this.attributes.uv.array, g = d.length / 3;
            void 0 === this.attributes.tangent && this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * g), 4));
            for (var h = this.attributes.tangent.array, i = [], j = [], k = 0; g > k; k++) i[k] = new THREE.Vector3(), 
            j[k] = new THREE.Vector3();
            var l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B = new THREE.Vector3(), C = new THREE.Vector3(), D = new THREE.Vector3(), E = new THREE.Vector2(), F = new THREE.Vector2(), G = new THREE.Vector2(), H = new THREE.Vector3(), I = new THREE.Vector3();
            0 === this.drawcalls.length && this.addDrawCall(0, c.length, 0);
            var J = this.drawcalls, k = 0;
            for (x = J.length; x > k; ++k) {
                w = J[k].start, y = J[k].count;
                var K = J[k].index, g = w;
                for (w += y; w > g; g += 3) y = K + c[g], z = K + c[g + 1], A = K + c[g + 2], a(y, z, A);
            }
            var L, M, N, O = new THREE.Vector3(), P = new THREE.Vector3(), Q = new THREE.Vector3(), R = new THREE.Vector3(), k = 0;
            for (x = J.length; x > k; ++k) for (w = J[k].start, y = J[k].count, K = J[k].index, 
            g = w, w += y; w > g; g += 3) y = K + c[g], z = K + c[g + 1], A = K + c[g + 2], 
            b(y), b(z), b(A);
        }
    },
    computeOffsets: function(a) {
        void 0 === a && (a = 65535);
        for (var b = this.attributes.index.array, c = this.attributes.position.array, d = b.length / 3, e = new Uint16Array(b.length), f = 0, g = 0, h = [ {
            start: 0,
            count: 0,
            index: 0
        } ], i = h[0], j = 0, k = 0, l = new Int32Array(6), m = new Int32Array(c.length), n = new Int32Array(c.length), o = 0; o < c.length; o++) m[o] = -1, 
        n[o] = -1;
        for (c = 0; d > c; c++) {
            for (var p = k = 0; 3 > p; p++) o = b[3 * c + p], -1 == m[o] ? (l[2 * p] = o, l[2 * p + 1] = -1, 
            k++) : m[o] < i.index ? (l[2 * p] = o, l[2 * p + 1] = -1, j++) : (l[2 * p] = o, 
            l[2 * p + 1] = m[o]);
            if (g + k > i.index + a) for (i = {
                start: f,
                count: 0,
                index: g
            }, h.push(i), k = 0; 6 > k; k += 2) p = l[k + 1], p > -1 && p < i.index && (l[k + 1] = -1);
            for (k = 0; 6 > k; k += 2) o = l[k], p = l[k + 1], -1 === p && (p = g++), m[o] = p, 
            n[p] = o, e[f++] = p - i.index, i.count++;
        }
        return this.reorderBuffers(e, n, g), this.drawcalls = this.offsets = h;
    },
    merge: function(a, b) {
        if (!1 != a instanceof THREE.BufferGeometry) {
            void 0 === b && (b = 0);
            var c, d = this.attributes;
            for (c in d) if (void 0 !== a.attributes[c]) for (var e = d[c].array, f = a.attributes[c], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, 
            f++) e[f] = g[h];
            return this;
        }
        THREE.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
    },
    normalizeNormals: function() {
        for (var a, b, c, d = this.attributes.normal.array, e = 0, f = d.length; f > e; e += 3) a = d[e], 
        b = d[e + 1], c = d[e + 2], a = 1 / Math.sqrt(a * a + b * b + c * c), d[e] *= a, 
        d[e + 1] *= a, d[e + 2] *= a;
    },
    reorderBuffers: function(a, b, c) {
        var d, e = {};
        for (d in this.attributes) "index" != d && (e[d] = new this.attributes[d].array.constructor(this.attributes[d].itemSize * c));
        for (var f = 0; c > f; f++) {
            var g = b[f];
            for (d in this.attributes) if ("index" != d) for (var h = this.attributes[d].array, i = this.attributes[d].itemSize, j = e[d], k = 0; i > k; k++) j[f * i + k] = h[g * i + k];
        }
        this.attributes.index.array = a;
        for (d in this.attributes) "index" != d && (this.attributes[d].array = e[d], this.attributes[d].numItems = this.attributes[d].itemSize * c);
    },
    toJSON: function() {
        var a, b = {
            metadata: {
                version: 4,
                type: "BufferGeometry",
                generator: "BufferGeometryExporter"
            },
            uuid: this.uuid,
            type: this.type,
            data: {
                attributes: {}
            }
        }, c = this.attributes, d = this.offsets, e = this.boundingSphere;
        for (a in c) {
            var f = c[a], g = Array.prototype.slice.call(f.array);
            b.data.attributes[a] = {
                itemSize: f.itemSize,
                type: f.array.constructor.name,
                array: g
            };
        }
        return 0 < d.length && (b.data.offsets = JSON.parse(JSON.stringify(d))), null !== e && (b.data.boundingSphere = {
            center: e.center.toArray(),
            radius: e.radius
        }), b;
    },
    clone: function() {
        var a, b = new THREE.BufferGeometry();
        for (a in this.attributes) b.addAttribute(a, this.attributes[a].clone());
        a = 0;
        for (var c = this.offsets.length; c > a; a++) {
            var d = this.offsets[a];
            b.offsets.push({
                start: d.start,
                index: d.index,
                count: d.count
            });
        }
        return b;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Geometry", 
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], 
    this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], 
    this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, 
    this.hasTangents = !1, this.dynamic = !0, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;
}, THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function(a) {
        for (var b = new THREE.Matrix3().getNormalMatrix(a), c = 0, d = this.vertices.length; d > c; c++) this.vertices[c].applyMatrix4(a);
        for (c = 0, d = this.faces.length; d > c; c++) {
            a = this.faces[c], a.normal.applyMatrix3(b).normalize();
            for (var e = 0, f = a.vertexNormals.length; f > e; e++) a.vertexNormals[e].applyMatrix3(b).normalize();
        }
        null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
        this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
    },
    fromBufferGeometry: function(a) {
        for (var b = this, c = a.attributes, d = c.position.array, e = void 0 !== c.index ? c.index.array : void 0, f = void 0 !== c.normal ? c.normal.array : void 0, g = void 0 !== c.color ? c.color.array : void 0, h = void 0 !== c.uv ? c.uv.array : void 0, i = [], j = [], k = c = 0; c < d.length; c += 3, 
        k += 2) b.vertices.push(new THREE.Vector3(d[c], d[c + 1], d[c + 2])), void 0 !== f && i.push(new THREE.Vector3(f[c], f[c + 1], f[c + 2])), 
        void 0 !== g && b.colors.push(new THREE.Color(g[c], g[c + 1], g[c + 2])), void 0 !== h && j.push(new THREE.Vector2(h[k], h[k + 1]));
        var l = function(a, c, d) {
            var e = void 0 !== f ? [ i[a].clone(), i[c].clone(), i[d].clone() ] : [], k = void 0 !== g ? [ b.colors[a].clone(), b.colors[c].clone(), b.colors[d].clone() ] : [];
            b.faces.push(new THREE.Face3(a, c, d, e, k)), void 0 !== h && b.faceVertexUvs[0].push([ j[a].clone(), j[c].clone(), j[d].clone() ]);
        };
        if (void 0 !== e) if (d = a.drawcalls, 0 < d.length) for (c = 0; c < d.length; c++) for (var k = d[c], m = k.start, n = k.count, o = k.index, k = m, m = m + n; m > k; k += 3) l(o + e[k], o + e[k + 1], o + e[k + 2]); else for (c = 0; c < e.length; c += 3) l(e[c], e[c + 1], e[c + 2]); else for (c = 0; c < d.length / 3; c += 3) l(c, c + 1, c + 2);
        return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), 
        null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this;
    },
    center: function() {
        this.computeBoundingBox();
        var a = this.boundingBox.center().negate();
        return this.applyMatrix(new THREE.Matrix4().setPosition(a)), a;
    },
    computeFaceNormals: function() {
        for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; d > c; c++) {
            var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
            a.subVectors(this.vertices[e.c], g), b.subVectors(f, g), a.cross(b), a.normalize(), 
            e.normal.copy(a);
        }
    },
    computeVertexNormals: function(a) {
        var b, c, d;
        for (d = Array(this.vertices.length), b = 0, c = this.vertices.length; c > b; b++) d[b] = new THREE.Vector3();
        if (a) {
            var e, f, g, h = new THREE.Vector3(), i = new THREE.Vector3();
            for (a = 0, b = this.faces.length; b > a; a++) c = this.faces[a], e = this.vertices[c.a], 
            f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), i.subVectors(e, f), 
            h.cross(i), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);
        } else for (a = 0, b = this.faces.length; b > a; a++) c = this.faces[a], d[c.a].add(c.normal), 
        d[c.b].add(c.normal), d[c.c].add(c.normal);
        for (b = 0, c = this.vertices.length; c > b; b++) d[b].normalize();
        for (a = 0, b = this.faces.length; b > a; a++) c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), 
        c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone();
    },
    computeMorphNormals: function() {
        var a, b, c, d, e;
        for (c = 0, d = this.faces.length; d > c; c++) for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), 
        e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; b > a; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
        var f = new THREE.Geometry();
        for (f.faces = this.faces, a = 0, b = this.morphTargets.length; b > a; a++) {
            if (!this.morphNormals[a]) {
                this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [], 
                e = this.morphNormals[a].faceNormals;
                var g, h, i = this.morphNormals[a].vertexNormals;
                for (c = 0, d = this.faces.length; d > c; c++) g = new THREE.Vector3(), h = {
                    a: new THREE.Vector3(),
                    b: new THREE.Vector3(),
                    c: new THREE.Vector3()
                }, e.push(g), i.push(h);
            }
            for (i = this.morphNormals[a], f.vertices = this.morphTargets[a].vertices, f.computeFaceNormals(), 
            f.computeVertexNormals(), c = 0, d = this.faces.length; d > c; c++) e = this.faces[c], 
            g = i.faceNormals[c], h = i.vertexNormals[c], g.copy(e.normal), h.a.copy(e.vertexNormals[0]), 
            h.b.copy(e.vertexNormals[1]), h.c.copy(e.vertexNormals[2]);
        }
        for (c = 0, d = this.faces.length; d > c; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, 
        e.vertexNormals = e.__originalVertexNormals;
    },
    computeTangents: function() {
        var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r = [], s = [];
        c = new THREE.Vector3();
        var t = new THREE.Vector3(), u = new THREE.Vector3(), v = new THREE.Vector3(), w = new THREE.Vector3();
        for (a = 0, b = this.vertices.length; b > a; a++) r[a] = new THREE.Vector3(), s[a] = new THREE.Vector3();
        for (a = 0, b = this.faces.length; b > a; a++) e = this.faces[a], f = this.faceVertexUvs[0][a], 
        d = e.a, q = e.b, e = e.c, g = this.vertices[d], h = this.vertices[q], i = this.vertices[e], 
        j = f[0], k = f[1], l = f[2], f = h.x - g.x, m = i.x - g.x, n = h.y - g.y, o = i.y - g.y, 
        h = h.z - g.z, g = i.z - g.z, i = k.x - j.x, p = l.x - j.x, k = k.y - j.y, j = l.y - j.y, 
        l = 1 / (i * j - p * k), c.set((j * f - k * m) * l, (j * n - k * o) * l, (j * h - k * g) * l), 
        t.set((i * m - p * f) * l, (i * o - p * n) * l, (i * g - p * h) * l), r[d].add(c), 
        r[q].add(c), r[e].add(c), s[d].add(t), s[q].add(t), s[e].add(t);
        for (t = [ "a", "b", "c", "d" ], a = 0, b = this.faces.length; b > a; a++) for (e = this.faces[a], 
        c = 0; c < Math.min(e.vertexNormals.length, 3); c++) w.copy(e.vertexNormals[c]), 
        d = e[t[c]], q = r[d], u.copy(q), u.sub(w.multiplyScalar(w.dot(q))).normalize(), 
        v.crossVectors(e.vertexNormals[c], q), d = v.dot(s[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(u.x, u.y, u.z, d);
        this.hasTangents = !0;
    },
    computeLineDistances: function() {
        for (var a = 0, b = this.vertices, c = 0, d = b.length; d > c; c++) c > 0 && (a += b[c].distanceTo(b[c - 1])), 
        this.lineDistances[c] = a;
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere()), this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(a, b, c) {
        if (!1 == a instanceof THREE.Geometry) THREE.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a); else {
            var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, i = a.faces, j = this.faceVertexUvs[0];
            a = a.faceVertexUvs[0], void 0 === c && (c = 0), void 0 !== b && (d = new THREE.Matrix3().getNormalMatrix(b));
            for (var k = 0, l = g.length; l > k; k++) {
                var m = g[k].clone();
                void 0 !== b && m.applyMatrix4(b), f.push(m);
            }
            for (k = 0, l = i.length; l > k; k++) {
                var n, g = i[k], o = g.vertexNormals, p = g.vertexColors, m = new THREE.Face3(g.a + e, g.b + e, g.c + e);
                for (m.normal.copy(g.normal), void 0 !== d && m.normal.applyMatrix3(d).normalize(), 
                b = 0, f = o.length; f > b; b++) n = o[b].clone(), void 0 !== d && n.applyMatrix3(d).normalize(), 
                m.vertexNormals.push(n);
                for (m.color.copy(g.color), b = 0, f = p.length; f > b; b++) n = p[b], m.vertexColors.push(n.clone());
                m.materialIndex = g.materialIndex + c, h.push(m);
            }
            for (k = 0, l = a.length; l > k; k++) if (c = a[k], d = [], void 0 !== c) {
                for (b = 0, f = c.length; f > b; b++) d.push(c[b].clone());
                j.push(d);
            }
        }
    },
    mergeMesh: function(a) {
        !1 == a instanceof THREE.Mesh ? THREE.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), 
        this.merge(a.geometry, a.matrix));
    },
    mergeVertices: function() {
        var a, b, c, d = {}, e = [], f = [], g = Math.pow(10, 4);
        for (b = 0, c = this.vertices.length; c > b; b++) a = this.vertices[b], a = Math.round(a.x * g) + "_" + Math.round(a.y * g) + "_" + Math.round(a.z * g), 
        void 0 === d[a] ? (d[a] = b, e.push(this.vertices[b]), f[b] = e.length - 1) : f[b] = f[d[a]];
        for (d = [], b = 0, c = this.faces.length; c > b; b++) for (g = this.faces[b], g.a = f[g.a], 
        g.b = f[g.b], g.c = f[g.c], g = [ g.a, g.b, g.c ], a = 0; 3 > a; a++) if (g[a] == g[(a + 1) % 3]) {
            d.push(b);
            break;
        }
        for (b = d.length - 1; b >= 0; b--) for (g = d[b], this.faces.splice(g, 1), f = 0, 
        c = this.faceVertexUvs.length; c > f; f++) this.faceVertexUvs[f].splice(g, 1);
        return b = this.vertices.length - e.length, this.vertices = e, b;
    },
    toJSON: function() {
        function a(a, b, c) {
            return c ? a | 1 << b : a & ~(1 << b);
        }
        function b(a) {
            var b = a.x.toString() + a.y.toString() + a.z.toString();
            return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3, i.push(a.x, a.y, a.z), j[b]);
        }
        function c(a) {
            var b = a.r.toString() + a.g.toString() + a.b.toString();
            return void 0 !== l[b] ? l[b] : (l[b] = k.length, k.push(a.getHex()), l[b]);
        }
        function d(a) {
            var b = a.x.toString() + a.y.toString();
            return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2, m.push(a.x, a.y), n[b]);
        }
        var e = {
            metadata: {
                version: 4,
                type: "BufferGeometry",
                generator: "BufferGeometryExporter"
            },
            uuid: this.uuid,
            type: this.type
        };
        if ("" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
            var f, g = this.parameters;
            for (f in g) void 0 !== g[f] && (e[f] = g[f]);
            return e;
        }
        for (g = [], f = 0; f < this.vertices.length; f++) {
            var h = this.vertices[f];
            g.push(h.x, h.y, h.z);
        }
        var h = [], i = [], j = {}, k = [], l = {}, m = [], n = {};
        for (f = 0; f < this.faces.length; f++) {
            var o = this.faces[f], p = void 0 !== this.faceVertexUvs[0][f], q = 0 < o.normal.length(), r = 0 < o.vertexNormals.length, s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b, t = 0 < o.vertexColors.length, u = 0, u = a(u, 0, 0), u = a(u, 1, !1), u = a(u, 2, !1), u = a(u, 3, p), u = a(u, 4, q), u = a(u, 5, r), u = a(u, 6, s), u = a(u, 7, t);
            h.push(u), h.push(o.a, o.b, o.c), p && (p = this.faceVertexUvs[0][f], h.push(d(p[0]), d(p[1]), d(p[2]))), 
            q && h.push(b(o.normal)), r && (q = o.vertexNormals, h.push(b(q[0]), b(q[1]), b(q[2]))), 
            s && h.push(c(o.color)), t && (o = o.vertexColors, h.push(c(o[0]), c(o[1]), c(o[2])));
        }
        return e.data = {}, e.data.vertices = g, e.data.normals = i, 0 < k.length && (e.data.colors = k), 
        0 < m.length && (e.data.uvs = [ m ]), e.data.faces = h, e;
    },
    clone: function() {
        for (var a = new THREE.Geometry(), b = this.vertices, c = 0, d = b.length; d > c; c++) a.vertices.push(b[c].clone());
        for (b = this.faces, c = 0, d = b.length; d > c; c++) a.faces.push(b[c].clone());
        for (c = 0, d = this.faceVertexUvs.length; d > c; c++) {
            b = this.faceVertexUvs[c], void 0 === a.faceVertexUvs[c] && (a.faceVertexUvs[c] = []);
            for (var e = 0, f = b.length; f > e; e++) {
                for (var g = b[e], h = [], i = 0, j = g.length; j > i; i++) h.push(g[i].clone());
                a.faceVertexUvs[c].push(h);
            }
        }
        return a;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, 
THREE.Camera = function() {
    THREE.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new THREE.Matrix4(), 
    this.projectionMatrix = new THREE.Matrix4();
}, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.constructor = THREE.Camera, 
THREE.Camera.prototype.getWorldDirection = function() {
    var a = new THREE.Quaternion();
    return function(b) {
        return b = b || new THREE.Vector3(), this.getWorldQuaternion(a), b.set(0, 0, -1).applyQuaternion(a);
    };
}(), THREE.Camera.prototype.lookAt = function() {
    var a = new THREE.Matrix4();
    return function(b) {
        a.lookAt(this.position, b, this.up), this.quaternion.setFromRotationMatrix(a);
    };
}(), THREE.Camera.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Camera()), THREE.Object3D.prototype.clone.call(this, a), 
    a.matrixWorldInverse.copy(this.matrixWorldInverse), a.projectionMatrix.copy(this.projectionMatrix), 
    a;
}, THREE.CubeCamera = function(a, b, c) {
    THREE.Object3D.call(this), this.type = "CubeCamera";
    var d = new THREE.PerspectiveCamera(90, 1, a, b);
    d.up.set(0, -1, 0), d.lookAt(new THREE.Vector3(1, 0, 0)), this.add(d);
    var e = new THREE.PerspectiveCamera(90, 1, a, b);
    e.up.set(0, -1, 0), e.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(e);
    var f = new THREE.PerspectiveCamera(90, 1, a, b);
    f.up.set(0, 0, 1), f.lookAt(new THREE.Vector3(0, 1, 0)), this.add(f);
    var g = new THREE.PerspectiveCamera(90, 1, a, b);
    g.up.set(0, 0, -1), g.lookAt(new THREE.Vector3(0, -1, 0)), this.add(g);
    var h = new THREE.PerspectiveCamera(90, 1, a, b);
    h.up.set(0, -1, 0), h.lookAt(new THREE.Vector3(0, 0, 1)), this.add(h);
    var i = new THREE.PerspectiveCamera(90, 1, a, b);
    i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(0, 0, -1)), this.add(i), this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    }), this.updateCubeMap = function(a, b) {
        var c = this.renderTarget, j = c.generateMipmaps;
        c.generateMipmaps = !1, c.activeCubeFace = 0, a.render(b, d, c), c.activeCubeFace = 1, 
        a.render(b, e, c), c.activeCubeFace = 2, a.render(b, f, c), c.activeCubeFace = 3, 
        a.render(b, g, c), c.activeCubeFace = 4, a.render(b, h, c), c.generateMipmaps = j, 
        c.activeCubeFace = 5, a.render(b, i, c);
    };
}, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CubeCamera.prototype.constructor = THREE.CubeCamera, 
THREE.OrthographicCamera = function(a, b, c, d, e, f) {
    THREE.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = a, 
    this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, 
    this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix();
}, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera, 
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
    var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2;
    this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far);
}, THREE.OrthographicCamera.prototype.clone = function() {
    var a = new THREE.OrthographicCamera();
    return THREE.Camera.prototype.clone.call(this, a), a.zoom = this.zoom, a.left = this.left, 
    a.right = this.right, a.top = this.top, a.bottom = this.bottom, a.near = this.near, 
    a.far = this.far, a.projectionMatrix.copy(this.projectionMatrix), a;
}, THREE.PerspectiveCamera = function(a, b, c, d) {
    THREE.Camera.call(this), this.type = "PerspectiveCamera", this.zoom = 1, this.fov = void 0 !== a ? a : 50, 
    this.aspect = void 0 !== b ? b : 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, 
    this.updateProjectionMatrix();
}, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera, 
THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
    void 0 === b && (b = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a))), 
    this.updateProjectionMatrix();
}, THREE.PerspectiveCamera.prototype.setViewOffset = function(a, b, c, d, e, f) {
    this.fullWidth = a, this.fullHeight = b, this.x = c, this.y = d, this.width = e, 
    this.height = f, this.updateProjectionMatrix();
}, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    var a = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
    if (this.fullWidth) {
        var b = this.fullWidth / this.fullHeight, a = Math.tan(THREE.Math.degToRad(.5 * a)) * this.near, c = -a, d = b * c, b = Math.abs(b * a - d), c = Math.abs(a - c);
        this.projectionMatrix.makeFrustum(d + this.x * b / this.fullWidth, d + (this.x + this.width) * b / this.fullWidth, a - (this.y + this.height) * c / this.fullHeight, a - this.y * c / this.fullHeight, this.near, this.far);
    } else this.projectionMatrix.makePerspective(a, this.aspect, this.near, this.far);
}, THREE.PerspectiveCamera.prototype.clone = function() {
    var a = new THREE.PerspectiveCamera();
    return THREE.Camera.prototype.clone.call(this, a), a.zoom = this.zoom, a.fov = this.fov, 
    a.aspect = this.aspect, a.near = this.near, a.far = this.far, a.projectionMatrix.copy(this.projectionMatrix), 
    a;
}, THREE.Light = function(a) {
    THREE.Object3D.call(this), this.type = "Light", this.color = new THREE.Color(a);
}, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.constructor = THREE.Light, 
THREE.Light.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Light()), THREE.Object3D.prototype.clone.call(this, a), 
    a.color.copy(this.color), a;
}, THREE.AmbientLight = function(a) {
    THREE.Light.call(this, a), this.type = "AmbientLight";
}, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.constructor = THREE.AmbientLight, 
THREE.AmbientLight.prototype.clone = function() {
    var a = new THREE.AmbientLight();
    return THREE.Light.prototype.clone.call(this, a), a;
}, THREE.AreaLight = function(a, b) {
    THREE.Light.call(this, a), this.type = "AreaLight", this.normal = new THREE.Vector3(0, -1, 0), 
    this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== b ? b : 1, 
    this.height = this.width = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, 
    this.quadraticAttenuation = .1;
}, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.AreaLight.prototype.constructor = THREE.AreaLight, 
THREE.DirectionalLight = function(a, b) {
    THREE.Light.call(this, a), this.type = "DirectionalLight", this.position.set(0, 1, 0), 
    this.target = new THREE.Object3D(), this.intensity = void 0 !== b ? b : 1, this.onlyShadow = this.castShadow = !1, 
    this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, 
    this.shadowCameraTop = this.shadowCameraRight = 500, this.shadowCameraBottom = -500, 
    this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, 
    this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), 
    this.shadowCascadeCount = 2, this.shadowCascadeBias = [ 0, 0, 0 ], this.shadowCascadeWidth = [ 512, 512, 512 ], 
    this.shadowCascadeHeight = [ 512, 512, 512 ], this.shadowCascadeNearZ = [ -1, .99, .998 ], 
    this.shadowCascadeFarZ = [ .99, .998, 1 ], this.shadowCascadeArray = [], this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
}, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight, 
THREE.DirectionalLight.prototype.clone = function() {
    var a = new THREE.DirectionalLight();
    return THREE.Light.prototype.clone.call(this, a), a.target = this.target.clone(), 
    a.intensity = this.intensity, a.castShadow = this.castShadow, a.onlyShadow = this.onlyShadow, 
    a.shadowCameraNear = this.shadowCameraNear, a.shadowCameraFar = this.shadowCameraFar, 
    a.shadowCameraLeft = this.shadowCameraLeft, a.shadowCameraRight = this.shadowCameraRight, 
    a.shadowCameraTop = this.shadowCameraTop, a.shadowCameraBottom = this.shadowCameraBottom, 
    a.shadowCameraVisible = this.shadowCameraVisible, a.shadowBias = this.shadowBias, 
    a.shadowDarkness = this.shadowDarkness, a.shadowMapWidth = this.shadowMapWidth, 
    a.shadowMapHeight = this.shadowMapHeight, a.shadowCascade = this.shadowCascade, 
    a.shadowCascadeOffset.copy(this.shadowCascadeOffset), a.shadowCascadeCount = this.shadowCascadeCount, 
    a.shadowCascadeBias = this.shadowCascadeBias.slice(0), a.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), 
    a.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), a.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), 
    a.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), a;
}, THREE.HemisphereLight = function(a, b, c) {
    THREE.Light.call(this, a), this.type = "HemisphereLight", this.position.set(0, 100, 0), 
    this.groundColor = new THREE.Color(b), this.intensity = void 0 !== c ? c : 1;
}, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight, 
THREE.HemisphereLight.prototype.clone = function() {
    var a = new THREE.HemisphereLight();
    return THREE.Light.prototype.clone.call(this, a), a.groundColor.copy(this.groundColor), 
    a.intensity = this.intensity, a;
}, THREE.PointLight = function(a, b, c, d) {
    THREE.Light.call(this, a), this.type = "PointLight", this.intensity = void 0 !== b ? b : 1, 
    this.distance = void 0 !== c ? c : 0, this.decay = void 0 !== d ? d : 1;
}, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.constructor = THREE.PointLight, 
THREE.PointLight.prototype.clone = function() {
    var a = new THREE.PointLight();
    return THREE.Light.prototype.clone.call(this, a), a.intensity = this.intensity, 
    a.distance = this.distance, a.decay = this.decay, a;
}, THREE.SpotLight = function(a, b, c, d, e, f) {
    THREE.Light.call(this, a), this.type = "SpotLight", this.position.set(0, 1, 0), 
    this.target = new THREE.Object3D(), this.intensity = void 0 !== b ? b : 1, this.distance = void 0 !== c ? c : 0, 
    this.angle = void 0 !== d ? d : Math.PI / 3, this.exponent = void 0 !== e ? e : 10, 
    this.decay = void 0 !== f ? f : 1, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, 
    this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, 
    this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, 
    this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
}, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.constructor = THREE.SpotLight, 
THREE.SpotLight.prototype.clone = function() {
    var a = new THREE.SpotLight();
    return THREE.Light.prototype.clone.call(this, a), a.target = this.target.clone(), 
    a.intensity = this.intensity, a.distance = this.distance, a.angle = this.angle, 
    a.exponent = this.exponent, a.decay = this.decay, a.castShadow = this.castShadow, 
    a.onlyShadow = this.onlyShadow, a.shadowCameraNear = this.shadowCameraNear, a.shadowCameraFar = this.shadowCameraFar, 
    a.shadowCameraFov = this.shadowCameraFov, a.shadowCameraVisible = this.shadowCameraVisible, 
    a.shadowBias = this.shadowBias, a.shadowDarkness = this.shadowDarkness, a.shadowMapWidth = this.shadowMapWidth, 
    a.shadowMapHeight = this.shadowMapHeight, a;
}, THREE.Cache = {
    files: {},
    add: function(a, b) {
        this.files[a] = b;
    },
    get: function(a) {
        return this.files[a];
    },
    remove: function(a) {
        delete this.files[a];
    },
    clear: function() {
        this.files = {};
    }
}, THREE.Loader = function(a) {
    this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null, 
    this.imageLoader = new THREE.ImageLoader(), this.onLoadStart = function() {}, this.onLoadProgress = function() {}, 
    this.onLoadComplete = function() {};
}, THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: void 0,
    addStatusElement: function() {
        var a = document.createElement("div");
        return a.style.position = "absolute", a.style.right = "0px", a.style.top = "0px", 
        a.style.fontSize = "0.8em", a.style.textAlign = "left", a.style.background = "rgba(0,0,0,0.25)", 
        a.style.color = "#fff", a.style.width = "120px", a.style.padding = "0.5em 0.5em 0.5em 0.5em", 
        a.style.zIndex = 1e3, a.innerHTML = "Loading ...", a;
    },
    updateProgress: function(a) {
        var b = "Loaded ", b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + "%") : b + ((a.loaded / 1024).toFixed(2) + " KB");
        this.statusDomElement.innerHTML = b;
    },
    extractUrlBase: function(a) {
        return a = a.split("/"), 1 === a.length ? "./" : (a.pop(), a.join("/") + "/");
    },
    initMaterials: function(a, b) {
        for (var c = [], d = 0; d < a.length; ++d) c[d] = this.createMaterial(a[d], b);
        return c;
    },
    needsTangents: function(a) {
        for (var b = 0, c = a.length; c > b; b++) if (a[b] instanceof THREE.ShaderMaterial) return !0;
        return !1;
    },
    createMaterial: function(a, b) {
        function c(a) {
            return a = Math.log(a) / Math.LN2, Math.pow(2, Math.round(a));
        }
        function d(a, d, e, g, h, i, j) {
            var k, l = b + e, m = THREE.Loader.Handlers.get(l);
            null !== m ? k = m.load(l) : (k = new THREE.Texture(), m = f.imageLoader, m.crossOrigin = f.crossOrigin, 
            m.load(l, function(a) {
                if (!1 === THREE.Math.isPowerOfTwo(a.width) || !1 === THREE.Math.isPowerOfTwo(a.height)) {
                    var b = c(a.width), d = c(a.height), e = document.createElement("canvas");
                    e.width = b, e.height = d, e.getContext("2d").drawImage(a, 0, 0, b, d), k.image = e;
                } else k.image = a;
                k.needsUpdate = !0;
            })), k.sourceFile = e, g && (k.repeat.set(g[0], g[1]), 1 !== g[0] && (k.wrapS = THREE.RepeatWrapping), 
            1 !== g[1] && (k.wrapT = THREE.RepeatWrapping)), h && k.offset.set(h[0], h[1]), 
            i && (e = {
                repeat: THREE.RepeatWrapping,
                mirror: THREE.MirroredRepeatWrapping
            }, void 0 !== e[i[0]] && (k.wrapS = e[i[0]]), void 0 !== e[i[1]] && (k.wrapT = e[i[1]])), 
            j && (k.anisotropy = j), a[d] = k;
        }
        function e(a) {
            return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
        }
        var f = this, g = "MeshLambertMaterial", h = {
            color: 15658734,
            opacity: 1,
            map: null,
            lightMap: null,
            normalMap: null,
            bumpMap: null,
            wireframe: !1
        };
        if (a.shading) {
            var i = a.shading.toLowerCase();
            "phong" === i ? g = "MeshPhongMaterial" : "basic" === i && (g = "MeshBasicMaterial");
        }
        return void 0 !== a.blending && void 0 !== THREE[a.blending] && (h.blending = THREE[a.blending]), 
        void 0 !== a.transparent && (h.transparent = a.transparent), void 0 !== a.opacity && 1 > a.opacity && (h.transparent = !0), 
        void 0 !== a.depthTest && (h.depthTest = a.depthTest), void 0 !== a.depthWrite && (h.depthWrite = a.depthWrite), 
        void 0 !== a.visible && (h.visible = a.visible), void 0 !== a.flipSided && (h.side = THREE.BackSide), 
        void 0 !== a.doubleSided && (h.side = THREE.DoubleSide), void 0 !== a.wireframe && (h.wireframe = a.wireframe), 
        void 0 !== a.vertexColors && ("face" === a.vertexColors ? h.vertexColors = THREE.FaceColors : a.vertexColors && (h.vertexColors = THREE.VertexColors)), 
        a.colorDiffuse ? h.color = e(a.colorDiffuse) : a.DbgColor && (h.color = a.DbgColor), 
        a.colorSpecular && (h.specular = e(a.colorSpecular)), a.colorEmissive && (h.emissive = e(a.colorEmissive)), 
        void 0 !== a.transparency && (console.warn("THREE.Loader: transparency has been renamed to opacity"), 
        a.opacity = a.transparency), void 0 !== a.opacity && (h.opacity = a.opacity), a.specularCoef && (h.shininess = a.specularCoef), 
        a.mapDiffuse && b && d(h, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy), 
        a.mapLight && b && d(h, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy), 
        a.mapBump && b && d(h, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy), 
        a.mapNormal && b && d(h, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy), 
        a.mapSpecular && b && d(h, "specularMap", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy), 
        a.mapAlpha && b && d(h, "alphaMap", a.mapAlpha, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy), 
        a.mapBumpScale && (h.bumpScale = a.mapBumpScale), a.mapNormalFactor && (h.normalScale = new THREE.Vector2(a.mapNormalFactor, a.mapNormalFactor)), 
        g = new THREE[g](h), void 0 !== a.DbgName && (g.name = a.DbgName), g;
    }
}, THREE.Loader.Handlers = {
    handlers: [],
    add: function(a, b) {
        this.handlers.push(a, b);
    },
    get: function(a) {
        for (var b = 0, c = this.handlers.length; c > b; b += 2) {
            var d = this.handlers[b + 1];
            if (this.handlers[b].test(a)) return d;
        }
        return null;
    }
}, THREE.XHRLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function(a, b, c, d) {
        var e = this, f = THREE.Cache.get(a);
        void 0 !== f ? b && b(f) : (f = new XMLHttpRequest(), f.open("GET", a, !0), f.addEventListener("load", function(c) {
            THREE.Cache.add(a, this.response), b && b(this.response), e.manager.itemEnd(a);
        }, !1), void 0 !== c && f.addEventListener("progress", function(a) {
            c(a);
        }, !1), void 0 !== d && f.addEventListener("error", function(a) {
            d(a);
        }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (f.responseType = this.responseType), 
        f.send(null), e.manager.itemStart(a));
    },
    setResponseType: function(a) {
        this.responseType = a;
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    }
}, THREE.ImageLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function(a, b, c, d) {
        var e = this, f = THREE.Cache.get(a);
        return void 0 === f ? (f = document.createElement("img"), f.addEventListener("load", function(c) {
            THREE.Cache.add(a, this), b && b(this), e.manager.itemEnd(a);
        }, !1), void 0 !== c && f.addEventListener("progress", function(a) {
            c(a);
        }, !1), void 0 !== d && f.addEventListener("error", function(a) {
            d(a);
        }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), f.src = a, 
        e.manager.itemStart(a), f) : void b(f);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    }
}, THREE.JSONLoader = function(a) {
    THREE.Loader.call(this, a), this.withCredentials = !1;
}, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.constructor = THREE.JSONLoader, 
THREE.JSONLoader.prototype.load = function(a, b, c) {
    c = c && "string" == typeof c ? c : this.extractUrlBase(a), this.onLoadStart(), 
    this.loadAjaxJSON(this, a, b, c);
}, THREE.JSONLoader.prototype.loadAjaxJSON = function(a, b, c, d, e) {
    var f = new XMLHttpRequest(), g = 0;
    f.onreadystatechange = function() {
        if (f.readyState === f.DONE) if (200 === f.status || 0 === f.status) {
            if (f.responseText) {
                var h = JSON.parse(f.responseText), i = h.metadata;
                if (void 0 !== i) {
                    if ("object" === i.type) return void THREE.error("THREE.JSONLoader: " + b + " should be loaded with THREE.ObjectLoader instead.");
                    if ("scene" === i.type) return void THREE.error("THREE.JSONLoader: " + b + " seems to be a Scene. Use THREE.SceneLoader instead.");
                }
                h = a.parse(h, d), c(h.geometry, h.materials);
            } else THREE.error("THREE.JSONLoader: " + b + " seems to be unreachable or the file is empty.");
            a.onLoadComplete();
        } else THREE.error("THREE.JSONLoader: Couldn't load " + b + " (" + f.status + ")"); else f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader("Content-Length")), 
        e({
            total: g,
            loaded: f.responseText.length
        })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader("Content-Length"));
    }, f.open("GET", b, !0), f.withCredentials = this.withCredentials, f.send(null);
}, THREE.JSONLoader.prototype.parse = function(a, b) {
    var c = new THREE.Geometry(), d = void 0 !== a.scale ? 1 / a.scale : 1;
    return function(b) {
        var d, e, f, g, h, i, j, k, l, m, n, o, p, q = a.faces;
        i = a.vertices;
        var r = a.normals, s = a.colors, t = 0;
        if (void 0 !== a.uvs) {
            for (d = 0; d < a.uvs.length; d++) a.uvs[d].length && t++;
            for (d = 0; t > d; d++) c.faceVertexUvs[d] = [];
        }
        for (g = 0, h = i.length; h > g; ) d = new THREE.Vector3(), d.x = i[g++] * b, d.y = i[g++] * b, 
        d.z = i[g++] * b, c.vertices.push(d);
        for (g = 0, h = q.length; h > g; ) if (b = q[g++], l = 1 & b, f = 2 & b, d = 8 & b, 
        j = 16 & b, m = 32 & b, i = 64 & b, b &= 128, l) {
            if (l = new THREE.Face3(), l.a = q[g], l.b = q[g + 1], l.c = q[g + 3], n = new THREE.Face3(), 
            n.a = q[g + 1], n.b = q[g + 2], n.c = q[g + 3], g += 4, f && (f = q[g++], l.materialIndex = f, 
            n.materialIndex = f), f = c.faces.length, d) for (d = 0; t > d; d++) for (o = a.uvs[d], 
            c.faceVertexUvs[d][f] = [], c.faceVertexUvs[d][f + 1] = [], e = 0; 4 > e; e++) k = q[g++], 
            p = o[2 * k], k = o[2 * k + 1], p = new THREE.Vector2(p, k), 2 !== e && c.faceVertexUvs[d][f].push(p), 
            0 !== e && c.faceVertexUvs[d][f + 1].push(p);
            if (j && (j = 3 * q[g++], l.normal.set(r[j++], r[j++], r[j]), n.normal.copy(l.normal)), 
            m) for (d = 0; 4 > d; d++) j = 3 * q[g++], m = new THREE.Vector3(r[j++], r[j++], r[j]), 
            2 !== d && l.vertexNormals.push(m), 0 !== d && n.vertexNormals.push(m);
            if (i && (i = q[g++], i = s[i], l.color.setHex(i), n.color.setHex(i)), b) for (d = 0; 4 > d; d++) i = q[g++], 
            i = s[i], 2 !== d && l.vertexColors.push(new THREE.Color(i)), 0 !== d && n.vertexColors.push(new THREE.Color(i));
            c.faces.push(l), c.faces.push(n);
        } else {
            if (l = new THREE.Face3(), l.a = q[g++], l.b = q[g++], l.c = q[g++], f && (f = q[g++], 
            l.materialIndex = f), f = c.faces.length, d) for (d = 0; t > d; d++) for (o = a.uvs[d], 
            c.faceVertexUvs[d][f] = [], e = 0; 3 > e; e++) k = q[g++], p = o[2 * k], k = o[2 * k + 1], 
            p = new THREE.Vector2(p, k), c.faceVertexUvs[d][f].push(p);
            if (j && (j = 3 * q[g++], l.normal.set(r[j++], r[j++], r[j])), m) for (d = 0; 3 > d; d++) j = 3 * q[g++], 
            m = new THREE.Vector3(r[j++], r[j++], r[j]), l.vertexNormals.push(m);
            if (i && (i = q[g++], l.color.setHex(s[i])), b) for (d = 0; 3 > d; d++) i = q[g++], 
            l.vertexColors.push(new THREE.Color(s[i]));
            c.faces.push(l);
        }
    }(d), function() {
        var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
        if (a.skinWeights) for (var d = 0, e = a.skinWeights.length; e > d; d += b) c.skinWeights.push(new THREE.Vector4(a.skinWeights[d], b > 1 ? a.skinWeights[d + 1] : 0, b > 2 ? a.skinWeights[d + 2] : 0, b > 3 ? a.skinWeights[d + 3] : 0));
        if (a.skinIndices) for (d = 0, e = a.skinIndices.length; e > d; d += b) c.skinIndices.push(new THREE.Vector4(a.skinIndices[d], b > 1 ? a.skinIndices[d + 1] : 0, b > 2 ? a.skinIndices[d + 2] : 0, b > 3 ? a.skinIndices[d + 3] : 0));
        c.bones = a.bones, c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && THREE.warn("THREE.JSONLoader: When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match."), 
        c.animation = a.animation, c.animations = a.animations;
    }(), function(b) {
        if (void 0 !== a.morphTargets) {
            var d, e, f, g, h, i;
            for (d = 0, e = a.morphTargets.length; e > d; d++) for (c.morphTargets[d] = {}, 
            c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], 
            h = c.morphTargets[d].vertices, i = a.morphTargets[d].vertices, f = 0, g = i.length; g > f; f += 3) {
                var j = new THREE.Vector3();
                j.x = i[f] * b, j.y = i[f + 1] * b, j.z = i[f + 2] * b, h.push(j);
            }
        }
        if (void 0 !== a.morphColors) for (d = 0, e = a.morphColors.length; e > d; d++) for (c.morphColors[d] = {}, 
        c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], g = c.morphColors[d].colors, 
        h = a.morphColors[d].colors, b = 0, f = h.length; f > b; b += 3) i = new THREE.Color(16755200), 
        i.setRGB(h[b], h[b + 1], h[b + 2]), g.push(i);
    }(d), c.computeFaceNormals(), c.computeBoundingSphere(), void 0 === a.materials || 0 === a.materials.length ? {
        geometry: c
    } : (d = this.initMaterials(a.materials, b), this.needsTangents(d) && c.computeTangents(), 
    {
        geometry: c,
        materials: d
    });
}, THREE.LoadingManager = function(a, b, c) {
    var d = this, e = 0, f = 0;
    this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function(a) {
        f++;
    }, this.itemEnd = function(a) {
        e++, void 0 !== d.onProgress && d.onProgress(a, e, f), e === f && void 0 !== d.onLoad && d.onLoad();
    };
}, THREE.DefaultLoadingManager = new THREE.LoadingManager(), THREE.BufferGeometryLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            b(e.parse(JSON.parse(a)));
        }, c, d);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    parse: function(a) {
        var b, c = new THREE.BufferGeometry(), d = a.data.attributes;
        for (b in d) {
            var e = d[b], f = new self[e.type](e.array);
            c.addAttribute(b, new THREE.BufferAttribute(f, e.itemSize));
        }
        return d = a.data.offsets, void 0 !== d && (c.offsets = JSON.parse(JSON.stringify(d))), 
        a = a.data.boundingSphere, void 0 !== a && (d = new THREE.Vector3(), void 0 !== a.center && d.fromArray(a.center), 
        c.boundingSphere = new THREE.Sphere(d, a.radius)), c;
    }
}, THREE.MaterialLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            b(e.parse(JSON.parse(a)));
        }, c, d);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    parse: function(a) {
        var b = new THREE[a.type]();
        if (void 0 !== a.color && b.color.setHex(a.color), void 0 !== a.emissive && b.emissive.setHex(a.emissive), 
        void 0 !== a.specular && b.specular.setHex(a.specular), void 0 !== a.shininess && (b.shininess = a.shininess), 
        void 0 !== a.uniforms && (b.uniforms = a.uniforms), void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader), 
        void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader), void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors), 
        void 0 !== a.shading && (b.shading = a.shading), void 0 !== a.blending && (b.blending = a.blending), 
        void 0 !== a.side && (b.side = a.side), void 0 !== a.opacity && (b.opacity = a.opacity), 
        void 0 !== a.transparent && (b.transparent = a.transparent), void 0 !== a.wireframe && (b.wireframe = a.wireframe), 
        void 0 !== a.size && (b.size = a.size), void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation), 
        void 0 !== a.materials) for (var c = 0, d = a.materials.length; d > c; c++) b.materials.push(this.parse(a.materials[c]));
        return b;
    }
}, THREE.ObjectLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.texturePath = "";
}, THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function(a, b, c, d) {
        "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            e.parse(JSON.parse(a), b);
        }, c, d);
    },
    setTexturePath: function(a) {
        this.texturePath = a;
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    parse: function(a, b) {
        var c = this.parseGeometries(a.geometries), d = this.parseImages(a.images, function() {
            void 0 !== b && b(e);
        }), d = this.parseTextures(a.textures, d), d = this.parseMaterials(a.materials, d), e = this.parseObject(a.object, c, d);
        return void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e), e;
    },
    parseGeometries: function(a) {
        var b = {};
        if (void 0 !== a) for (var c = new THREE.JSONLoader(), d = new THREE.BufferGeometryLoader(), e = 0, f = a.length; f > e; e++) {
            var g, h = a[e];
            switch (h.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                g = new THREE[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                break;

              case "BoxGeometry":
              case "CubeGeometry":
                g = new THREE.BoxGeometry(h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                break;

              case "CircleGeometry":
                g = new THREE.CircleGeometry(h.radius, h.segments);
                break;

              case "CylinderGeometry":
                g = new THREE.CylinderGeometry(h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded);
                break;

              case "SphereGeometry":
                g = new THREE.SphereGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                break;

              case "IcosahedronGeometry":
                g = new THREE.IcosahedronGeometry(h.radius, h.detail);
                break;

              case "TorusGeometry":
                g = new THREE.TorusGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                break;

              case "TorusKnotGeometry":
                g = new THREE.TorusKnotGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.p, h.q, h.heightScale);
                break;

              case "BufferGeometry":
                g = d.parse(h);
                break;

              case "Geometry":
                g = c.parse(h.data).geometry;
            }
            g.uuid = h.uuid, void 0 !== h.name && (g.name = h.name), b[h.uuid] = g;
        }
        return b;
    },
    parseMaterials: function(a, b) {
        var c = {};
        if (void 0 !== a) for (var d = function(a) {
            return void 0 === b[a] && THREE.warn("THREE.ObjectLoader: Undefined texture", a), 
            b[a];
        }, e = new THREE.MaterialLoader(), f = 0, g = a.length; g > f; f++) {
            var h = a[f], i = e.parse(h);
            i.uuid = h.uuid, void 0 !== h.name && (i.name = h.name), void 0 !== h.map && (i.map = d(h.map)), 
            void 0 !== h.bumpMap && (i.bumpMap = d(h.bumpMap), h.bumpScale && (i.bumpScale = new THREE.Vector2(h.bumpScale, h.bumpScale))), 
            void 0 !== h.alphaMap && (i.alphaMap = d(h.alphaMap)), void 0 !== h.envMap && (i.envMap = d(h.envMap)), 
            void 0 !== h.normalMap && (i.normalMap = d(h.normalMap), h.normalScale && (i.normalScale = new THREE.Vector2(h.normalScale, h.normalScale))), 
            void 0 !== h.lightMap && (i.lightMap = d(h.lightMap)), void 0 !== h.specularMap && (i.specularMap = d(h.specularMap)), 
            c[h.uuid] = i;
        }
        return c;
    },
    parseImages: function(a, b) {
        var c = this, d = {};
        if (void 0 !== a && 0 < a.length) {
            var e = new THREE.LoadingManager(b), f = new THREE.ImageLoader(e);
            f.setCrossOrigin(this.crossOrigin);
            for (var e = function(a) {
                return c.manager.itemStart(a), f.load(a, function() {
                    c.manager.itemEnd(a);
                });
            }, g = 0, h = a.length; h > g; g++) {
                var i = a[g], j = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i.url) ? i.url : c.texturePath + i.url;
                d[i.uuid] = e(j);
            }
        }
        return d;
    },
    parseTextures: function(a, b) {
        var c = {};
        if (void 0 !== a) for (var d = 0, e = a.length; e > d; d++) {
            var f = a[d];
            void 0 === f.image && THREE.warn('THREE.ObjectLoader: No "image" speficied for', f.uuid), 
            void 0 === b[f.image] && THREE.warn("THREE.ObjectLoader: Undefined image", f.image);
            var g = new THREE.Texture(b[f.image]);
            g.needsUpdate = !0, g.uuid = f.uuid, void 0 !== f.name && (g.name = f.name), void 0 !== f.repeat && (g.repeat = new THREE.Vector2(f.repeat[0], f.repeat[1])), 
            void 0 !== f.minFilter && (g.minFilter = THREE[f.minFilter]), void 0 !== f.magFilter && (g.magFilter = THREE[f.magFilter]), 
            void 0 !== f.anisotropy && (g.anisotropy = f.anisotropy), f.wrap instanceof Array && (g.wrapS = THREE[f.wrap[0]], 
            g.wrapT = THREE[f.wrap[1]]), c[f.uuid] = g;
        }
        return c;
    },
    parseObject: function() {
        var a = new THREE.Matrix4();
        return function(b, c, d) {
            var e;
            e = function(a) {
                return void 0 === c[a] && THREE.warn("THREE.ObjectLoader: Undefined geometry", a), 
                c[a];
            };
            var f = function(a) {
                return void 0 === d[a] && THREE.warn("THREE.ObjectLoader: Undefined material", a), 
                d[a];
            };
            switch (b.type) {
              case "Scene":
                e = new THREE.Scene();
                break;

              case "PerspectiveCamera":
                e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
                break;

              case "OrthographicCamera":
                e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
                break;

              case "AmbientLight":
                e = new THREE.AmbientLight(b.color);
                break;

              case "DirectionalLight":
                e = new THREE.DirectionalLight(b.color, b.intensity);
                break;

              case "PointLight":
                e = new THREE.PointLight(b.color, b.intensity, b.distance, b.decay);
                break;

              case "SpotLight":
                e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent, b.decay);
                break;

              case "HemisphereLight":
                e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
                break;

              case "Mesh":
                e = new THREE.Mesh(e(b.geometry), f(b.material));
                break;

              case "Line":
                e = new THREE.Line(e(b.geometry), f(b.material), b.mode);
                break;

              case "PointCloud":
                e = new THREE.PointCloud(e(b.geometry), f(b.material));
                break;

              case "Sprite":
                e = new THREE.Sprite(f(b.material));
                break;

              case "Group":
                e = new THREE.Group();
                break;

              default:
                e = new THREE.Object3D();
            }
            if (e.uuid = b.uuid, void 0 !== b.name && (e.name = b.name), void 0 !== b.matrix ? (a.fromArray(b.matrix), 
            a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), 
            void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale)), 
            void 0 !== b.visible && (e.visible = b.visible), void 0 !== b.userData && (e.userData = b.userData), 
            void 0 !== b.children) for (var g in b.children) e.add(this.parseObject(b.children[g], c, d));
            return e;
        };
    }()
}, THREE.TextureLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function(a, b, c, d) {
        var e = new THREE.ImageLoader(this.manager);
        e.setCrossOrigin(this.crossOrigin), e.load(a, function(a) {
            a = new THREE.Texture(a), a.needsUpdate = !0, void 0 !== b && b(a);
        }, c, d);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    }
}, THREE.DataTextureLoader = THREE.BinaryTextureLoader = function() {
    this._parser = null;
}, THREE.BinaryTextureLoader.prototype = {
    constructor: THREE.BinaryTextureLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.DataTexture(), g = new THREE.XHRLoader();
        return g.setResponseType("arraybuffer"), g.load(a, function(a) {
            (a = e._parser(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, 
            f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping, 
            f.wrapT = void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ? a.magFilter : THREE.LinearFilter, 
            f.minFilter = void 0 !== a.minFilter ? a.minFilter : THREE.LinearMipMapLinearFilter, 
            f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), 
            void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 
            1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, a));
        }, c, d), f;
    }
}, THREE.CompressedTextureLoader = function() {
    this._parser = null;
}, THREE.CompressedTextureLoader.prototype = {
    constructor: THREE.CompressedTextureLoader,
    load: function(a, b, c) {
        var d = this, e = [], f = new THREE.CompressedTexture();
        f.image = e;
        var g = new THREE.XHRLoader();
        if (g.setResponseType("arraybuffer"), a instanceof Array) {
            var h = 0;
            c = function(c) {
                g.load(a[c], function(a) {
                    a = d._parser(a, !0), e[c] = {
                        width: a.width,
                        height: a.height,
                        format: a.format,
                        mipmaps: a.mipmaps
                    }, h += 1, 6 === h && (1 == a.mipmapCount && (f.minFilter = THREE.LinearFilter), 
                    f.format = a.format, f.needsUpdate = !0, b && b(f));
                });
            };
            for (var i = 0, j = a.length; j > i; ++i) c(i);
        } else g.load(a, function(a) {
            if (a = d._parser(a, !0), a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, g = 0; c > g; g++) {
                e[g] = {
                    mipmaps: []
                };
                for (var h = 0; h < a.mipmapCount; h++) e[g].mipmaps.push(a.mipmaps[g * a.mipmapCount + h]), 
                e[g].format = a.format, e[g].width = a.width, e[g].height = a.height;
            } else f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
            1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.format = a.format, 
            f.needsUpdate = !0, b && b(f);
        });
        return f;
    }
}, THREE.Material = function() {
    Object.defineProperty(this, "id", {
        value: THREE.MaterialIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Material", 
    this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, 
    this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, 
    this.blendEquation = THREE.AddEquation, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, 
    this.colorWrite = this.depthWrite = this.depthTest = !0, this.polygonOffset = !1, 
    this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, 
    this._needsUpdate = this.visible = !0;
}, THREE.Material.prototype = {
    constructor: THREE.Material,
    get needsUpdate() {
        return this._needsUpdate;
    },
    set needsUpdate(a) {
        !0 === a && this.update(), this._needsUpdate = a;
    },
    setValues: function(a) {
        if (void 0 !== a) for (var b in a) {
            var c = a[b];
            if (void 0 === c) THREE.warn("THREE.Material: '" + b + "' parameter is undefined."); else if (b in this) {
                var d = this[b];
                d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = "overdraw" == b ? Number(c) : c;
            }
        }
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type
        };
        return "" !== this.name && (a.name = this.name), this instanceof THREE.MeshBasicMaterial ? (a.color = this.color.getHex(), 
        this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), 
        this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (a.color = this.color.getHex(), 
        a.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), 
        this.shading !== THREE.SmoothShading && (a.shading = this.shading), this.blending !== THREE.NormalBlending && (a.blending = this.blending), 
        this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (a.color = this.color.getHex(), 
        a.emissive = this.emissive.getHex(), a.specular = this.specular.getHex(), a.shininess = this.shininess, 
        this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (a.shading = this.shading), 
        this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), 
        this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), 
        this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.PointCloudMaterial ? (a.size = this.size, 
        a.sizeAttenuation = this.sizeAttenuation, a.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), 
        this.blending !== THREE.NormalBlending && (a.blending = this.blending)) : this instanceof THREE.ShaderMaterial ? (a.uniforms = this.uniforms, 
        a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (a.color = this.color.getHex()), 
        1 > this.opacity && (a.opacity = this.opacity), !1 !== this.transparent && (a.transparent = this.transparent), 
        !1 !== this.wireframe && (a.wireframe = this.wireframe), a;
    },
    clone: function(a) {
        return void 0 === a && (a = new THREE.Material()), a.name = this.name, a.side = this.side, 
        a.opacity = this.opacity, a.transparent = this.transparent, a.blending = this.blending, 
        a.blendSrc = this.blendSrc, a.blendDst = this.blendDst, a.blendEquation = this.blendEquation, 
        a.blendSrcAlpha = this.blendSrcAlpha, a.blendDstAlpha = this.blendDstAlpha, a.blendEquationAlpha = this.blendEquationAlpha, 
        a.depthTest = this.depthTest, a.depthWrite = this.depthWrite, a.polygonOffset = this.polygonOffset, 
        a.polygonOffsetFactor = this.polygonOffsetFactor, a.polygonOffsetUnits = this.polygonOffsetUnits, 
        a.alphaTest = this.alphaTest, a.overdraw = this.overdraw, a.visible = this.visible, 
        a;
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        });
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, 
THREE.LineBasicMaterial = function(a) {
    THREE.Material.call(this), this.type = "LineBasicMaterial", this.color = new THREE.Color(16777215), 
    this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = THREE.NoColors, 
    this.fog = !0, this.setValues(a);
}, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial, THREE.LineBasicMaterial.prototype.clone = function() {
    var a = new THREE.LineBasicMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.linewidth = this.linewidth, 
    a.linecap = this.linecap, a.linejoin = this.linejoin, a.vertexColors = this.vertexColors, 
    a.fog = this.fog, a;
}, THREE.LineDashedMaterial = function(a) {
    THREE.Material.call(this), this.type = "LineDashedMaterial", this.color = new THREE.Color(16777215), 
    this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, 
    this.fog = !0, this.setValues(a);
}, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial, THREE.LineDashedMaterial.prototype.clone = function() {
    var a = new THREE.LineDashedMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.linewidth = this.linewidth, 
    a.scale = this.scale, a.dashSize = this.dashSize, a.gapSize = this.gapSize, a.vertexColors = this.vertexColors, 
    a.fog = this.fog, a;
}, THREE.MeshBasicMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshBasicMaterial", this.color = new THREE.Color(16777215), 
    this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, 
    this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
    this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, 
    this.morphTargets = this.skinning = !1, this.setValues(a);
}, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial, THREE.MeshBasicMaterial.prototype.clone = function() {
    var a = new THREE.MeshBasicMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.map = this.map, 
    a.lightMap = this.lightMap, a.specularMap = this.specularMap, a.alphaMap = this.alphaMap, 
    a.envMap = this.envMap, a.combine = this.combine, a.reflectivity = this.reflectivity, 
    a.refractionRatio = this.refractionRatio, a.fog = this.fog, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.wireframeLinecap = this.wireframeLinecap, 
    a.wireframeLinejoin = this.wireframeLinejoin, a.vertexColors = this.vertexColors, 
    a.skinning = this.skinning, a.morphTargets = this.morphTargets, a;
}, THREE.MeshLambertMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshLambertMaterial", this.color = new THREE.Color(16777215), 
    this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), 
    this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, 
    this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
    this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, 
    this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a);
}, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial, THREE.MeshLambertMaterial.prototype.clone = function() {
    var a = new THREE.MeshLambertMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.emissive.copy(this.emissive), 
    a.wrapAround = this.wrapAround, a.wrapRGB.copy(this.wrapRGB), a.map = this.map, 
    a.lightMap = this.lightMap, a.specularMap = this.specularMap, a.alphaMap = this.alphaMap, 
    a.envMap = this.envMap, a.combine = this.combine, a.reflectivity = this.reflectivity, 
    a.refractionRatio = this.refractionRatio, a.fog = this.fog, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.wireframeLinecap = this.wireframeLinecap, 
    a.wireframeLinejoin = this.wireframeLinejoin, a.vertexColors = this.vertexColors, 
    a.skinning = this.skinning, a.morphTargets = this.morphTargets, a.morphNormals = this.morphNormals, 
    a;
}, THREE.MeshPhongMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshPhongMaterial", this.color = new THREE.Color(16777215), 
    this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, 
    this.wrapAround = this.metal = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.bumpMap = this.lightMap = this.map = null, 
    this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), 
    this.envMap = this.alphaMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, 
    this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, 
    this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
    this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, 
    this.setValues(a);
}, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial, THREE.MeshPhongMaterial.prototype.clone = function() {
    var a = new THREE.MeshPhongMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.emissive.copy(this.emissive), 
    a.specular.copy(this.specular), a.shininess = this.shininess, a.metal = this.metal, 
    a.wrapAround = this.wrapAround, a.wrapRGB.copy(this.wrapRGB), a.map = this.map, 
    a.lightMap = this.lightMap, a.bumpMap = this.bumpMap, a.bumpScale = this.bumpScale, 
    a.normalMap = this.normalMap, a.normalScale.copy(this.normalScale), a.specularMap = this.specularMap, 
    a.alphaMap = this.alphaMap, a.envMap = this.envMap, a.combine = this.combine, a.reflectivity = this.reflectivity, 
    a.refractionRatio = this.refractionRatio, a.fog = this.fog, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.wireframeLinecap = this.wireframeLinecap, 
    a.wireframeLinejoin = this.wireframeLinejoin, a.vertexColors = this.vertexColors, 
    a.skinning = this.skinning, a.morphTargets = this.morphTargets, a.morphNormals = this.morphNormals, 
    a;
}, THREE.MeshDepthMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshDepthMaterial", this.wireframe = this.morphTargets = !1, 
    this.wireframeLinewidth = 1, this.setValues(a);
}, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial, THREE.MeshDepthMaterial.prototype.clone = function() {
    var a = new THREE.MeshDepthMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.wireframe = this.wireframe, 
    a.wireframeLinewidth = this.wireframeLinewidth, a;
}, THREE.MeshNormalMaterial = function(a) {
    THREE.Material.call(this, a), this.type = "MeshNormalMaterial", this.wireframe = !1, 
    this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(a);
}, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial, THREE.MeshNormalMaterial.prototype.clone = function() {
    var a = new THREE.MeshNormalMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.wireframe = this.wireframe, 
    a.wireframeLinewidth = this.wireframeLinewidth, a;
}, THREE.MeshFaceMaterial = function(a) {
    this.uuid = THREE.Math.generateUUID(), this.type = "MeshFaceMaterial", this.materials = a instanceof Array ? a : [];
}, THREE.MeshFaceMaterial.prototype = {
    constructor: THREE.MeshFaceMaterial,
    toJSON: function() {
        for (var a = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        }, b = 0, c = this.materials.length; c > b; b++) a.materials.push(this.materials[b].toJSON());
        return a;
    },
    clone: function() {
        for (var a = new THREE.MeshFaceMaterial(), b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
        return a;
    }
}, THREE.PointCloudMaterial = function(a) {
    THREE.Material.call(this), this.type = "PointCloudMaterial", this.color = new THREE.Color(16777215), 
    this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, 
    this.fog = !0, this.setValues(a);
}, THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial, THREE.PointCloudMaterial.prototype.clone = function() {
    var a = new THREE.PointCloudMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.map = this.map, 
    a.size = this.size, a.sizeAttenuation = this.sizeAttenuation, a.vertexColors = this.vertexColors, 
    a.fog = this.fog, a;
}, THREE.ParticleBasicMaterial = function(a) {
    return THREE.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), 
    new THREE.PointCloudMaterial(a);
}, THREE.ParticleSystemMaterial = function(a) {
    return THREE.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), 
    new THREE.PointCloudMaterial(a);
}, THREE.ShaderMaterial = function(a) {
    THREE.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, 
    this.attributes = null, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
    this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", 
    this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, 
    this.defaultAttributeValues = {
        color: [ 1, 1, 1 ],
        uv: [ 0, 0 ],
        uv2: [ 0, 0 ]
    }, this.index0AttributeName = void 0, this.setValues(a);
}, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial, 
THREE.ShaderMaterial.prototype.clone = function() {
    var a = new THREE.ShaderMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.fragmentShader = this.fragmentShader, 
    a.vertexShader = this.vertexShader, a.uniforms = THREE.UniformsUtils.clone(this.uniforms), 
    a.attributes = this.attributes, a.defines = this.defines, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.fog = this.fog, 
    a.lights = this.lights, a.vertexColors = this.vertexColors, a.skinning = this.skinning, 
    a.morphTargets = this.morphTargets, a.morphNormals = this.morphNormals, a;
}, THREE.RawShaderMaterial = function(a) {
    THREE.ShaderMaterial.call(this, a), this.type = "RawShaderMaterial";
}, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), 
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial, THREE.RawShaderMaterial.prototype.clone = function() {
    var a = new THREE.RawShaderMaterial();
    return THREE.ShaderMaterial.prototype.clone.call(this, a), a;
}, THREE.SpriteMaterial = function(a) {
    THREE.Material.call(this), this.type = "SpriteMaterial", this.color = new THREE.Color(16777215), 
    this.map = null, this.rotation = 0, this.fog = !1, this.setValues(a);
}, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial, 
THREE.SpriteMaterial.prototype.clone = function() {
    var a = new THREE.SpriteMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.map = this.map, 
    a.rotation = this.rotation, a.fog = this.fog, a;
}, THREE.Texture = function(a, b, c, d, e, f, g, h, i) {
    Object.defineProperty(this, "id", {
        value: THREE.TextureIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.sourceFile = this.name = "", this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE, 
    this.mipmaps = [], this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING, 
    this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping, 
    this.magFilter = void 0 !== e ? e : THREE.LinearFilter, this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter, 
    this.anisotropy = void 0 !== i ? i : 1, this.format = void 0 !== g ? g : THREE.RGBAFormat, 
    this.type = void 0 !== h ? h : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), 
    this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, 
    this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null;
}, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping, 
THREE.Texture.prototype = {
    constructor: THREE.Texture,
    get needsUpdate() {
        return this._needsUpdate;
    },
    set needsUpdate(a) {
        !0 === a && this.update(), this._needsUpdate = a;
    },
    clone: function(a) {
        return void 0 === a && (a = new THREE.Texture()), a.image = this.image, a.mipmaps = this.mipmaps.slice(0), 
        a.mapping = this.mapping, a.wrapS = this.wrapS, a.wrapT = this.wrapT, a.magFilter = this.magFilter, 
        a.minFilter = this.minFilter, a.anisotropy = this.anisotropy, a.format = this.format, 
        a.type = this.type, a.offset.copy(this.offset), a.repeat.copy(this.repeat), a.generateMipmaps = this.generateMipmaps, 
        a.premultiplyAlpha = this.premultiplyAlpha, a.flipY = this.flipY, a.unpackAlignment = this.unpackAlignment, 
        a;
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        });
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, 
THREE.CubeTexture = function(a, b, c, d, e, f, g, h, i) {
    b = void 0 !== b ? b : THREE.CubeReflectionMapping, THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), 
    this.images = a;
}, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.prototype.constructor = THREE.CubeTexture, 
THREE.CubeTexture.clone = function(a) {
    return void 0 === a && (a = new THREE.CubeTexture()), THREE.Texture.prototype.clone.call(this, a), 
    a.images = this.images, a;
}, THREE.CompressedTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
    THREE.Texture.call(this, null, f, g, h, i, j, d, e, k), this.image = {
        width: b,
        height: c
    }, this.mipmaps = a, this.generateMipmaps = this.flipY = !1;
}, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture, 
THREE.CompressedTexture.prototype.clone = function() {
    var a = new THREE.CompressedTexture();
    return THREE.Texture.prototype.clone.call(this, a), a;
}, THREE.DataTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
    THREE.Texture.call(this, null, f, g, h, i, j, d, e, k), this.image = {
        data: a,
        width: b,
        height: c
    };
}, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.constructor = THREE.DataTexture, 
THREE.DataTexture.prototype.clone = function() {
    var a = new THREE.DataTexture();
    return THREE.Texture.prototype.clone.call(this, a), a;
}, THREE.VideoTexture = function(a, b, c, d, e, f, g, h, i) {
    THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), this.generateMipmaps = !1;
    var j = this, k = function() {
        requestAnimationFrame(k), a.readyState === a.HAVE_ENOUGH_DATA && (j.needsUpdate = !0);
    };
    k();
}, THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype), THREE.VideoTexture.prototype.constructor = THREE.VideoTexture, 
THREE.Group = function() {
    THREE.Object3D.call(this), this.type = "Group";
}, THREE.Group.prototype = Object.create(THREE.Object3D.prototype), THREE.Group.prototype.constructor = THREE.Group, 
THREE.PointCloud = function(a, b) {
    THREE.Object3D.call(this), this.type = "PointCloud", this.geometry = void 0 !== a ? a : new THREE.Geometry(), 
    this.material = void 0 !== b ? b : new THREE.PointCloudMaterial({
        color: 16777215 * Math.random()
    });
}, THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype), THREE.PointCloud.prototype.constructor = THREE.PointCloud, 
THREE.PointCloud.prototype.raycast = function() {
    var a = new THREE.Matrix4(), b = new THREE.Ray();
    return function(c, d) {
        var e = this, f = e.geometry, g = c.params.PointCloud.threshold;
        if (a.getInverse(this.matrixWorld), b.copy(c.ray).applyMatrix4(a), null === f.boundingBox || !1 !== b.isIntersectionBox(f.boundingBox)) {
            var h = g / ((this.scale.x + this.scale.y + this.scale.z) / 3), i = new THREE.Vector3(), g = function(a, f) {
                var g = b.distanceToPoint(a);
                if (h > g) {
                    var i = b.closestPointToPoint(a);
                    i.applyMatrix4(e.matrixWorld);
                    var j = c.ray.origin.distanceTo(i);
                    d.push({
                        distance: j,
                        distanceToRay: g,
                        point: i.clone(),
                        index: f,
                        face: null,
                        object: e
                    });
                }
            };
            if (f instanceof THREE.BufferGeometry) {
                var j = f.attributes, k = j.position.array;
                if (void 0 !== j.index) {
                    var j = j.index.array, l = f.offsets;
                    0 === l.length && (l = [ {
                        start: 0,
                        count: j.length,
                        index: 0
                    } ]);
                    for (var m = 0, n = l.length; n > m; ++m) for (var o = l[m].start, p = l[m].index, f = o, o = o + l[m].count; o > f; f++) {
                        var q = p + j[f];
                        i.fromArray(k, 3 * q), g(i, q);
                    }
                } else for (j = k.length / 3, f = 0; j > f; f++) i.set(k[3 * f], k[3 * f + 1], k[3 * f + 2]), 
                g(i, f);
            } else for (i = this.geometry.vertices, f = 0; f < i.length; f++) g(i[f], f);
        }
    };
}(), THREE.PointCloud.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.PointCloud(this.geometry, this.material)), 
    THREE.Object3D.prototype.clone.call(this, a), a;
}, THREE.ParticleSystem = function(a, b) {
    return THREE.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), 
    new THREE.PointCloud(a, b);
}, THREE.Line = function(a, b, c) {
    THREE.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new THREE.Geometry(), 
    this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
        color: 16777215 * Math.random()
    }), this.mode = void 0 !== c ? c : THREE.LineStrip;
}, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), 
THREE.Line.prototype.constructor = THREE.Line, THREE.Line.prototype.raycast = function() {
    var a = new THREE.Matrix4(), b = new THREE.Ray(), c = new THREE.Sphere();
    return function(d, e) {
        var f = d.linePrecision, f = f * f, g = this.geometry;
        if (null === g.boundingSphere && g.computeBoundingSphere(), c.copy(g.boundingSphere), 
        c.applyMatrix4(this.matrixWorld), !1 !== d.ray.isIntersectionSphere(c)) {
            a.getInverse(this.matrixWorld), b.copy(d.ray).applyMatrix4(a);
            var h = new THREE.Vector3(), i = new THREE.Vector3(), j = new THREE.Vector3(), k = new THREE.Vector3(), l = this.mode === THREE.LineStrip ? 1 : 2;
            if (g instanceof THREE.BufferGeometry) {
                var m = g.attributes;
                if (void 0 !== m.index) {
                    var n = m.index.array, m = m.position.array, o = g.offsets;
                    0 === o.length && (o = [ {
                        start: 0,
                        count: n.length,
                        index: 0
                    } ]);
                    for (var p = 0; p < o.length; p++) for (var q = o[p].start, r = o[p].count, s = o[p].index, g = q; q + r - 1 > g; g += l) {
                        var t = s + n[g + 1];
                        h.fromArray(m, 3 * (s + n[g])), i.fromArray(m, 3 * t), t = b.distanceSqToSegment(h, i, k, j), 
                        t > f || (t = b.origin.distanceTo(k), t < d.near || t > d.far || e.push({
                            distance: t,
                            point: j.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            offsetIndex: p,
                            face: null,
                            faceIndex: null,
                            object: this
                        }));
                    }
                } else for (m = m.position.array, g = 0; g < m.length / 3 - 1; g += l) h.fromArray(m, 3 * g), 
                i.fromArray(m, 3 * g + 3), t = b.distanceSqToSegment(h, i, k, j), t > f || (t = b.origin.distanceTo(k), 
                t < d.near || t > d.far || e.push({
                    distance: t,
                    point: j.clone().applyMatrix4(this.matrixWorld),
                    index: g,
                    face: null,
                    faceIndex: null,
                    object: this
                }));
            } else if (g instanceof THREE.Geometry) for (h = g.vertices, i = h.length, g = 0; i - 1 > g; g += l) t = b.distanceSqToSegment(h[g], h[g + 1], k, j), 
            t > f || (t = b.origin.distanceTo(k), t < d.near || t > d.far || e.push({
                distance: t,
                point: j.clone().applyMatrix4(this.matrixWorld),
                index: g,
                face: null,
                faceIndex: null,
                object: this
            }));
        }
    };
}(), THREE.Line.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.mode)), 
    THREE.Object3D.prototype.clone.call(this, a), a;
}, THREE.Mesh = function(a, b) {
    THREE.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new THREE.Geometry(), 
    this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
        color: 16777215 * Math.random()
    }), this.updateMorphTargets();
}, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.constructor = THREE.Mesh, 
THREE.Mesh.prototype.updateMorphTargets = function() {
    if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
        this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], 
        this.morphTargetDictionary = {};
        for (var a = 0, b = this.geometry.morphTargets.length; b > a; a++) this.morphTargetInfluences.push(0), 
        this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;
    }
}, THREE.Mesh.prototype.getMorphTargetIndexByName = function(a) {
    return void 0 !== this.morphTargetDictionary[a] ? this.morphTargetDictionary[a] : (THREE.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0."), 
    0);
}, THREE.Mesh.prototype.raycast = function() {
    var a = new THREE.Matrix4(), b = new THREE.Ray(), c = new THREE.Sphere(), d = new THREE.Vector3(), e = new THREE.Vector3(), f = new THREE.Vector3();
    return function(g, h) {
        var i = this.geometry;
        if (null === i.boundingSphere && i.computeBoundingSphere(), c.copy(i.boundingSphere), 
        c.applyMatrix4(this.matrixWorld), !1 !== g.ray.isIntersectionSphere(c) && (a.getInverse(this.matrixWorld), 
        b.copy(g.ray).applyMatrix4(a), null === i.boundingBox || !1 !== b.isIntersectionBox(i.boundingBox))) if (i instanceof THREE.BufferGeometry) {
            var j = this.material;
            if (void 0 !== j) {
                var k, l, m = i.attributes, n = g.precision;
                if (void 0 !== m.index) {
                    var o = m.index.array, p = m.position.array, q = i.offsets;
                    0 === q.length && (q = [ {
                        start: 0,
                        count: o.length,
                        index: 0
                    } ]);
                    for (var r = 0, s = q.length; s > r; ++r) for (var m = q[r].start, t = q[r].index, i = m, u = m + q[r].count; u > i; i += 3) {
                        m = t + o[i], k = t + o[i + 1], l = t + o[i + 2], d.fromArray(p, 3 * m), e.fromArray(p, 3 * k), 
                        f.fromArray(p, 3 * l);
                        var v = j.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, j.side !== THREE.DoubleSide);
                        if (null !== v) {
                            v.applyMatrix4(this.matrixWorld);
                            var w = g.ray.origin.distanceTo(v);
                            n > w || w < g.near || w > g.far || h.push({
                                distance: w,
                                point: v,
                                face: new THREE.Face3(m, k, l, THREE.Triangle.normal(d, e, f)),
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                } else for (p = m.position.array, o = i = 0, u = p.length; u > i; i += 3, o += 9) m = i, 
                k = i + 1, l = i + 2, d.fromArray(p, o), e.fromArray(p, o + 3), f.fromArray(p, o + 6), 
                v = j.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, j.side !== THREE.DoubleSide), 
                null !== v && (v.applyMatrix4(this.matrixWorld), w = g.ray.origin.distanceTo(v), 
                n > w || w < g.near || w > g.far || h.push({
                    distance: w,
                    point: v,
                    face: new THREE.Face3(m, k, l, THREE.Triangle.normal(d, e, f)),
                    faceIndex: null,
                    object: this
                }));
            }
        } else if (i instanceof THREE.Geometry) for (o = this.material instanceof THREE.MeshFaceMaterial, 
        p = !0 === o ? this.material.materials : null, n = g.precision, q = i.vertices, 
        r = 0, s = i.faces.length; s > r; r++) if (t = i.faces[r], j = !0 === o ? p[t.materialIndex] : this.material, 
        void 0 !== j) {
            if (m = q[t.a], k = q[t.b], l = q[t.c], !0 === j.morphTargets) {
                v = i.morphTargets, w = this.morphTargetInfluences, d.set(0, 0, 0), e.set(0, 0, 0), 
                f.set(0, 0, 0);
                for (var u = 0, x = v.length; x > u; u++) {
                    var y = w[u];
                    if (0 !== y) {
                        var z = v[u].vertices;
                        d.x += (z[t.a].x - m.x) * y, d.y += (z[t.a].y - m.y) * y, d.z += (z[t.a].z - m.z) * y, 
                        e.x += (z[t.b].x - k.x) * y, e.y += (z[t.b].y - k.y) * y, e.z += (z[t.b].z - k.z) * y, 
                        f.x += (z[t.c].x - l.x) * y, f.y += (z[t.c].y - l.y) * y, f.z += (z[t.c].z - l.z) * y;
                    }
                }
                d.add(m), e.add(k), f.add(l), m = d, k = e, l = f;
            }
            v = j.side === THREE.BackSide ? b.intersectTriangle(l, k, m, !0) : b.intersectTriangle(m, k, l, j.side !== THREE.DoubleSide), 
            null !== v && (v.applyMatrix4(this.matrixWorld), w = g.ray.origin.distanceTo(v), 
            n > w || w < g.near || w > g.far || h.push({
                distance: w,
                point: v,
                face: t,
                faceIndex: r,
                object: this
            }));
        }
    };
}(), THREE.Mesh.prototype.clone = function(a, b) {
    return void 0 === a && (a = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, a, b), 
    a;
}, THREE.Bone = function(a) {
    THREE.Object3D.call(this), this.type = "Bone", this.skin = a;
}, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.constructor = THREE.Bone, 
THREE.Skeleton = function(a, b, c) {
    if (this.useVertexTexture = void 0 !== c ? c : !0, this.identityMatrix = new THREE.Matrix4(), 
    a = a || [], this.bones = a.slice(0), this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, 
    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), 
    this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), 
    this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, 
    this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length), 
    void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (THREE.warn("THREE.Skeleton bonInverses is the wrong length."), 
    this.boneInverses = [], b = 0, a = this.bones.length; a > b; b++) this.boneInverses.push(new THREE.Matrix4());
}, THREE.Skeleton.prototype.calculateInverses = function() {
    this.boneInverses = [];
    for (var a = 0, b = this.bones.length; b > a; a++) {
        var c = new THREE.Matrix4();
        this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c);
    }
}, THREE.Skeleton.prototype.pose = function() {
    for (var a, b = 0, c = this.bones.length; c > b; b++) (a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
    for (b = 0, c = this.bones.length; c > b; b++) (a = this.bones[b]) && (a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), 
    a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale));
}, THREE.Skeleton.prototype.update = function() {
    var a = new THREE.Matrix4();
    return function() {
        for (var b = 0, c = this.bones.length; c > b; b++) a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), 
        a.flattenToArrayOffset(this.boneMatrices, 16 * b);
        this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
    };
}(), THREE.SkinnedMesh = function(a, b, c) {
    if (THREE.Mesh.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", 
    this.bindMatrix = new THREE.Matrix4(), this.bindMatrixInverse = new THREE.Matrix4(), 
    a = [], this.geometry && void 0 !== this.geometry.bones) {
        for (var d, e, f, g, h = 0, i = this.geometry.bones.length; i > h; ++h) d = this.geometry.bones[h], 
        e = d.pos, f = d.rotq, g = d.scl, b = new THREE.Bone(this), a.push(b), b.name = d.name, 
        b.position.set(e[0], e[1], e[2]), b.quaternion.set(f[0], f[1], f[2], f[3]), void 0 !== g ? b.scale.set(g[0], g[1], g[2]) : b.scale.set(1, 1, 1);
        for (h = 0, i = this.geometry.bones.length; i > h; ++h) d = this.geometry.bones[h], 
        -1 !== d.parent ? a[d.parent].add(a[h]) : this.add(a[h]);
    }
    this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(a, void 0, c));
}, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh, 
THREE.SkinnedMesh.prototype.bind = function(a, b) {
    this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), b = this.matrixWorld), 
    this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b);
}, THREE.SkinnedMesh.prototype.pose = function() {
    this.skeleton.pose();
}, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
    if (this.geometry instanceof THREE.Geometry) for (var a = 0; a < this.geometry.skinIndices.length; a++) {
        var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
        1 / 0 !== c ? b.multiplyScalar(c) : b.set(1);
    }
}, THREE.SkinnedMesh.prototype.updateMatrixWorld = function(a) {
    THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : THREE.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode);
}, THREE.SkinnedMesh.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), 
    THREE.Mesh.prototype.clone.call(this, a), a;
}, THREE.MorphAnimMesh = function(a, b) {
    THREE.Mesh.call(this, a, b), this.type = "MorphAnimMesh", this.duration = 1e3, this.mirroredLoop = !1, 
    this.currentKeyframe = this.lastKeyframe = this.time = 0, this.direction = 1, this.directionBackwards = !1, 
    this.setFrameRange(0, this.geometry.morphTargets.length - 1);
}, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh, 
THREE.MorphAnimMesh.prototype.setFrameRange = function(a, b) {
    this.startKeyframe = a, this.endKeyframe = b, this.length = this.endKeyframe - this.startKeyframe + 1;
}, THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
    this.direction = 1, this.directionBackwards = !1;
}, THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
    this.direction = -1, this.directionBackwards = !0;
}, THREE.MorphAnimMesh.prototype.parseAnimations = function() {
    var a = this.geometry;
    a.animations || (a.animations = {});
    for (var b, c = a.animations, d = /([a-z]+)_?(\d+)/, e = 0, f = a.morphTargets.length; f > e; e++) {
        var g = a.morphTargets[e].name.match(d);
        if (g && 1 < g.length) {
            g = g[1], c[g] || (c[g] = {
                start: 1 / 0,
                end: -(1 / 0)
            });
            var h = c[g];
            e < h.start && (h.start = e), e > h.end && (h.end = e), b || (b = g);
        }
    }
    a.firstAnimation = b;
}, THREE.MorphAnimMesh.prototype.setAnimationLabel = function(a, b, c) {
    this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[a] = {
        start: b,
        end: c
    };
}, THREE.MorphAnimMesh.prototype.playAnimation = function(a, b) {
    var c = this.geometry.animations[a];
    c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1e3, 
    this.time = 0) : THREE.warn("THREE.MorphAnimMesh: animation[" + a + "] undefined in .playAnimation()");
}, THREE.MorphAnimMesh.prototype.updateAnimation = function(a) {
    var b = this.duration / this.length;
    this.time += this.direction * a, this.mirroredLoop ? (this.time > this.duration || 0 > this.time) && (this.direction *= -1, 
    this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 
    0 > this.time && (this.time = 0, this.directionBackwards = !1)) : (this.time %= this.duration, 
    0 > this.time && (this.time += this.duration)), a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1), 
    a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, 
    this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, 
    this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a), b = this.time % b / b, 
    this.directionBackwards && (b = 1 - b), this.morphTargetInfluences[this.currentKeyframe] = b, 
    this.morphTargetInfluences[this.lastKeyframe] = 1 - b;
}, THREE.MorphAnimMesh.prototype.interpolateTargets = function(a, b, c) {
    for (var d = this.morphTargetInfluences, e = 0, f = d.length; f > e; e++) d[e] = 0;
    a > -1 && (d[a] = 1 - c), b > -1 && (d[b] = c);
}, THREE.MorphAnimMesh.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material)), 
    a.duration = this.duration, a.mirroredLoop = this.mirroredLoop, a.time = this.time, 
    a.lastKeyframe = this.lastKeyframe, a.currentKeyframe = this.currentKeyframe, a.direction = this.direction, 
    a.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, a), 
    a;
}, THREE.LOD = function() {
    THREE.Object3D.call(this), this.objects = [];
}, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.constructor = THREE.LOD, 
THREE.LOD.prototype.addLevel = function(a, b) {
    void 0 === b && (b = 0), b = Math.abs(b);
    for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++) ;
    this.objects.splice(c, 0, {
        distance: b,
        object: a
    }), this.add(a);
}, THREE.LOD.prototype.getObjectForDistance = function(a) {
    for (var b = 1, c = this.objects.length; c > b && !(a < this.objects[b].distance); b++) ;
    return this.objects[b - 1].object;
}, THREE.LOD.prototype.raycast = function() {
    var a = new THREE.Vector3();
    return function(b, c) {
        a.setFromMatrixPosition(this.matrixWorld);
        var d = b.ray.origin.distanceTo(a);
        this.getObjectForDistance(d).raycast(b, c);
    };
}(), THREE.LOD.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function(c) {
        if (1 < this.objects.length) {
            a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld), 
            c = a.distanceTo(b), this.objects[0].object.visible = !0;
            for (var d = 1, e = this.objects.length; e > d && c >= this.objects[d].distance; d++) this.objects[d - 1].object.visible = !1, 
            this.objects[d].object.visible = !0;
            for (;e > d; d++) this.objects[d].object.visible = !1;
        }
    };
}(), THREE.LOD.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.LOD()), THREE.Object3D.prototype.clone.call(this, a);
    for (var b = 0, c = this.objects.length; c > b; b++) {
        var d = this.objects[b].object.clone();
        d.visible = 0 === b, a.addLevel(d, this.objects[b].distance);
    }
    return a;
}, THREE.Sprite = function() {
    var a = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]), b = new Float32Array([ -.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0 ]), c = new Float32Array([ 0, 0, 1, 0, 1, 1, 0, 1 ]), d = new THREE.BufferGeometry();
    return d.addAttribute("index", new THREE.BufferAttribute(a, 1)), d.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    d.addAttribute("uv", new THREE.BufferAttribute(c, 2)), function(a) {
        THREE.Object3D.call(this), this.type = "Sprite", this.geometry = d, this.material = void 0 !== a ? a : new THREE.SpriteMaterial();
    };
}(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.constructor = THREE.Sprite, 
THREE.Sprite.prototype.raycast = function() {
    var a = new THREE.Vector3();
    return function(b, c) {
        a.setFromMatrixPosition(this.matrixWorld);
        var d = b.ray.distanceToPoint(a);
        d > this.scale.x || c.push({
            distance: d,
            point: this.position,
            face: null,
            object: this
        });
    };
}(), THREE.Sprite.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, a), 
    a;
}, THREE.Particle = THREE.Sprite, THREE.LensFlare = function(a, b, c, d, e) {
    THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3(), 
    this.customUpdateCallback = void 0, void 0 !== a && this.add(a, b, c, d, e);
}, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.constructor = THREE.LensFlare, 
THREE.LensFlare.prototype.add = function(a, b, c, d, e, f) {
    void 0 === b && (b = -1), void 0 === c && (c = 0), void 0 === f && (f = 1), void 0 === e && (e = new THREE.Color(16777215)), 
    void 0 === d && (d = THREE.NormalBlending), c = Math.min(c, Math.max(0, c)), this.lensFlares.push({
        texture: a,
        size: b,
        distance: c,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 1,
        opacity: f,
        color: e,
        blending: d
    });
}, THREE.LensFlare.prototype.updateLensFlares = function() {
    var a, b, c = this.lensFlares.length, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
    for (a = 0; c > a; a++) b = this.lensFlares[a], b.x = this.positionScreen.x + d * b.distance, 
    b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, 
    b.rotation += .25 * (b.wantedRotation - b.rotation);
}, THREE.Scene = function() {
    THREE.Object3D.call(this), this.type = "Scene", this.overrideMaterial = this.fog = null, 
    this.autoUpdate = !0;
}, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.constructor = THREE.Scene, 
THREE.Scene.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Scene()), THREE.Object3D.prototype.clone.call(this, a), 
    null !== this.fog && (a.fog = this.fog.clone()), null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone()), 
    a.autoUpdate = this.autoUpdate, a.matrixAutoUpdate = this.matrixAutoUpdate, a;
}, THREE.Fog = function(a, b, c) {
    this.name = "", this.color = new THREE.Color(a), this.near = void 0 !== b ? b : 1, 
    this.far = void 0 !== c ? c : 1e3;
}, THREE.Fog.prototype.clone = function() {
    return new THREE.Fog(this.color.getHex(), this.near, this.far);
}, THREE.FogExp2 = function(a, b) {
    this.name = "", this.color = new THREE.Color(a), this.density = void 0 !== b ? b : 25e-5;
}, THREE.FogExp2.prototype.clone = function() {
    return new THREE.FogExp2(this.color.getHex(), this.density);
}, THREE.ShaderChunk = {}, THREE.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n	float distance = dot( planeNormal, point-pointOnPlane );\n	return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n	}\n	return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n	return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n	return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\n", 
THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n", 
THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n", 
THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n", 
THREE.ShaderChunk.default_vertex = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n", 
THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", 
THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif", 
THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif", 
THREE.ShaderChunk.lights_phong_fragment = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n			// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n", 
THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif", 
THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif", 
THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", 
THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n", 
THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n", 
THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif", 
THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif", 
THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif", 
THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif", 
THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif", 
THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n", 
THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n", 
THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n	vColor.xyz = inputToLinear( color.xyz );\n\n#endif", 
THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n", 
THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n", 
THREE.ShaderChunk.linear_to_gamma_fragment = "\n	outgoingLight = linearToOutput( outgoingLight );\n", 
THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", 
THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n", 
THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n", 
THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif", 
THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif", 
THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif", 
THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif", 
THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n		fogFactor = whiteCompliment( fogFactor );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif", 
THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n", 
THREE.ShaderChunk.defaultnormal_vertex = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n", 
THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n", 
THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", 
THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", 
THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n	outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif", 
THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", 
THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif", 
THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif", 
THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n	shadowColor = inputToLinear( shadowColor );\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n", 
THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif", 
THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif", 
THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", 
THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n", 
THREE.UniformsUtils = {
    merge: function(a) {
        for (var b = {}, c = 0; c < a.length; c++) {
            var d, e = this.clone(a[c]);
            for (d in e) b[d] = e[d];
        }
        return b;
    },
    clone: function(a) {
        var b, c = {};
        for (b in a) {
            c[b] = {};
            for (var d in a[b]) {
                var e = a[b][d];
                c[b][d] = e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? e.clone() : e instanceof Array ? e.slice() : e;
            }
        }
        return c;
    }
}, THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        lightMap: {
            type: "t",
            value: null
        },
        specularMap: {
            type: "t",
            value: null
        },
        alphaMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "f",
            value: -1
        },
        reflectivity: {
            type: "f",
            value: 1
        },
        refractionRatio: {
            type: "f",
            value: .98
        },
        morphTargetInfluences: {
            type: "f",
            value: 0
        }
    },
    bump: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1, 1)
        }
    },
    fog: {
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "fv",
            value: []
        },
        directionalLightDirection: {
            type: "fv",
            value: []
        },
        directionalLightColor: {
            type: "fv",
            value: []
        },
        hemisphereLightDirection: {
            type: "fv",
            value: []
        },
        hemisphereLightSkyColor: {
            type: "fv",
            value: []
        },
        hemisphereLightGroundColor: {
            type: "fv",
            value: []
        },
        pointLightColor: {
            type: "fv",
            value: []
        },
        pointLightPosition: {
            type: "fv",
            value: []
        },
        pointLightDistance: {
            type: "fv1",
            value: []
        },
        pointLightDecay: {
            type: "fv1",
            value: []
        },
        spotLightColor: {
            type: "fv",
            value: []
        },
        spotLightPosition: {
            type: "fv",
            value: []
        },
        spotLightDirection: {
            type: "fv",
            value: []
        },
        spotLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightAngleCos: {
            type: "fv1",
            value: []
        },
        spotLightExponent: {
            type: "fv1",
            value: []
        },
        spotLightDecay: {
            type: "fv1",
            value: []
        }
    },
    particle: {
        psColor: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        size: {
            type: "f",
            value: 1
        },
        scale: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    shadowmap: {
        shadowMap: {
            type: "tv",
            value: []
        },
        shadowMapSize: {
            type: "v2v",
            value: []
        },
        shadowBias: {
            type: "fv1",
            value: []
        },
        shadowDarkness: {
            type: "fv1",
            value: []
        },
        shadowMatrix: {
            type: "m4v",
            value: []
        }
    }
}, THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap ]),
        vertexShader: [ THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}" ].join("\n")
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        } ]),
        vertexShader: [ "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	#ifdef DOUBLE_SIDED\n		if ( gl_FrontFacing )\n			outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n		else\n			outgoingLight += diffuseColor.rgb * vLightBack + emissive;\n	#else\n		outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n	#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}" ].join("\n")
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        } ]),
        vertexShader: [ "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}" ].join("\n")
    },
    particle_basic: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap ]),
        vertexShader: [ "uniform float size;\nuniform float scale;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n	#else\n		gl_PointSize = size;\n	#endif\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphatest_fragment, "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}" ].join("\n")
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.fog, {
            scale: {
                type: "f",
                value: 1
            },
            dashSize: {
                type: "f",
                value: 1
            },
            totalSize: {
                type: "f",
                value: 2
            }
        } ]),
        vertexShader: [ "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}" ].join("\n")
    },
    depth: {
        uniforms: {
            mNear: {
                type: "f",
                value: 1
            },
            mFar: {
                type: "f",
                value: 2e3
            },
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: [ THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	float color = 1.0 - smoothstep( mNear, mFar, depth );\n	gl_FragColor = vec4( vec3( color ), opacity );\n}" ].join("\n")
    },
    normal: {
        uniforms: {
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: [ "varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}" ].join("\n")
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: [ "varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}" ].join("\n")
    },
    equirect: {
        uniforms: {
            tEquirect: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: [ "varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\nvec3 direction = normalize( vWorldPosition );\nvec2 sampleUV;\nsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\nsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\ngl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment, "}" ].join("\n")
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: [ THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nvoid main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n	#else\n		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n	#endif\n}" ].join("\n")
    }
}, THREE.WebGLRenderer = function(a) {
    function b(a) {
        var b = a.geometry;
        a = a.material;
        var c = b.vertices.length;
        if (a.attributes) {
            void 0 === b.__webglCustomAttributesList && (b.__webglCustomAttributesList = []);
            for (var d in a.attributes) {
                var e = a.attributes[d];
                if (!e.__webglInitialized || e.createUniqueBuffers) {
                    e.__webglInitialized = !0;
                    var f = 1;
                    "v2" === e.type ? f = 2 : "v3" === e.type ? f = 3 : "v4" === e.type ? f = 4 : "c" === e.type && (f = 3), 
                    e.size = f, e.array = new Float32Array(c * f), e.buffer = W.createBuffer(), e.buffer.belongsToAttribute = d, 
                    e.needsUpdate = !0;
                }
                b.__webglCustomAttributesList.push(e);
            }
        }
    }
    function c(a, b) {
        return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material;
    }
    function d(a, b, c, d) {
        c = c.attributes;
        var e = b.attributes;
        b = b.attributesKeys;
        for (var f = 0, g = b.length; g > f; f++) {
            var h = b[f], i = e[h];
            if (i >= 0) {
                var j = c[h];
                void 0 !== j ? (h = j.itemSize, W.bindBuffer(W.ARRAY_BUFFER, j.buffer), ra.enableAttribute(i), 
                W.vertexAttribPointer(i, h, W.FLOAT, !1, 0, d * h * 4)) : void 0 !== a.defaultAttributeValues && (2 === a.defaultAttributeValues[h].length ? W.vertexAttrib2fv(i, a.defaultAttributeValues[h]) : 3 === a.defaultAttributeValues[h].length && W.vertexAttrib3fv(i, a.defaultAttributeValues[h]));
            }
        }
        ra.disableUnusedAttributes();
    }
    function e(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
    }
    function f(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
    }
    function g(a, b) {
        return b[0] - a[0];
    }
    function h(a) {
        if (!1 !== a.visible) {
            if (!(a instanceof THREE.Scene || a instanceof THREE.Group)) {
                void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4(), 
                a._normalMatrix = new THREE.Matrix3(), a.addEventListener("removed", Ma));
                var c = a.geometry;
                if (void 0 !== c && void 0 === c.__webglInit) if (c.__webglInit = !0, c.addEventListener("dispose", Na), 
                c instanceof THREE.BufferGeometry) X.info.memory.geometries++; else if (a instanceof THREE.Mesh) l(a, c); else if (a instanceof THREE.Line) {
                    if (void 0 === c.__webglVertexBuffer) {
                        c.__webglVertexBuffer = W.createBuffer(), c.__webglColorBuffer = W.createBuffer(), 
                        c.__webglLineDistanceBuffer = W.createBuffer(), X.info.memory.geometries++;
                        var d = c.vertices.length;
                        c.__vertexArray = new Float32Array(3 * d), c.__colorArray = new Float32Array(3 * d), 
                        c.__lineDistanceArray = new Float32Array(1 * d), c.__webglLineCount = d, b(a), c.verticesNeedUpdate = !0, 
                        c.colorsNeedUpdate = !0, c.lineDistancesNeedUpdate = !0;
                    }
                } else a instanceof THREE.PointCloud && void 0 === c.__webglVertexBuffer && (c.__webglVertexBuffer = W.createBuffer(), 
                c.__webglColorBuffer = W.createBuffer(), X.info.memory.geometries++, d = c.vertices.length, 
                c.__vertexArray = new Float32Array(3 * d), c.__colorArray = new Float32Array(3 * d), 
                c.__webglParticleCount = d, b(a), c.verticesNeedUpdate = !0, c.colorsNeedUpdate = !0);
                if (void 0 === a.__webglActive) if (a.__webglActive = !0, a instanceof THREE.Mesh) {
                    if (c instanceof THREE.BufferGeometry) m(Q, c, a); else if (c instanceof THREE.Geometry) for (var c = Ta[c.id], d = 0, e = c.length; e > d; d++) m(Q, c[d], a);
                } else a instanceof THREE.Line || a instanceof THREE.PointCloud ? m(Q, c, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && R.push({
                    id: null,
                    object: a,
                    opaque: null,
                    transparent: null,
                    z: 0
                });
                if (a instanceof THREE.Light) P.push(a); else if (a instanceof THREE.Sprite) U.push(a); else if (a instanceof THREE.LensFlare) V.push(a); else if ((c = Q[a.id]) && (!1 === a.frustumCulled || !0 === ja.intersectsObject(a))) for (d = 0, 
                e = c.length; e > d; d++) {
                    var f = c[d], g = f, i = g.object, j = g.buffer, k = i.geometry, i = i.material;
                    i instanceof THREE.MeshFaceMaterial ? (i = i.materials[k instanceof THREE.BufferGeometry ? 0 : j.materialIndex], 
                    g.material = i, i.transparent ? T.push(g) : S.push(g)) : i && (g.material = i, i.transparent ? T.push(g) : S.push(g)), 
                    f.render = !0, !0 === X.sortObjects && (la.setFromMatrixPosition(a.matrixWorld), 
                    la.applyProjection(ka), f.z = la.z);
                }
            }
            for (d = 0, e = a.children.length; e > d; d++) h(a.children[d]);
        }
    }
    function i(a, b, c, d, e) {
        for (var f, g = 0, h = a.length; h > g; g++) {
            f = a[g];
            var i = f.object, j = f.buffer;
            if (u(i, b), e) f = e; else {
                if (f = f.material, !f) continue;
                q(f);
            }
            X.setMaterialFaces(f), j instanceof THREE.BufferGeometry ? X.renderBufferDirect(b, c, d, f, j, i) : X.renderBuffer(b, c, d, f, j, i);
        }
    }
    function j(a, b, c, d, e, f) {
        for (var g, h = 0, i = a.length; i > h; h++) {
            g = a[h];
            var j = g.object;
            if (j.visible) {
                if (f) g = f; else {
                    if (g = g[b], !g) continue;
                    q(g);
                }
                X.renderImmediateObject(c, d, e, g, j);
            }
        }
    }
    function k(a) {
        var b = a.object.material;
        b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null);
    }
    function l(a, b) {
        var d = a.material, e = !1;
        if (void 0 === Ta[b.id] || !0 === b.groupsNeedUpdate) {
            delete Q[a.id];
            for (var f, g, h = Ta, i = b.id, d = d instanceof THREE.MeshFaceMaterial, j = sa.get("OES_element_index_uint") ? 4294967296 : 65535, e = {}, k = b.morphTargets.length, l = b.morphNormals.length, n = {}, o = [], p = 0, q = b.faces.length; q > p; p++) {
                f = b.faces[p];
                var r = d ? f.materialIndex : 0;
                r in e || (e[r] = {
                    hash: r,
                    counter: 0
                }), f = e[r].hash + "_" + e[r].counter, f in n || (g = {
                    id: Ua++,
                    faces3: [],
                    materialIndex: r,
                    vertices: 0,
                    numMorphTargets: k,
                    numMorphNormals: l
                }, n[f] = g, o.push(g)), n[f].vertices + 3 > j && (e[r].counter += 1, f = e[r].hash + "_" + e[r].counter, 
                f in n || (g = {
                    id: Ua++,
                    faces3: [],
                    materialIndex: r,
                    vertices: 0,
                    numMorphTargets: k,
                    numMorphNormals: l
                }, n[f] = g, o.push(g))), n[f].faces3.push(p), n[f].vertices += 3;
            }
            h[i] = o, b.groupsNeedUpdate = !1;
        }
        for (h = Ta[b.id], i = 0, d = h.length; d > i; i++) {
            if (j = h[i], void 0 === j.__webglVertexBuffer) {
                if (e = j, e.__webglVertexBuffer = W.createBuffer(), e.__webglNormalBuffer = W.createBuffer(), 
                e.__webglTangentBuffer = W.createBuffer(), e.__webglColorBuffer = W.createBuffer(), 
                e.__webglUVBuffer = W.createBuffer(), e.__webglUV2Buffer = W.createBuffer(), e.__webglSkinIndicesBuffer = W.createBuffer(), 
                e.__webglSkinWeightsBuffer = W.createBuffer(), e.__webglFaceBuffer = W.createBuffer(), 
                e.__webglLineBuffer = W.createBuffer(), l = e.numMorphTargets) for (e.__webglMorphTargetsBuffers = [], 
                k = 0; l > k; k++) e.__webglMorphTargetsBuffers.push(W.createBuffer());
                if (l = e.numMorphNormals) for (e.__webglMorphNormalsBuffers = [], k = 0; l > k; k++) e.__webglMorphNormalsBuffers.push(W.createBuffer());
                if (X.info.memory.geometries++, e = j, p = a, q = p.geometry, l = e.faces3, k = 3 * l.length, 
                n = 1 * l.length, o = 3 * l.length, l = c(p, e), e.__vertexArray = new Float32Array(3 * k), 
                e.__normalArray = new Float32Array(3 * k), e.__colorArray = new Float32Array(3 * k), 
                e.__uvArray = new Float32Array(2 * k), 1 < q.faceVertexUvs.length && (e.__uv2Array = new Float32Array(2 * k)), 
                q.hasTangents && (e.__tangentArray = new Float32Array(4 * k)), p.geometry.skinWeights.length && p.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * k), 
                e.__skinWeightArray = new Float32Array(4 * k)), p = null !== sa.get("OES_element_index_uint") && n > 21845 ? Uint32Array : Uint16Array, 
                e.__typeArray = p, e.__faceArray = new p(3 * n), e.__lineArray = new p(2 * o), q = e.numMorphTargets) for (e.__morphTargetsArrays = [], 
                p = 0; q > p; p++) e.__morphTargetsArrays.push(new Float32Array(3 * k));
                if (q = e.numMorphNormals) for (e.__morphNormalsArrays = [], p = 0; q > p; p++) e.__morphNormalsArrays.push(new Float32Array(3 * k));
                if (e.__webglFaceCount = 3 * n, e.__webglLineCount = 2 * o, l.attributes) for (n in void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []), 
                n = void 0, l.attributes) {
                    var s, o = l.attributes[n], p = {};
                    for (s in o) p[s] = o[s];
                    (!p.__webglInitialized || p.createUniqueBuffers) && (p.__webglInitialized = !0, 
                    q = 1, "v2" === p.type ? q = 2 : "v3" === p.type ? q = 3 : "v4" === p.type ? q = 4 : "c" === p.type && (q = 3), 
                    p.size = q, p.array = new Float32Array(k * q), p.buffer = W.createBuffer(), p.buffer.belongsToAttribute = n, 
                    o.needsUpdate = !0, p.__original = o), e.__webglCustomAttributesList.push(p);
                }
                e.__inittedArrays = !0, b.verticesNeedUpdate = !0, b.morphTargetsNeedUpdate = !0, 
                b.elementsNeedUpdate = !0, b.uvsNeedUpdate = !0, b.normalsNeedUpdate = !0, b.tangentsNeedUpdate = !0, 
                e = b.colorsNeedUpdate = !0;
            } else e = !1;
            (e || void 0 === a.__webglActive) && m(Q, j, a);
        }
        a.__webglActive = !0;
    }
    function m(a, b, c) {
        var d = c.id;
        a[d] = a[d] || [], a[d].push({
            id: d,
            buffer: b,
            object: c,
            material: null,
            z: 0
        });
    }
    function n(a) {
        var b = a.geometry;
        if (b instanceof THREE.BufferGeometry) for (var d = b.attributes, e = b.attributesKeys, f = 0, g = e.length; g > f; f++) {
            var h = e[f], i = d[h], j = "index" === h ? W.ELEMENT_ARRAY_BUFFER : W.ARRAY_BUFFER;
            void 0 === i.buffer ? (i.buffer = W.createBuffer(), W.bindBuffer(j, i.buffer), W.bufferData(j, i.array, i instanceof THREE.DynamicBufferAttribute ? W.DYNAMIC_DRAW : W.STATIC_DRAW), 
            i.needsUpdate = !1) : !0 === i.needsUpdate && (W.bindBuffer(j, i.buffer), void 0 === i.updateRange || -1 === i.updateRange.count ? W.bufferSubData(j, 0, i.array) : 0 === i.updateRange.count ? console.error("THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.") : (W.bufferSubData(j, i.updateRange.offset * i.array.BYTES_PER_ELEMENT, i.array.subarray(i.updateRange.offset, i.updateRange.offset + i.updateRange.count)), 
            i.updateRange.count = 0), i.needsUpdate = !1);
        } else if (a instanceof THREE.Mesh) {
            !0 === b.groupsNeedUpdate && l(a, b);
            for (var k = Ta[b.id], f = 0, m = k.length; m > f; f++) {
                var n = k[f], q = c(a, n), r = q.attributes && o(q);
                if (b.verticesNeedUpdate || b.morphTargetsNeedUpdate || b.elementsNeedUpdate || b.uvsNeedUpdate || b.normalsNeedUpdate || b.colorsNeedUpdate || b.tangentsNeedUpdate || r) {
                    var s = n, t = a, u = W.DYNAMIC_DRAW, v = !b.dynamic, w = q;
                    if (s.__inittedArrays) {
                        var x = !1 == w instanceof THREE.MeshPhongMaterial && w.shading === THREE.FlatShading, y = void 0, z = void 0, A = void 0, B = void 0, C = void 0, D = void 0, E = void 0, F = void 0, G = void 0, H = void 0, I = void 0, J = void 0, K = void 0, L = void 0, M = void 0, N = void 0, O = void 0, P = void 0, Q = void 0, R = void 0, S = void 0, T = void 0, U = void 0, V = void 0, X = void 0, Y = void 0, Z = void 0, $ = void 0, _ = void 0, aa = void 0, ba = void 0, ca = void 0, da = void 0, ea = void 0, fa = void 0, ga = void 0, ha = void 0, ia = void 0, ja = void 0, ka = void 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = void 0, ya = s.__vertexArray, za = s.__uvArray, Aa = s.__uv2Array, Ba = s.__normalArray, Ca = s.__tangentArray, Da = s.__colorArray, Ea = s.__skinIndexArray, Fa = s.__skinWeightArray, Ga = s.__morphTargetsArrays, Ha = s.__morphNormalsArrays, Ia = s.__webglCustomAttributesList, Ja = void 0, Ka = s.__faceArray, La = s.__lineArray, Ma = t.geometry, Na = Ma.elementsNeedUpdate, Oa = Ma.uvsNeedUpdate, Pa = Ma.normalsNeedUpdate, Qa = Ma.tangentsNeedUpdate, Ra = Ma.colorsNeedUpdate, Sa = Ma.morphTargetsNeedUpdate, Ua = Ma.vertices, Va = s.faces3, Wa = Ma.faces, Xa = Ma.faceVertexUvs[0], Ya = Ma.faceVertexUvs[1], Za = Ma.skinIndices, $a = Ma.skinWeights, _a = Ma.morphTargets, ab = Ma.morphNormals;
                        if (Ma.verticesNeedUpdate) {
                            for (y = 0, z = Va.length; z > y; y++) B = Wa[Va[y]], J = Ua[B.a], K = Ua[B.b], 
                            L = Ua[B.c], ya[ma] = J.x, ya[ma + 1] = J.y, ya[ma + 2] = J.z, ya[ma + 3] = K.x, 
                            ya[ma + 4] = K.y, ya[ma + 5] = K.z, ya[ma + 6] = L.x, ya[ma + 7] = L.y, ya[ma + 8] = L.z, 
                            ma += 9;
                            W.bindBuffer(W.ARRAY_BUFFER, s.__webglVertexBuffer), W.bufferData(W.ARRAY_BUFFER, ya, u);
                        }
                        if (Sa) for (fa = 0, ga = _a.length; ga > fa; fa++) {
                            for (y = va = 0, z = Va.length; z > y; y++) ja = Va[y], B = Wa[ja], J = _a[fa].vertices[B.a], 
                            K = _a[fa].vertices[B.b], L = _a[fa].vertices[B.c], ha = Ga[fa], ha[va] = J.x, ha[va + 1] = J.y, 
                            ha[va + 2] = J.z, ha[va + 3] = K.x, ha[va + 4] = K.y, ha[va + 5] = K.z, ha[va + 6] = L.x, 
                            ha[va + 7] = L.y, ha[va + 8] = L.z, w.morphNormals && (x ? R = Q = P = ab[fa].faceNormals[ja] : (ka = ab[fa].vertexNormals[ja], 
                            P = ka.a, Q = ka.b, R = ka.c), ia = Ha[fa], ia[va] = P.x, ia[va + 1] = P.y, ia[va + 2] = P.z, 
                            ia[va + 3] = Q.x, ia[va + 4] = Q.y, ia[va + 5] = Q.z, ia[va + 6] = R.x, ia[va + 7] = R.y, 
                            ia[va + 8] = R.z), va += 9;
                            W.bindBuffer(W.ARRAY_BUFFER, s.__webglMorphTargetsBuffers[fa]), W.bufferData(W.ARRAY_BUFFER, Ga[fa], u), 
                            w.morphNormals && (W.bindBuffer(W.ARRAY_BUFFER, s.__webglMorphNormalsBuffers[fa]), 
                            W.bufferData(W.ARRAY_BUFFER, Ha[fa], u));
                        }
                        if ($a.length) {
                            for (y = 0, z = Va.length; z > y; y++) B = Wa[Va[y]], V = $a[B.a], X = $a[B.b], 
                            Y = $a[B.c], Fa[ua] = V.x, Fa[ua + 1] = V.y, Fa[ua + 2] = V.z, Fa[ua + 3] = V.w, 
                            Fa[ua + 4] = X.x, Fa[ua + 5] = X.y, Fa[ua + 6] = X.z, Fa[ua + 7] = X.w, Fa[ua + 8] = Y.x, 
                            Fa[ua + 9] = Y.y, Fa[ua + 10] = Y.z, Fa[ua + 11] = Y.w, Z = Za[B.a], $ = Za[B.b], 
                            _ = Za[B.c], Ea[ua] = Z.x, Ea[ua + 1] = Z.y, Ea[ua + 2] = Z.z, Ea[ua + 3] = Z.w, 
                            Ea[ua + 4] = $.x, Ea[ua + 5] = $.y, Ea[ua + 6] = $.z, Ea[ua + 7] = $.w, Ea[ua + 8] = _.x, 
                            Ea[ua + 9] = _.y, Ea[ua + 10] = _.z, Ea[ua + 11] = _.w, ua += 12;
                            ua > 0 && (W.bindBuffer(W.ARRAY_BUFFER, s.__webglSkinIndicesBuffer), W.bufferData(W.ARRAY_BUFFER, Ea, u), 
                            W.bindBuffer(W.ARRAY_BUFFER, s.__webglSkinWeightsBuffer), W.bufferData(W.ARRAY_BUFFER, Fa, u));
                        }
                        if (Ra) {
                            for (y = 0, z = Va.length; z > y; y++) B = Wa[Va[y]], E = B.vertexColors, F = B.color, 
                            3 === E.length && w.vertexColors === THREE.VertexColors ? (S = E[0], T = E[1], U = E[2]) : U = T = S = F, 
                            Da[ta] = S.r, Da[ta + 1] = S.g, Da[ta + 2] = S.b, Da[ta + 3] = T.r, Da[ta + 4] = T.g, 
                            Da[ta + 5] = T.b, Da[ta + 6] = U.r, Da[ta + 7] = U.g, Da[ta + 8] = U.b, ta += 9;
                            ta > 0 && (W.bindBuffer(W.ARRAY_BUFFER, s.__webglColorBuffer), W.bufferData(W.ARRAY_BUFFER, Da, u));
                        }
                        if (Qa && Ma.hasTangents) {
                            for (y = 0, z = Va.length; z > y; y++) B = Wa[Va[y]], G = B.vertexTangents, M = G[0], 
                            N = G[1], O = G[2], Ca[ra] = M.x, Ca[ra + 1] = M.y, Ca[ra + 2] = M.z, Ca[ra + 3] = M.w, 
                            Ca[ra + 4] = N.x, Ca[ra + 5] = N.y, Ca[ra + 6] = N.z, Ca[ra + 7] = N.w, Ca[ra + 8] = O.x, 
                            Ca[ra + 9] = O.y, Ca[ra + 10] = O.z, Ca[ra + 11] = O.w, ra += 12;
                            W.bindBuffer(W.ARRAY_BUFFER, s.__webglTangentBuffer), W.bufferData(W.ARRAY_BUFFER, Ca, u);
                        }
                        if (Pa) {
                            for (y = 0, z = Va.length; z > y; y++) if (B = Wa[Va[y]], C = B.vertexNormals, D = B.normal, 
                            3 === C.length && !1 === x) for (aa = 0; 3 > aa; aa++) ca = C[aa], Ba[qa] = ca.x, 
                            Ba[qa + 1] = ca.y, Ba[qa + 2] = ca.z, qa += 3; else for (aa = 0; 3 > aa; aa++) Ba[qa] = D.x, 
                            Ba[qa + 1] = D.y, Ba[qa + 2] = D.z, qa += 3;
                            W.bindBuffer(W.ARRAY_BUFFER, s.__webglNormalBuffer), W.bufferData(W.ARRAY_BUFFER, Ba, u);
                        }
                        if (Oa && Xa) {
                            for (y = 0, z = Va.length; z > y; y++) if (A = Va[y], H = Xa[A], void 0 !== H) for (aa = 0; 3 > aa; aa++) da = H[aa], 
                            za[na] = da.x, za[na + 1] = da.y, na += 2;
                            na > 0 && (W.bindBuffer(W.ARRAY_BUFFER, s.__webglUVBuffer), W.bufferData(W.ARRAY_BUFFER, za, u));
                        }
                        if (Oa && Ya) {
                            for (y = 0, z = Va.length; z > y; y++) if (A = Va[y], I = Ya[A], void 0 !== I) for (aa = 0; 3 > aa; aa++) ea = I[aa], 
                            Aa[oa] = ea.x, Aa[oa + 1] = ea.y, oa += 2;
                            oa > 0 && (W.bindBuffer(W.ARRAY_BUFFER, s.__webglUV2Buffer), W.bufferData(W.ARRAY_BUFFER, Aa, u));
                        }
                        if (Na) {
                            for (y = 0, z = Va.length; z > y; y++) Ka[pa] = la, Ka[pa + 1] = la + 1, Ka[pa + 2] = la + 2, 
                            pa += 3, La[sa] = la, La[sa + 1] = la + 1, La[sa + 2] = la, La[sa + 3] = la + 2, 
                            La[sa + 4] = la + 1, La[sa + 5] = la + 2, sa += 6, la += 3;
                            W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, s.__webglFaceBuffer), W.bufferData(W.ELEMENT_ARRAY_BUFFER, Ka, u), 
                            W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, s.__webglLineBuffer), W.bufferData(W.ELEMENT_ARRAY_BUFFER, La, u);
                        }
                        if (Ia) for (aa = 0, ba = Ia.length; ba > aa; aa++) if (Ja = Ia[aa], Ja.__original.needsUpdate) {
                            if (wa = 0, 1 === Ja.size) {
                                if (void 0 === Ja.boundTo || "vertices" === Ja.boundTo) for (y = 0, z = Va.length; z > y; y++) B = Wa[Va[y]], 
                                Ja.array[wa] = Ja.value[B.a], Ja.array[wa + 1] = Ja.value[B.b], Ja.array[wa + 2] = Ja.value[B.c], 
                                wa += 3; else if ("faces" === Ja.boundTo) for (y = 0, z = Va.length; z > y; y++) xa = Ja.value[Va[y]], 
                                Ja.array[wa] = xa, Ja.array[wa + 1] = xa, Ja.array[wa + 2] = xa, wa += 3;
                            } else if (2 === Ja.size) {
                                if (void 0 === Ja.boundTo || "vertices" === Ja.boundTo) for (y = 0, z = Va.length; z > y; y++) B = Wa[Va[y]], 
                                J = Ja.value[B.a], K = Ja.value[B.b], L = Ja.value[B.c], Ja.array[wa] = J.x, Ja.array[wa + 1] = J.y, 
                                Ja.array[wa + 2] = K.x, Ja.array[wa + 3] = K.y, Ja.array[wa + 4] = L.x, Ja.array[wa + 5] = L.y, 
                                wa += 6; else if ("faces" === Ja.boundTo) for (y = 0, z = Va.length; z > y; y++) L = K = J = xa = Ja.value[Va[y]], 
                                Ja.array[wa] = J.x, Ja.array[wa + 1] = J.y, Ja.array[wa + 2] = K.x, Ja.array[wa + 3] = K.y, 
                                Ja.array[wa + 4] = L.x, Ja.array[wa + 5] = L.y, wa += 6;
                            } else if (3 === Ja.size) {
                                var bb;
                                if (bb = "c" === Ja.type ? [ "r", "g", "b" ] : [ "x", "y", "z" ], void 0 === Ja.boundTo || "vertices" === Ja.boundTo) for (y = 0, 
                                z = Va.length; z > y; y++) B = Wa[Va[y]], J = Ja.value[B.a], K = Ja.value[B.b], 
                                L = Ja.value[B.c], Ja.array[wa] = J[bb[0]], Ja.array[wa + 1] = J[bb[1]], Ja.array[wa + 2] = J[bb[2]], 
                                Ja.array[wa + 3] = K[bb[0]], Ja.array[wa + 4] = K[bb[1]], Ja.array[wa + 5] = K[bb[2]], 
                                Ja.array[wa + 6] = L[bb[0]], Ja.array[wa + 7] = L[bb[1]], Ja.array[wa + 8] = L[bb[2]], 
                                wa += 9; else if ("faces" === Ja.boundTo) for (y = 0, z = Va.length; z > y; y++) L = K = J = xa = Ja.value[Va[y]], 
                                Ja.array[wa] = J[bb[0]], Ja.array[wa + 1] = J[bb[1]], Ja.array[wa + 2] = J[bb[2]], 
                                Ja.array[wa + 3] = K[bb[0]], Ja.array[wa + 4] = K[bb[1]], Ja.array[wa + 5] = K[bb[2]], 
                                Ja.array[wa + 6] = L[bb[0]], Ja.array[wa + 7] = L[bb[1]], Ja.array[wa + 8] = L[bb[2]], 
                                wa += 9; else if ("faceVertices" === Ja.boundTo) for (y = 0, z = Va.length; z > y; y++) xa = Ja.value[Va[y]], 
                                J = xa[0], K = xa[1], L = xa[2], Ja.array[wa] = J[bb[0]], Ja.array[wa + 1] = J[bb[1]], 
                                Ja.array[wa + 2] = J[bb[2]], Ja.array[wa + 3] = K[bb[0]], Ja.array[wa + 4] = K[bb[1]], 
                                Ja.array[wa + 5] = K[bb[2]], Ja.array[wa + 6] = L[bb[0]], Ja.array[wa + 7] = L[bb[1]], 
                                Ja.array[wa + 8] = L[bb[2]], wa += 9;
                            } else if (4 === Ja.size) if (void 0 === Ja.boundTo || "vertices" === Ja.boundTo) for (y = 0, 
                            z = Va.length; z > y; y++) B = Wa[Va[y]], J = Ja.value[B.a], K = Ja.value[B.b], 
                            L = Ja.value[B.c], Ja.array[wa] = J.x, Ja.array[wa + 1] = J.y, Ja.array[wa + 2] = J.z, 
                            Ja.array[wa + 3] = J.w, Ja.array[wa + 4] = K.x, Ja.array[wa + 5] = K.y, Ja.array[wa + 6] = K.z, 
                            Ja.array[wa + 7] = K.w, Ja.array[wa + 8] = L.x, Ja.array[wa + 9] = L.y, Ja.array[wa + 10] = L.z, 
                            Ja.array[wa + 11] = L.w, wa += 12; else if ("faces" === Ja.boundTo) for (y = 0, 
                            z = Va.length; z > y; y++) L = K = J = xa = Ja.value[Va[y]], Ja.array[wa] = J.x, 
                            Ja.array[wa + 1] = J.y, Ja.array[wa + 2] = J.z, Ja.array[wa + 3] = J.w, Ja.array[wa + 4] = K.x, 
                            Ja.array[wa + 5] = K.y, Ja.array[wa + 6] = K.z, Ja.array[wa + 7] = K.w, Ja.array[wa + 8] = L.x, 
                            Ja.array[wa + 9] = L.y, Ja.array[wa + 10] = L.z, Ja.array[wa + 11] = L.w, wa += 12; else if ("faceVertices" === Ja.boundTo) for (y = 0, 
                            z = Va.length; z > y; y++) xa = Ja.value[Va[y]], J = xa[0], K = xa[1], L = xa[2], 
                            Ja.array[wa] = J.x, Ja.array[wa + 1] = J.y, Ja.array[wa + 2] = J.z, Ja.array[wa + 3] = J.w, 
                            Ja.array[wa + 4] = K.x, Ja.array[wa + 5] = K.y, Ja.array[wa + 6] = K.z, Ja.array[wa + 7] = K.w, 
                            Ja.array[wa + 8] = L.x, Ja.array[wa + 9] = L.y, Ja.array[wa + 10] = L.z, Ja.array[wa + 11] = L.w, 
                            wa += 12;
                            W.bindBuffer(W.ARRAY_BUFFER, Ja.buffer), W.bufferData(W.ARRAY_BUFFER, Ja.array, u);
                        }
                        v && (delete s.__inittedArrays, delete s.__colorArray, delete s.__normalArray, delete s.__tangentArray, 
                        delete s.__uvArray, delete s.__uv2Array, delete s.__faceArray, delete s.__vertexArray, 
                        delete s.__lineArray, delete s.__skinIndexArray, delete s.__skinWeightArray);
                    }
                }
            }
            b.verticesNeedUpdate = !1, b.morphTargetsNeedUpdate = !1, b.elementsNeedUpdate = !1, 
            b.uvsNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.tangentsNeedUpdate = !1, 
            q.attributes && p(q);
        } else if (a instanceof THREE.Line) {
            if (q = c(a, b), r = q.attributes && o(q), b.verticesNeedUpdate || b.colorsNeedUpdate || b.lineDistancesNeedUpdate || r) {
                var cb, db, eb, fb, gb, hb, ib, jb, kb, lb, mb, nb, ob = W.DYNAMIC_DRAW, pb = b.vertices, qb = b.colors, rb = b.lineDistances, sb = pb.length, tb = qb.length, ub = rb.length, vb = b.__vertexArray, wb = b.__colorArray, xb = b.__lineDistanceArray, yb = b.colorsNeedUpdate, zb = b.lineDistancesNeedUpdate, Ab = b.__webglCustomAttributesList;
                if (b.verticesNeedUpdate) {
                    for (cb = 0; sb > cb; cb++) fb = pb[cb], gb = 3 * cb, vb[gb] = fb.x, vb[gb + 1] = fb.y, 
                    vb[gb + 2] = fb.z;
                    W.bindBuffer(W.ARRAY_BUFFER, b.__webglVertexBuffer), W.bufferData(W.ARRAY_BUFFER, vb, ob);
                }
                if (yb) {
                    for (db = 0; tb > db; db++) hb = qb[db], gb = 3 * db, wb[gb] = hb.r, wb[gb + 1] = hb.g, 
                    wb[gb + 2] = hb.b;
                    W.bindBuffer(W.ARRAY_BUFFER, b.__webglColorBuffer), W.bufferData(W.ARRAY_BUFFER, wb, ob);
                }
                if (zb) {
                    for (eb = 0; ub > eb; eb++) xb[eb] = rb[eb];
                    W.bindBuffer(W.ARRAY_BUFFER, b.__webglLineDistanceBuffer), W.bufferData(W.ARRAY_BUFFER, xb, ob);
                }
                if (Ab) for (ib = 0, jb = Ab.length; jb > ib; ib++) if (nb = Ab[ib], nb.needsUpdate && (void 0 === nb.boundTo || "vertices" === nb.boundTo)) {
                    if (gb = 0, lb = nb.value.length, 1 === nb.size) for (kb = 0; lb > kb; kb++) nb.array[kb] = nb.value[kb]; else if (2 === nb.size) for (kb = 0; lb > kb; kb++) mb = nb.value[kb], 
                    nb.array[gb] = mb.x, nb.array[gb + 1] = mb.y, gb += 2; else if (3 === nb.size) if ("c" === nb.type) for (kb = 0; lb > kb; kb++) mb = nb.value[kb], 
                    nb.array[gb] = mb.r, nb.array[gb + 1] = mb.g, nb.array[gb + 2] = mb.b, gb += 3; else for (kb = 0; lb > kb; kb++) mb = nb.value[kb], 
                    nb.array[gb] = mb.x, nb.array[gb + 1] = mb.y, nb.array[gb + 2] = mb.z, gb += 3; else if (4 === nb.size) for (kb = 0; lb > kb; kb++) mb = nb.value[kb], 
                    nb.array[gb] = mb.x, nb.array[gb + 1] = mb.y, nb.array[gb + 2] = mb.z, nb.array[gb + 3] = mb.w, 
                    gb += 4;
                    W.bindBuffer(W.ARRAY_BUFFER, nb.buffer), W.bufferData(W.ARRAY_BUFFER, nb.array, ob), 
                    nb.needsUpdate = !1;
                }
            }
            b.verticesNeedUpdate = !1, b.colorsNeedUpdate = !1, b.lineDistancesNeedUpdate = !1, 
            q.attributes && p(q);
        } else if (a instanceof THREE.PointCloud) {
            if (q = c(a, b), r = q.attributes && o(q), b.verticesNeedUpdate || b.colorsNeedUpdate || r) {
                var Bb, Cb, Db, Eb, Fb, Gb, Hb, Ib, Jb, Kb, Lb, Mb = W.DYNAMIC_DRAW, Nb = b.vertices, Ob = Nb.length, Pb = b.colors, Qb = Pb.length, Rb = b.__vertexArray, Sb = b.__colorArray, Tb = b.colorsNeedUpdate, Ub = b.__webglCustomAttributesList;
                if (b.verticesNeedUpdate) {
                    for (Bb = 0; Ob > Bb; Bb++) Db = Nb[Bb], Eb = 3 * Bb, Rb[Eb] = Db.x, Rb[Eb + 1] = Db.y, 
                    Rb[Eb + 2] = Db.z;
                    W.bindBuffer(W.ARRAY_BUFFER, b.__webglVertexBuffer), W.bufferData(W.ARRAY_BUFFER, Rb, Mb);
                }
                if (Tb) {
                    for (Cb = 0; Qb > Cb; Cb++) Fb = Pb[Cb], Eb = 3 * Cb, Sb[Eb] = Fb.r, Sb[Eb + 1] = Fb.g, 
                    Sb[Eb + 2] = Fb.b;
                    W.bindBuffer(W.ARRAY_BUFFER, b.__webglColorBuffer), W.bufferData(W.ARRAY_BUFFER, Sb, Mb);
                }
                if (Ub) for (Gb = 0, Hb = Ub.length; Hb > Gb; Gb++) {
                    if (Lb = Ub[Gb], Lb.needsUpdate && (void 0 === Lb.boundTo || "vertices" === Lb.boundTo)) if (Jb = Lb.value.length, 
                    Eb = 0, 1 === Lb.size) for (Ib = 0; Jb > Ib; Ib++) Lb.array[Ib] = Lb.value[Ib]; else if (2 === Lb.size) for (Ib = 0; Jb > Ib; Ib++) Kb = Lb.value[Ib], 
                    Lb.array[Eb] = Kb.x, Lb.array[Eb + 1] = Kb.y, Eb += 2; else if (3 === Lb.size) if ("c" === Lb.type) for (Ib = 0; Jb > Ib; Ib++) Kb = Lb.value[Ib], 
                    Lb.array[Eb] = Kb.r, Lb.array[Eb + 1] = Kb.g, Lb.array[Eb + 2] = Kb.b, Eb += 3; else for (Ib = 0; Jb > Ib; Ib++) Kb = Lb.value[Ib], 
                    Lb.array[Eb] = Kb.x, Lb.array[Eb + 1] = Kb.y, Lb.array[Eb + 2] = Kb.z, Eb += 3; else if (4 === Lb.size) for (Ib = 0; Jb > Ib; Ib++) Kb = Lb.value[Ib], 
                    Lb.array[Eb] = Kb.x, Lb.array[Eb + 1] = Kb.y, Lb.array[Eb + 2] = Kb.z, Lb.array[Eb + 3] = Kb.w, 
                    Eb += 4;
                    W.bindBuffer(W.ARRAY_BUFFER, Lb.buffer), W.bufferData(W.ARRAY_BUFFER, Lb.array, Mb), 
                    Lb.needsUpdate = !1;
                }
            }
            b.verticesNeedUpdate = !1, b.colorsNeedUpdate = !1, q.attributes && p(q);
        }
    }
    function o(a) {
        for (var b in a.attributes) if (a.attributes[b].needsUpdate) return !0;
        return !1;
    }
    function p(a) {
        for (var b in a.attributes) a.attributes[b].needsUpdate = !1;
    }
    function q(a) {
        !0 === a.transparent ? ra.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha) : ra.setBlending(THREE.NoBlending), 
        ra.setDepthTest(a.depthTest), ra.setDepthWrite(a.depthWrite), ra.setColorWrite(a.colorWrite), 
        ra.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits);
    }
    function r(a, b, c, d, e) {
        var f, g, h, i;
        if (ca = 0, d.needsUpdate) {
            d.program && Sa(d), d.addEventListener("dispose", Qa);
            var j = Va[d.type];
            if (j) {
                var k = THREE.ShaderLib[j];
                d.__webglShader = {
                    uniforms: THREE.UniformsUtils.clone(k.uniforms),
                    vertexShader: k.vertexShader,
                    fragmentShader: k.fragmentShader
                };
            } else d.__webglShader = {
                uniforms: d.uniforms,
                vertexShader: d.vertexShader,
                fragmentShader: d.fragmentShader
            };
            for (var l = 0, m = 0, n = 0, o = 0, p = 0, q = b.length; q > p; p++) {
                var r = b[p];
                r.onlyShadow || !1 === r.visible || (r instanceof THREE.DirectionalLight && l++, 
                r instanceof THREE.PointLight && m++, r instanceof THREE.SpotLight && n++, r instanceof THREE.HemisphereLight && o++);
            }
            f = l, g = m, h = n, i = o;
            for (var u, y = 0, z = 0, A = b.length; A > z; z++) {
                var D = b[z];
                D.castShadow && (D instanceof THREE.SpotLight && y++, D instanceof THREE.DirectionalLight && !D.shadowCascade && y++);
            }
            u = y;
            var E;
            if (Ba && e && e.skeleton && e.skeleton.useVertexTexture) E = 1024; else {
                var G = W.getParameter(W.MAX_VERTEX_UNIFORM_VECTORS), H = Math.floor((G - 20) / 4);
                void 0 !== e && e instanceof THREE.SkinnedMesh && (H = Math.min(e.skeleton.bones.length, H), 
                H < e.skeleton.bones.length && THREE.warn("WebGLRenderer: too many bones - " + e.skeleton.bones.length + ", this GPU supports just " + H + " (try OpenGL instead of ANGLE)")), 
                E = H;
            }
            var I = {
                precision: F,
                supportsVertexTextures: Aa,
                map: !!d.map,
                envMap: !!d.envMap,
                envMapMode: d.envMap && d.envMap.mapping,
                lightMap: !!d.lightMap,
                bumpMap: !!d.bumpMap,
                normalMap: !!d.normalMap,
                specularMap: !!d.specularMap,
                alphaMap: !!d.alphaMap,
                combine: d.combine,
                vertexColors: d.vertexColors,
                fog: c,
                useFog: d.fog,
                fogExp: c instanceof THREE.FogExp2,
                flatShading: d.shading === THREE.FlatShading,
                sizeAttenuation: d.sizeAttenuation,
                logarithmicDepthBuffer: M,
                skinning: d.skinning,
                maxBones: E,
                useVertexTexture: Ba && e && e.skeleton && e.skeleton.useVertexTexture,
                morphTargets: d.morphTargets,
                morphNormals: d.morphNormals,
                maxMorphTargets: X.maxMorphTargets,
                maxMorphNormals: X.maxMorphNormals,
                maxDirLights: f,
                maxPointLights: g,
                maxSpotLights: h,
                maxHemiLights: i,
                maxShadows: u,
                shadowMapEnabled: X.shadowMapEnabled && e.receiveShadow && u > 0,
                shadowMapType: X.shadowMapType,
                shadowMapDebug: X.shadowMapDebug,
                shadowMapCascade: X.shadowMapCascade,
                alphaTest: d.alphaTest,
                metal: d.metal,
                wrapAround: d.wrapAround,
                doubleSided: d.side === THREE.DoubleSide,
                flipSided: d.side === THREE.BackSide
            }, J = [];
            if (j ? J.push(j) : (J.push(d.fragmentShader), J.push(d.vertexShader)), void 0 !== d.defines) for (var K in d.defines) J.push(K), 
            J.push(d.defines[K]);
            for (K in I) J.push(K), J.push(I[K]);
            for (var L, N = J.join(), O = 0, P = Y.length; P > O; O++) {
                var Q = Y[O];
                if (Q.code === N) {
                    L = Q, L.usedTimes++;
                    break;
                }
            }
            void 0 === L && (L = new THREE.WebGLProgram(X, N, d, I), Y.push(L), X.info.memory.programs = Y.length), 
            d.program = L;
            var R = L.attributes;
            if (d.morphTargets) {
                d.numSupportedMorphTargets = 0;
                for (var S, T = "morphTarget", U = 0; U < X.maxMorphTargets; U++) S = T + U, 0 <= R[S] && d.numSupportedMorphTargets++;
            }
            if (d.morphNormals) for (d.numSupportedMorphNormals = 0, T = "morphNormal", U = 0; U < X.maxMorphNormals; U++) S = T + U, 
            0 <= R[S] && d.numSupportedMorphNormals++;
            d.uniformsList = [];
            for (var V in d.__webglShader.uniforms) {
                var $ = d.program.uniforms[V];
                $ && d.uniformsList.push([ d.__webglShader.uniforms[V], $ ]);
            }
            d.needsUpdate = !1;
        }
        d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(X.maxMorphTargets));
        var aa = !1, da = !1, ea = !1, fa = d.program, ga = fa.uniforms, ha = d.__webglShader.uniforms;
        if (fa.id !== Z && (W.useProgram(fa.program), Z = fa.id, ea = da = aa = !0), d.id !== _ && (-1 === _ && (ea = !0), 
        _ = d.id, da = !0), (aa || a !== ba) && (W.uniformMatrix4fv(ga.projectionMatrix, !1, a.projectionMatrix.elements), 
        M && W.uniform1f(ga.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !== ba && (ba = a), 
        (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== ga.cameraPosition && (la.setFromMatrixPosition(a.matrixWorld), 
        W.uniform3f(ga.cameraPosition, la.x, la.y, la.z)), (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshBasicMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== ga.viewMatrix && W.uniformMatrix4fv(ga.viewMatrix, !1, a.matrixWorldInverse.elements)), 
        d.skinning) if (e.bindMatrix && null !== ga.bindMatrix && W.uniformMatrix4fv(ga.bindMatrix, !1, e.bindMatrix.elements), 
        e.bindMatrixInverse && null !== ga.bindMatrixInverse && W.uniformMatrix4fv(ga.bindMatrixInverse, !1, e.bindMatrixInverse.elements), 
        Ba && e.skeleton && e.skeleton.useVertexTexture) {
            if (null !== ga.boneTexture) {
                var ia = t();
                W.uniform1i(ga.boneTexture, ia), X.setTexture(e.skeleton.boneTexture, ia);
            }
            null !== ga.boneTextureWidth && W.uniform1i(ga.boneTextureWidth, e.skeleton.boneTextureWidth), 
            null !== ga.boneTextureHeight && W.uniform1i(ga.boneTextureHeight, e.skeleton.boneTextureHeight);
        } else e.skeleton && e.skeleton.boneMatrices && null !== ga.boneGlobalMatrices && W.uniformMatrix4fv(ga.boneGlobalMatrices, !1, e.skeleton.boneMatrices);
        if (da) {
            if (c && d.fog && (ha.fogColor.value = c.color, c instanceof THREE.Fog ? (ha.fogNear.value = c.near, 
            ha.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (ha.fogDensity.value = c.density)), 
            d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
                if (na) {
                    var ja, ka, pa, qa, ra, sa, ta, ua, ea = !0, va = 0, wa = 0, xa = 0, ya = oa, Ca = ya.directional.colors, Da = ya.directional.positions, Ea = ya.point.colors, Fa = ya.point.positions, Ha = ya.point.distances, Ia = ya.point.decays, Ja = ya.spot.colors, Ka = ya.spot.positions, La = ya.spot.distances, Ma = ya.spot.directions, Na = ya.spot.anglesCos, Pa = ya.spot.exponents, Ra = ya.spot.decays, Ta = ya.hemi.skyColors, Ua = ya.hemi.groundColors, Wa = ya.hemi.positions, Xa = 0, Ya = 0, Za = 0, $a = 0, _a = 0, ab = 0, bb = 0, cb = 0, db = 0, eb = 0, fb = 0, gb = 0;
                    for (ja = 0, ka = b.length; ka > ja; ja++) pa = b[ja], pa.onlyShadow || (qa = pa.color, 
                    ta = pa.intensity, ua = pa.distance, pa instanceof THREE.AmbientLight ? pa.visible && (va += qa.r, 
                    wa += qa.g, xa += qa.b) : pa instanceof THREE.DirectionalLight ? (_a += 1, pa.visible && (ma.setFromMatrixPosition(pa.matrixWorld), 
                    la.setFromMatrixPosition(pa.target.matrixWorld), ma.sub(la), ma.normalize(), db = 3 * Xa, 
                    Da[db] = ma.x, Da[db + 1] = ma.y, Da[db + 2] = ma.z, v(Ca, db, qa, ta), Xa += 1)) : pa instanceof THREE.PointLight ? (ab += 1, 
                    pa.visible && (eb = 3 * Ya, v(Ea, eb, qa, ta), la.setFromMatrixPosition(pa.matrixWorld), 
                    Fa[eb] = la.x, Fa[eb + 1] = la.y, Fa[eb + 2] = la.z, Ha[Ya] = ua, Ia[Ya] = 0 === pa.distance ? 0 : pa.decay, 
                    Ya += 1)) : pa instanceof THREE.SpotLight ? (bb += 1, pa.visible && (fb = 3 * Za, 
                    v(Ja, fb, qa, ta), ma.setFromMatrixPosition(pa.matrixWorld), Ka[fb] = ma.x, Ka[fb + 1] = ma.y, 
                    Ka[fb + 2] = ma.z, La[Za] = ua, la.setFromMatrixPosition(pa.target.matrixWorld), 
                    ma.sub(la), ma.normalize(), Ma[fb] = ma.x, Ma[fb + 1] = ma.y, Ma[fb + 2] = ma.z, 
                    Na[Za] = Math.cos(pa.angle), Pa[Za] = pa.exponent, Ra[Za] = 0 === pa.distance ? 0 : pa.decay, 
                    Za += 1)) : pa instanceof THREE.HemisphereLight && (cb += 1, pa.visible && (ma.setFromMatrixPosition(pa.matrixWorld), 
                    ma.normalize(), gb = 3 * $a, Wa[gb] = ma.x, Wa[gb + 1] = ma.y, Wa[gb + 2] = ma.z, 
                    ra = pa.color, sa = pa.groundColor, v(Ta, gb, ra, ta), v(Ua, gb, sa, ta), $a += 1)));
                    for (ja = 3 * Xa, ka = Math.max(Ca.length, 3 * _a); ka > ja; ja++) Ca[ja] = 0;
                    for (ja = 3 * Ya, ka = Math.max(Ea.length, 3 * ab); ka > ja; ja++) Ea[ja] = 0;
                    for (ja = 3 * Za, ka = Math.max(Ja.length, 3 * bb); ka > ja; ja++) Ja[ja] = 0;
                    for (ja = 3 * $a, ka = Math.max(Ta.length, 3 * cb); ka > ja; ja++) Ta[ja] = 0;
                    for (ja = 3 * $a, ka = Math.max(Ua.length, 3 * cb); ka > ja; ja++) Ua[ja] = 0;
                    ya.directional.length = Xa, ya.point.length = Ya, ya.spot.length = Za, ya.hemi.length = $a, 
                    ya.ambient[0] = va, ya.ambient[1] = wa, ya.ambient[2] = xa, na = !1;
                }
                if (ea) {
                    var hb = oa;
                    ha.ambientLightColor.value = hb.ambient, ha.directionalLightColor.value = hb.directional.colors, 
                    ha.directionalLightDirection.value = hb.directional.positions, ha.pointLightColor.value = hb.point.colors, 
                    ha.pointLightPosition.value = hb.point.positions, ha.pointLightDistance.value = hb.point.distances, 
                    ha.pointLightDecay.value = hb.point.decays, ha.spotLightColor.value = hb.spot.colors, 
                    ha.spotLightPosition.value = hb.spot.positions, ha.spotLightDistance.value = hb.spot.distances, 
                    ha.spotLightDirection.value = hb.spot.directions, ha.spotLightAngleCos.value = hb.spot.anglesCos, 
                    ha.spotLightExponent.value = hb.spot.exponents, ha.spotLightDecay.value = hb.spot.decays, 
                    ha.hemisphereLightSkyColor.value = hb.hemi.skyColors, ha.hemisphereLightGroundColor.value = hb.hemi.groundColors, 
                    ha.hemisphereLightDirection.value = hb.hemi.positions, s(ha, !0);
                } else s(ha, !1);
            }
            if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
                ha.opacity.value = d.opacity, ha.diffuse.value = d.color, ha.map.value = d.map, 
                ha.lightMap.value = d.lightMap, ha.specularMap.value = d.specularMap, ha.alphaMap.value = d.alphaMap, 
                d.bumpMap && (ha.bumpMap.value = d.bumpMap, ha.bumpScale.value = d.bumpScale), d.normalMap && (ha.normalMap.value = d.normalMap, 
                ha.normalScale.value.copy(d.normalScale));
                var ib;
                if (d.map ? ib = d.map : d.specularMap ? ib = d.specularMap : d.normalMap ? ib = d.normalMap : d.bumpMap ? ib = d.bumpMap : d.alphaMap && (ib = d.alphaMap), 
                void 0 !== ib) {
                    var jb = ib.offset, kb = ib.repeat;
                    ha.offsetRepeat.value.set(jb.x, jb.y, kb.x, kb.y);
                }
                ha.envMap.value = d.envMap, ha.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, 
                ha.reflectivity.value = d.reflectivity, ha.refractionRatio.value = d.refractionRatio;
            }
            if (d instanceof THREE.LineBasicMaterial) ha.diffuse.value = d.color, ha.opacity.value = d.opacity; else if (d instanceof THREE.LineDashedMaterial) ha.diffuse.value = d.color, 
            ha.opacity.value = d.opacity, ha.dashSize.value = d.dashSize, ha.totalSize.value = d.dashSize + d.gapSize, 
            ha.scale.value = d.scale; else if (d instanceof THREE.PointCloudMaterial) {
                if (ha.psColor.value = d.color, ha.opacity.value = d.opacity, ha.size.value = d.size, 
                ha.scale.value = C.height / 2, ha.map.value = d.map, null !== d.map) {
                    var lb = d.map.offset, mb = d.map.repeat;
                    ha.offsetRepeat.value.set(lb.x, lb.y, mb.x, mb.y);
                }
            } else d instanceof THREE.MeshPhongMaterial ? (ha.shininess.value = d.shininess, 
            ha.emissive.value = d.emissive, ha.specular.value = d.specular, d.wrapAround && ha.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (ha.emissive.value = d.emissive, 
            d.wrapAround && ha.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (ha.mNear.value = a.near, 
            ha.mFar.value = a.far, ha.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (ha.opacity.value = d.opacity);
            if (e.receiveShadow && !d._shadowPass && ha.shadowMatrix) for (var nb = 0, ob = 0, pb = b.length; pb > ob; ob++) {
                var qb = b[ob];
                qb.castShadow && (qb instanceof THREE.SpotLight || qb instanceof THREE.DirectionalLight && !qb.shadowCascade) && (ha.shadowMap.value[nb] = qb.shadowMap, 
                ha.shadowMapSize.value[nb] = qb.shadowMapSize, ha.shadowMatrix.value[nb] = qb.shadowMatrix, 
                ha.shadowDarkness.value[nb] = qb.shadowDarkness, ha.shadowBias.value[nb] = qb.shadowBias, 
                nb++);
            }
            for (var rb, sb, tb, ub = d.uniformsList, vb = 0, wb = ub.length; wb > vb; vb++) {
                var xb = ub[vb][0];
                if (!1 !== xb.needsUpdate) {
                    var yb = xb.type, zb = xb.value, Ab = ub[vb][1];
                    switch (yb) {
                      case "1i":
                        W.uniform1i(Ab, zb);
                        break;

                      case "1f":
                        W.uniform1f(Ab, zb);
                        break;

                      case "2f":
                        W.uniform2f(Ab, zb[0], zb[1]);
                        break;

                      case "3f":
                        W.uniform3f(Ab, zb[0], zb[1], zb[2]);
                        break;

                      case "4f":
                        W.uniform4f(Ab, zb[0], zb[1], zb[2], zb[3]);
                        break;

                      case "1iv":
                        W.uniform1iv(Ab, zb);
                        break;

                      case "3iv":
                        W.uniform3iv(Ab, zb);
                        break;

                      case "1fv":
                        W.uniform1fv(Ab, zb);
                        break;

                      case "2fv":
                        W.uniform2fv(Ab, zb);
                        break;

                      case "3fv":
                        W.uniform3fv(Ab, zb);
                        break;

                      case "4fv":
                        W.uniform4fv(Ab, zb);
                        break;

                      case "Matrix3fv":
                        W.uniformMatrix3fv(Ab, !1, zb);
                        break;

                      case "Matrix4fv":
                        W.uniformMatrix4fv(Ab, !1, zb);
                        break;

                      case "i":
                        W.uniform1i(Ab, zb);
                        break;

                      case "f":
                        W.uniform1f(Ab, zb);
                        break;

                      case "v2":
                        W.uniform2f(Ab, zb.x, zb.y);
                        break;

                      case "v3":
                        W.uniform3f(Ab, zb.x, zb.y, zb.z);
                        break;

                      case "v4":
                        W.uniform4f(Ab, zb.x, zb.y, zb.z, zb.w);
                        break;

                      case "c":
                        W.uniform3f(Ab, zb.r, zb.g, zb.b);
                        break;

                      case "iv1":
                        W.uniform1iv(Ab, zb);
                        break;

                      case "iv":
                        W.uniform3iv(Ab, zb);
                        break;

                      case "fv1":
                        W.uniform1fv(Ab, zb);
                        break;

                      case "fv":
                        W.uniform3fv(Ab, zb);
                        break;

                      case "v2v":
                        void 0 === xb._array && (xb._array = new Float32Array(2 * zb.length));
                        for (var Bb = 0, Cb = zb.length; Cb > Bb; Bb++) tb = 2 * Bb, xb._array[tb] = zb[Bb].x, 
                        xb._array[tb + 1] = zb[Bb].y;
                        W.uniform2fv(Ab, xb._array);
                        break;

                      case "v3v":
                        for (void 0 === xb._array && (xb._array = new Float32Array(3 * zb.length)), Bb = 0, 
                        Cb = zb.length; Cb > Bb; Bb++) tb = 3 * Bb, xb._array[tb] = zb[Bb].x, xb._array[tb + 1] = zb[Bb].y, 
                        xb._array[tb + 2] = zb[Bb].z;
                        W.uniform3fv(Ab, xb._array);
                        break;

                      case "v4v":
                        for (void 0 === xb._array && (xb._array = new Float32Array(4 * zb.length)), Bb = 0, 
                        Cb = zb.length; Cb > Bb; Bb++) tb = 4 * Bb, xb._array[tb] = zb[Bb].x, xb._array[tb + 1] = zb[Bb].y, 
                        xb._array[tb + 2] = zb[Bb].z, xb._array[tb + 3] = zb[Bb].w;
                        W.uniform4fv(Ab, xb._array);
                        break;

                      case "m3":
                        W.uniformMatrix3fv(Ab, !1, zb.elements);
                        break;

                      case "m3v":
                        for (void 0 === xb._array && (xb._array = new Float32Array(9 * zb.length)), Bb = 0, 
                        Cb = zb.length; Cb > Bb; Bb++) zb[Bb].flattenToArrayOffset(xb._array, 9 * Bb);
                        W.uniformMatrix3fv(Ab, !1, xb._array);
                        break;

                      case "m4":
                        W.uniformMatrix4fv(Ab, !1, zb.elements);
                        break;

                      case "m4v":
                        for (void 0 === xb._array && (xb._array = new Float32Array(16 * zb.length)), Bb = 0, 
                        Cb = zb.length; Cb > Bb; Bb++) zb[Bb].flattenToArrayOffset(xb._array, 16 * Bb);
                        W.uniformMatrix4fv(Ab, !1, xb._array);
                        break;

                      case "t":
                        if (rb = zb, sb = t(), W.uniform1i(Ab, sb), !rb) continue;
                        if (rb instanceof THREE.CubeTexture || rb.image instanceof Array && 6 === rb.image.length) {
                            var Db = rb, Eb = sb;
                            if (6 === Db.image.length) if (Db.needsUpdate) {
                                Db.image.__webglTextureCube || (Db.addEventListener("dispose", Oa), Db.image.__webglTextureCube = W.createTexture(), 
                                X.info.memory.textures++), W.activeTexture(W.TEXTURE0 + Eb), W.bindTexture(W.TEXTURE_CUBE_MAP, Db.image.__webglTextureCube), 
                                W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, Db.flipY);
                                for (var Fb = Db instanceof THREE.CompressedTexture, Gb = Db.image[0] instanceof THREE.DataTexture, Hb = [], Ib = 0; 6 > Ib; Ib++) Hb[Ib] = !X.autoScaleCubemaps || Fb || Gb ? Gb ? Db.image[Ib].image : Db.image[Ib] : x(Db.image[Ib], za);
                                var Jb = Hb[0], Kb = THREE.Math.isPowerOfTwo(Jb.width) && THREE.Math.isPowerOfTwo(Jb.height), Lb = B(Db.format), Mb = B(Db.type);
                                for (w(W.TEXTURE_CUBE_MAP, Db, Kb), Ib = 0; 6 > Ib; Ib++) if (Fb) for (var Nb, Ob = Hb[Ib].mipmaps, Pb = 0, Qb = Ob.length; Qb > Pb; Pb++) Nb = Ob[Pb], 
                                Db.format !== THREE.RGBAFormat && Db.format !== THREE.RGBFormat ? -1 < Ga().indexOf(Lb) ? W.compressedTexImage2D(W.TEXTURE_CUBE_MAP_POSITIVE_X + Ib, Pb, Lb, Nb.width, Nb.height, 0, Nb.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : W.texImage2D(W.TEXTURE_CUBE_MAP_POSITIVE_X + Ib, Pb, Lb, Nb.width, Nb.height, 0, Lb, Mb, Nb.data); else Gb ? W.texImage2D(W.TEXTURE_CUBE_MAP_POSITIVE_X + Ib, 0, Lb, Hb[Ib].width, Hb[Ib].height, 0, Lb, Mb, Hb[Ib].data) : W.texImage2D(W.TEXTURE_CUBE_MAP_POSITIVE_X + Ib, 0, Lb, Lb, Mb, Hb[Ib]);
                                Db.generateMipmaps && Kb && W.generateMipmap(W.TEXTURE_CUBE_MAP), Db.needsUpdate = !1, 
                                Db.onUpdate && Db.onUpdate();
                            } else W.activeTexture(W.TEXTURE0 + Eb), W.bindTexture(W.TEXTURE_CUBE_MAP, Db.image.__webglTextureCube);
                        } else if (rb instanceof THREE.WebGLRenderTargetCube) {
                            var Rb = rb;
                            W.activeTexture(W.TEXTURE0 + sb), W.bindTexture(W.TEXTURE_CUBE_MAP, Rb.__webglTexture);
                        } else X.setTexture(rb, sb);
                        break;

                      case "tv":
                        for (void 0 === xb._array && (xb._array = []), Bb = 0, Cb = xb.value.length; Cb > Bb; Bb++) xb._array[Bb] = t();
                        for (W.uniform1iv(Ab, xb._array), Bb = 0, Cb = xb.value.length; Cb > Bb; Bb++) rb = xb.value[Bb], 
                        sb = xb._array[Bb], rb && X.setTexture(rb, sb);
                        break;

                      default:
                        THREE.warn("THREE.WebGLRenderer: Unknown uniform type: " + yb);
                    }
                }
            }
        }
        return W.uniformMatrix4fv(ga.modelViewMatrix, !1, e._modelViewMatrix.elements), 
        ga.normalMatrix && W.uniformMatrix3fv(ga.normalMatrix, !1, e._normalMatrix.elements), 
        null !== ga.modelMatrix && W.uniformMatrix4fv(ga.modelMatrix, !1, e.matrixWorld.elements), 
        fa;
    }
    function s(a, b) {
        a.ambientLightColor.needsUpdate = b, a.directionalLightColor.needsUpdate = b, a.directionalLightDirection.needsUpdate = b, 
        a.pointLightColor.needsUpdate = b, a.pointLightPosition.needsUpdate = b, a.pointLightDistance.needsUpdate = b, 
        a.pointLightDecay.needsUpdate = b, a.spotLightColor.needsUpdate = b, a.spotLightPosition.needsUpdate = b, 
        a.spotLightDistance.needsUpdate = b, a.spotLightDirection.needsUpdate = b, a.spotLightAngleCos.needsUpdate = b, 
        a.spotLightExponent.needsUpdate = b, a.spotLightDecay.needsUpdate = b, a.hemisphereLightSkyColor.needsUpdate = b, 
        a.hemisphereLightGroundColor.needsUpdate = b, a.hemisphereLightDirection.needsUpdate = b;
    }
    function t() {
        var a = ca;
        return a >= wa && THREE.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + wa), 
        ca += 1, a;
    }
    function u(a, b) {
        a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, a.matrixWorld), a._normalMatrix.getNormalMatrix(a._modelViewMatrix);
    }
    function v(a, b, c, d) {
        a[b] = c.r * d, a[b + 1] = c.g * d, a[b + 2] = c.b * d;
    }
    function w(a, b, c) {
        c ? (W.texParameteri(a, W.TEXTURE_WRAP_S, B(b.wrapS)), W.texParameteri(a, W.TEXTURE_WRAP_T, B(b.wrapT)), 
        W.texParameteri(a, W.TEXTURE_MAG_FILTER, B(b.magFilter)), W.texParameteri(a, W.TEXTURE_MIN_FILTER, B(b.minFilter))) : (W.texParameteri(a, W.TEXTURE_WRAP_S, W.CLAMP_TO_EDGE), 
        W.texParameteri(a, W.TEXTURE_WRAP_T, W.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( " + b.sourceFile + " )"), 
        W.texParameteri(a, W.TEXTURE_MAG_FILTER, A(b.magFilter)), W.texParameteri(a, W.TEXTURE_MIN_FILTER, A(b.minFilter)), 
        b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( " + b.sourceFile + " )")), 
        (c = sa.get("EXT_texture_filter_anisotropic")) && b.type !== THREE.FloatType && b.type !== THREE.HalfFloatType && (1 < b.anisotropy || b.__currentAnisotropy) && (W.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, X.getMaxAnisotropy())), 
        b.__currentAnisotropy = b.anisotropy);
    }
    function x(a, b) {
        if (a.width > b || a.height > b) {
            var c = b / Math.max(a.width, a.height), d = document.createElement("canvas");
            return d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c), d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), 
            THREE.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a), 
            d;
        }
        return a;
    }
    function y(a, b) {
        W.bindRenderbuffer(W.RENDERBUFFER, a), b.depthBuffer && !b.stencilBuffer ? (W.renderbufferStorage(W.RENDERBUFFER, W.DEPTH_COMPONENT16, b.width, b.height), 
        W.framebufferRenderbuffer(W.FRAMEBUFFER, W.DEPTH_ATTACHMENT, W.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (W.renderbufferStorage(W.RENDERBUFFER, W.DEPTH_STENCIL, b.width, b.height), 
        W.framebufferRenderbuffer(W.FRAMEBUFFER, W.DEPTH_STENCIL_ATTACHMENT, W.RENDERBUFFER, a)) : W.renderbufferStorage(W.RENDERBUFFER, W.RGBA4, b.width, b.height);
    }
    function z(a) {
        a instanceof THREE.WebGLRenderTargetCube ? (W.bindTexture(W.TEXTURE_CUBE_MAP, a.__webglTexture), 
        W.generateMipmap(W.TEXTURE_CUBE_MAP), W.bindTexture(W.TEXTURE_CUBE_MAP, null)) : (W.bindTexture(W.TEXTURE_2D, a.__webglTexture), 
        W.generateMipmap(W.TEXTURE_2D), W.bindTexture(W.TEXTURE_2D, null));
    }
    function A(a) {
        return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? W.NEAREST : W.LINEAR;
    }
    function B(a) {
        var b;
        if (a === THREE.RepeatWrapping) return W.REPEAT;
        if (a === THREE.ClampToEdgeWrapping) return W.CLAMP_TO_EDGE;
        if (a === THREE.MirroredRepeatWrapping) return W.MIRRORED_REPEAT;
        if (a === THREE.NearestFilter) return W.NEAREST;
        if (a === THREE.NearestMipMapNearestFilter) return W.NEAREST_MIPMAP_NEAREST;
        if (a === THREE.NearestMipMapLinearFilter) return W.NEAREST_MIPMAP_LINEAR;
        if (a === THREE.LinearFilter) return W.LINEAR;
        if (a === THREE.LinearMipMapNearestFilter) return W.LINEAR_MIPMAP_NEAREST;
        if (a === THREE.LinearMipMapLinearFilter) return W.LINEAR_MIPMAP_LINEAR;
        if (a === THREE.UnsignedByteType) return W.UNSIGNED_BYTE;
        if (a === THREE.UnsignedShort4444Type) return W.UNSIGNED_SHORT_4_4_4_4;
        if (a === THREE.UnsignedShort5551Type) return W.UNSIGNED_SHORT_5_5_5_1;
        if (a === THREE.UnsignedShort565Type) return W.UNSIGNED_SHORT_5_6_5;
        if (a === THREE.ByteType) return W.BYTE;
        if (a === THREE.ShortType) return W.SHORT;
        if (a === THREE.UnsignedShortType) return W.UNSIGNED_SHORT;
        if (a === THREE.IntType) return W.INT;
        if (a === THREE.UnsignedIntType) return W.UNSIGNED_INT;
        if (a === THREE.FloatType) return W.FLOAT;
        if (b = sa.get("OES_texture_half_float"), null !== b && a === THREE.HalfFloatType) return b.HALF_FLOAT_OES;
        if (a === THREE.AlphaFormat) return W.ALPHA;
        if (a === THREE.RGBFormat) return W.RGB;
        if (a === THREE.RGBAFormat) return W.RGBA;
        if (a === THREE.LuminanceFormat) return W.LUMINANCE;
        if (a === THREE.LuminanceAlphaFormat) return W.LUMINANCE_ALPHA;
        if (a === THREE.AddEquation) return W.FUNC_ADD;
        if (a === THREE.SubtractEquation) return W.FUNC_SUBTRACT;
        if (a === THREE.ReverseSubtractEquation) return W.FUNC_REVERSE_SUBTRACT;
        if (a === THREE.ZeroFactor) return W.ZERO;
        if (a === THREE.OneFactor) return W.ONE;
        if (a === THREE.SrcColorFactor) return W.SRC_COLOR;
        if (a === THREE.OneMinusSrcColorFactor) return W.ONE_MINUS_SRC_COLOR;
        if (a === THREE.SrcAlphaFactor) return W.SRC_ALPHA;
        if (a === THREE.OneMinusSrcAlphaFactor) return W.ONE_MINUS_SRC_ALPHA;
        if (a === THREE.DstAlphaFactor) return W.DST_ALPHA;
        if (a === THREE.OneMinusDstAlphaFactor) return W.ONE_MINUS_DST_ALPHA;
        if (a === THREE.DstColorFactor) return W.DST_COLOR;
        if (a === THREE.OneMinusDstColorFactor) return W.ONE_MINUS_DST_COLOR;
        if (a === THREE.SrcAlphaSaturateFactor) return W.SRC_ALPHA_SATURATE;
        if (b = sa.get("WEBGL_compressed_texture_s3tc"), null !== b) {
            if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (b = sa.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
            if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (b = sa.get("EXT_blend_minmax"), null !== b) {
            if (a === THREE.MinEquation) return b.MIN_EXT;
            if (a === THREE.MaxEquation) return b.MAX_EXT;
        }
        return 0;
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION), a = a || {};
    var C = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"), D = void 0 !== a.context ? a.context : null, E = 1, F = void 0 !== a.precision ? a.precision : "highp", G = void 0 !== a.alpha ? a.alpha : !1, H = void 0 !== a.depth ? a.depth : !0, I = void 0 !== a.stencil ? a.stencil : !0, J = void 0 !== a.antialias ? a.antialias : !1, K = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, L = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, M = void 0 !== a.logarithmicDepthBuffer ? a.logarithmicDepthBuffer : !1, N = new THREE.Color(0), O = 0, P = [], Q = {}, R = [], S = [], T = [], U = [], V = [];
    this.domElement = C, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, 
    this.gammaFactor = 2, this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1, 
    this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, 
    this.shadowMapCascade = this.shadowMapDebug = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, 
    this.autoScaleCubemaps = !0, this.info = {
        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },
        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }
    };
    var W, X = this, Y = [], Z = null, $ = null, _ = -1, aa = "", ba = null, ca = 0, da = 0, ea = 0, fa = C.width, ga = C.height, ha = 0, ia = 0, ja = new THREE.Frustum(), ka = new THREE.Matrix4(), la = new THREE.Vector3(), ma = new THREE.Vector3(), na = !0, oa = {
        ambient: [ 0, 0, 0 ],
        directional: {
            length: 0,
            colors: [],
            positions: []
        },
        point: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            decays: []
        },
        spot: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            directions: [],
            anglesCos: [],
            exponents: [],
            decays: []
        },
        hemi: {
            length: 0,
            skyColors: [],
            groundColors: [],
            positions: []
        }
    };
    try {
        var pa = {
            alpha: G,
            depth: H,
            stencil: I,
            antialias: J,
            premultipliedAlpha: K,
            preserveDrawingBuffer: L
        };
        if (W = D || C.getContext("webgl", pa) || C.getContext("experimental-webgl", pa), 
        null === W) {
            if (null !== C.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
            throw "Error creating WebGL context.";
        }
        C.addEventListener("webglcontextlost", function(a) {
            a.preventDefault(), va(), ua(), Q = {};
        }, !1);
    } catch (qa) {
        THREE.error("THREE.WebGLRenderer: " + qa);
    }
    var ra = new THREE.WebGLState(W, B);
    void 0 === W.getShaderPrecisionFormat && (W.getShaderPrecisionFormat = function() {
        return {
            rangeMin: 1,
            rangeMax: 1,
            precision: 1
        };
    });
    var sa = new THREE.WebGLExtensions(W);
    sa.get("OES_texture_float"), sa.get("OES_texture_float_linear"), sa.get("OES_texture_half_float"), 
    sa.get("OES_texture_half_float_linear"), sa.get("OES_standard_derivatives"), M && sa.get("EXT_frag_depth");
    var ta = function(a, b, c, d) {
        !0 === K && (a *= d, b *= d, c *= d), W.clearColor(a, b, c, d);
    }, ua = function() {
        W.clearColor(0, 0, 0, 1), W.clearDepth(1), W.clearStencil(0), W.enable(W.DEPTH_TEST), 
        W.depthFunc(W.LEQUAL), W.frontFace(W.CCW), W.cullFace(W.BACK), W.enable(W.CULL_FACE), 
        W.enable(W.BLEND), W.blendEquation(W.FUNC_ADD), W.blendFunc(W.SRC_ALPHA, W.ONE_MINUS_SRC_ALPHA), 
        W.viewport(da, ea, fa, ga), ta(N.r, N.g, N.b, O);
    }, va = function() {
        ba = Z = null, aa = "", _ = -1, na = !0, ra.reset();
    };
    ua(), this.context = W, this.state = ra;
    var wa = W.getParameter(W.MAX_TEXTURE_IMAGE_UNITS), xa = W.getParameter(W.MAX_VERTEX_TEXTURE_IMAGE_UNITS), ya = W.getParameter(W.MAX_TEXTURE_SIZE), za = W.getParameter(W.MAX_CUBE_MAP_TEXTURE_SIZE), Aa = xa > 0, Ba = Aa && sa.get("OES_texture_float"), Ca = W.getShaderPrecisionFormat(W.VERTEX_SHADER, W.HIGH_FLOAT), Da = W.getShaderPrecisionFormat(W.VERTEX_SHADER, W.MEDIUM_FLOAT), Ea = W.getShaderPrecisionFormat(W.FRAGMENT_SHADER, W.HIGH_FLOAT), Fa = W.getShaderPrecisionFormat(W.FRAGMENT_SHADER, W.MEDIUM_FLOAT), Ga = function() {
        var a;
        return function() {
            if (void 0 !== a) return a;
            if (a = [], sa.get("WEBGL_compressed_texture_pvrtc") || sa.get("WEBGL_compressed_texture_s3tc")) for (var b = W.getParameter(W.COMPRESSED_TEXTURE_FORMATS), c = 0; c < b.length; c++) a.push(b[c]);
            return a;
        };
    }(), Ha = 0 < Ca.precision && 0 < Ea.precision, Ia = 0 < Da.precision && 0 < Fa.precision;
    "highp" !== F || Ha || (Ia ? (F = "mediump", THREE.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (F = "lowp", 
    THREE.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), 
    "mediump" !== F || Ia || (F = "lowp", THREE.warn("THREE.WebGLRenderer: mediump not supported, using lowp."));
    var Ja = new THREE.ShadowMapPlugin(this, P, Q, R), Ka = new THREE.SpritePlugin(this, U), La = new THREE.LensFlarePlugin(this, V);
    this.getContext = function() {
        return W;
    }, this.forceContextLoss = function() {
        sa.get("WEBGL_lose_context").loseContext();
    }, this.supportsVertexTextures = function() {
        return Aa;
    }, this.supportsFloatTextures = function() {
        return sa.get("OES_texture_float");
    }, this.supportsHalfFloatTextures = function() {
        return sa.get("OES_texture_half_float");
    }, this.supportsStandardDerivatives = function() {
        return sa.get("OES_standard_derivatives");
    }, this.supportsCompressedTextureS3TC = function() {
        return sa.get("WEBGL_compressed_texture_s3tc");
    }, this.supportsCompressedTexturePVRTC = function() {
        return sa.get("WEBGL_compressed_texture_pvrtc");
    }, this.supportsBlendMinMax = function() {
        return sa.get("EXT_blend_minmax");
    }, this.getMaxAnisotropy = function() {
        var a;
        return function() {
            if (void 0 !== a) return a;
            var b = sa.get("EXT_texture_filter_anisotropic");
            return a = null !== b ? W.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        };
    }(), this.getPrecision = function() {
        return F;
    }, this.getPixelRatio = function() {
        return E;
    }, this.setPixelRatio = function(a) {
        E = a;
    }, this.setSize = function(a, b, c) {
        C.width = a * E, C.height = b * E, !1 !== c && (C.style.width = a + "px", C.style.height = b + "px"), 
        this.setViewport(0, 0, a, b);
    }, this.setViewport = function(a, b, c, d) {
        da = a * E, ea = b * E, fa = c * E, ga = d * E, W.viewport(da, ea, fa, ga);
    }, this.setScissor = function(a, b, c, d) {
        W.scissor(a * E, b * E, c * E, d * E);
    }, this.enableScissorTest = function(a) {
        a ? W.enable(W.SCISSOR_TEST) : W.disable(W.SCISSOR_TEST);
    }, this.getClearColor = function() {
        return N;
    }, this.setClearColor = function(a, b) {
        N.set(a), O = void 0 !== b ? b : 1, ta(N.r, N.g, N.b, O);
    }, this.getClearAlpha = function() {
        return O;
    }, this.setClearAlpha = function(a) {
        O = a, ta(N.r, N.g, N.b, O);
    }, this.clear = function(a, b, c) {
        var d = 0;
        (void 0 === a || a) && (d |= W.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= W.DEPTH_BUFFER_BIT), 
        (void 0 === c || c) && (d |= W.STENCIL_BUFFER_BIT), W.clear(d);
    }, this.clearColor = function() {
        W.clear(W.COLOR_BUFFER_BIT);
    }, this.clearDepth = function() {
        W.clear(W.DEPTH_BUFFER_BIT);
    }, this.clearStencil = function() {
        W.clear(W.STENCIL_BUFFER_BIT);
    }, this.clearTarget = function(a, b, c, d) {
        this.setRenderTarget(a), this.clear(b, c, d);
    }, this.resetGLState = va;
    var Ma = function(a) {
        a.target.traverse(function(a) {
            if (a.removeEventListener("remove", Ma), a instanceof THREE.Mesh || a instanceof THREE.PointCloud || a instanceof THREE.Line) delete Q[a.id]; else if (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) for (var b = R, c = b.length - 1; c >= 0; c--) b[c].object === a && b.splice(c, 1);
            delete a.__webglInit, delete a._modelViewMatrix, delete a._normalMatrix, delete a.__webglActive;
        });
    }, Na = function(a) {
        if (a = a.target, a.removeEventListener("dispose", Na), delete a.__webglInit, a instanceof THREE.BufferGeometry) {
            for (var b in a.attributes) {
                var c = a.attributes[b];
                void 0 !== c.buffer && (W.deleteBuffer(c.buffer), delete c.buffer);
            }
            X.info.memory.geometries--;
        } else if (b = Ta[a.id], void 0 !== b) {
            for (var c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                if (void 0 !== e.numMorphTargets) {
                    for (var f = 0, g = e.numMorphTargets; g > f; f++) W.deleteBuffer(e.__webglMorphTargetsBuffers[f]);
                    delete e.__webglMorphTargetsBuffers;
                }
                if (void 0 !== e.numMorphNormals) {
                    for (f = 0, g = e.numMorphNormals; g > f; f++) W.deleteBuffer(e.__webglMorphNormalsBuffers[f]);
                    delete e.__webglMorphNormalsBuffers;
                }
                Ra(e);
            }
            delete Ta[a.id];
        } else Ra(a);
        aa = "";
    }, Oa = function(a) {
        a = a.target, a.removeEventListener("dispose", Oa), a.image && a.image.__webglTextureCube ? (W.deleteTexture(a.image.__webglTextureCube), 
        delete a.image.__webglTextureCube) : void 0 !== a.__webglInit && (W.deleteTexture(a.__webglTexture), 
        delete a.__webglTexture, delete a.__webglInit), X.info.memory.textures--;
    }, Pa = function(a) {
        if (a = a.target, a.removeEventListener("dispose", Pa), a && void 0 !== a.__webglTexture) {
            if (W.deleteTexture(a.__webglTexture), delete a.__webglTexture, a instanceof THREE.WebGLRenderTargetCube) for (var b = 0; 6 > b; b++) W.deleteFramebuffer(a.__webglFramebuffer[b]), 
            W.deleteRenderbuffer(a.__webglRenderbuffer[b]); else W.deleteFramebuffer(a.__webglFramebuffer), 
            W.deleteRenderbuffer(a.__webglRenderbuffer);
            delete a.__webglFramebuffer, delete a.__webglRenderbuffer;
        }
        X.info.memory.textures--;
    }, Qa = function(a) {
        a = a.target, a.removeEventListener("dispose", Qa), Sa(a);
    }, Ra = function(a) {
        for (var b = "__webglVertexBuffer __webglNormalBuffer __webglTangentBuffer __webglColorBuffer __webglUVBuffer __webglUV2Buffer __webglSkinIndicesBuffer __webglSkinWeightsBuffer __webglFaceBuffer __webglLineBuffer __webglLineDistanceBuffer".split(" "), c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            void 0 !== a[e] && (W.deleteBuffer(a[e]), delete a[e]);
        }
        if (void 0 !== a.__webglCustomAttributesList) {
            for (e in a.__webglCustomAttributesList) W.deleteBuffer(a.__webglCustomAttributesList[e].buffer);
            delete a.__webglCustomAttributesList;
        }
        X.info.memory.geometries--;
    }, Sa = function(a) {
        var b = a.program.program;
        if (void 0 !== b) {
            a.program = void 0;
            var c, d, e = !1;
            for (a = 0, c = Y.length; c > a; a++) if (d = Y[a], d.program === b) {
                d.usedTimes--, 0 === d.usedTimes && (e = !0);
                break;
            }
            if (!0 === e) {
                for (e = [], a = 0, c = Y.length; c > a; a++) d = Y[a], d.program !== b && e.push(d);
                Y = e, W.deleteProgram(b), X.info.memory.programs--;
            }
        }
    };
    this.renderBufferImmediate = function(a, b, c) {
        if (ra.initAttributes(), a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = W.createBuffer()), 
        a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = W.createBuffer()), 
        a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = W.createBuffer()), a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = W.createBuffer()), 
        a.hasPositions && (W.bindBuffer(W.ARRAY_BUFFER, a.__webglVertexBuffer), W.bufferData(W.ARRAY_BUFFER, a.positionArray, W.DYNAMIC_DRAW), 
        ra.enableAttribute(b.attributes.position), W.vertexAttribPointer(b.attributes.position, 3, W.FLOAT, !1, 0, 0)), 
        a.hasNormals) {
            if (W.bindBuffer(W.ARRAY_BUFFER, a.__webglNormalBuffer), !1 == c instanceof THREE.MeshPhongMaterial && c.shading === THREE.FlatShading) {
                var d, e, f, g, h, i, j, k, l, m, n, o = 3 * a.count;
                for (n = 0; o > n; n += 9) m = a.normalArray, d = m[n], e = m[n + 1], f = m[n + 2], 
                g = m[n + 3], i = m[n + 4], k = m[n + 5], h = m[n + 6], j = m[n + 7], l = m[n + 8], 
                d = (d + g + h) / 3, e = (e + i + j) / 3, f = (f + k + l) / 3, m[n] = d, m[n + 1] = e, 
                m[n + 2] = f, m[n + 3] = d, m[n + 4] = e, m[n + 5] = f, m[n + 6] = d, m[n + 7] = e, 
                m[n + 8] = f;
            }
            W.bufferData(W.ARRAY_BUFFER, a.normalArray, W.DYNAMIC_DRAW), ra.enableAttribute(b.attributes.normal), 
            W.vertexAttribPointer(b.attributes.normal, 3, W.FLOAT, !1, 0, 0);
        }
        a.hasUvs && c.map && (W.bindBuffer(W.ARRAY_BUFFER, a.__webglUvBuffer), W.bufferData(W.ARRAY_BUFFER, a.uvArray, W.DYNAMIC_DRAW), 
        ra.enableAttribute(b.attributes.uv), W.vertexAttribPointer(b.attributes.uv, 2, W.FLOAT, !1, 0, 0)), 
        a.hasColors && c.vertexColors !== THREE.NoColors && (W.bindBuffer(W.ARRAY_BUFFER, a.__webglColorBuffer), 
        W.bufferData(W.ARRAY_BUFFER, a.colorArray, W.DYNAMIC_DRAW), ra.enableAttribute(b.attributes.color), 
        W.vertexAttribPointer(b.attributes.color, 3, W.FLOAT, !1, 0, 0)), ra.disableUnusedAttributes(), 
        W.drawArrays(W.TRIANGLES, 0, a.count), a.count = 0;
    }, this.renderBufferDirect = function(a, b, c, e, f, g) {
        if (!1 !== e.visible) if (n(g), a = r(a, b, c, e, g), b = !1, c = "direct_" + f.id + "_" + a.id + "_" + (e.wireframe ? 1 : 0), 
        c !== aa && (aa = c, b = !0), b && ra.initAttributes(), g instanceof THREE.Mesh) {
            g = !0 === e.wireframe ? W.LINES : W.TRIANGLES;
            var h = f.attributes.index;
            if (h) {
                var i, j;
                if (h.array instanceof Uint32Array && sa.get("OES_element_index_uint") ? (i = W.UNSIGNED_INT, 
                j = 4) : (i = W.UNSIGNED_SHORT, j = 2), c = f.offsets, 0 === c.length) b && (d(e, a, f, 0), 
                W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, h.buffer)), W.drawElements(g, h.array.length, i, 0), 
                X.info.render.calls++, X.info.render.vertices += h.array.length, X.info.render.faces += h.array.length / 3; else {
                    b = !0;
                    for (var k = 0, l = c.length; l > k; k++) {
                        var m = c[k].index;
                        b && (d(e, a, f, m), W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, h.buffer)), W.drawElements(g, c[k].count, i, c[k].start * j), 
                        X.info.render.calls++, X.info.render.vertices += c[k].count, X.info.render.faces += c[k].count / 3;
                    }
                }
            } else b && d(e, a, f, 0), e = f.attributes.position, W.drawArrays(g, 0, e.array.length / e.itemSize), 
            X.info.render.calls++, X.info.render.vertices += e.array.length / e.itemSize, X.info.render.faces += e.array.length / (3 * e.itemSize);
        } else if (g instanceof THREE.PointCloud) if (g = W.POINTS, h = f.attributes.index) if (h.array instanceof Uint32Array && sa.get("OES_element_index_uint") ? (i = W.UNSIGNED_INT, 
        j = 4) : (i = W.UNSIGNED_SHORT, j = 2), c = f.offsets, 0 === c.length) b && (d(e, a, f, 0), 
        W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, h.buffer)), W.drawElements(g, h.array.length, i, 0), 
        X.info.render.calls++, X.info.render.points += h.array.length; else for (1 < c.length && (b = !0), 
        k = 0, l = c.length; l > k; k++) m = c[k].index, b && (d(e, a, f, m), W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, h.buffer)), 
        W.drawElements(g, c[k].count, i, c[k].start * j), X.info.render.calls++, X.info.render.points += c[k].count; else if (b && d(e, a, f, 0), 
        e = f.attributes.position, c = f.offsets, 0 === c.length) W.drawArrays(g, 0, e.array.length / 3), 
        X.info.render.calls++, X.info.render.points += e.array.length / 3; else for (k = 0, 
        l = c.length; l > k; k++) W.drawArrays(g, c[k].index, c[k].count), X.info.render.calls++, 
        X.info.render.points += c[k].count; else if (g instanceof THREE.Line) if (g = g.mode === THREE.LineStrip ? W.LINE_STRIP : W.LINES, 
        ra.setLineWidth(e.linewidth * E), h = f.attributes.index) if (h.array instanceof Uint32Array ? (i = W.UNSIGNED_INT, 
        j = 4) : (i = W.UNSIGNED_SHORT, j = 2), c = f.offsets, 0 === c.length) b && (d(e, a, f, 0), 
        W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, h.buffer)), W.drawElements(g, h.array.length, i, 0), 
        X.info.render.calls++, X.info.render.vertices += h.array.length; else for (1 < c.length && (b = !0), 
        k = 0, l = c.length; l > k; k++) m = c[k].index, b && (d(e, a, f, m), W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, h.buffer)), 
        W.drawElements(g, c[k].count, i, c[k].start * j), X.info.render.calls++, X.info.render.vertices += c[k].count; else if (b && d(e, a, f, 0), 
        e = f.attributes.position, c = f.offsets, 0 === c.length) W.drawArrays(g, 0, e.array.length / 3), 
        X.info.render.calls++, X.info.render.vertices += e.array.length / 3; else for (k = 0, 
        l = c.length; l > k; k++) W.drawArrays(g, c[k].index, c[k].count), X.info.render.calls++, 
        X.info.render.vertices += c[k].count;
    }, this.renderBuffer = function(a, b, c, d, e, f) {
        if (!1 !== d.visible) {
            if (n(f), c = r(a, b, c, d, f), b = c.attributes, a = !1, c = e.id + "_" + c.id + "_" + (d.wireframe ? 1 : 0), 
            c !== aa && (aa = c, a = !0), a && ra.initAttributes(), !d.morphTargets && 0 <= b.position) a && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglVertexBuffer), 
            ra.enableAttribute(b.position), W.vertexAttribPointer(b.position, 3, W.FLOAT, !1, 0, 0)); else if (f.morphTargetBase) {
                if (c = d.program.attributes, -1 !== f.morphTargetBase && 0 <= c.position ? (W.bindBuffer(W.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), 
                ra.enableAttribute(c.position), W.vertexAttribPointer(c.position, 3, W.FLOAT, !1, 0, 0)) : 0 <= c.position && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglVertexBuffer), 
                ra.enableAttribute(c.position), W.vertexAttribPointer(c.position, 3, W.FLOAT, !1, 0, 0)), 
                f.morphTargetForcedOrder.length) for (var h, i = 0, j = f.morphTargetForcedOrder, k = f.morphTargetInfluences; i < d.numSupportedMorphTargets && i < j.length; ) h = c["morphTarget" + i], 
                h >= 0 && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[j[i]]), ra.enableAttribute(h), 
                W.vertexAttribPointer(h, 3, W.FLOAT, !1, 0, 0)), h = c["morphNormal" + i], h >= 0 && d.morphNormals && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[j[i]]), 
                ra.enableAttribute(h), W.vertexAttribPointer(h, 3, W.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[i] = k[j[i]], 
                i++; else {
                    for (j = [], k = f.morphTargetInfluences, i = f.geometry.morphTargets, k.length > i.length && (console.warn("THREE.WebGLRenderer: Influences array is bigger than morphTargets array."), 
                    k.length = i.length), i = 0, h = k.length; h > i; i++) j.push([ k[i], i ]);
                    j.length > d.numSupportedMorphTargets ? (j.sort(g), j.length = d.numSupportedMorphTargets) : j.length > d.numSupportedMorphNormals ? j.sort(g) : 0 === j.length && j.push([ 0, 0 ]);
                    for (var i = 0, l = d.numSupportedMorphTargets; l > i; i++) if (j[i]) {
                        var m = j[i][1];
                        h = c["morphTarget" + i], h >= 0 && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[m]), 
                        ra.enableAttribute(h), W.vertexAttribPointer(h, 3, W.FLOAT, !1, 0, 0)), h = c["morphNormal" + i], 
                        h >= 0 && d.morphNormals && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[m]), 
                        ra.enableAttribute(h), W.vertexAttribPointer(h, 3, W.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[i] = k[m];
                    } else f.__webglMorphTargetInfluences[i] = 0;
                }
                null !== d.program.uniforms.morphTargetInfluences && W.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences);
            }
            if (a) {
                if (e.__webglCustomAttributesList) for (c = 0, k = e.__webglCustomAttributesList.length; k > c; c++) j = e.__webglCustomAttributesList[c], 
                0 <= b[j.buffer.belongsToAttribute] && (W.bindBuffer(W.ARRAY_BUFFER, j.buffer), 
                ra.enableAttribute(b[j.buffer.belongsToAttribute]), W.vertexAttribPointer(b[j.buffer.belongsToAttribute], j.size, W.FLOAT, !1, 0, 0));
                0 <= b.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (W.bindBuffer(W.ARRAY_BUFFER, e.__webglColorBuffer), 
                ra.enableAttribute(b.color), W.vertexAttribPointer(b.color, 3, W.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && W.vertexAttrib3fv(b.color, d.defaultAttributeValues.color)), 
                0 <= b.normal && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglNormalBuffer), ra.enableAttribute(b.normal), 
                W.vertexAttribPointer(b.normal, 3, W.FLOAT, !1, 0, 0)), 0 <= b.tangent && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglTangentBuffer), 
                ra.enableAttribute(b.tangent), W.vertexAttribPointer(b.tangent, 4, W.FLOAT, !1, 0, 0)), 
                0 <= b.uv && (f.geometry.faceVertexUvs[0] ? (W.bindBuffer(W.ARRAY_BUFFER, e.__webglUVBuffer), 
                ra.enableAttribute(b.uv), W.vertexAttribPointer(b.uv, 2, W.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && W.vertexAttrib2fv(b.uv, d.defaultAttributeValues.uv)), 
                0 <= b.uv2 && (f.geometry.faceVertexUvs[1] ? (W.bindBuffer(W.ARRAY_BUFFER, e.__webglUV2Buffer), 
                ra.enableAttribute(b.uv2), W.vertexAttribPointer(b.uv2, 2, W.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && W.vertexAttrib2fv(b.uv2, d.defaultAttributeValues.uv2)), 
                d.skinning && 0 <= b.skinIndex && 0 <= b.skinWeight && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), 
                ra.enableAttribute(b.skinIndex), W.vertexAttribPointer(b.skinIndex, 4, W.FLOAT, !1, 0, 0), 
                W.bindBuffer(W.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), ra.enableAttribute(b.skinWeight), 
                W.vertexAttribPointer(b.skinWeight, 4, W.FLOAT, !1, 0, 0)), 0 <= b.lineDistance && (W.bindBuffer(W.ARRAY_BUFFER, e.__webglLineDistanceBuffer), 
                ra.enableAttribute(b.lineDistance), W.vertexAttribPointer(b.lineDistance, 1, W.FLOAT, !1, 0, 0));
            }
            ra.disableUnusedAttributes(), f instanceof THREE.Mesh ? (f = e.__typeArray === Uint32Array ? W.UNSIGNED_INT : W.UNSIGNED_SHORT, 
            d.wireframe ? (ra.setLineWidth(d.wireframeLinewidth * E), a && W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), 
            W.drawElements(W.LINES, e.__webglLineCount, f, 0)) : (a && W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), 
            W.drawElements(W.TRIANGLES, e.__webglFaceCount, f, 0)), X.info.render.calls++, X.info.render.vertices += e.__webglFaceCount, 
            X.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.mode === THREE.LineStrip ? W.LINE_STRIP : W.LINES, 
            ra.setLineWidth(d.linewidth * E), W.drawArrays(f, 0, e.__webglLineCount), X.info.render.calls++) : f instanceof THREE.PointCloud && (W.drawArrays(W.POINTS, 0, e.__webglParticleCount), 
            X.info.render.calls++, X.info.render.points += e.__webglParticleCount);
        }
    }, this.render = function(a, b, c, d) {
        if (!1 == b instanceof THREE.Camera) THREE.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else {
            var g = a.fog;
            aa = "", _ = -1, ba = null, na = !0, !0 === a.autoUpdate && a.updateMatrixWorld(), 
            void 0 === b.parent && b.updateMatrixWorld(), a.traverse(function(a) {
                a instanceof THREE.SkinnedMesh && a.skeleton.update();
            }), b.matrixWorldInverse.getInverse(b.matrixWorld), ka.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), 
            ja.setFromMatrix(ka), P.length = 0, S.length = 0, T.length = 0, U.length = 0, V.length = 0, 
            h(a), !0 === X.sortObjects && (S.sort(e), T.sort(f)), Ja.render(a, b), X.info.render.calls = 0, 
            X.info.render.vertices = 0, X.info.render.faces = 0, X.info.render.points = 0, this.setRenderTarget(c), 
            (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), 
            d = 0;
            for (var l = R.length; l > d; d++) {
                var m = R[d], n = m.object;
                n.visible && (u(n, b), k(m));
            }
            a.overrideMaterial ? (d = a.overrideMaterial, q(d), i(S, b, P, g, d), i(T, b, P, g, d), 
            j(R, "", b, P, g, d)) : (ra.setBlending(THREE.NoBlending), i(S, b, P, g, null), 
            j(R, "opaque", b, P, g, null), i(T, b, P, g, null), j(R, "transparent", b, P, g, null)), 
            Ka.render(a, b), La.render(a, b, ha, ia), c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && z(c), 
            ra.setDepthTest(!0), ra.setDepthWrite(!0), ra.setColorWrite(!0);
        }
    }, this.renderImmediateObject = function(a, b, c, d, e) {
        var f = r(a, b, c, d, e);
        aa = "", X.setMaterialFaces(d), e.immediateRenderCallback ? e.immediateRenderCallback(f, W, ja) : e.render(function(a) {
            X.renderBufferImmediate(a, f, d);
        });
    };
    var Ta = {}, Ua = 0, Va = {
        MeshDepthMaterial: "depth",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointCloudMaterial: "particle_basic"
    };
    this.setFaceCulling = function(a, b) {
        a === THREE.CullFaceNone ? W.disable(W.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? W.frontFace(W.CW) : W.frontFace(W.CCW), 
        a === THREE.CullFaceBack ? W.cullFace(W.BACK) : a === THREE.CullFaceFront ? W.cullFace(W.FRONT) : W.cullFace(W.FRONT_AND_BACK), 
        W.enable(W.CULL_FACE));
    }, this.setMaterialFaces = function(a) {
        ra.setDoubleSided(a.side === THREE.DoubleSide), ra.setFlipSided(a.side === THREE.BackSide);
    }, this.uploadTexture = function(a) {
        void 0 === a.__webglInit && (a.__webglInit = !0, a.addEventListener("dispose", Oa), 
        a.__webglTexture = W.createTexture(), X.info.memory.textures++), W.bindTexture(W.TEXTURE_2D, a.__webglTexture), 
        W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, a.flipY), W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), 
        W.pixelStorei(W.UNPACK_ALIGNMENT, a.unpackAlignment), a.image = x(a.image, ya);
        var b = a.image, c = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height), d = B(a.format), e = B(a.type);
        w(W.TEXTURE_2D, a, c);
        var f = a.mipmaps;
        if (a instanceof THREE.DataTexture) if (0 < f.length && c) {
            for (var g = 0, h = f.length; h > g; g++) b = f[g], W.texImage2D(W.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data);
            a.generateMipmaps = !1;
        } else W.texImage2D(W.TEXTURE_2D, 0, d, b.width, b.height, 0, d, e, b.data); else if (a instanceof THREE.CompressedTexture) for (g = 0, 
        h = f.length; h > g; g++) b = f[g], a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? -1 < Ga().indexOf(d) ? W.compressedTexImage2D(W.TEXTURE_2D, g, d, b.width, b.height, 0, b.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : W.texImage2D(W.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data); else if (0 < f.length && c) {
            for (g = 0, h = f.length; h > g; g++) b = f[g], W.texImage2D(W.TEXTURE_2D, g, d, d, e, b);
            a.generateMipmaps = !1;
        } else W.texImage2D(W.TEXTURE_2D, 0, d, d, e, a.image);
        a.generateMipmaps && c && W.generateMipmap(W.TEXTURE_2D), a.needsUpdate = !1, a.onUpdate && a.onUpdate();
    }, this.setTexture = function(a, b) {
        W.activeTexture(W.TEXTURE0 + b), a.needsUpdate ? X.uploadTexture(a) : W.bindTexture(W.TEXTURE_2D, a.__webglTexture);
    }, this.setRenderTarget = function(a) {
        var b = a instanceof THREE.WebGLRenderTargetCube;
        if (a && void 0 === a.__webglFramebuffer) {
            void 0 === a.depthBuffer && (a.depthBuffer = !0), void 0 === a.stencilBuffer && (a.stencilBuffer = !0), 
            a.addEventListener("dispose", Pa), a.__webglTexture = W.createTexture(), X.info.memory.textures++;
            var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height), d = B(a.format), e = B(a.type);
            if (b) {
                a.__webglFramebuffer = [], a.__webglRenderbuffer = [], W.bindTexture(W.TEXTURE_CUBE_MAP, a.__webglTexture), 
                w(W.TEXTURE_CUBE_MAP, a, c);
                for (var f = 0; 6 > f; f++) {
                    a.__webglFramebuffer[f] = W.createFramebuffer(), a.__webglRenderbuffer[f] = W.createRenderbuffer(), 
                    W.texImage2D(W.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);
                    var g = a, h = W.TEXTURE_CUBE_MAP_POSITIVE_X + f;
                    W.bindFramebuffer(W.FRAMEBUFFER, a.__webglFramebuffer[f]), W.framebufferTexture2D(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, h, g.__webglTexture, 0), 
                    y(a.__webglRenderbuffer[f], a);
                }
                c && W.generateMipmap(W.TEXTURE_CUBE_MAP);
            } else a.__webglFramebuffer = W.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : W.createRenderbuffer(), 
            W.bindTexture(W.TEXTURE_2D, a.__webglTexture), w(W.TEXTURE_2D, a, c), W.texImage2D(W.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), 
            d = W.TEXTURE_2D, W.bindFramebuffer(W.FRAMEBUFFER, a.__webglFramebuffer), W.framebufferTexture2D(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), 
            a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? W.framebufferRenderbuffer(W.FRAMEBUFFER, W.DEPTH_ATTACHMENT, W.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && W.framebufferRenderbuffer(W.FRAMEBUFFER, W.DEPTH_STENCIL_ATTACHMENT, W.RENDERBUFFER, a.__webglRenderbuffer) : y(a.__webglRenderbuffer, a), 
            c && W.generateMipmap(W.TEXTURE_2D);
            b ? W.bindTexture(W.TEXTURE_CUBE_MAP, null) : W.bindTexture(W.TEXTURE_2D, null), 
            W.bindRenderbuffer(W.RENDERBUFFER, null), W.bindFramebuffer(W.FRAMEBUFFER, null);
        }
        a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, 
        a = a.height, e = d = 0) : (b = null, c = fa, a = ga, d = da, e = ea), b !== $ && (W.bindFramebuffer(W.FRAMEBUFFER, b), 
        W.viewport(d, e, c, a), $ = b), ha = c, ia = a;
    }, this.readRenderTargetPixels = function(a, b, c, d, e, f) {
        if (a instanceof THREE.WebGLRenderTarget) {
            if (a.__webglFramebuffer) if (a.format !== THREE.RGBAFormat) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format."); else {
                var g = !1;
                a.__webglFramebuffer !== $ && (W.bindFramebuffer(W.FRAMEBUFFER, a.__webglFramebuffer), 
                g = !0), W.checkFramebufferStatus(W.FRAMEBUFFER) === W.FRAMEBUFFER_COMPLETE ? W.readPixels(b, c, d, e, W.RGBA, W.UNSIGNED_BYTE, f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."), 
                g && W.bindFramebuffer(W.FRAMEBUFFER, $);
            }
        } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    }, this.initMaterial = function() {
        THREE.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    }, this.addPrePlugin = function() {
        THREE.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    }, this.addPostPlugin = function() {
        THREE.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    }, this.updateShadowMap = function() {
        THREE.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    };
}, THREE.WebGLRenderTarget = function(a, b, c) {
    this.width = a, this.height = b, c = c || {}, this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping, 
    this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter, 
    this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter, 
    this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), 
    this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat, 
    this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType, this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0, 
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0, this.generateMipmaps = !0, 
    this.shareDepthFrom = void 0 !== c.shareDepthFrom ? c.shareDepthFrom : null;
}, THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    setSize: function(a, b) {
        this.width = a, this.height = b;
    },
    clone: function() {
        var a = new THREE.WebGLRenderTarget(this.width, this.height);
        return a.wrapS = this.wrapS, a.wrapT = this.wrapT, a.magFilter = this.magFilter, 
        a.minFilter = this.minFilter, a.anisotropy = this.anisotropy, a.offset.copy(this.offset), 
        a.repeat.copy(this.repeat), a.format = this.format, a.type = this.type, a.depthBuffer = this.depthBuffer, 
        a.stencilBuffer = this.stencilBuffer, a.generateMipmaps = this.generateMipmaps, 
        a.shareDepthFrom = this.shareDepthFrom, a;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function(a, b, c) {
    THREE.WebGLRenderTarget.call(this, a, b, c), this.activeCubeFace = 0;
}, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), 
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube, 
THREE.WebGLExtensions = function(a) {
    var b = {};
    this.get = function(c) {
        if (void 0 !== b[c]) return b[c];
        var d;
        switch (c) {
          case "EXT_texture_filter_anisotropic":
            d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;

          case "WEBGL_compressed_texture_s3tc":
            d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;

          case "WEBGL_compressed_texture_pvrtc":
            d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;

          default:
            d = a.getExtension(c);
        }
        return null === d && THREE.warn("THREE.WebGLRenderer: " + c + " extension not supported."), 
        b[c] = d;
    };
}, THREE.WebGLProgram = function() {
    var a = 0;
    return function(b, c, d, e) {
        var f = b.context, g = d.defines, h = d.__webglShader.uniforms, i = d.attributes, j = d.__webglShader.vertexShader, k = d.__webglShader.fragmentShader, l = d.index0AttributeName;
        void 0 === l && !0 === e.morphTargets && (l = "position");
        var m = "SHADOWMAP_TYPE_BASIC";
        e.shadowMapType === THREE.PCFShadowMap ? m = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === THREE.PCFSoftShadowMap && (m = "SHADOWMAP_TYPE_PCF_SOFT");
        var n = "ENVMAP_TYPE_CUBE", o = "ENVMAP_MODE_REFLECTION", p = "ENVMAP_BLENDING_MULTIPLY";
        if (e.envMap) {
            switch (d.envMap.mapping) {
              case THREE.CubeReflectionMapping:
              case THREE.CubeRefractionMapping:
                n = "ENVMAP_TYPE_CUBE";
                break;

              case THREE.EquirectangularReflectionMapping:
              case THREE.EquirectangularRefractionMapping:
                n = "ENVMAP_TYPE_EQUIREC";
                break;

              case THREE.SphericalReflectionMapping:
                n = "ENVMAP_TYPE_SPHERE";
            }
            switch (d.envMap.mapping) {
              case THREE.CubeRefractionMapping:
              case THREE.EquirectangularRefractionMapping:
                o = "ENVMAP_MODE_REFRACTION";
            }
            switch (d.combine) {
              case THREE.MultiplyOperation:
                p = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case THREE.MixOperation:
                p = "ENVMAP_BLENDING_MIX";
                break;

              case THREE.AddOperation:
                p = "ENVMAP_BLENDING_ADD";
            }
        }
        var q, r, s = 0 < b.gammaFactor ? b.gammaFactor : 1;
        q = [];
        for (var t in g) r = g[t], !1 !== r && (r = "#define " + t + " " + r, q.push(r));
        q = q.join("\n"), g = f.createProgram(), d instanceof THREE.RawShaderMaterial ? b = d = "" : (d = [ "precision " + e.precision + " float;", "precision " + e.precision + " int;", q, e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + s, "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, "#define MAX_BONES " + e.maxBones, e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + o : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.useVertexTexture ? "#define BONE_TEXTURE" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals ? "#define USE_MORPHNORMALS" : "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + m : "", e.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n	attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n	attribute vec3 morphTarget0;\n	attribute vec3 morphTarget1;\n	attribute vec3 morphTarget2;\n	attribute vec3 morphTarget3;\n	#ifdef USE_MORPHNORMALS\n		attribute vec3 morphNormal0;\n		attribute vec3 morphNormal1;\n		attribute vec3 morphNormal2;\n		attribute vec3 morphNormal3;\n	#else\n		attribute vec3 morphTarget4;\n		attribute vec3 morphTarget5;\n		attribute vec3 morphTarget6;\n		attribute vec3 morphTarget7;\n	#endif\n#endif\n#ifdef USE_SKINNING\n	attribute vec4 skinIndex;\n	attribute vec4 skinWeight;\n#endif\n" ].join("\n"), 
        b = [ "precision " + e.precision + " float;", "precision " + e.precision + " int;", e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", q, "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, e.alphaTest ? "#define ALPHATEST " + e.alphaTest : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + s, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + n : "", e.envMap ? "#define " + o : "", e.envMap ? "#define " + p : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.metal ? "#define METAL" : "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + m : "", e.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n" ].join("\n")), 
        j = new THREE.WebGLShader(f, f.VERTEX_SHADER, d + j), k = new THREE.WebGLShader(f, f.FRAGMENT_SHADER, b + k), 
        f.attachShader(g, j), f.attachShader(g, k), void 0 !== l && f.bindAttribLocation(g, 0, l), 
        f.linkProgram(g), l = f.getProgramInfoLog(g), !1 === f.getProgramParameter(g, f.LINK_STATUS) && THREE.error("THREE.WebGLProgram: shader error: " + f.getError(), "gl.VALIDATE_STATUS", f.getProgramParameter(g, f.VALIDATE_STATUS), "gl.getPRogramInfoLog", l), 
        "" !== l && THREE.warn("THREE.WebGLProgram: gl.getProgramInfoLog()" + l), f.deleteShader(j), 
        f.deleteShader(k), l = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" "), 
        e.useVertexTexture ? (l.push("boneTexture"), l.push("boneTextureWidth"), l.push("boneTextureHeight")) : l.push("boneGlobalMatrices"), 
        e.logarithmicDepthBuffer && l.push("logDepthBufFC");
        for (var u in h) l.push(u);
        for (h = l, u = {}, l = 0, b = h.length; b > l; l++) m = h[l], u[m] = f.getUniformLocation(g, m);
        for (this.uniforms = u, l = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" "), 
        h = 0; h < e.maxMorphTargets; h++) l.push("morphTarget" + h);
        for (h = 0; h < e.maxMorphNormals; h++) l.push("morphNormal" + h);
        for (var v in i) l.push(v);
        for (e = l, i = {}, v = 0, h = e.length; h > v; v++) u = e[v], i[u] = f.getAttribLocation(g, u);
        return this.attributes = i, this.attributesKeys = Object.keys(this.attributes), 
        this.id = a++, this.code = c, this.usedTimes = 1, this.program = g, this.vertexShader = j, 
        this.fragmentShader = k, this;
    };
}(), THREE.WebGLShader = function() {
    var a = function(a) {
        a = a.split("\n");
        for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
        return a.join("\n");
    };
    return function(b, c, d) {
        return c = b.createShader(c), b.shaderSource(c, d), b.compileShader(c), !1 === b.getShaderParameter(c, b.COMPILE_STATUS) && THREE.error("THREE.WebGLShader: Shader couldn't compile."), 
        "" !== b.getShaderInfoLog(c) && THREE.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b.getShaderInfoLog(c), a(d)), 
        c;
    };
}(), THREE.WebGLState = function(a, b) {
    var c = new Uint8Array(16), d = new Uint8Array(16), e = null, f = null, g = null, h = null, i = null, j = null, k = null, l = null, m = null, n = null, o = null, p = null, q = null, r = null, s = null, t = null;
    this.initAttributes = function() {
        for (var a = 0, b = c.length; b > a; a++) c[a] = 0;
    }, this.enableAttribute = function(b) {
        c[b] = 1, 0 === d[b] && (a.enableVertexAttribArray(b), d[b] = 1);
    }, this.disableUnusedAttributes = function() {
        for (var b = 0, e = d.length; e > b; b++) d[b] !== c[b] && (a.disableVertexAttribArray(b), 
        d[b] = 0);
    }, this.setBlending = function(c, d, l, m, n, o, p) {
        c !== e && (c === THREE.NoBlending ? a.disable(a.BLEND) : c === THREE.AdditiveBlending ? (a.enable(a.BLEND), 
        a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : c === THREE.SubtractiveBlending ? (a.enable(a.BLEND), 
        a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : c === THREE.MultiplyBlending ? (a.enable(a.BLEND), 
        a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : c === THREE.CustomBlending ? a.enable(a.BLEND) : (a.enable(a.BLEND), 
        a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), 
        e = c), c === THREE.CustomBlending ? (n = n || d, o = o || l, p = p || m, (d !== f || n !== i) && (a.blendEquationSeparate(b(d), b(n)), 
        f = d, i = n), (l !== g || m !== h || o !== j || p !== k) && (a.blendFuncSeparate(b(l), b(m), b(o), b(p)), 
        g = l, h = m, j = o, k = p)) : k = j = i = h = g = f = null;
    }, this.setDepthTest = function(b) {
        l !== b && (b ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), l = b);
    }, this.setDepthWrite = function(b) {
        m !== b && (a.depthMask(b), m = b);
    }, this.setColorWrite = function(b) {
        n !== b && (a.colorMask(b, b, b, b), n = b);
    }, this.setDoubleSided = function(b) {
        o !== b && (b ? a.disable(a.CULL_FACE) : a.enable(a.CULL_FACE), o = b);
    }, this.setFlipSided = function(b) {
        p !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), p = b);
    }, this.setLineWidth = function(b) {
        b !== q && (a.lineWidth(b), q = b);
    }, this.setPolygonOffset = function(b, c, d) {
        r !== b && (b ? a.enable(a.POLYGON_OFFSET_FILL) : a.disable(a.POLYGON_OFFSET_FILL), 
        r = b), !b || s === c && t === d || (a.polygonOffset(c, d), s = c, t = d);
    }, this.reset = function() {
        for (var a = 0; a < d.length; a++) d[a] = 0;
        p = o = n = m = l = e = null;
    };
}, THREE.LensFlarePlugin = function(a, b) {
    var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = a.context;
    this.render = function(t, u, v, w) {
        if (0 !== b.length) {
            t = new THREE.Vector3();
            var x = w / v, y = .5 * v, z = .5 * w, A = 16 / w, B = new THREE.Vector2(A * x, A), C = new THREE.Vector3(1, 1, 0), D = new THREE.Vector2(1, 1);
            if (void 0 === o) {
                var A = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]), E = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
                m = s.createBuffer(), n = s.createBuffer(), s.bindBuffer(s.ARRAY_BUFFER, m), s.bufferData(s.ARRAY_BUFFER, A, s.STATIC_DRAW), 
                s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, n), s.bufferData(s.ELEMENT_ARRAY_BUFFER, E, s.STATIC_DRAW), 
                q = s.createTexture(), r = s.createTexture(), s.bindTexture(s.TEXTURE_2D, q), s.texImage2D(s.TEXTURE_2D, 0, s.RGB, 16, 16, 0, s.RGB, s.UNSIGNED_BYTE, null), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), 
                s.bindTexture(s.TEXTURE_2D, r), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, 16, 16, 0, s.RGBA, s.UNSIGNED_BYTE, null), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST);
                var A = (p = 0 < s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                    fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                } : {
                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                    fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                }, E = s.createProgram(), F = s.createShader(s.FRAGMENT_SHADER), G = s.createShader(s.VERTEX_SHADER), H = "precision " + a.getPrecision() + " float;\n";
                s.shaderSource(F, H + A.fragmentShader), s.shaderSource(G, H + A.vertexShader), 
                s.compileShader(F), s.compileShader(G), s.attachShader(E, F), s.attachShader(E, G), 
                s.linkProgram(E), o = E, k = s.getAttribLocation(o, "position"), l = s.getAttribLocation(o, "uv"), 
                c = s.getUniformLocation(o, "renderType"), d = s.getUniformLocation(o, "map"), e = s.getUniformLocation(o, "occlusionMap"), 
                f = s.getUniformLocation(o, "opacity"), g = s.getUniformLocation(o, "color"), h = s.getUniformLocation(o, "scale"), 
                i = s.getUniformLocation(o, "rotation"), j = s.getUniformLocation(o, "screenPosition");
            }
            for (s.useProgram(o), s.enableVertexAttribArray(k), s.enableVertexAttribArray(l), 
            s.uniform1i(e, 0), s.uniform1i(d, 1), s.bindBuffer(s.ARRAY_BUFFER, m), s.vertexAttribPointer(k, 2, s.FLOAT, !1, 16, 0), 
            s.vertexAttribPointer(l, 2, s.FLOAT, !1, 16, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, n), 
            s.disable(s.CULL_FACE), s.depthMask(!1), E = 0, F = b.length; F > E; E++) if (A = 16 / w, 
            B.set(A * x, A), G = b[E], t.set(G.matrixWorld.elements[12], G.matrixWorld.elements[13], G.matrixWorld.elements[14]), 
            t.applyMatrix4(u.matrixWorldInverse), t.applyProjection(u.projectionMatrix), C.copy(t), 
            D.x = C.x * y + y, D.y = C.y * z + z, p || 0 < D.x && D.x < v && 0 < D.y && D.y < w) {
                s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, q), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGB, D.x - 8, D.y - 8, 16, 16, 0), 
                s.uniform1i(c, 0), s.uniform2f(h, B.x, B.y), s.uniform3f(j, C.x, C.y, C.z), s.disable(s.BLEND), 
                s.enable(s.DEPTH_TEST), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), s.activeTexture(s.TEXTURE0), 
                s.bindTexture(s.TEXTURE_2D, r), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGBA, D.x - 8, D.y - 8, 16, 16, 0), 
                s.uniform1i(c, 1), s.disable(s.DEPTH_TEST), s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, q), 
                s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), G.positionScreen.copy(C), G.customUpdateCallback ? G.customUpdateCallback(G) : G.updateLensFlares(), 
                s.uniform1i(c, 2), s.enable(s.BLEND);
                for (var H = 0, I = G.lensFlares.length; I > H; H++) {
                    var J = G.lensFlares[H];
                    .001 < J.opacity && .001 < J.scale && (C.x = J.x, C.y = J.y, C.z = J.z, A = J.size * J.scale / w, 
                    B.x = A * x, B.y = A, s.uniform3f(j, C.x, C.y, C.z), s.uniform2f(h, B.x, B.y), s.uniform1f(i, J.rotation), 
                    s.uniform1f(f, J.opacity), s.uniform3f(g, J.color.r, J.color.g, J.color.b), a.state.setBlending(J.blending, J.blendEquation, J.blendSrc, J.blendDst), 
                    a.setTexture(J.texture, 1), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0));
                }
            }
            s.enable(s.CULL_FACE), s.enable(s.DEPTH_TEST), s.depthMask(!0), a.resetGLState();
        }
    };
}, THREE.ShadowMapPlugin = function(a, b, c, d) {
    function e(a, b, d) {
        if (b.visible) {
            var f = c[b.id];
            if (f && b.castShadow && (!1 === b.frustumCulled || !0 === k.intersectsObject(b))) for (var g = 0, h = f.length; h > g; g++) {
                var i = f[g];
                b._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, b.matrixWorld), p.push(i);
            }
            for (g = 0, h = b.children.length; h > g; g++) e(a, b.children[g], d);
        }
    }
    var f, g, h, i, j = a.context, k = new THREE.Frustum(), l = new THREE.Matrix4(), m = new THREE.Vector3(), n = new THREE.Vector3(), o = new THREE.Vector3(), p = [], q = THREE.ShaderLib.depthRGBA, r = THREE.UniformsUtils.clone(q.uniforms);
    f = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader
    }), g = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader,
        morphTargets: !0
    }), h = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader,
        skinning: !0
    }), i = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader,
        morphTargets: !0,
        skinning: !0
    }), f._shadowPass = !0, g._shadowPass = !0, h._shadowPass = !0, i._shadowPass = !0, 
    this.render = function(c, q) {
        if (!1 !== a.shadowMapEnabled) {
            var r, s, t, u, v, w, x, y, z = [];
            for (u = 0, j.clearColor(1, 1, 1, 1), j.disable(j.BLEND), j.enable(j.CULL_FACE), 
            j.frontFace(j.CCW), a.shadowMapCullFace === THREE.CullFaceFront ? j.cullFace(j.FRONT) : j.cullFace(j.BACK), 
            a.state.setDepthTest(!0), r = 0, s = b.length; s > r; r++) if (t = b[r], t.castShadow) if (t instanceof THREE.DirectionalLight && t.shadowCascade) for (v = 0; v < t.shadowCascadeCount; v++) {
                var A;
                if (t.shadowCascadeArray[v]) A = t.shadowCascadeArray[v]; else {
                    x = t;
                    var B = v;
                    A = new THREE.DirectionalLight(), A.isVirtual = !0, A.onlyShadow = !0, A.castShadow = !0, 
                    A.shadowCameraNear = x.shadowCameraNear, A.shadowCameraFar = x.shadowCameraFar, 
                    A.shadowCameraLeft = x.shadowCameraLeft, A.shadowCameraRight = x.shadowCameraRight, 
                    A.shadowCameraBottom = x.shadowCameraBottom, A.shadowCameraTop = x.shadowCameraTop, 
                    A.shadowCameraVisible = x.shadowCameraVisible, A.shadowDarkness = x.shadowDarkness, 
                    A.shadowBias = x.shadowCascadeBias[B], A.shadowMapWidth = x.shadowCascadeWidth[B], 
                    A.shadowMapHeight = x.shadowCascadeHeight[B], A.pointsWorld = [], A.pointsFrustum = [], 
                    y = A.pointsWorld, w = A.pointsFrustum;
                    for (var C = 0; 8 > C; C++) y[C] = new THREE.Vector3(), w[C] = new THREE.Vector3();
                    y = x.shadowCascadeNearZ[B], x = x.shadowCascadeFarZ[B], w[0].set(-1, -1, y), w[1].set(1, -1, y), 
                    w[2].set(-1, 1, y), w[3].set(1, 1, y), w[4].set(-1, -1, x), w[5].set(1, -1, x), 
                    w[6].set(-1, 1, x), w[7].set(1, 1, x), A.originalCamera = q, w = new THREE.Gyroscope(), 
                    w.position.copy(t.shadowCascadeOffset), w.add(A), w.add(A.target), q.add(w), t.shadowCascadeArray[v] = A;
                }
                B = t, y = v, x = B.shadowCascadeArray[y], x.position.copy(B.position), x.target.position.copy(B.target.position), 
                x.lookAt(x.target), x.shadowCameraVisible = B.shadowCameraVisible, x.shadowDarkness = B.shadowDarkness, 
                x.shadowBias = B.shadowCascadeBias[y], w = B.shadowCascadeNearZ[y], B = B.shadowCascadeFarZ[y], 
                x = x.pointsFrustum, x[0].z = w, x[1].z = w, x[2].z = w, x[3].z = w, x[4].z = B, 
                x[5].z = B, x[6].z = B, x[7].z = B, z[u] = A, u++;
            } else z[u] = t, u++;
            for (r = 0, s = z.length; s > r; r++) {
                if (t = z[r], t.shadowMap || (v = THREE.LinearFilter, a.shadowMapType === THREE.PCFSoftShadowMap && (v = THREE.NearestFilter), 
                t.shadowMap = new THREE.WebGLRenderTarget(t.shadowMapWidth, t.shadowMapHeight, {
                    minFilter: v,
                    magFilter: v,
                    format: THREE.RGBAFormat
                }), t.shadowMapSize = new THREE.Vector2(t.shadowMapWidth, t.shadowMapHeight), t.shadowMatrix = new THREE.Matrix4()), 
                !t.shadowCamera) {
                    if (t instanceof THREE.SpotLight) t.shadowCamera = new THREE.PerspectiveCamera(t.shadowCameraFov, t.shadowMapWidth / t.shadowMapHeight, t.shadowCameraNear, t.shadowCameraFar); else {
                        if (!(t instanceof THREE.DirectionalLight)) {
                            THREE.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", t);
                            continue;
                        }
                        t.shadowCamera = new THREE.OrthographicCamera(t.shadowCameraLeft, t.shadowCameraRight, t.shadowCameraTop, t.shadowCameraBottom, t.shadowCameraNear, t.shadowCameraFar);
                    }
                    c.add(t.shadowCamera), !0 === c.autoUpdate && c.updateMatrixWorld();
                }
                if (t.shadowCameraVisible && !t.cameraHelper && (t.cameraHelper = new THREE.CameraHelper(t.shadowCamera), 
                c.add(t.cameraHelper)), t.isVirtual && A.originalCamera == q) {
                    for (v = q, u = t.shadowCamera, w = t.pointsFrustum, x = t.pointsWorld, m.set(1 / 0, 1 / 0, 1 / 0), 
                    n.set(-(1 / 0), -(1 / 0), -(1 / 0)), B = 0; 8 > B; B++) y = x[B], y.copy(w[B]), 
                    y.unproject(v), y.applyMatrix4(u.matrixWorldInverse), y.x < m.x && (m.x = y.x), 
                    y.x > n.x && (n.x = y.x), y.y < m.y && (m.y = y.y), y.y > n.y && (n.y = y.y), y.z < m.z && (m.z = y.z), 
                    y.z > n.z && (n.z = y.z);
                    u.left = m.x, u.right = n.x, u.top = n.y, u.bottom = m.y, u.updateProjectionMatrix();
                }
                for (u = t.shadowMap, w = t.shadowMatrix, v = t.shadowCamera, v.position.setFromMatrixPosition(t.matrixWorld), 
                o.setFromMatrixPosition(t.target.matrixWorld), v.lookAt(o), v.updateMatrixWorld(), 
                v.matrixWorldInverse.getInverse(v.matrixWorld), t.cameraHelper && (t.cameraHelper.visible = t.shadowCameraVisible), 
                t.shadowCameraVisible && t.cameraHelper.update(), w.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), 
                w.multiply(v.projectionMatrix), w.multiply(v.matrixWorldInverse), l.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse), 
                k.setFromMatrix(l), a.setRenderTarget(u), a.clear(), p.length = 0, e(c, c, v), t = 0, 
                u = p.length; u > t; t++) x = p[t], w = x.object, x = x.buffer, B = w.material instanceof THREE.MeshFaceMaterial ? w.material.materials[0] : w.material, 
                y = void 0 !== w.geometry.morphTargets && 0 < w.geometry.morphTargets.length && B.morphTargets, 
                C = w instanceof THREE.SkinnedMesh && B.skinning, y = w.customDepthMaterial ? w.customDepthMaterial : C ? y ? i : h : y ? g : f, 
                a.setMaterialFaces(B), x instanceof THREE.BufferGeometry ? a.renderBufferDirect(v, b, null, y, x, w) : a.renderBuffer(v, b, null, y, x, w);
                for (t = 0, u = d.length; u > t; t++) x = d[t], w = x.object, w.visible && w.castShadow && (w._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, w.matrixWorld), 
                a.renderImmediateObject(v, b, null, f, w));
            }
            r = a.getClearColor(), s = a.getClearAlpha(), j.clearColor(r.r, r.g, r.b, s), j.enable(j.BLEND), 
            a.shadowMapCullFace === THREE.CullFaceFront && j.cullFace(j.BACK), a.resetGLState();
        }
    };
}, THREE.SpritePlugin = function(a, b) {
    function c(a, b) {
        return a.z !== b.z ? b.z - a.z : b.id - a.id;
    }
    var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y = a.context, z = new THREE.Vector3(), A = new THREE.Quaternion(), B = new THREE.Vector3();
    this.render = function(C, D) {
        if (0 !== b.length) {
            if (void 0 === w) {
                var E = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]), F = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
                u = y.createBuffer(), v = y.createBuffer(), y.bindBuffer(y.ARRAY_BUFFER, u), y.bufferData(y.ARRAY_BUFFER, E, y.STATIC_DRAW), 
                y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, v), y.bufferData(y.ELEMENT_ARRAY_BUFFER, F, y.STATIC_DRAW);
                var E = y.createProgram(), F = y.createShader(y.VERTEX_SHADER), G = y.createShader(y.FRAGMENT_SHADER);
                y.shaderSource(F, [ "precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}" ].join("\n")), 
                y.shaderSource(G, [ "precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}" ].join("\n")), 
                y.compileShader(F), y.compileShader(G), y.attachShader(E, F), y.attachShader(E, G), 
                y.linkProgram(E), w = E, s = y.getAttribLocation(w, "position"), t = y.getAttribLocation(w, "uv"), 
                d = y.getUniformLocation(w, "uvOffset"), e = y.getUniformLocation(w, "uvScale"), 
                f = y.getUniformLocation(w, "rotation"), g = y.getUniformLocation(w, "scale"), h = y.getUniformLocation(w, "color"), 
                i = y.getUniformLocation(w, "map"), j = y.getUniformLocation(w, "opacity"), k = y.getUniformLocation(w, "modelViewMatrix"), 
                l = y.getUniformLocation(w, "projectionMatrix"), m = y.getUniformLocation(w, "fogType"), 
                n = y.getUniformLocation(w, "fogDensity"), o = y.getUniformLocation(w, "fogNear"), 
                p = y.getUniformLocation(w, "fogFar"), q = y.getUniformLocation(w, "fogColor"), 
                r = y.getUniformLocation(w, "alphaTest"), E = document.createElement("canvas"), 
                E.width = 8, E.height = 8, F = E.getContext("2d"), F.fillStyle = "white", F.fillRect(0, 0, 8, 8), 
                x = new THREE.Texture(E), x.needsUpdate = !0;
            }
            y.useProgram(w), y.enableVertexAttribArray(s), y.enableVertexAttribArray(t), y.disable(y.CULL_FACE), 
            y.enable(y.BLEND), y.bindBuffer(y.ARRAY_BUFFER, u), y.vertexAttribPointer(s, 2, y.FLOAT, !1, 16, 0), 
            y.vertexAttribPointer(t, 2, y.FLOAT, !1, 16, 8), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, v), 
            y.uniformMatrix4fv(l, !1, D.projectionMatrix.elements), y.activeTexture(y.TEXTURE0), 
            y.uniform1i(i, 0), F = E = 0, (G = C.fog) ? (y.uniform3f(q, G.color.r, G.color.g, G.color.b), 
            G instanceof THREE.Fog ? (y.uniform1f(o, G.near), y.uniform1f(p, G.far), y.uniform1i(m, 1), 
            F = E = 1) : G instanceof THREE.FogExp2 && (y.uniform1f(n, G.density), y.uniform1i(m, 2), 
            F = E = 2)) : (y.uniform1i(m, 0), F = E = 0);
            for (var G = 0, H = b.length; H > G; G++) {
                var I = b[G];
                I._modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, I.matrixWorld), I.z = -I._modelViewMatrix.elements[14];
            }
            b.sort(c);
            for (var J = [], G = 0, H = b.length; H > G; G++) {
                var I = b[G], K = I.material;
                y.uniform1f(r, K.alphaTest), y.uniformMatrix4fv(k, !1, I._modelViewMatrix.elements), 
                I.matrixWorld.decompose(z, A, B), J[0] = B.x, J[1] = B.y, I = 0, C.fog && K.fog && (I = F), 
                E !== I && (y.uniform1i(m, I), E = I), null !== K.map ? (y.uniform2f(d, K.map.offset.x, K.map.offset.y), 
                y.uniform2f(e, K.map.repeat.x, K.map.repeat.y)) : (y.uniform2f(d, 0, 0), y.uniform2f(e, 1, 1)), 
                y.uniform1f(j, K.opacity), y.uniform3f(h, K.color.r, K.color.g, K.color.b), y.uniform1f(f, K.rotation), 
                y.uniform2fv(g, J), a.state.setBlending(K.blending, K.blendEquation, K.blendSrc, K.blendDst), 
                a.state.setDepthTest(K.depthTest), a.state.setDepthWrite(K.depthWrite), K.map && K.map.image && K.map.image.width ? a.setTexture(K.map, 0) : a.setTexture(x, 0), 
                y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0);
            }
            y.enable(y.CULL_FACE), a.resetGLState();
        }
    };
}, THREE.GeometryUtils = {
    merge: function(a, b, c) {
        THREE.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        var d;
        b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, 
        b = b.geometry), a.merge(b, d, c);
    },
    center: function(a) {
        return THREE.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), 
        a.center();
    }
}, THREE.ImageUtils = {
    crossOrigin: void 0,
    loadTexture: function(a, b, c, d) {
        var e = new THREE.ImageLoader();
        e.crossOrigin = this.crossOrigin;
        var f = new THREE.Texture(void 0, b);
        return e.load(a, function(a) {
            f.image = a, f.needsUpdate = !0, c && c(f);
        }, void 0, function(a) {
            d && d(a);
        }), f.sourceFile = a, f;
    },
    loadTextureCube: function(a, b, c, d) {
        var e = new THREE.ImageLoader();
        e.crossOrigin = this.crossOrigin;
        var f = new THREE.CubeTexture([], b);
        f.flipY = !1;
        var g = 0;
        b = function(b) {
            e.load(a[b], function(a) {
                f.images[b] = a, g += 1, 6 === g && (f.needsUpdate = !0, c && c(f));
            }, void 0, d);
        };
        for (var h = 0, i = a.length; i > h; ++h) b(h);
        return f;
    },
    loadCompressedTexture: function() {
        THREE.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    },
    loadCompressedTextureCube: function() {
        THREE.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    },
    getNormalMap: function(a, b) {
        var c = function(a) {
            var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
            return [ a[0] / b, a[1] / b, a[2] / b ];
        };
        b |= 1;
        var d = a.width, e = a.height, f = document.createElement("canvas");
        f.width = d, f.height = e;
        var g = f.getContext("2d");
        g.drawImage(a, 0, 0);
        for (var h = g.getImageData(0, 0, d, e).data, i = g.createImageData(d, e), j = i.data, k = 0; d > k; k++) for (var l = 0; e > l; l++) {
            var m = 0 > l - 1 ? 0 : l - 1, n = l + 1 > e - 1 ? e - 1 : l + 1, o = 0 > k - 1 ? 0 : k - 1, p = k + 1 > d - 1 ? d - 1 : k + 1, q = [], r = [ 0, 0, h[4 * (l * d + k)] / 255 * b ];
            for (q.push([ -1, 0, h[4 * (l * d + o)] / 255 * b ]), q.push([ -1, -1, h[4 * (m * d + o)] / 255 * b ]), 
            q.push([ 0, -1, h[4 * (m * d + k)] / 255 * b ]), q.push([ 1, -1, h[4 * (m * d + p)] / 255 * b ]), 
            q.push([ 1, 0, h[4 * (l * d + p)] / 255 * b ]), q.push([ 1, 1, h[4 * (n * d + p)] / 255 * b ]), 
            q.push([ 0, 1, h[4 * (n * d + k)] / 255 * b ]), q.push([ -1, 1, h[4 * (n * d + o)] / 255 * b ]), 
            m = [], o = q.length, n = 0; o > n; n++) {
                var p = q[n], s = q[(n + 1) % o], p = [ p[0] - r[0], p[1] - r[1], p[2] - r[2] ], s = [ s[0] - r[0], s[1] - r[1], s[2] - r[2] ];
                m.push(c([ p[1] * s[2] - p[2] * s[1], p[2] * s[0] - p[0] * s[2], p[0] * s[1] - p[1] * s[0] ]));
            }
            for (q = [ 0, 0, 0 ], n = 0; n < m.length; n++) q[0] += m[n][0], q[1] += m[n][1], 
            q[2] += m[n][2];
            q[0] /= m.length, q[1] /= m.length, q[2] /= m.length, r = 4 * (l * d + k), j[r] = (q[0] + 1) / 2 * 255 | 0, 
            j[r + 1] = (q[1] + 1) / 2 * 255 | 0, j[r + 2] = 255 * q[2] | 0, j[r + 3] = 255;
        }
        return g.putImageData(i, 0, 0), f;
    },
    generateDataTexture: function(a, b, c) {
        var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g);
        c = Math.floor(255 * c.b);
        for (var h = 0; d > h; h++) e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
        return a = new THREE.DataTexture(e, a, b, THREE.RGBFormat), a.needsUpdate = !0, 
        a;
    }
}, THREE.SceneUtils = {
    createMultiMaterialObject: function(a, b) {
        for (var c = new THREE.Object3D(), d = 0, e = b.length; e > d; d++) c.add(new THREE.Mesh(a, b[d]));
        return c;
    },
    detach: function(a, b, c) {
        a.applyMatrix(b.matrixWorld), b.remove(a), c.add(a);
    },
    attach: function(a, b, c) {
        var d = new THREE.Matrix4();
        d.getInverse(c.matrixWorld), a.applyMatrix(d), b.remove(a), c.add(a);
    }
}, THREE.FontUtils = {
    faces: {},
    face: "helvetiker",
    weight: "normal",
    style: "normal",
    size: 150,
    divisions: 10,
    getFace: function() {
        try {
            return this.faces[this.face][this.weight][this.style];
        } catch (a) {
            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
        }
    },
    loadFace: function(a) {
        var b = a.familyName.toLowerCase();
        return this.faces[b] = this.faces[b] || {}, this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {}, 
        this.faces[b][a.cssFontWeight][a.cssFontStyle] = a, this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
    },
    drawText: function(a) {
        var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(""), f = e.length, g = [];
        for (a = 0; f > a; a++) {
            var h = new THREE.Path(), h = this.extractGlyphPoints(e[a], b, c, d, h), d = d + h.offset;
            g.push(h.path);
        }
        return {
            paths: g,
            offset: d / 2
        };
    },
    extractGlyphPoints: function(a, b, c, d, e) {
        var f, g, h, i, j, k, l, m, n, o, p, q = [], r = b.glyphs[a] || b.glyphs["?"];
        if (r) {
            if (r.o) for (b = r._cachedOutline || (r._cachedOutline = r.o.split(" ")), i = b.length, 
            a = 0; i > a; ) switch (h = b[a++]) {
              case "m":
                h = b[a++] * c + d, j = b[a++] * c, e.moveTo(h, j);
                break;

              case "l":
                h = b[a++] * c + d, j = b[a++] * c, e.lineTo(h, j);
                break;

              case "q":
                if (h = b[a++] * c + d, j = b[a++] * c, m = b[a++] * c + d, n = b[a++] * c, e.quadraticCurveTo(m, n, h, j), 
                f = q[q.length - 1]) for (k = f.x, l = f.y, f = 1, g = this.divisions; g >= f; f++) {
                    var s = f / g;
                    THREE.Shape.Utils.b2(s, k, m, h), THREE.Shape.Utils.b2(s, l, n, j);
                }
                break;

              case "b":
                if (h = b[a++] * c + d, j = b[a++] * c, m = b[a++] * c + d, n = b[a++] * c, o = b[a++] * c + d, 
                p = b[a++] * c, e.bezierCurveTo(m, n, o, p, h, j), f = q[q.length - 1]) for (k = f.x, 
                l = f.y, f = 1, g = this.divisions; g >= f; f++) s = f / g, THREE.Shape.Utils.b3(s, k, m, o, h), 
                THREE.Shape.Utils.b3(s, l, n, p, j);
            }
            return {
                offset: r.ha * c,
                path: e
            };
        }
    }
}, THREE.FontUtils.generateShapes = function(a, b) {
    b = b || {};
    var c = void 0 !== b.curveSegments ? b.curveSegments : 4, d = void 0 !== b.font ? b.font : "helvetiker", e = void 0 !== b.weight ? b.weight : "normal", f = void 0 !== b.style ? b.style : "normal";
    for (THREE.FontUtils.size = void 0 !== b.size ? b.size : 100, THREE.FontUtils.divisions = c, 
    THREE.FontUtils.face = d, THREE.FontUtils.weight = e, THREE.FontUtils.style = f, 
    c = THREE.FontUtils.drawText(a).paths, d = [], e = 0, f = c.length; f > e; e++) Array.prototype.push.apply(d, c[e].toShapes());
    return d;
}, function(a) {
    var b = function(a) {
        for (var b = a.length, c = 0, d = b - 1, e = 0; b > e; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
        return .5 * c;
    };
    return a.Triangulate = function(a, c) {
        var d = a.length;
        if (3 > d) return null;
        var e, f, g, h = [], i = [], j = [];
        if (0 < b(a)) for (f = 0; d > f; f++) i[f] = f; else for (f = 0; d > f; f++) i[f] = d - 1 - f;
        var k = 2 * d;
        for (f = d - 1; d > 2; ) {
            if (0 >= k--) {
                THREE.warn("THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()");
                break;
            }
            e = f, e >= d && (e = 0), f = e + 1, f >= d && (f = 0), g = f + 1, g >= d && (g = 0);
            var l;
            a: {
                var m = l = void 0, n = void 0, o = void 0, p = void 0, q = void 0, r = void 0, s = void 0, t = void 0, m = a[i[e]].x, n = a[i[e]].y, o = a[i[f]].x, p = a[i[f]].y, q = a[i[g]].x, r = a[i[g]].y;
                if (1e-10 > (o - m) * (r - n) - (p - n) * (q - m)) l = !1; else {
                    var u = void 0, v = void 0, w = void 0, x = void 0, y = void 0, z = void 0, A = void 0, B = void 0, C = void 0, D = void 0, C = B = A = t = s = void 0, u = q - o, v = r - p, w = m - q, x = n - r, y = o - m, z = p - n;
                    for (l = 0; d > l; l++) if (s = a[i[l]].x, t = a[i[l]].y, !(s === m && t === n || s === o && t === p || s === q && t === r) && (A = s - m, 
                    B = t - n, C = s - o, D = t - p, s -= q, t -= r, C = u * D - v * C, A = y * B - z * A, 
                    B = w * t - x * s, C >= -1e-10 && B >= -1e-10 && A >= -1e-10)) {
                        l = !1;
                        break a;
                    }
                    l = !0;
                }
            }
            if (l) {
                for (h.push([ a[i[e]], a[i[f]], a[i[g]] ]), j.push([ i[e], i[f], i[g] ]), e = f, 
                g = f + 1; d > g; e++, g++) i[e] = i[g];
                d--, k = 2 * d;
            }
        }
        return c ? j : h;
    }, a.Triangulate.area = b, a;
}(THREE.FontUtils), self._typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
}, THREE.typeface_js = self._typeface_js, THREE.Audio = function(a) {
    THREE.Object3D.call(this), this.type = "Audio", this.context = a.context, this.source = this.context.createBufferSource(), 
    this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), 
    this.gain.connect(this.context.destination), this.panner = this.context.createPanner(), 
    this.panner.connect(this.gain), this.autoplay = !1, this.startTime = 0, this.isPlaying = !1;
}, THREE.Audio.prototype = Object.create(THREE.Object3D.prototype), THREE.Audio.prototype.constructor = THREE.Audio, 
THREE.Audio.prototype.load = function(a) {
    var b = this, c = new XMLHttpRequest();
    return c.open("GET", a, !0), c.responseType = "arraybuffer", c.onload = function(a) {
        b.context.decodeAudioData(this.response, function(a) {
            b.source.buffer = a, b.autoplay && b.play();
        });
    }, c.send(), this;
}, THREE.Audio.prototype.play = function() {
    if (!0 === this.isPlaying) THREE.warn("THREE.Audio: Audio is already playing."); else {
        var a = this.context.createBufferSource();
        a.buffer = this.source.buffer, a.loop = this.source.loop, a.onended = this.source.onended, 
        a.connect(this.panner), a.start(0, this.startTime), this.isPlaying = !0, this.source = a;
    }
}, THREE.Audio.prototype.pause = function() {
    this.source.stop(), this.startTime = this.context.currentTime;
}, THREE.Audio.prototype.stop = function() {
    this.source.stop(), this.startTime = 0;
}, THREE.Audio.prototype.onEnded = function() {
    this.isPlaying = !1;
}, THREE.Audio.prototype.setLoop = function(a) {
    this.source.loop = a;
}, THREE.Audio.prototype.setRefDistance = function(a) {
    this.panner.refDistance = a;
}, THREE.Audio.prototype.setRolloffFactor = function(a) {
    this.panner.rolloffFactor = a;
}, THREE.Audio.prototype.setVolume = function(a) {
    this.gain.gain.value = a;
}, THREE.Audio.prototype.updateMatrixWorld = function() {
    var a = new THREE.Vector3();
    return function(b) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, b), a.setFromMatrixPosition(this.matrixWorld), 
        this.panner.setPosition(a.x, a.y, a.z);
    };
}(), THREE.AudioListener = function() {
    THREE.Object3D.call(this), this.type = "AudioListener", this.context = new (window.AudioContext || window.webkitAudioContext)();
}, THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype), THREE.AudioListener.prototype.constructor = THREE.AudioListener, 
THREE.AudioListener.prototype.updateMatrixWorld = function() {
    var a = new THREE.Vector3(), b = new THREE.Quaternion(), c = new THREE.Vector3(), d = new THREE.Vector3(), e = new THREE.Vector3(), f = new THREE.Vector3();
    return function(g) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, g), g = this.context.listener;
        var h = this.up;
        this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), e.subVectors(a, f), 
        g.setPosition(a.x, a.y, a.z), g.setOrientation(d.x, d.y, d.z, h.x, h.y, h.z), g.setVelocity(e.x, e.y, e.z), 
        f.copy(a);
    };
}(), THREE.Curve = function() {}, THREE.Curve.prototype.getPoint = function(a) {
    return THREE.warn("THREE.Curve: Warning, getPoint() not implemented!"), null;
}, THREE.Curve.prototype.getPointAt = function(a) {
    return a = this.getUtoTmapping(a), this.getPoint(a);
}, THREE.Curve.prototype.getPoints = function(a) {
    a || (a = 5);
    var b, c = [];
    for (b = 0; a >= b; b++) c.push(this.getPoint(b / a));
    return c;
}, THREE.Curve.prototype.getSpacedPoints = function(a) {
    a || (a = 5);
    var b, c = [];
    for (b = 0; a >= b; b++) c.push(this.getPointAt(b / a));
    return c;
}, THREE.Curve.prototype.getLength = function() {
    var a = this.getLengths();
    return a[a.length - 1];
}, THREE.Curve.prototype.getLengths = function(a) {
    if (a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = !1;
    var b, c, d = [], e = this.getPoint(0), f = 0;
    for (d.push(0), c = 1; a >= c; c++) b = this.getPoint(c / a), f += b.distanceTo(e), 
    d.push(f), e = b;
    return this.cacheArcLengths = d;
}, THREE.Curve.prototype.updateArcLengths = function() {
    this.needsUpdate = !0, this.getLengths();
}, THREE.Curve.prototype.getUtoTmapping = function(a, b) {
    var c, d = this.getLengths(), e = 0, f = d.length;
    c = b ? b : a * d[f - 1];
    for (var g, h = 0, i = f - 1; i >= h; ) if (e = Math.floor(h + (i - h) / 2), g = d[e] - c, 
    0 > g) h = e + 1; else {
        if (!(g > 0)) {
            i = e;
            break;
        }
        i = e - 1;
    }
    return e = i, d[e] == c ? e / (f - 1) : (h = d[e], d = (e + (c - h) / (d[e + 1] - h)) / (f - 1));
}, THREE.Curve.prototype.getTangent = function(a) {
    var b = a - 1e-4;
    return a += 1e-4, 0 > b && (b = 0), a > 1 && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize();
}, THREE.Curve.prototype.getTangentAt = function(a) {
    return a = this.getUtoTmapping(a), this.getTangent(a);
}, THREE.Curve.Utils = {
    tangentQuadraticBezier: function(a, b, c, d) {
        return 2 * (1 - a) * (c - b) + 2 * a * (d - c);
    },
    tangentCubicBezier: function(a, b, c, d, e) {
        return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;
    },
    tangentSpline: function(a, b, c, d, e) {
        return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);
    },
    interpolate: function(a, b, c, d, e) {
        a = .5 * (c - a), d = .5 * (d - b);
        var f = e * e;
        return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;
    }
}, THREE.Curve.create = function(a, b) {
    return a.prototype = Object.create(THREE.Curve.prototype), a.prototype.constructor = a, 
    a.prototype.getPoint = b, a;
}, THREE.CurvePath = function() {
    this.curves = [], this.bends = [], this.autoClose = !1;
}, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.constructor = THREE.CurvePath, 
THREE.CurvePath.prototype.add = function(a) {
    this.curves.push(a);
}, THREE.CurvePath.prototype.checkConnection = function() {}, THREE.CurvePath.prototype.closePath = function() {
    var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));
}, THREE.CurvePath.prototype.getPoint = function(a) {
    var b = a * this.getLength(), c = this.getCurveLengths();
    for (a = 0; a < c.length; ) {
        if (c[a] >= b) return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), 
        a.getPointAt(b);
        a++;
    }
    return null;
}, THREE.CurvePath.prototype.getLength = function() {
    var a = this.getCurveLengths();
    return a[a.length - 1];
}, THREE.CurvePath.prototype.getCurveLengths = function() {
    if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
    var a, b = [], c = 0, d = this.curves.length;
    for (a = 0; d > a; a++) c += this.curves[a].getLength(), b.push(c);
    return this.cacheLengths = b;
}, THREE.CurvePath.prototype.getBoundingBox = function() {
    var a, b, c, d, e, f, g = this.getPoints();
    a = b = Number.NEGATIVE_INFINITY, d = e = Number.POSITIVE_INFINITY;
    var h, i, j, k, l = g[0] instanceof THREE.Vector3;
    for (k = l ? new THREE.Vector3() : new THREE.Vector2(), i = 0, j = g.length; j > i; i++) h = g[i], 
    h.x > a ? a = h.x : h.x < d && (d = h.x), h.y > b ? b = h.y : h.y < e && (e = h.y), 
    l && (h.z > c ? c = h.z : h.z < f && (f = h.z)), k.add(h);
    return g = {
        minX: d,
        minY: e,
        maxX: a,
        maxY: b
    }, l && (g.maxZ = c, g.minZ = f), g;
}, THREE.CurvePath.prototype.createPointsGeometry = function(a) {
    return a = this.getPoints(a, !0), this.createGeometry(a);
}, THREE.CurvePath.prototype.createSpacedPointsGeometry = function(a) {
    return a = this.getSpacedPoints(a, !0), this.createGeometry(a);
}, THREE.CurvePath.prototype.createGeometry = function(a) {
    for (var b = new THREE.Geometry(), c = 0; c < a.length; c++) b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
    return b;
}, THREE.CurvePath.prototype.addWrapPath = function(a) {
    this.bends.push(a);
}, THREE.CurvePath.prototype.getTransformedPoints = function(a, b) {
    var c, d, e = this.getPoints(a);
    for (b || (b = this.bends), c = 0, d = b.length; d > c; c++) e = this.getWrapPoints(e, b[c]);
    return e;
}, THREE.CurvePath.prototype.getTransformedSpacedPoints = function(a, b) {
    var c, d, e = this.getSpacedPoints(a);
    for (b || (b = this.bends), c = 0, d = b.length; d > c; c++) e = this.getWrapPoints(e, b[c]);
    return e;
}, THREE.CurvePath.prototype.getWrapPoints = function(a, b) {
    var c, d, e, f, g, h, i = this.getBoundingBox();
    for (c = 0, d = a.length; d > c; c++) e = a[c], f = e.x, g = e.y, h = f / i.maxX, 
    h = b.getUtoTmapping(h, f), f = b.getPoint(h), h = b.getTangent(h), h.set(-h.y, h.x).multiplyScalar(g), 
    e.x = f.x + h.x, e.y = f.y + h.y;
    return a;
}, THREE.Gyroscope = function() {
    THREE.Object3D.call(this);
}, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.constructor = THREE.Gyroscope, 
THREE.Gyroscope.prototype.updateMatrixWorld = function() {
    var a = new THREE.Vector3(), b = new THREE.Quaternion(), c = new THREE.Vector3(), d = new THREE.Vector3(), e = new THREE.Quaternion(), f = new THREE.Vector3();
    return function(g) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || g) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
        this.matrixWorld.decompose(d, e, f), this.matrix.decompose(a, b, c), this.matrixWorld.compose(d, b, f)) : this.matrixWorld.copy(this.matrix), 
        this.matrixWorldNeedsUpdate = !1, g = !0);
        for (var h = 0, i = this.children.length; i > h; h++) this.children[h].updateMatrixWorld(g);
    };
}(), THREE.Path = function(a) {
    THREE.CurvePath.call(this), this.actions = [], a && this.fromPoints(a);
}, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.Path.prototype.constructor = THREE.Path, 
THREE.PathActions = {
    MOVE_TO: "moveTo",
    LINE_TO: "lineTo",
    QUADRATIC_CURVE_TO: "quadraticCurveTo",
    BEZIER_CURVE_TO: "bezierCurveTo",
    CSPLINE_THRU: "splineThru",
    ARC: "arc",
    ELLIPSE: "ellipse"
}, THREE.Path.prototype.fromPoints = function(a) {
    this.moveTo(a[0].x, a[0].y);
    for (var b = 1, c = a.length; c > b; b++) this.lineTo(a[b].x, a[b].y);
}, THREE.Path.prototype.moveTo = function(a, b) {
    var c = Array.prototype.slice.call(arguments);
    this.actions.push({
        action: THREE.PathActions.MOVE_TO,
        args: c
    });
}, THREE.Path.prototype.lineTo = function(a, b) {
    var c = Array.prototype.slice.call(arguments), d = this.actions[this.actions.length - 1].args, d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
    this.curves.push(d), this.actions.push({
        action: THREE.PathActions.LINE_TO,
        args: c
    });
}, THREE.Path.prototype.quadraticCurveTo = function(a, b, c, d) {
    var e = Array.prototype.slice.call(arguments), f = this.actions[this.actions.length - 1].args, f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
    this.curves.push(f), this.actions.push({
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: e
    });
}, THREE.Path.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
    var g = Array.prototype.slice.call(arguments), h = this.actions[this.actions.length - 1].args, h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
    this.curves.push(h), this.actions.push({
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: g
    });
}, THREE.Path.prototype.splineThru = function(a) {
    var b = Array.prototype.slice.call(arguments), c = this.actions[this.actions.length - 1].args, c = [ new THREE.Vector2(c[c.length - 2], c[c.length - 1]) ];
    Array.prototype.push.apply(c, a), c = new THREE.SplineCurve(c), this.curves.push(c), 
    this.actions.push({
        action: THREE.PathActions.CSPLINE_THRU,
        args: b
    });
}, THREE.Path.prototype.arc = function(a, b, c, d, e, f) {
    var g = this.actions[this.actions.length - 1].args;
    this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);
}, THREE.Path.prototype.absarc = function(a, b, c, d, e, f) {
    this.absellipse(a, b, c, c, d, e, f);
}, THREE.Path.prototype.ellipse = function(a, b, c, d, e, f, g) {
    var h = this.actions[this.actions.length - 1].args;
    this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g);
}, THREE.Path.prototype.absellipse = function(a, b, c, d, e, f, g) {
    var h = Array.prototype.slice.call(arguments), i = new THREE.EllipseCurve(a, b, c, d, e, f, g);
    this.curves.push(i), i = i.getPoint(1), h.push(i.x), h.push(i.y), this.actions.push({
        action: THREE.PathActions.ELLIPSE,
        args: h
    });
}, THREE.Path.prototype.getSpacedPoints = function(a, b) {
    a || (a = 40);
    for (var c = [], d = 0; a > d; d++) c.push(this.getPoint(d / a));
    return c;
}, THREE.Path.prototype.getPoints = function(a, b) {
    if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(a, b);
    a = a || 12;
    var c, d, e, f, g, h, i, j, k, l, m, n, o, p = [];
    for (c = 0, d = this.actions.length; d > c; c++) switch (e = this.actions[c], f = e.action, 
    e = e.args, f) {
      case THREE.PathActions.MOVE_TO:
        p.push(new THREE.Vector2(e[0], e[1]));
        break;

      case THREE.PathActions.LINE_TO:
        p.push(new THREE.Vector2(e[0], e[1]));
        break;

      case THREE.PathActions.QUADRATIC_CURVE_TO:
        for (g = e[2], h = e[3], k = e[0], l = e[1], 0 < p.length ? (f = p[p.length - 1], 
        m = f.x, n = f.y) : (f = this.actions[c - 1].args, m = f[f.length - 2], n = f[f.length - 1]), 
        e = 1; a >= e; e++) o = e / a, f = THREE.Shape.Utils.b2(o, m, k, g), o = THREE.Shape.Utils.b2(o, n, l, h), 
        p.push(new THREE.Vector2(f, o));
        break;

      case THREE.PathActions.BEZIER_CURVE_TO:
        for (g = e[4], h = e[5], k = e[0], l = e[1], i = e[2], j = e[3], 0 < p.length ? (f = p[p.length - 1], 
        m = f.x, n = f.y) : (f = this.actions[c - 1].args, m = f[f.length - 2], n = f[f.length - 1]), 
        e = 1; a >= e; e++) o = e / a, f = THREE.Shape.Utils.b3(o, m, k, i, g), o = THREE.Shape.Utils.b3(o, n, l, j, h), 
        p.push(new THREE.Vector2(f, o));
        break;

      case THREE.PathActions.CSPLINE_THRU:
        for (f = this.actions[c - 1].args, o = [ new THREE.Vector2(f[f.length - 2], f[f.length - 1]) ], 
        f = a * e[0].length, o = o.concat(e[0]), o = new THREE.SplineCurve(o), e = 1; f >= e; e++) p.push(o.getPointAt(e / f));
        break;

      case THREE.PathActions.ARC:
        for (g = e[0], h = e[1], l = e[2], i = e[3], f = e[4], k = !!e[5], m = f - i, n = 2 * a, 
        e = 1; n >= e; e++) o = e / n, k || (o = 1 - o), o = i + o * m, f = g + l * Math.cos(o), 
        o = h + l * Math.sin(o), p.push(new THREE.Vector2(f, o));
        break;

      case THREE.PathActions.ELLIPSE:
        for (g = e[0], h = e[1], l = e[2], j = e[3], i = e[4], f = e[5], k = !!e[6], m = f - i, 
        n = 2 * a, e = 1; n >= e; e++) o = e / n, k || (o = 1 - o), o = i + o * m, f = g + l * Math.cos(o), 
        o = h + j * Math.sin(o), p.push(new THREE.Vector2(f, o));
    }
    return c = p[p.length - 1], 1e-10 > Math.abs(c.x - p[0].x) && 1e-10 > Math.abs(c.y - p[0].y) && p.splice(p.length - 1, 1), 
    b && p.push(p[0]), p;
}, THREE.Path.prototype.toShapes = function(a, b) {
    function c(a) {
        for (var b = [], c = 0, d = a.length; d > c; c++) {
            var e = a[c], f = new THREE.Shape();
            f.actions = e.actions, f.curves = e.curves, b.push(f);
        }
        return b;
    }
    function d(a, b) {
        for (var c = b.length, d = !1, e = c - 1, f = 0; c > f; e = f++) {
            var g = b[e], h = b[f], i = h.x - g.x, j = h.y - g.y;
            if (1e-10 < Math.abs(j)) {
                if (0 > j && (g = b[f], i = -i, h = b[e], j = -j), !(a.y < g.y || a.y > h.y)) if (a.y == g.y) {
                    if (a.x == g.x) return !0;
                } else {
                    if (e = j * (a.x - g.x) - i * (a.y - g.y), 0 == e) return !0;
                    0 > e || (d = !d);
                }
            } else if (a.y == g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0;
        }
        return d;
    }
    var e = function(a) {
        var b, c, d, e, f = [], g = new THREE.Path();
        for (b = 0, c = a.length; c > b; b++) d = a[b], e = d.args, d = d.action, d == THREE.PathActions.MOVE_TO && 0 != g.actions.length && (f.push(g), 
        g = new THREE.Path()), g[d].apply(g, e);
        return 0 != g.actions.length && f.push(g), f;
    }(this.actions);
    if (0 == e.length) return [];
    if (!0 === b) return c(e);
    var f, g, h, i = [];
    if (1 == e.length) return g = e[0], h = new THREE.Shape(), h.actions = g.actions, 
    h.curves = g.curves, i.push(h), i;
    var j = !THREE.Shape.Utils.isClockWise(e[0].getPoints()), j = a ? !j : j;
    h = [];
    var k, l = [], m = [], n = 0;
    l[n] = void 0, m[n] = [];
    var o, p;
    for (o = 0, p = e.length; p > o; o++) g = e[o], k = g.getPoints(), f = THREE.Shape.Utils.isClockWise(k), 
    (f = a ? !f : f) ? (!j && l[n] && n++, l[n] = {
        s: new THREE.Shape(),
        p: k
    }, l[n].s.actions = g.actions, l[n].s.curves = g.curves, j && n++, m[n] = []) : m[n].push({
        h: g,
        p: k[0]
    });
    if (!l[0]) return c(e);
    if (1 < l.length) {
        for (o = !1, p = [], g = 0, e = l.length; e > g; g++) h[g] = [];
        for (g = 0, e = l.length; e > g; g++) for (f = m[g], j = 0; j < f.length; j++) {
            n = f[j], k = !0;
            for (var q = 0; q < l.length; q++) d(n.p, l[q].p) && (g != q && p.push({
                froms: g,
                tos: q,
                hole: j
            }), k ? (k = !1, h[q].push(n)) : o = !0);
            k && h[g].push(n);
        }
        0 < p.length && (o || (m = h));
    }
    for (o = 0, p = l.length; p > o; o++) for (h = l[o].s, i.push(h), g = m[o], e = 0, 
    f = g.length; f > e; e++) h.holes.push(g[e].h);
    return i;
}, THREE.Shape = function() {
    THREE.Path.apply(this, arguments), this.holes = [];
}, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.constructor = THREE.Shape, 
THREE.Shape.prototype.extrude = function(a) {
    return new THREE.ExtrudeGeometry(this, a);
}, THREE.Shape.prototype.makeGeometry = function(a) {
    return new THREE.ShapeGeometry(this, a);
}, THREE.Shape.prototype.getPointsHoles = function(a) {
    var b, c = this.holes.length, d = [];
    for (b = 0; c > b; b++) d[b] = this.holes[b].getTransformedPoints(a, this.bends);
    return d;
}, THREE.Shape.prototype.getSpacedPointsHoles = function(a) {
    var b, c = this.holes.length, d = [];
    for (b = 0; c > b; b++) d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
    return d;
}, THREE.Shape.prototype.extractAllPoints = function(a) {
    return {
        shape: this.getTransformedPoints(a),
        holes: this.getPointsHoles(a)
    };
}, THREE.Shape.prototype.extractPoints = function(a) {
    return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a);
}, THREE.Shape.prototype.extractAllSpacedPoints = function(a) {
    return {
        shape: this.getTransformedSpacedPoints(a),
        holes: this.getSpacedPointsHoles(a)
    };
}, THREE.Shape.Utils = {
    triangulateShape: function(a, b) {
        function c(a, b, c) {
            return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y;
        }
        function d(a, b, d, e, f) {
            var g = b.x - a.x, h = b.y - a.y, i = e.x - d.x, j = e.y - d.y, k = a.x - d.x, l = a.y - d.y, m = h * i - g * j, n = h * k - g * l;
            if (1e-10 < Math.abs(m)) {
                if (m > 0) {
                    if (0 > n || n > m) return [];
                    if (i = j * k - i * l, 0 > i || i > m) return [];
                } else {
                    if (n > 0 || m > n) return [];
                    if (i = j * k - i * l, i > 0 || m > i) return [];
                }
                return 0 == i ? !f || 0 != n && n != m ? [ a ] : [] : i == m ? !f || 0 != n && n != m ? [ b ] : [] : 0 == n ? [ d ] : n == m ? [ e ] : (f = i / m, 
                [ {
                    x: a.x + f * g,
                    y: a.y + f * h
                } ]);
            }
            return 0 != n || j * k != i * l ? [] : (h = 0 == g && 0 == h, i = 0 == i && 0 == j, 
            h && i ? a.x != d.x || a.y != d.y ? [] : [ a ] : h ? c(d, e, a) ? [ a ] : [] : i ? c(a, b, d) ? [ d ] : [] : (0 != g ? (a.x < b.x ? (g = a, 
            i = a.x, h = b, a = b.x) : (g = b, i = b.x, h = a, a = a.x), d.x < e.x ? (b = d, 
            m = d.x, j = e, d = e.x) : (b = e, m = e.x, j = d, d = d.x)) : (a.y < b.y ? (g = a, 
            i = a.y, h = b, a = b.y) : (g = b, i = b.y, h = a, a = a.y), d.y < e.y ? (b = d, 
            m = d.y, j = e, d = e.y) : (b = e, m = e.y, j = d, d = d.y)), m >= i ? m > a ? [] : a == m ? f ? [] : [ b ] : d >= a ? [ b, h ] : [ b, j ] : i > d ? [] : i == d ? f ? [] : [ g ] : d >= a ? [ g, h ] : [ g, j ]));
        }
        function e(a, b, c, d) {
            var e = b.x - a.x, f = b.y - a.y;
            b = c.x - a.x, c = c.y - a.y;
            var g = d.x - a.x;
            return d = d.y - a.y, a = e * c - f * b, e = e * d - f * g, 1e-10 < Math.abs(a) ? (b = g * c - d * b, 
            a > 0 ? e >= 0 && b >= 0 : e >= 0 || b >= 0) : e > 0;
        }
        var f, g, h, i, j, k = {};
        for (h = a.concat(), f = 0, g = b.length; g > f; f++) Array.prototype.push.apply(h, b[f]);
        for (f = 0, g = h.length; g > f; f++) j = h[f].x + ":" + h[f].y, void 0 !== k[j] && THREE.warn("THREE.Shape: Duplicate point", j), 
        k[j] = f;
        f = function(a, b) {
            function c(a, b) {
                var c = q.length - 1, d = a - 1;
                0 > d && (d = c);
                var f = a + 1;
                return f > c && (f = 0), (c = e(q[a], q[d], q[f], h[b])) ? (c = h.length - 1, d = b - 1, 
                0 > d && (d = c), f = b + 1, f > c && (f = 0), (c = e(h[b], h[d], h[f], q[a])) ? !0 : !1) : !1;
            }
            function f(a, b) {
                var c, e;
                for (c = 0; c < q.length; c++) if (e = c + 1, e %= q.length, e = d(a, b, q[c], q[e], !0), 
                0 < e.length) return !0;
                return !1;
            }
            function g(a, c) {
                var e, f, g, h;
                for (e = 0; e < r.length; e++) for (f = b[r[e]], g = 0; g < f.length; g++) if (h = g + 1, 
                h %= f.length, h = d(a, c, f[g], f[h], !0), 0 < h.length) return !0;
                return !1;
            }
            var h, i, j, k, l, m, n, o, p, q = a.concat(), r = [], s = [], t = 0;
            for (i = b.length; i > t; t++) r.push(t);
            n = 0;
            for (var u = 2 * r.length; 0 < r.length; ) {
                if (u--, 0 > u) {
                    console.log("Infinite Loop! Holes left:" + r.length + ", Probably Hole outside Shape!");
                    break;
                }
                for (j = n; j < q.length; j++) {
                    for (k = q[j], i = -1, t = 0; t < r.length; t++) if (l = r[t], m = k.x + ":" + k.y + ":" + l, 
                    void 0 === s[m]) {
                        for (h = b[l], o = 0; o < h.length; o++) if (l = h[o], c(j, o) && !f(k, l) && !g(k, l)) {
                            i = o, r.splice(t, 1), n = q.slice(0, j + 1), l = q.slice(j), o = h.slice(i), p = h.slice(0, i + 1), 
                            q = n.concat(o).concat(p).concat(l), n = j;
                            break;
                        }
                        if (i >= 0) break;
                        s[m] = !0;
                    }
                    if (i >= 0) break;
                }
            }
            return q;
        }(a, b);
        var l = THREE.FontUtils.Triangulate(f, !1);
        for (f = 0, g = l.length; g > f; f++) for (i = l[f], h = 0; 3 > h; h++) j = i[h].x + ":" + i[h].y, 
        j = k[j], void 0 !== j && (i[h] = j);
        return l.concat();
    },
    isClockWise: function(a) {
        return 0 > THREE.FontUtils.Triangulate.area(a);
    },
    b2p0: function(a, b) {
        var c = 1 - a;
        return c * c * b;
    },
    b2p1: function(a, b) {
        return 2 * (1 - a) * a * b;
    },
    b2p2: function(a, b) {
        return a * a * b;
    },
    b2: function(a, b, c, d) {
        return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d);
    },
    b3p0: function(a, b) {
        var c = 1 - a;
        return c * c * c * b;
    },
    b3p1: function(a, b) {
        var c = 1 - a;
        return 3 * c * c * a * b;
    },
    b3p2: function(a, b) {
        return 3 * (1 - a) * a * a * b;
    },
    b3p3: function(a, b) {
        return a * a * a * b;
    },
    b3: function(a, b, c, d, e) {
        return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e);
    }
}, THREE.LineCurve = function(a, b) {
    this.v1 = a, this.v2 = b;
}, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.constructor = THREE.LineCurve, 
THREE.LineCurve.prototype.getPoint = function(a) {
    var b = this.v2.clone().sub(this.v1);
    return b.multiplyScalar(a).add(this.v1), b;
}, THREE.LineCurve.prototype.getPointAt = function(a) {
    return this.getPoint(a);
}, THREE.LineCurve.prototype.getTangent = function(a) {
    return this.v2.clone().sub(this.v1).normalize();
}, THREE.QuadraticBezierCurve = function(a, b, c) {
    this.v0 = a, this.v1 = b, this.v2 = c;
}, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), 
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve, THREE.QuadraticBezierCurve.prototype.getPoint = function(a) {
    var b = new THREE.Vector2();
    return b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x), b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y), 
    b;
}, THREE.QuadraticBezierCurve.prototype.getTangent = function(a) {
    var b = new THREE.Vector2();
    return b.x = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x), 
    b.y = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y), 
    b.normalize();
}, THREE.CubicBezierCurve = function(a, b, c, d) {
    this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d;
}, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve, 
THREE.CubicBezierCurve.prototype.getPoint = function(a) {
    var b;
    return b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), 
    a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(b, a);
}, THREE.CubicBezierCurve.prototype.getTangent = function(a) {
    var b;
    return b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), 
    a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), 
    b = new THREE.Vector2(b, a), b.normalize(), b;
}, THREE.SplineCurve = function(a) {
    this.points = void 0 == a ? [] : a;
}, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.constructor = THREE.SplineCurve, 
THREE.SplineCurve.prototype.getPoint = function(a) {
    var b = this.points;
    a *= b.length - 1;
    var c = Math.floor(a);
    a -= c;
    var d = b[0 == c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = new THREE.Vector2();
    return c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a), c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a), 
    c;
}, THREE.EllipseCurve = function(a, b, c, d, e, f, g) {
    this.aX = a, this.aY = b, this.xRadius = c, this.yRadius = d, this.aStartAngle = e, 
    this.aEndAngle = f, this.aClockwise = g;
}, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve, 
THREE.EllipseCurve.prototype.getPoint = function(a) {
    var b = this.aEndAngle - this.aStartAngle;
    return 0 > b && (b += 2 * Math.PI), b > 2 * Math.PI && (b -= 2 * Math.PI), a = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b, 
    b = new THREE.Vector2(), b.x = this.aX + this.xRadius * Math.cos(a), b.y = this.aY + this.yRadius * Math.sin(a), 
    b;
}, THREE.ArcCurve = function(a, b, c, d, e, f) {
    THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);
}, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.ArcCurve.prototype.constructor = THREE.ArcCurve, 
THREE.LineCurve3 = THREE.Curve.create(function(a, b) {
    this.v1 = a, this.v2 = b;
}, function(a) {
    var b = new THREE.Vector3();
    return b.subVectors(this.v2, this.v1), b.multiplyScalar(a), b.add(this.v1), b;
}), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(a, b, c) {
    this.v0 = a, this.v1 = b, this.v2 = c;
}, function(a) {
    var b = new THREE.Vector3();
    return b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x), b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y), 
    b.z = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z), b;
}), THREE.CubicBezierCurve3 = THREE.Curve.create(function(a, b, c, d) {
    this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d;
}, function(a) {
    var b = new THREE.Vector3();
    return b.x = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), 
    b.y = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b.z = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z), 
    b;
}), THREE.SplineCurve3 = THREE.Curve.create(function(a) {
    this.points = void 0 == a ? [] : a;
}, function(a) {
    var b = this.points;
    a *= b.length - 1;
    var c = Math.floor(a);
    a -= c;
    var d = b[0 == c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = new THREE.Vector3();
    return c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a), c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a), 
    c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a), c;
}), THREE.ClosedSplineCurve3 = THREE.Curve.create(function(a) {
    this.points = void 0 == a ? [] : a;
}, function(a) {
    var b = this.points;
    a *= b.length - 0;
    var c = Math.floor(a);
    a -= c;
    var c = c + (c > 0 ? 0 : (Math.floor(Math.abs(c) / b.length) + 1) * b.length), d = b[(c - 1) % b.length], e = b[c % b.length], f = b[(c + 1) % b.length], b = b[(c + 2) % b.length], c = new THREE.Vector3();
    return c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a), c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a), 
    c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a), c;
}), THREE.AnimationHandler = {
    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2,
    add: function() {
        THREE.warn("THREE.AnimationHandler.add() has been deprecated.");
    },
    get: function() {
        THREE.warn("THREE.AnimationHandler.get() has been deprecated.");
    },
    remove: function() {
        THREE.warn("THREE.AnimationHandler.remove() has been deprecated.");
    },
    animations: [],
    init: function(a) {
        if (!0 === a.initialized) return a;
        for (var b = 0; b < a.hierarchy.length; b++) {
            for (var c = 0; c < a.hierarchy[b].keys.length; c++) if (0 > a.hierarchy[b].keys[c].time && (a.hierarchy[b].keys[c].time = 0), 
            void 0 !== a.hierarchy[b].keys[c].rot && !(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)) {
                var d = a.hierarchy[b].keys[c].rot;
                a.hierarchy[b].keys[c].rot = new THREE.Quaternion().fromArray(d);
            }
            if (a.hierarchy[b].keys.length && void 0 !== a.hierarchy[b].keys[0].morphTargets) {
                for (d = {}, c = 0; c < a.hierarchy[b].keys.length; c++) for (var e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) {
                    var f = a.hierarchy[b].keys[c].morphTargets[e];
                    d[f] = -1;
                }
                for (a.hierarchy[b].usedMorphTargets = d, c = 0; c < a.hierarchy[b].keys.length; c++) {
                    var g = {};
                    for (f in d) {
                        for (e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) if (a.hierarchy[b].keys[c].morphTargets[e] === f) {
                            g[f] = a.hierarchy[b].keys[c].morphTargetsInfluences[e];
                            break;
                        }
                        e === a.hierarchy[b].keys[c].morphTargets.length && (g[f] = 0);
                    }
                    a.hierarchy[b].keys[c].morphTargetsInfluences = g;
                }
            }
            for (c = 1; c < a.hierarchy[b].keys.length; c++) a.hierarchy[b].keys[c].time === a.hierarchy[b].keys[c - 1].time && (a.hierarchy[b].keys.splice(c, 1), 
            c--);
            for (c = 0; c < a.hierarchy[b].keys.length; c++) a.hierarchy[b].keys[c].index = c;
        }
        return a.initialized = !0, a;
    },
    parse: function(a) {
        var b = function(a, c) {
            c.push(a);
            for (var d = 0; d < a.children.length; d++) b(a.children[d], c);
        }, c = [];
        if (a instanceof THREE.SkinnedMesh) for (var d = 0; d < a.skeleton.bones.length; d++) c.push(a.skeleton.bones[d]); else b(a, c);
        return c;
    },
    play: function(a) {
        -1 === this.animations.indexOf(a) && this.animations.push(a);
    },
    stop: function(a) {
        a = this.animations.indexOf(a), -1 !== a && this.animations.splice(a, 1);
    },
    update: function(a) {
        for (var b = 0; b < this.animations.length; b++) this.animations[b].resetBlendWeights();
        for (b = 0; b < this.animations.length; b++) this.animations[b].update(a);
    }
}, THREE.Animation = function(a, b) {
    this.root = a, this.data = THREE.AnimationHandler.init(b), this.hierarchy = THREE.AnimationHandler.parse(a), 
    this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, 
    this.interpolationType = THREE.AnimationHandler.LINEAR;
}, THREE.Animation.prototype = {
    constructor: THREE.Animation,
    keyTypes: [ "pos", "rot", "scl" ],
    play: function(a, b) {
        this.currentTime = void 0 !== a ? a : 0, this.weight = void 0 !== b ? b : 1, this.isPlaying = !0, 
        this.reset(), THREE.AnimationHandler.play(this);
    },
    stop: function() {
        this.isPlaying = !1, THREE.AnimationHandler.stop(this);
    },
    reset: function() {
        for (var a = 0, b = this.hierarchy.length; b > a; a++) {
            var c = this.hierarchy[a];
            void 0 === c.animationCache && (c.animationCache = {
                animations: {},
                blending: {
                    positionWeight: 0,
                    quaternionWeight: 0,
                    scaleWeight: 0
                }
            });
            var d = this.data.name, e = c.animationCache.animations, f = e[d];
            for (void 0 === f && (f = {
                prevKey: {
                    pos: 0,
                    rot: 0,
                    scl: 0
                },
                nextKey: {
                    pos: 0,
                    rot: 0,
                    scl: 0
                },
                originalMatrix: c.matrix
            }, e[d] = f), c = 0; 3 > c; c++) {
                for (var d = this.keyTypes[c], e = this.data.hierarchy[a].keys[0], g = this.getNextKeyWith(d, a, 1); g.time < this.currentTime && g.index > e.index; ) e = g, 
                g = this.getNextKeyWith(d, a, g.index + 1);
                f.prevKey[d] = e, f.nextKey[d] = g;
            }
        }
    },
    resetBlendWeights: function() {
        for (var a = 0, b = this.hierarchy.length; b > a; a++) {
            var c = this.hierarchy[a].animationCache;
            void 0 !== c && (c = c.blending, c.positionWeight = 0, c.quaternionWeight = 0, c.scaleWeight = 0);
        }
    },
    update: function() {
        var a = [], b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Quaternion(), e = function(a, b) {
            var c, d, e, g, h, i, j = [], k = [];
            return c = (a.length - 1) * b, d = Math.floor(c), c -= d, j[0] = 0 === d ? d : d - 1, 
            j[1] = d, j[2] = d > a.length - 2 ? d : d + 1, j[3] = d > a.length - 3 ? d : d + 2, 
            d = a[j[0]], g = a[j[1]], h = a[j[2]], i = a[j[3]], j = c * c, e = c * j, k[0] = f(d[0], g[0], h[0], i[0], c, j, e), 
            k[1] = f(d[1], g[1], h[1], i[1], c, j, e), k[2] = f(d[2], g[2], h[2], i[2], c, j, e), 
            k;
        }, f = function(a, b, c, d, e, f, g) {
            return a = .5 * (c - a), d = .5 * (d - b), (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
        };
        return function(f) {
            if (!1 !== this.isPlaying && (this.currentTime += f * this.timeScale, 0 !== this.weight)) {
                f = this.data.length, (this.currentTime > f || 0 > this.currentTime) && (this.loop ? (this.currentTime %= f, 
                0 > this.currentTime && (this.currentTime += f), this.reset()) : this.stop()), f = 0;
                for (var g = this.hierarchy.length; g > f; f++) for (var h = this.hierarchy[f], i = h.animationCache.animations[this.data.name], j = h.animationCache.blending, k = 0; 3 > k; k++) {
                    var l = this.keyTypes[k], m = i.prevKey[l], n = i.nextKey[l];
                    if (0 < this.timeScale && n.time <= this.currentTime || 0 > this.timeScale && m.time >= this.currentTime) {
                        for (m = this.data.hierarchy[f].keys[0], n = this.getNextKeyWith(l, f, 1); n.time < this.currentTime && n.index > m.index; ) m = n, 
                        n = this.getNextKeyWith(l, f, n.index + 1);
                        i.prevKey[l] = m, i.nextKey[l] = n;
                    }
                    var o = (this.currentTime - m.time) / (n.time - m.time), p = m[l], q = n[l];
                    0 > o && (o = 0), o > 1 && (o = 1), "pos" === l ? this.interpolationType === THREE.AnimationHandler.LINEAR ? (c.x = p[0] + (q[0] - p[0]) * o, 
                    c.y = p[1] + (q[1] - p[1]) * o, c.z = p[2] + (q[2] - p[2]) * o, m = this.weight / (this.weight + j.positionWeight), 
                    h.position.lerp(c, m), j.positionWeight += this.weight) : (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) && (a[0] = this.getPrevKeyWith("pos", f, m.index - 1).pos, 
                    a[1] = p, a[2] = q, a[3] = this.getNextKeyWith("pos", f, n.index + 1).pos, o = .33 * o + .33, 
                    n = e(a, o), m = this.weight / (this.weight + j.positionWeight), j.positionWeight += this.weight, 
                    l = h.position, l.x += (n[0] - l.x) * m, l.y += (n[1] - l.y) * m, l.z += (n[2] - l.z) * m, 
                    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (o = e(a, 1.01 * o), 
                    b.set(o[0], o[1], o[2]), b.sub(l), b.y = 0, b.normalize(), o = Math.atan2(b.x, b.z), 
                    h.rotation.set(0, o, 0))) : "rot" === l ? (THREE.Quaternion.slerp(p, q, d, o), 0 === j.quaternionWeight ? (h.quaternion.copy(d), 
                    j.quaternionWeight = this.weight) : (m = this.weight / (this.weight + j.quaternionWeight), 
                    THREE.Quaternion.slerp(h.quaternion, d, h.quaternion, m), j.quaternionWeight += this.weight)) : "scl" === l && (c.x = p[0] + (q[0] - p[0]) * o, 
                    c.y = p[1] + (q[1] - p[1]) * o, c.z = p[2] + (q[2] - p[2]) * o, m = this.weight / (this.weight + j.scaleWeight), 
                    h.scale.lerp(c, m), j.scaleWeight += this.weight);
                }
                return !0;
            }
        };
    }(),
    getNextKeyWith: function(a, b, c) {
        var d = this.data.hierarchy[b].keys;
        for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++) if (void 0 !== d[c][a]) return d[c];
        return this.data.hierarchy[b].keys[0];
    },
    getPrevKeyWith: function(a, b, c) {
        var d = this.data.hierarchy[b].keys;
        for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c > 0 ? c : 0 : c >= 0 ? c : c + d.length; c >= 0; c--) if (void 0 !== d[c][a]) return d[c];
        return this.data.hierarchy[b].keys[d.length - 1];
    }
}, THREE.KeyFrameAnimation = function(a) {
    this.root = a.node, this.data = THREE.AnimationHandler.init(a), this.hierarchy = THREE.AnimationHandler.parse(this.root), 
    this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.loop = this.isPaused = !0, 
    a = 0;
    for (var b = this.hierarchy.length; b > a; a++) {
        var c = this.data.hierarchy[a].sids, d = this.hierarchy[a];
        if (this.data.hierarchy[a].keys.length && c) {
            for (var e = 0; e < c.length; e++) {
                var f = c[e], g = this.getNextKeyWith(f, a, 0);
                g && g.apply(f);
            }
            d.matrixAutoUpdate = !1, this.data.hierarchy[a].node.updateMatrix(), d.matrixWorldNeedsUpdate = !0;
        }
    }
}, THREE.KeyFrameAnimation.prototype = {
    constructor: THREE.KeyFrameAnimation,
    play: function(a) {
        if (this.currentTime = void 0 !== a ? a : 0, !1 === this.isPlaying) {
            this.isPlaying = !0;
            var b, c, d = this.hierarchy.length;
            for (a = 0; d > a; a++) b = this.hierarchy[a], c = this.data.hierarchy[a], void 0 === c.animationCache && (c.animationCache = {}, 
            c.animationCache.prevKey = null, c.animationCache.nextKey = null, c.animationCache.originalMatrix = b.matrix), 
            b = this.data.hierarchy[a].keys, b.length && (c.animationCache.prevKey = b[0], c.animationCache.nextKey = b[1], 
            this.startTime = Math.min(b[0].time, this.startTime), this.endTime = Math.max(b[b.length - 1].time, this.endTime));
            this.update(0);
        }
        this.isPaused = !1, THREE.AnimationHandler.play(this);
    },
    stop: function() {
        this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.stop(this);
        for (var a = 0; a < this.data.hierarchy.length; a++) {
            var b = this.hierarchy[a], c = this.data.hierarchy[a];
            if (void 0 !== c.animationCache) {
                var d = c.animationCache.originalMatrix;
                d.copy(b.matrix), b.matrix = d, delete c.animationCache;
            }
        }
    },
    update: function(a) {
        if (!1 !== this.isPlaying) {
            this.currentTime += a * this.timeScale, a = this.data.length, !0 === this.loop && this.currentTime > a && (this.currentTime %= a), 
            this.currentTime = Math.min(this.currentTime, a), a = 0;
            for (var b = this.hierarchy.length; b > a; a++) {
                var c = this.hierarchy[a], d = this.data.hierarchy[a], e = d.keys, d = d.animationCache;
                if (e.length) {
                    var f = d.prevKey, g = d.nextKey;
                    if (g.time <= this.currentTime) {
                        for (;g.time < this.currentTime && g.index > f.index; ) f = g, g = e[f.index + 1];
                        d.prevKey = f, d.nextKey = g;
                    }
                    g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time), 
                    this.data.hierarchy[a].node.updateMatrix(), c.matrixWorldNeedsUpdate = !0;
                }
            }
        }
    },
    getNextKeyWith: function(a, b, c) {
        for (b = this.data.hierarchy[b].keys, c %= b.length; c < b.length; c++) if (b[c].hasTarget(a)) return b[c];
        return b[0];
    },
    getPrevKeyWith: function(a, b, c) {
        for (b = this.data.hierarchy[b].keys, c = c >= 0 ? c : c + b.length; c >= 0; c--) if (b[c].hasTarget(a)) return b[c];
        return b[b.length - 1];
    }
}, THREE.MorphAnimation = function(a) {
    this.mesh = a, this.frames = a.morphTargetInfluences.length, this.currentTime = 0, 
    this.duration = 1e3, this.loop = !0, this.currentFrame = this.lastFrame = 0, this.isPlaying = !1;
}, THREE.MorphAnimation.prototype = {
    constructor: THREE.MorphAnimation,
    play: function() {
        this.isPlaying = !0;
    },
    pause: function() {
        this.isPlaying = !1;
    },
    update: function(a) {
        if (!1 !== this.isPlaying) {
            this.currentTime += a, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), 
            this.currentTime = Math.min(this.currentTime, this.duration), a = this.duration / this.frames;
            var b = Math.floor(this.currentTime / a), c = this.mesh.morphTargetInfluences;
            b != this.currentFrame && (c[this.lastFrame] = 0, c[this.currentFrame] = 1, c[b] = 0, 
            this.lastFrame = this.currentFrame, this.currentFrame = b), c[b] = this.currentTime % a / a, 
            c[this.lastFrame] = 1 - c[b];
        }
    }
}, THREE.BoxGeometry = function(a, b, c, d, e, f) {
    function g(a, b, c, d, e, f, g, i) {
        var j, k = h.widthSegments, l = h.heightSegments, m = e / 2, n = f / 2, o = h.vertices.length;
        "x" === a && "y" === b || "y" === a && "x" === b ? j = "z" : "x" === a && "z" === b || "z" === a && "x" === b ? (j = "y", 
        l = h.depthSegments) : ("z" === a && "y" === b || "y" === a && "z" === b) && (j = "x", 
        k = h.depthSegments);
        var p = k + 1, q = l + 1, r = e / k, s = f / l, t = new THREE.Vector3();
        for (t[j] = g > 0 ? 1 : -1, e = 0; q > e; e++) for (f = 0; p > f; f++) {
            var u = new THREE.Vector3();
            u[a] = (f * r - m) * c, u[b] = (e * s - n) * d, u[j] = g, h.vertices.push(u);
        }
        for (e = 0; l > e; e++) for (f = 0; k > f; f++) n = f + p * e, a = f + p * (e + 1), 
        b = f + 1 + p * (e + 1), c = f + 1 + p * e, d = new THREE.Vector2(f / k, 1 - e / l), 
        g = new THREE.Vector2(f / k, 1 - (e + 1) / l), j = new THREE.Vector2((f + 1) / k, 1 - (e + 1) / l), 
        m = new THREE.Vector2((f + 1) / k, 1 - e / l), n = new THREE.Face3(n + o, a + o, c + o), 
        n.normal.copy(t), n.vertexNormals.push(t.clone(), t.clone(), t.clone()), n.materialIndex = i, 
        h.faces.push(n), h.faceVertexUvs[0].push([ d, g, m ]), n = new THREE.Face3(a + o, b + o, c + o), 
        n.normal.copy(t), n.vertexNormals.push(t.clone(), t.clone(), t.clone()), n.materialIndex = i, 
        h.faces.push(n), h.faceVertexUvs[0].push([ g.clone(), j, m.clone() ]);
    }
    THREE.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
        width: a,
        height: b,
        depth: c,
        widthSegments: d,
        heightSegments: e,
        depthSegments: f
    }, this.widthSegments = d || 1, this.heightSegments = e || 1, this.depthSegments = f || 1;
    var h = this;
    d = a / 2, e = b / 2, f = c / 2, g("z", "y", -1, -1, c, b, d, 0), g("z", "y", 1, -1, c, b, -d, 1), 
    g("x", "z", 1, 1, a, c, e, 2), g("x", "z", 1, -1, a, c, -e, 3), g("x", "y", 1, -1, a, b, f, 4), 
    g("x", "y", -1, -1, a, b, -f, 5), this.mergeVertices();
}, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry, 
THREE.CircleGeometry = function(a, b, c, d) {
    THREE.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
        radius: a,
        segments: b,
        thetaStart: c,
        thetaLength: d
    }, a = a || 50, b = void 0 !== b ? Math.max(3, b) : 8, c = void 0 !== c ? c : 0, 
    d = void 0 !== d ? d : 2 * Math.PI;
    var e, f = [];
    e = new THREE.Vector3();
    var g = new THREE.Vector2(.5, .5);
    for (this.vertices.push(e), f.push(g), e = 0; b >= e; e++) {
        var h = new THREE.Vector3(), i = c + e / b * d;
        h.x = a * Math.cos(i), h.y = a * Math.sin(i), this.vertices.push(h), f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2));
    }
    for (c = new THREE.Vector3(0, 0, 1), e = 1; b >= e; e++) this.faces.push(new THREE.Face3(e, e + 1, 0, [ c.clone(), c.clone(), c.clone() ])), 
    this.faceVertexUvs[0].push([ f[e].clone(), f[e + 1].clone(), g.clone() ]);
    this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
}, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry, 
THREE.CubeGeometry = function(a, b, c, d, e, f) {
    return THREE.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry."), 
    new THREE.BoxGeometry(a, b, c, d, e, f);
}, THREE.CylinderGeometry = function(a, b, c, d, e, f, g, h) {
    THREE.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
        radiusTop: a,
        radiusBottom: b,
        height: c,
        radialSegments: d,
        heightSegments: e,
        openEnded: f,
        thetaStart: g,
        thetaLength: h
    }, a = void 0 !== a ? a : 20, b = void 0 !== b ? b : 20, c = void 0 !== c ? c : 100, 
    d = d || 8, e = e || 1, f = void 0 !== f ? f : !1, g = void 0 !== g ? g : 0, h = void 0 !== h ? h : 2 * Math.PI;
    var i, j, k = c / 2, l = [], m = [];
    for (j = 0; e >= j; j++) {
        var n = [], o = [], p = j / e, q = p * (b - a) + a;
        for (i = 0; d >= i; i++) {
            var r = i / d, s = new THREE.Vector3();
            s.x = q * Math.sin(r * h + g), s.y = -p * c + k, s.z = q * Math.cos(r * h + g), 
            this.vertices.push(s), n.push(this.vertices.length - 1), o.push(new THREE.Vector2(r, 1 - p));
        }
        l.push(n), m.push(o);
    }
    for (c = (b - a) / c, i = 0; d > i; i++) for (0 !== a ? (g = this.vertices[l[0][i]].clone(), 
    h = this.vertices[l[0][i + 1]].clone()) : (g = this.vertices[l[1][i]].clone(), h = this.vertices[l[1][i + 1]].clone()), 
    g.setY(Math.sqrt(g.x * g.x + g.z * g.z) * c).normalize(), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * c).normalize(), 
    j = 0; e > j; j++) {
        var n = l[j][i], o = l[j + 1][i], p = l[j + 1][i + 1], q = l[j][i + 1], r = g.clone(), s = g.clone(), t = h.clone(), u = h.clone(), v = m[j][i].clone(), w = m[j + 1][i].clone(), x = m[j + 1][i + 1].clone(), y = m[j][i + 1].clone();
        this.faces.push(new THREE.Face3(n, o, q, [ r, s, u ])), this.faceVertexUvs[0].push([ v, w, y ]), 
        this.faces.push(new THREE.Face3(o, p, q, [ s.clone(), t, u.clone() ])), this.faceVertexUvs[0].push([ w.clone(), x, y.clone() ]);
    }
    if (!1 === f && a > 0) for (this.vertices.push(new THREE.Vector3(0, k, 0)), i = 0; d > i; i++) n = l[0][i], 
    o = l[0][i + 1], p = this.vertices.length - 1, r = new THREE.Vector3(0, 1, 0), s = new THREE.Vector3(0, 1, 0), 
    t = new THREE.Vector3(0, 1, 0), v = m[0][i].clone(), w = m[0][i + 1].clone(), x = new THREE.Vector2(w.x, 0), 
    this.faces.push(new THREE.Face3(n, o, p, [ r, s, t ])), this.faceVertexUvs[0].push([ v, w, x ]);
    if (!1 === f && b > 0) for (this.vertices.push(new THREE.Vector3(0, -k, 0)), i = 0; d > i; i++) n = l[e][i + 1], 
    o = l[e][i], p = this.vertices.length - 1, r = new THREE.Vector3(0, -1, 0), s = new THREE.Vector3(0, -1, 0), 
    t = new THREE.Vector3(0, -1, 0), v = m[e][i + 1].clone(), w = m[e][i].clone(), x = new THREE.Vector2(w.x, 1), 
    this.faces.push(new THREE.Face3(n, o, p, [ r, s, t ])), this.faceVertexUvs[0].push([ v, w, x ]);
    this.computeFaceNormals();
}, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry, 
THREE.ExtrudeGeometry = function(a, b) {
    "undefined" != typeof a && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", 
    a = a instanceof Array ? a : [ a ], this.addShapeList(a, b), this.computeFaceNormals());
}, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry, 
THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = a.length, d = 0; c > d; d++) this.addShape(a[d], b);
}, THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
    function c(a, b, c) {
        return b || THREE.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(c).add(a);
    }
    function d(a, b, c) {
        var d = 1, d = a.x - b.x, e = a.y - b.y, f = c.x - a.x, g = c.y - a.y, h = d * d + e * e;
        if (1e-10 < Math.abs(d * g - e * f)) {
            var i = Math.sqrt(h), j = Math.sqrt(f * f + g * g), h = b.x - e / i;
            if (b = b.y + d / i, f = ((c.x - g / j - h) * g - (c.y + f / j - b) * f) / (d * g - e * f), 
            c = h + d * f - a.x, a = b + e * f - a.y, d = c * c + a * a, 2 >= d) return new THREE.Vector2(c, a);
            d = Math.sqrt(d / 2);
        } else a = !1, d > 1e-10 ? f > 1e-10 && (a = !0) : -1e-10 > d ? -1e-10 > f && (a = !0) : Math.sign(e) == Math.sign(g) && (a = !0), 
        a ? (c = -e, a = d, d = Math.sqrt(h)) : (c = d, a = e, d = Math.sqrt(h / 2));
        return new THREE.Vector2(c / d, a / d);
    }
    function e(a, b) {
        var c, d;
        for (O = a.length; 0 <= --O; ) {
            c = O, d = O - 1, 0 > d && (d = a.length - 1);
            for (var e = 0, f = s + 2 * p, e = 0; f > e; e++) {
                var g = M * e, h = M * (e + 1), i = b + c + g, g = b + d + g, j = b + d + h, h = b + c + h, i = i + C, g = g + C, j = j + C, h = h + C;
                B.faces.push(new THREE.Face3(i, g, h, null, null, w)), B.faces.push(new THREE.Face3(g, j, h, null, null, w)), 
                i = x.generateSideWallUV(B, i, g, j, h), B.faceVertexUvs[0].push([ i[0], i[1], i[3] ]), 
                B.faceVertexUvs[0].push([ i[1], i[2], i[3] ]);
            }
        }
    }
    function f(a, b, c) {
        B.vertices.push(new THREE.Vector3(a, b, c));
    }
    function g(a, b, c) {
        a += C, b += C, c += C, B.faces.push(new THREE.Face3(a, b, c, null, null, v)), a = x.generateTopUV(B, a, b, c), 
        B.faceVertexUvs[0].push(a);
    }
    var h, i, j, k, l, m = void 0 !== b.amount ? b.amount : 100, n = void 0 !== b.bevelThickness ? b.bevelThickness : 6, o = void 0 !== b.bevelSize ? b.bevelSize : n - 2, p = void 0 !== b.bevelSegments ? b.bevelSegments : 3, q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, r = void 0 !== b.curveSegments ? b.curveSegments : 12, s = void 0 !== b.steps ? b.steps : 1, t = b.extrudePath, u = !1, v = b.material, w = b.extrudeMaterial, x = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
    t && (h = t.getSpacedPoints(s), u = !0, q = !1, i = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(t, s, !1), 
    j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3()), q || (o = n = p = 0);
    var y, z, A, B = this, C = this.vertices.length, t = a.extractPoints(r), r = t.shape, D = t.holes;
    if (t = !THREE.Shape.Utils.isClockWise(r)) {
        for (r = r.reverse(), z = 0, A = D.length; A > z; z++) y = D[z], THREE.Shape.Utils.isClockWise(y) && (D[z] = y.reverse());
        t = !1;
    }
    var E = THREE.Shape.Utils.triangulateShape(r, D), F = r;
    for (z = 0, A = D.length; A > z; z++) y = D[z], r = r.concat(y);
    var G, H, I, J, K, L, M = r.length, N = E.length, t = [], O = 0;
    for (I = F.length, G = I - 1, H = O + 1; I > O; O++, G++, H++) G === I && (G = 0), 
    H === I && (H = 0), t[O] = d(F[O], F[G], F[H]);
    var P, Q = [], R = t.concat();
    for (z = 0, A = D.length; A > z; z++) {
        for (y = D[z], P = [], O = 0, I = y.length, G = I - 1, H = O + 1; I > O; O++, G++, 
        H++) G === I && (G = 0), H === I && (H = 0), P[O] = d(y[O], y[G], y[H]);
        Q.push(P), R = R.concat(P);
    }
    for (G = 0; p > G; G++) {
        for (I = G / p, J = n * (1 - I), H = o * Math.sin(I * Math.PI / 2), O = 0, I = F.length; I > O; O++) K = c(F[O], t[O], H), 
        f(K.x, K.y, -J);
        for (z = 0, A = D.length; A > z; z++) for (y = D[z], P = Q[z], O = 0, I = y.length; I > O; O++) K = c(y[O], P[O], H), 
        f(K.x, K.y, -J);
    }
    for (H = o, O = 0; M > O; O++) K = q ? c(r[O], R[O], H) : r[O], u ? (k.copy(i.normals[0]).multiplyScalar(K.x), 
    j.copy(i.binormals[0]).multiplyScalar(K.y), l.copy(h[0]).add(k).add(j), f(l.x, l.y, l.z)) : f(K.x, K.y, 0);
    for (I = 1; s >= I; I++) for (O = 0; M > O; O++) K = q ? c(r[O], R[O], H) : r[O], 
    u ? (k.copy(i.normals[I]).multiplyScalar(K.x), j.copy(i.binormals[I]).multiplyScalar(K.y), 
    l.copy(h[I]).add(k).add(j), f(l.x, l.y, l.z)) : f(K.x, K.y, m / s * I);
    for (G = p - 1; G >= 0; G--) {
        for (I = G / p, J = n * (1 - I), H = o * Math.sin(I * Math.PI / 2), O = 0, I = F.length; I > O; O++) K = c(F[O], t[O], H), 
        f(K.x, K.y, m + J);
        for (z = 0, A = D.length; A > z; z++) for (y = D[z], P = Q[z], O = 0, I = y.length; I > O; O++) K = c(y[O], P[O], H), 
        u ? f(K.x, K.y + h[s - 1].y, h[s - 1].x + J) : f(K.x, K.y, m + J);
    }
    !function() {
        if (q) {
            var a;
            for (a = 0 * M, O = 0; N > O; O++) L = E[O], g(L[2] + a, L[1] + a, L[0] + a);
            for (a = s + 2 * p, a *= M, O = 0; N > O; O++) L = E[O], g(L[0] + a, L[1] + a, L[2] + a);
        } else {
            for (O = 0; N > O; O++) L = E[O], g(L[2], L[1], L[0]);
            for (O = 0; N > O; O++) L = E[O], g(L[0] + M * s, L[1] + M * s, L[2] + M * s);
        }
    }(), function() {
        var a = 0;
        for (e(F, a), a += F.length, z = 0, A = D.length; A > z; z++) y = D[z], e(y, a), 
        a += y.length;
    }();
}, THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(a, b, c, d) {
        return a = a.vertices, b = a[b], c = a[c], d = a[d], [ new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y), new THREE.Vector2(d.x, d.y) ];
    },
    generateSideWallUV: function(a, b, c, d, e) {
        return a = a.vertices, b = a[b], c = a[c], d = a[d], e = a[e], .01 > Math.abs(b.y - c.y) ? [ new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z) ] : [ new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z), new THREE.Vector2(e.y, 1 - e.z) ];
    }
}, THREE.ShapeGeometry = function(a, b) {
    THREE.Geometry.call(this), this.type = "ShapeGeometry", !1 == a instanceof Array && (a = [ a ]), 
    this.addShapeList(a, b), this.computeFaceNormals();
}, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry, 
THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = 0, d = a.length; d > c; c++) this.addShape(a[c], b);
    return this;
}, THREE.ShapeGeometry.prototype.addShape = function(a, b) {
    void 0 === b && (b = {});
    var c, d, e, f = b.material, g = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, h = this.vertices.length;
    c = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
    var i = c.shape, j = c.holes;
    if (!THREE.Shape.Utils.isClockWise(i)) for (i = i.reverse(), c = 0, d = j.length; d > c; c++) e = j[c], 
    THREE.Shape.Utils.isClockWise(e) && (j[c] = e.reverse());
    var k = THREE.Shape.Utils.triangulateShape(i, j);
    for (c = 0, d = j.length; d > c; c++) e = j[c], i = i.concat(e);
    for (j = i.length, d = k.length, c = 0; j > c; c++) e = i[c], this.vertices.push(new THREE.Vector3(e.x, e.y, 0));
    for (c = 0; d > c; c++) j = k[c], i = j[0] + h, e = j[1] + h, j = j[2] + h, this.faces.push(new THREE.Face3(i, e, j, null, null, f)), 
    this.faceVertexUvs[0].push(g.generateTopUV(this, i, e, j));
}, THREE.LatheGeometry = function(a, b, c, d) {
    THREE.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
        points: a,
        segments: b,
        phiStart: c,
        phiLength: d
    }, b = b || 12, c = c || 0, d = d || 2 * Math.PI;
    for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; h >= g; g++) for (var i = c + g * f * d, j = Math.cos(i), k = Math.sin(i), i = 0, l = a.length; l > i; i++) {
        var m = a[i], n = new THREE.Vector3();
        n.x = j * m.x - k * m.y, n.y = k * m.x + j * m.y, n.z = m.z, this.vertices.push(n);
    }
    for (c = a.length, g = 0, h = b; h > g; g++) for (i = 0, l = a.length - 1; l > i; i++) {
        b = k = i + c * g, d = k + c;
        var j = k + 1 + c, k = k + 1, m = g * f, n = i * e, o = m + f, p = n + e;
        this.faces.push(new THREE.Face3(b, d, k)), this.faceVertexUvs[0].push([ new THREE.Vector2(m, n), new THREE.Vector2(o, n), new THREE.Vector2(m, p) ]), 
        this.faces.push(new THREE.Face3(d, j, k)), this.faceVertexUvs[0].push([ new THREE.Vector2(o, n), new THREE.Vector2(o, p), new THREE.Vector2(m, p) ]);
    }
    this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry, 
THREE.PlaneGeometry = function(a, b, c, d) {
    console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint."), 
    THREE.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    }, this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d));
}, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry, 
THREE.PlaneBufferGeometry = function(a, b, c, d) {
    THREE.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    };
    var e = a / 2, f = b / 2;
    c = c || 1, d = d || 1;
    var g = c + 1, h = d + 1, i = a / c, j = b / d;
    b = new Float32Array(g * h * 3), a = new Float32Array(g * h * 3);
    for (var k = new Float32Array(g * h * 2), l = 0, m = 0, n = 0; h > n; n++) for (var o = n * j - f, p = 0; g > p; p++) b[l] = p * i - e, 
    b[l + 1] = -o, a[l + 2] = 1, k[m] = p / c, k[m + 1] = 1 - n / d, l += 3, m += 2;
    for (l = 0, e = new (65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6), 
    n = 0; d > n; n++) for (p = 0; c > p; p++) f = p + g * (n + 1), h = p + 1 + g * (n + 1), 
    i = p + 1 + g * n, e[l] = p + g * n, e[l + 1] = f, e[l + 2] = i, e[l + 3] = f, e[l + 4] = h, 
    e[l + 5] = i, l += 6;
    this.addAttribute("index", new THREE.BufferAttribute(e, 1)), this.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    this.addAttribute("normal", new THREE.BufferAttribute(a, 3)), this.addAttribute("uv", new THREE.BufferAttribute(k, 2));
}, THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry, THREE.RingGeometry = function(a, b, c, d, e, f) {
    THREE.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
        innerRadius: a,
        outerRadius: b,
        thetaSegments: c,
        phiSegments: d,
        thetaStart: e,
        thetaLength: f
    }, a = a || 0, b = b || 50, e = void 0 !== e ? e : 0, f = void 0 !== f ? f : 2 * Math.PI, 
    c = void 0 !== c ? Math.max(3, c) : 8, d = void 0 !== d ? Math.max(1, d) : 8;
    var g, h = [], i = a, j = (b - a) / d;
    for (a = 0; d + 1 > a; a++) {
        for (g = 0; c + 1 > g; g++) {
            var k = new THREE.Vector3(), l = e + g / c * f;
            k.x = i * Math.cos(l), k.y = i * Math.sin(l), this.vertices.push(k), h.push(new THREE.Vector2((k.x / b + 1) / 2, (k.y / b + 1) / 2));
        }
        i += j;
    }
    for (b = new THREE.Vector3(0, 0, 1), a = 0; d > a; a++) for (e = a * (c + 1), g = 0; c > g; g++) f = l = g + e, 
    j = l + c + 1, k = l + c + 2, this.faces.push(new THREE.Face3(f, j, k, [ b.clone(), b.clone(), b.clone() ])), 
    this.faceVertexUvs[0].push([ h[f].clone(), h[j].clone(), h[k].clone() ]), f = l, 
    j = l + c + 2, k = l + 1, this.faces.push(new THREE.Face3(f, j, k, [ b.clone(), b.clone(), b.clone() ])), 
    this.faceVertexUvs[0].push([ h[f].clone(), h[j].clone(), h[k].clone() ]);
    this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), i);
}, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry.prototype.constructor = THREE.RingGeometry, 
THREE.SphereGeometry = function(a, b, c, d, e, f, g) {
    THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
        radius: a,
        widthSegments: b,
        heightSegments: c,
        phiStart: d,
        phiLength: e,
        thetaStart: f,
        thetaLength: g
    }, a = a || 50, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), 
    d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, 
    g = void 0 !== g ? g : Math.PI;
    var h, i, j = [], k = [];
    for (i = 0; c >= i; i++) {
        var l = [], m = [];
        for (h = 0; b >= h; h++) {
            var n = h / b, o = i / c, p = new THREE.Vector3();
            p.x = -a * Math.cos(d + n * e) * Math.sin(f + o * g), p.y = a * Math.cos(f + o * g), 
            p.z = a * Math.sin(d + n * e) * Math.sin(f + o * g), this.vertices.push(p), l.push(this.vertices.length - 1), 
            m.push(new THREE.Vector2(n, 1 - o));
        }
        j.push(l), k.push(m);
    }
    for (i = 0; c > i; i++) for (h = 0; b > h; h++) {
        d = j[i][h + 1], e = j[i][h], f = j[i + 1][h], g = j[i + 1][h + 1];
        var l = this.vertices[d].clone().normalize(), m = this.vertices[e].clone().normalize(), n = this.vertices[f].clone().normalize(), o = this.vertices[g].clone().normalize(), p = k[i][h + 1].clone(), q = k[i][h].clone(), r = k[i + 1][h].clone(), s = k[i + 1][h + 1].clone();
        Math.abs(this.vertices[d].y) === a ? (p.x = (p.x + q.x) / 2, this.faces.push(new THREE.Face3(d, f, g, [ l, n, o ])), 
        this.faceVertexUvs[0].push([ p, r, s ])) : Math.abs(this.vertices[f].y) === a ? (r.x = (r.x + s.x) / 2, 
        this.faces.push(new THREE.Face3(d, e, f, [ l, m, n ])), this.faceVertexUvs[0].push([ p, q, r ])) : (this.faces.push(new THREE.Face3(d, e, g, [ l, m, o ])), 
        this.faceVertexUvs[0].push([ p, q, s ]), this.faces.push(new THREE.Face3(e, f, g, [ m.clone(), n, o.clone() ])), 
        this.faceVertexUvs[0].push([ q.clone(), r, s.clone() ]));
    }
    this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
}, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry, 
THREE.TextGeometry = function(a, b) {
    b = b || {};
    var c = THREE.FontUtils.generateShapes(a, b);
    b.amount = void 0 !== b.height ? b.height : 50, void 0 === b.bevelThickness && (b.bevelThickness = 10), 
    void 0 === b.bevelSize && (b.bevelSize = 8), void 0 === b.bevelEnabled && (b.bevelEnabled = !1), 
    THREE.ExtrudeGeometry.call(this, c, b), this.type = "TextGeometry";
}, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), 
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry, THREE.TorusGeometry = function(a, b, c, d, e) {
    THREE.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        arc: e
    }, a = a || 100, b = b || 40, c = c || 8, d = d || 6, e = e || 2 * Math.PI;
    for (var f = new THREE.Vector3(), g = [], h = [], i = 0; c >= i; i++) for (var j = 0; d >= j; j++) {
        var k = j / d * e, l = i / c * Math.PI * 2;
        f.x = a * Math.cos(k), f.y = a * Math.sin(k);
        var m = new THREE.Vector3();
        m.x = (a + b * Math.cos(l)) * Math.cos(k), m.y = (a + b * Math.cos(l)) * Math.sin(k), 
        m.z = b * Math.sin(l), this.vertices.push(m), g.push(new THREE.Vector2(j / d, i / c)), 
        h.push(m.clone().sub(f).normalize());
    }
    for (i = 1; c >= i; i++) for (j = 1; d >= j; j++) a = (d + 1) * i + j - 1, b = (d + 1) * (i - 1) + j - 1, 
    e = (d + 1) * (i - 1) + j, f = (d + 1) * i + j, k = new THREE.Face3(a, b, f, [ h[a].clone(), h[b].clone(), h[f].clone() ]), 
    this.faces.push(k), this.faceVertexUvs[0].push([ g[a].clone(), g[b].clone(), g[f].clone() ]), 
    k = new THREE.Face3(b, e, f, [ h[b].clone(), h[e].clone(), h[f].clone() ]), this.faces.push(k), 
    this.faceVertexUvs[0].push([ g[b].clone(), g[e].clone(), g[f].clone() ]);
    this.computeFaceNormals();
}, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry, 
THREE.TorusKnotGeometry = function(a, b, c, d, e, f, g) {
    function h(a, b, c, d, e) {
        var f = Math.cos(a), g = Math.sin(a);
        return a *= b / c, b = Math.cos(a), f *= d * (2 + b) * .5, g = d * (2 + b) * g * .5, 
        d = e * d * Math.sin(a) * .5, new THREE.Vector3(f, g, d);
    }
    THREE.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        p: e,
        q: f,
        heightScale: g
    }, a = a || 100, b = b || 40, c = c || 64, d = d || 8, e = e || 2, f = f || 3, g = g || 1;
    for (var i = Array(c), j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3(), m = 0; c > m; ++m) {
        i[m] = Array(d);
        var n = m / c * 2 * e * Math.PI, o = h(n, f, e, a, g), n = h(n + .01, f, e, a, g);
        for (j.subVectors(n, o), k.addVectors(n, o), l.crossVectors(j, k), k.crossVectors(l, j), 
        l.normalize(), k.normalize(), n = 0; d > n; ++n) {
            var p = n / d * 2 * Math.PI, q = -b * Math.cos(p), p = b * Math.sin(p), r = new THREE.Vector3();
            r.x = o.x + q * k.x + p * l.x, r.y = o.y + q * k.y + p * l.y, r.z = o.z + q * k.z + p * l.z, 
            i[m][n] = this.vertices.push(r) - 1;
        }
    }
    for (m = 0; c > m; ++m) for (n = 0; d > n; ++n) e = (m + 1) % c, f = (n + 1) % d, 
    a = i[m][n], b = i[e][n], e = i[e][f], f = i[m][f], g = new THREE.Vector2(m / c, n / d), 
    j = new THREE.Vector2((m + 1) / c, n / d), k = new THREE.Vector2((m + 1) / c, (n + 1) / d), 
    l = new THREE.Vector2(m / c, (n + 1) / d), this.faces.push(new THREE.Face3(a, b, f)), 
    this.faceVertexUvs[0].push([ g, j, l ]), this.faces.push(new THREE.Face3(b, e, f)), 
    this.faceVertexUvs[0].push([ j.clone(), k, l.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry, THREE.TubeGeometry = function(a, b, c, d, e, f) {
    THREE.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
        path: a,
        segments: b,
        radius: c,
        radialSegments: d,
        closed: e
    }, b = b || 64, c = c || 1, d = d || 8, e = e || !1, f = f || THREE.TubeGeometry.NoTaper;
    var g, h, i, j, k, l, m, n, o, p, q = [], r = b + 1, s = new THREE.Vector3();
    for (n = new THREE.TubeGeometry.FrenetFrames(a, b, e), o = n.normals, p = n.binormals, 
    this.tangents = n.tangents, this.normals = o, this.binormals = p, n = 0; r > n; n++) for (q[n] = [], 
    i = n / (r - 1), m = a.getPointAt(i), g = o[n], h = p[n], k = c * f(i), i = 0; d > i; i++) j = i / d * 2 * Math.PI, 
    l = -k * Math.cos(j), j = k * Math.sin(j), s.copy(m), s.x += l * g.x + j * h.x, 
    s.y += l * g.y + j * h.y, s.z += l * g.z + j * h.z, q[n][i] = this.vertices.push(new THREE.Vector3(s.x, s.y, s.z)) - 1;
    for (n = 0; b > n; n++) for (i = 0; d > i; i++) f = e ? (n + 1) % b : n + 1, r = (i + 1) % d, 
    a = q[n][i], c = q[f][i], f = q[f][r], r = q[n][r], s = new THREE.Vector2(n / b, i / d), 
    o = new THREE.Vector2((n + 1) / b, i / d), p = new THREE.Vector2((n + 1) / b, (i + 1) / d), 
    g = new THREE.Vector2(n / b, (i + 1) / d), this.faces.push(new THREE.Face3(a, c, r)), 
    this.faceVertexUvs[0].push([ s, o, g ]), this.faces.push(new THREE.Face3(c, f, r)), 
    this.faceVertexUvs[0].push([ o.clone(), p, g.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry, 
THREE.TubeGeometry.NoTaper = function(a) {
    return 1;
}, THREE.TubeGeometry.SinusoidalTaper = function(a) {
    return Math.sin(Math.PI * a);
}, THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
    var d = new THREE.Vector3(), e = [], f = [], g = [], h = new THREE.Vector3(), i = new THREE.Matrix4();
    b += 1;
    var j, k, l;
    for (this.tangents = e, this.normals = f, this.binormals = g, j = 0; b > j; j++) k = j / (b - 1), 
    e[j] = a.getTangentAt(k), e[j].normalize();
    for (f[0] = new THREE.Vector3(), g[0] = new THREE.Vector3(), a = Number.MAX_VALUE, 
    j = Math.abs(e[0].x), k = Math.abs(e[0].y), l = Math.abs(e[0].z), a >= j && (a = j, 
    d.set(1, 0, 0)), a >= k && (a = k, d.set(0, 1, 0)), a >= l && d.set(0, 0, 1), h.crossVectors(e[0], d).normalize(), 
    f[0].crossVectors(e[0], h), g[0].crossVectors(e[0], f[0]), j = 1; b > j; j++) f[j] = f[j - 1].clone(), 
    g[j] = g[j - 1].clone(), h.crossVectors(e[j - 1], e[j]), 1e-4 < h.length() && (h.normalize(), 
    d = Math.acos(THREE.Math.clamp(e[j - 1].dot(e[j]), -1, 1)), f[j].applyMatrix4(i.makeRotationAxis(h, d))), 
    g[j].crossVectors(e[j], f[j]);
    if (c) for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 
    0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), j = 1; b > j; j++) f[j].applyMatrix4(i.makeRotationAxis(e[j], d * j)), 
    g[j].crossVectors(e[j], f[j]);
}, THREE.PolyhedronGeometry = function(a, b, c, d) {
    function e(a) {
        var b = a.normalize().clone();
        b.index = i.vertices.push(b) - 1;
        var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
        return a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5, b.uv = new THREE.Vector2(c, 1 - a), 
        b;
    }
    function f(a, b, c) {
        var d = new THREE.Face3(a.index, b.index, c.index, [ a.clone(), b.clone(), c.clone() ]);
        i.faces.push(d), q.copy(a).add(b).add(c).divideScalar(3), d = Math.atan2(q.z, -q.x), 
        i.faceVertexUvs[0].push([ h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d) ]);
    }
    function g(a, b) {
        for (var c = Math.pow(2, b), d = e(i.vertices[a.a]), g = e(i.vertices[a.b]), h = e(i.vertices[a.c]), j = [], k = 0; c >= k; k++) {
            j[k] = [];
            for (var l = e(d.clone().lerp(h, k / c)), m = e(g.clone().lerp(h, k / c)), n = c - k, o = 0; n >= o; o++) j[k][o] = 0 == o && k == c ? l : e(l.clone().lerp(m, o / n));
        }
        for (k = 0; c > k; k++) for (o = 0; 2 * (c - k) - 1 > o; o++) d = Math.floor(o / 2), 
        0 == o % 2 ? f(j[k][d + 1], j[k + 1][d], j[k][d]) : f(j[k][d + 1], j[k + 1][d + 1], j[k + 1][d]);
    }
    function h(a, b, c) {
        return 0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y)), 0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y)), 
        a.clone();
    }
    THREE.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
        vertices: a,
        indices: b,
        radius: c,
        detail: d
    }, c = c || 1, d = d || 0;
    for (var i = this, j = 0, k = a.length; k > j; j += 3) e(new THREE.Vector3(a[j], a[j + 1], a[j + 2]));
    a = this.vertices;
    for (var l = [], m = j = 0, k = b.length; k > j; j += 3, m++) {
        var n = a[b[j]], o = a[b[j + 1]], p = a[b[j + 2]];
        l[m] = new THREE.Face3(n.index, o.index, p.index, [ n.clone(), o.clone(), p.clone() ]);
    }
    for (var q = new THREE.Vector3(), j = 0, k = l.length; k > j; j++) g(l[j], d);
    for (j = 0, k = this.faceVertexUvs[0].length; k > j; j++) b = this.faceVertexUvs[0][j], 
    d = b[0].x, a = b[1].x, l = b[2].x, m = Math.max(d, Math.max(a, l)), n = Math.min(d, Math.min(a, l)), 
    m > .9 && .1 > n && (.2 > d && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > l && (b[2].x += 1));
    for (j = 0, k = this.vertices.length; k > j; j++) this.vertices[j].multiplyScalar(c);
    this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);
}, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry, THREE.DodecahedronGeometry = function(a, b) {
    this.parameters = {
        radius: a,
        detail: b
    };
    var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
    THREE.PolyhedronGeometry.call(this, [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d ], [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ], a, b);
}, THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry, THREE.IcosahedronGeometry = function(a, b) {
    var c = (1 + Math.sqrt(5)) / 2;
    THREE.PolyhedronGeometry.call(this, [ -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1 ], [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ], a, b), 
    this.type = "IcosahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry, THREE.OctahedronGeometry = function(a, b) {
    this.parameters = {
        radius: a,
        detail: b
    }, THREE.PolyhedronGeometry.call(this, [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ], a, b), 
    this.type = "OctahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry, THREE.TetrahedronGeometry = function(a, b) {
    THREE.PolyhedronGeometry.call(this, [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ], a, b), 
    this.type = "TetrahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry, THREE.ParametricGeometry = function(a, b, c) {
    THREE.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
        func: a,
        slices: b,
        stacks: c
    };
    var d, e, f, g, h = this.vertices, i = this.faces, j = this.faceVertexUvs[0], k = b + 1;
    for (d = 0; c >= d; d++) for (g = d / c, e = 0; b >= e; e++) f = e / b, f = a(f, g), 
    h.push(f);
    var l, m, n, o;
    for (d = 0; c > d; d++) for (e = 0; b > e; e++) a = d * k + e, h = d * k + e + 1, 
    g = (d + 1) * k + e + 1, f = (d + 1) * k + e, l = new THREE.Vector2(e / b, d / c), 
    m = new THREE.Vector2((e + 1) / b, d / c), n = new THREE.Vector2((e + 1) / b, (d + 1) / c), 
    o = new THREE.Vector2(e / b, (d + 1) / c), i.push(new THREE.Face3(a, h, f)), j.push([ l, m, o ]), 
    i.push(new THREE.Face3(h, g, f)), j.push([ m.clone(), n, o.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry, THREE.AxisHelper = function(a) {
    a = a || 1;
    var b = new Float32Array([ 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a ]), c = new Float32Array([ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ]);
    a = new THREE.BufferGeometry(), a.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    a.addAttribute("color", new THREE.BufferAttribute(c, 3)), b = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    }), THREE.Line.call(this, a, b, THREE.LinePieces);
}, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.AxisHelper.prototype.constructor = THREE.AxisHelper, 
THREE.ArrowHelper = function() {
    var a = new THREE.Geometry();
    a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
    var b = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
    return b.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0)), function(c, d, e, f, g, h) {
        THREE.Object3D.call(this), void 0 === f && (f = 16776960), void 0 === e && (e = 1), 
        void 0 === g && (g = .2 * e), void 0 === h && (h = .2 * g), this.position.copy(d), 
        this.line = new THREE.Line(a, new THREE.LineBasicMaterial({
            color: f
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({
            color: f
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(c), 
        this.setLength(e, g, h);
    };
}(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper, 
THREE.ArrowHelper.prototype.setDirection = function() {
    var a, b = new THREE.Vector3();
    return function(c) {
        .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), 
        a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a));
    };
}(), THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, a - b, 1), 
    this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, 
    this.cone.updateMatrix();
}, THREE.ArrowHelper.prototype.setColor = function(a) {
    this.line.material.color.set(a), this.cone.material.color.set(a);
}, THREE.BoxHelper = function(a) {
    var b = new THREE.BufferGeometry();
    b.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3)), 
    THREE.Line.call(this, b, new THREE.LineBasicMaterial({
        color: 16776960
    }), THREE.LinePieces), void 0 !== a && this.update(a);
}, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.constructor = THREE.BoxHelper, 
THREE.BoxHelper.prototype.update = function(a) {
    var b = a.geometry;
    null === b.boundingBox && b.computeBoundingBox();
    var c = b.boundingBox.min, b = b.boundingBox.max, d = this.geometry.attributes.position.array;
    d[0] = b.x, d[1] = b.y, d[2] = b.z, d[3] = c.x, d[4] = b.y, d[5] = b.z, d[6] = c.x, 
    d[7] = b.y, d[8] = b.z, d[9] = c.x, d[10] = c.y, d[11] = b.z, d[12] = c.x, d[13] = c.y, 
    d[14] = b.z, d[15] = b.x, d[16] = c.y, d[17] = b.z, d[18] = b.x, d[19] = c.y, d[20] = b.z, 
    d[21] = b.x, d[22] = b.y, d[23] = b.z, d[24] = b.x, d[25] = b.y, d[26] = c.z, d[27] = c.x, 
    d[28] = b.y, d[29] = c.z, d[30] = c.x, d[31] = b.y, d[32] = c.z, d[33] = c.x, d[34] = c.y, 
    d[35] = c.z, d[36] = c.x, d[37] = c.y, d[38] = c.z, d[39] = b.x, d[40] = c.y, d[41] = c.z, 
    d[42] = b.x, d[43] = c.y, d[44] = c.z, d[45] = b.x, d[46] = b.y, d[47] = c.z, d[48] = b.x, 
    d[49] = b.y, d[50] = b.z, d[51] = b.x, d[52] = b.y, d[53] = c.z, d[54] = c.x, d[55] = b.y, 
    d[56] = b.z, d[57] = c.x, d[58] = b.y, d[59] = c.z, d[60] = c.x, d[61] = c.y, d[62] = b.z, 
    d[63] = c.x, d[64] = c.y, d[65] = c.z, d[66] = b.x, d[67] = c.y, d[68] = b.z, d[69] = b.x, 
    d[70] = c.y, d[71] = c.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), 
    this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.BoundingBoxHelper = function(a, b) {
    var c = void 0 !== b ? b : 8947848;
    this.object = a, this.box = new THREE.Box3(), THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: c,
        wireframe: !0
    }));
}, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper, 
THREE.BoundingBoxHelper.prototype.update = function() {
    this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position);
}, THREE.CameraHelper = function(a) {
    function b(a, b, d) {
        c(a, d), c(b, d);
    }
    function c(a, b) {
        d.vertices.push(new THREE.Vector3()), d.colors.push(new THREE.Color(b)), void 0 === f[a] && (f[a] = []), 
        f[a].push(d.vertices.length - 1);
    }
    var d = new THREE.Geometry(), e = new THREE.LineBasicMaterial({
        color: 16777215,
        vertexColors: THREE.FaceColors
    }), f = {};
    b("n1", "n2", 16755200), b("n2", "n4", 16755200), b("n4", "n3", 16755200), b("n3", "n1", 16755200), 
    b("f1", "f2", 16755200), b("f2", "f4", 16755200), b("f4", "f3", 16755200), b("f3", "f1", 16755200), 
    b("n1", "f1", 16755200), b("n2", "f2", 16755200), b("n3", "f3", 16755200), b("n4", "f4", 16755200), 
    b("p", "n1", 16711680), b("p", "n2", 16711680), b("p", "n3", 16711680), b("p", "n4", 16711680), 
    b("u1", "u2", 43775), b("u2", "u3", 43775), b("u3", "u1", 43775), b("c", "t", 16777215), 
    b("p", "c", 3355443), b("cn1", "cn2", 3355443), b("cn3", "cn4", 3355443), b("cf1", "cf2", 3355443), 
    b("cf3", "cf4", 3355443), THREE.Line.call(this, d, e, THREE.LinePieces), this.camera = a, 
    this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = f, this.update();
}, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.constructor = THREE.CameraHelper, 
THREE.CameraHelper.prototype.update = function() {
    var a, b, c = new THREE.Vector3(), d = new THREE.Camera(), e = function(e, f, g, h) {
        if (c.set(f, g, h).unproject(d), e = b[e], void 0 !== e) for (f = 0, g = e.length; g > f; f++) a.vertices[e[f]].copy(c);
    };
    return function() {
        a = this.geometry, b = this.pointMap, d.projectionMatrix.copy(this.camera.projectionMatrix), 
        e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), 
        e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), 
        e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), 
        e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), 
        e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), a.verticesNeedUpdate = !0;
    };
}(), THREE.DirectionalLightHelper = function(a, b) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, b = b || 1;
    var c = new THREE.Geometry();
    c.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));
    var d = new THREE.LineBasicMaterial({
        fog: !1
    });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(c, d), 
    this.add(this.lightPlane), c = new THREE.Geometry(), c.vertices.push(new THREE.Vector3(), new THREE.Vector3()), 
    d = new THREE.LineBasicMaterial({
        fog: !1
    }), d.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(c, d), 
    this.add(this.targetLine), this.update();
}, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), 
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper, 
THREE.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), 
    this.targetLine.material.dispose();
}, THREE.DirectionalLightHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function() {
        a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
        c.subVectors(b, a), this.lightPlane.lookAt(c), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), 
        this.targetLine.geometry.vertices[1].copy(c), this.targetLine.geometry.verticesNeedUpdate = !0, 
        this.targetLine.material.color.copy(this.lightPlane.material.color);
    };
}(), THREE.EdgesHelper = function(a, b, c) {
    b = void 0 !== b ? b : 16777215, c = Math.cos(THREE.Math.degToRad(void 0 !== c ? c : 1));
    var d, e = [ 0, 0 ], f = {}, g = function(a, b) {
        return a - b;
    }, h = [ "a", "b", "c" ], i = new THREE.BufferGeometry();
    a.geometry instanceof THREE.BufferGeometry ? (d = new THREE.Geometry(), d.fromBufferGeometry(a.geometry)) : d = a.geometry.clone(), 
    d.mergeVertices(), d.computeFaceNormals();
    var j = d.vertices;
    d = d.faces;
    for (var k = 0, l = 0, m = d.length; m > l; l++) for (var n = d[l], o = 0; 3 > o; o++) {
        e[0] = n[h[o]], e[1] = n[h[(o + 1) % 3]], e.sort(g);
        var p = e.toString();
        void 0 === f[p] ? (f[p] = {
            vert1: e[0],
            vert2: e[1],
            face1: l,
            face2: void 0
        }, k++) : f[p].face2 = l;
    }
    e = new Float32Array(6 * k), g = 0;
    for (p in f) h = f[p], (void 0 === h.face2 || d[h.face1].normal.dot(d[h.face2].normal) <= c) && (k = j[h.vert1], 
    e[g++] = k.x, e[g++] = k.y, e[g++] = k.z, k = j[h.vert2], e[g++] = k.x, e[g++] = k.y, 
    e[g++] = k.z);
    i.addAttribute("position", new THREE.BufferAttribute(e, 3)), THREE.Line.call(this, i, new THREE.LineBasicMaterial({
        color: b
    }), THREE.LinePieces), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper, 
THREE.FaceNormalsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16776960, 
    d = void 0 !== d ? d : 1, b = new THREE.Geometry(), c = 0;
    for (var e = this.object.geometry.faces.length; e > c; c++) b.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    THREE.Line.call(this, b, new THREE.LineBasicMaterial({
        color: a,
        linewidth: d
    }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3(), 
    this.update();
}, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper, 
THREE.FaceNormalsHelper.prototype.update = function() {
    var a = this.geometry.vertices, b = this.object, c = b.geometry.vertices, d = b.geometry.faces, e = b.matrixWorld;
    b.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(e);
    for (var f = b = 0, g = d.length; g > b; b++, f += 2) {
        var h = d[b];
        a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e), a[f + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f]);
    }
    return this.geometry.verticesNeedUpdate = !0, this;
}, THREE.GridHelper = function(a, b) {
    var c = new THREE.Geometry(), d = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
    for (var e = -a; a >= e; e += b) {
        c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
        var f = 0 === e ? this.color1 : this.color2;
        c.colors.push(f, f, f, f);
    }
    THREE.Line.call(this, c, d, THREE.LinePieces);
}, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.constructor = THREE.GridHelper, 
THREE.GridHelper.prototype.setColors = function(a, b) {
    this.color1.set(a), this.color2.set(b), this.geometry.colorsNeedUpdate = !0;
}, THREE.HemisphereLightHelper = function(a, b) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, this.colors = [ new THREE.Color(), new THREE.Color() ];
    var c = new THREE.SphereGeometry(b, 4, 2);
    c.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    for (var d = 0; 8 > d; d++) c.faces[d].color = this.colors[4 > d ? 0 : 1];
    d = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    }), this.lightSphere = new THREE.Mesh(c, d), this.add(this.lightSphere), this.update();
}, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), 
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper, 
THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose();
}, THREE.HemisphereLightHelper.prototype.update = function() {
    var a = new THREE.Vector3();
    return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), 
        this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()), 
        this.lightSphere.geometry.colorsNeedUpdate = !0;
    };
}(), THREE.PointLightHelper = function(a, b) {
    this.light = a, this.light.updateMatrixWorld();
    var c = new THREE.SphereGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, c, d), 
    this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper, 
THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose();
}, THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
}, THREE.SkeletonHelper = function(a) {
    this.bones = this.getBoneList(a);
    for (var b = new THREE.Geometry(), c = 0; c < this.bones.length; c++) this.bones[c].parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3()), 
    b.vertices.push(new THREE.Vector3()), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)));
    c = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }), THREE.Line.call(this, b, c, THREE.LinePieces), this.root = a, this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, this.update();
}, THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype), THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper, 
THREE.SkeletonHelper.prototype.getBoneList = function(a) {
    var b = [];
    a instanceof THREE.Bone && b.push(a);
    for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
    return b;
}, THREE.SkeletonHelper.prototype.update = function() {
    for (var a = this.geometry, b = new THREE.Matrix4().getInverse(this.root.matrixWorld), c = new THREE.Matrix4(), d = 0, e = 0; e < this.bones.length; e++) {
        var f = this.bones[e];
        f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), 
        c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), 
        d += 2);
    }
    a.verticesNeedUpdate = !0, a.computeBoundingSphere();
}, THREE.SpotLightHelper = function(a) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0), a.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0)), 
    a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    var b = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    this.cone = new THREE.Mesh(a, b), this.add(this.cone), this.update();
}, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper, 
THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
}, THREE.SpotLightHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function() {
        var c = this.light.distance ? this.light.distance : 1e4, d = c * Math.tan(this.light.angle);
        this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
        this.cone.lookAt(b.sub(a)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
}(), THREE.VertexNormalsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, b = void 0 !== c ? c : 16711680, 
    d = void 0 !== d ? d : 1, c = new THREE.Geometry(), a = a.geometry.faces;
    for (var e = 0, f = a.length; f > e; e++) for (var g = 0, h = a[e].vertexNormals.length; h > g; g++) c.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: d
    }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3(), 
    this.update();
}, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper, 
THREE.VertexNormalsHelper.prototype.update = function(a) {
    var b = new THREE.Vector3();
    return function(a) {
        a = [ "a", "b", "c", "d" ], this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        for (var c = this.geometry.vertices, d = this.object.geometry.vertices, e = this.object.geometry.faces, f = this.object.matrixWorld, g = 0, h = 0, i = e.length; i > h; h++) for (var j = e[h], k = 0, l = j.vertexNormals.length; l > k; k++) {
            var m = j.vertexNormals[k];
            c[g].copy(d[j[a[k]]]).applyMatrix4(f), b.copy(m).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), 
            b.add(c[g]), g += 1, c[g].copy(b), g += 1;
        }
        return this.geometry.verticesNeedUpdate = !0, this;
    };
}(), THREE.VertexTangentsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, b = void 0 !== c ? c : 255, d = void 0 !== d ? d : 1, 
    c = new THREE.Geometry(), a = a.geometry.faces;
    for (var e = 0, f = a.length; f > e; e++) for (var g = 0, h = a[e].vertexTangents.length; h > g; g++) c.vertices.push(new THREE.Vector3()), 
    c.vertices.push(new THREE.Vector3());
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: d
    }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update();
}, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper, 
THREE.VertexTangentsHelper.prototype.update = function(a) {
    var b = new THREE.Vector3();
    return function(a) {
        a = [ "a", "b", "c", "d" ], this.object.updateMatrixWorld(!0);
        for (var c = this.geometry.vertices, d = this.object.geometry.vertices, e = this.object.geometry.faces, f = this.object.matrixWorld, g = 0, h = 0, i = e.length; i > h; h++) for (var j = e[h], k = 0, l = j.vertexTangents.length; l > k; k++) {
            var m = j.vertexTangents[k];
            c[g].copy(d[j[a[k]]]).applyMatrix4(f), b.copy(m).transformDirection(f).multiplyScalar(this.size), 
            b.add(c[g]), g += 1, c[g].copy(b), g += 1;
        }
        return this.geometry.verticesNeedUpdate = !0, this;
    };
}(), THREE.WireframeHelper = function(a, b) {
    var c = void 0 !== b ? b : 16777215, d = [ 0, 0 ], e = {}, f = function(a, b) {
        return a - b;
    }, g = [ "a", "b", "c" ], h = new THREE.BufferGeometry();
    if (a.geometry instanceof THREE.Geometry) {
        for (var i = a.geometry.vertices, j = a.geometry.faces, k = 0, l = new Uint32Array(6 * j.length), m = 0, n = j.length; n > m; m++) for (var o = j[m], p = 0; 3 > p; p++) {
            d[0] = o[g[p]], d[1] = o[g[(p + 1) % 3]], d.sort(f);
            var q = d.toString();
            void 0 === e[q] && (l[2 * k] = d[0], l[2 * k + 1] = d[1], e[q] = !0, k++);
        }
        for (d = new Float32Array(6 * k), m = 0, n = k; n > m; m++) for (p = 0; 2 > p; p++) k = i[l[2 * m + p]], 
        g = 6 * m + 3 * p, d[g + 0] = k.x, d[g + 1] = k.y, d[g + 2] = k.z;
        h.addAttribute("position", new THREE.BufferAttribute(d, 3));
    } else if (a.geometry instanceof THREE.BufferGeometry) {
        if (void 0 !== a.geometry.attributes.index) {
            i = a.geometry.attributes.position.array, n = a.geometry.attributes.index.array, 
            j = a.geometry.drawcalls, k = 0, 0 === j.length && (j = [ {
                count: n.length,
                index: 0,
                start: 0
            } ]);
            for (var l = new Uint32Array(2 * n.length), o = 0, r = j.length; r > o; ++o) for (var p = j[o].start, q = j[o].count, g = j[o].index, m = p, s = p + q; s > m; m += 3) for (p = 0; 3 > p; p++) d[0] = g + n[m + p], 
            d[1] = g + n[m + (p + 1) % 3], d.sort(f), q = d.toString(), void 0 === e[q] && (l[2 * k] = d[0], 
            l[2 * k + 1] = d[1], e[q] = !0, k++);
            for (d = new Float32Array(6 * k), m = 0, n = k; n > m; m++) for (p = 0; 2 > p; p++) g = 6 * m + 3 * p, 
            k = 3 * l[2 * m + p], d[g + 0] = i[k], d[g + 1] = i[k + 1], d[g + 2] = i[k + 2];
        } else for (i = a.geometry.attributes.position.array, k = i.length / 3, l = k / 3, 
        d = new Float32Array(6 * k), m = 0, n = l; n > m; m++) for (p = 0; 3 > p; p++) g = 18 * m + 6 * p, 
        l = 9 * m + 3 * p, d[g + 0] = i[l], d[g + 1] = i[l + 1], d[g + 2] = i[l + 2], k = 9 * m + (p + 1) % 3 * 3, 
        d[g + 3] = i[k], d[g + 4] = i[k + 1], d[g + 5] = i[k + 2];
        h.addAttribute("position", new THREE.BufferAttribute(d, 3));
    }
    THREE.Line.call(this, h, new THREE.LineBasicMaterial({
        color: c
    }), THREE.LinePieces), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper, 
THREE.ImmediateRenderObject = function() {
    THREE.Object3D.call(this), this.render = function(a) {};
}, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), 
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject, 
THREE.MorphBlendMesh = function(a, b) {
    THREE.Mesh.call(this, a, b), this.animationsMap = {}, this.animationsList = [];
    var c = this.geometry.morphTargets.length;
    this.createAnimation("__default", 0, c - 1, c / 1), this.setAnimationWeight("__default", 1);
}, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh, 
THREE.MorphBlendMesh.prototype.createAnimation = function(a, b, c, d) {
    b = {
        startFrame: b,
        endFrame: c,
        length: c - b + 1,
        fps: d,
        duration: (c - b) / d,
        lastFrame: 0,
        currentFrame: 0,
        active: !1,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: !1,
        mirroredLoop: !1
    }, this.animationsMap[a] = b, this.animationsList.push(b);
}, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(a) {
    for (var b, c = /([a-z]+)_?(\d+)/, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; g > f; f++) {
        var h = e.morphTargets[f].name.match(c);
        if (h && 1 < h.length) {
            var i = h[1];
            d[i] || (d[i] = {
                start: 1 / 0,
                end: -(1 / 0)
            }), h = d[i], f < h.start && (h.start = f), f > h.end && (h.end = f), b || (b = i);
        }
    }
    for (i in d) h = d[i], this.createAnimation(i, h.start, h.end, a);
    this.firstAnimation = b;
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(a) {
    (a = this.animationsMap[a]) && (a.direction = 1, a.directionBackwards = !1);
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(a) {
    (a = this.animationsMap[a]) && (a.direction = -1, a.directionBackwards = !0);
}, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);
}, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);
}, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.weight = b);
}, THREE.MorphBlendMesh.prototype.setAnimationTime = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.time = b);
}, THREE.MorphBlendMesh.prototype.getAnimationTime = function(a) {
    var b = 0;
    return (a = this.animationsMap[a]) && (b = a.time), b;
}, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(a) {
    var b = -1;
    return (a = this.animationsMap[a]) && (b = a.duration), b;
}, THREE.MorphBlendMesh.prototype.playAnimation = function(a) {
    var b = this.animationsMap[a];
    b ? (b.time = 0, b.active = !0) : THREE.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()");
}, THREE.MorphBlendMesh.prototype.stopAnimation = function(a) {
    (a = this.animationsMap[a]) && (a.active = !1);
}, THREE.MorphBlendMesh.prototype.update = function(a) {
    for (var b = 0, c = this.animationsList.length; c > b; b++) {
        var d = this.animationsList[b];
        if (d.active) {
            var e = d.duration / d.length;
            d.time += d.direction * a, d.mirroredLoop ? (d.time > d.duration || 0 > d.time) && (d.direction *= -1, 
            d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, 
            d.directionBackwards = !1)) : (d.time %= d.duration, 0 > d.time && (d.time += d.duration));
            var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
            f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, 
            this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f), 
            e = d.time % e / e, d.directionBackwards && (e = 1 - e), this.morphTargetInfluences[d.currentFrame] = e * g, 
            this.morphTargetInfluences[d.lastFrame] = (1 - e) * g;
        }
    }
}, THREE.OrbitControls = function(a, b) {
    function c() {
        return 2 * Math.PI / 60 / 60 * o.autoRotateSpeed;
    }
    function d() {
        return Math.pow(.95, o.zoomSpeed);
    }
    function e(a) {
        if (o.enabled !== !1) {
            if (a.preventDefault(), a.button === o.mouseButtons.ORBIT) {
                if (o.noRotate === !0) return;
                I = H.ROTATE, q.set(a.clientX, a.clientY);
            } else if (a.button === o.mouseButtons.ZOOM) {
                if (o.noZoom === !0) return;
                I = H.DOLLY, y.set(a.clientX, a.clientY);
            } else if (a.button === o.mouseButtons.PAN) {
                if (o.noPan === !0) return;
                I = H.PAN, t.set(a.clientX, a.clientY);
            }
            I !== H.NONE && (document.addEventListener("mousemove", f, !1), document.addEventListener("mouseup", g, !1), 
            o.dispatchEvent && o.dispatchEvent(M));
        }
    }
    function f(a) {
        if (o.enabled !== !1) {
            a.preventDefault();
            var b = o.domElement === document ? o.domElement.body : o.domElement;
            if (I === H.ROTATE) {
                if (o.noRotate === !0) return;
                r.set(a.clientX, a.clientY), s.subVectors(r, q), o.rotateLeft(2 * Math.PI * s.x / b.clientWidth * o.rotateSpeed), 
                o.rotateUp(2 * Math.PI * s.y / b.clientHeight * o.rotateSpeed), q.copy(r);
            } else if (I === H.DOLLY) {
                if (o.noZoom === !0) return;
                z.set(a.clientX, a.clientY), A.subVectors(z, y), A.y > 0 ? o.dollyIn() : o.dollyOut(), 
                y.copy(z);
            } else if (I === H.PAN) {
                if (o.noPan === !0) return;
                u.set(a.clientX, a.clientY), v.subVectors(u, t), o.pan(v.x, v.y), t.copy(u);
            }
            I !== H.NONE && o.update();
        }
    }
    function g() {
        o.enabled !== !1 && (document.removeEventListener("mousemove", f, !1), document.removeEventListener("mouseup", g, !1), 
        o.dispatchEvent && o.dispatchEvent(N), I = H.NONE);
    }
    function h(a) {
        if (o.enabled !== !1 && o.noZoom !== !0 && I === H.NONE) {
            a.preventDefault(), a.stopPropagation();
            var b = 0;
            void 0 !== a.wheelDelta ? b = a.wheelDelta : void 0 !== a.detail && (b = -a.detail), 
            b > 0 ? o.dollyOut() : o.dollyIn(), o.update(), o.dispatchEvent && o.dispatchEvent(M), 
            o.dispatchEvent && o.dispatchEvent(N);
        }
    }
    function i(a) {
        if (o.enabled !== !1 && o.noKeys !== !0 && o.noPan !== !0) switch (a.keyCode) {
          case o.keys.UP:
            o.pan(0, o.keyPanSpeed), o.update();
            break;

          case o.keys.BOTTOM:
            o.pan(0, -o.keyPanSpeed), o.update();
            break;

          case o.keys.LEFT:
            o.pan(o.keyPanSpeed, 0), o.update();
            break;

          case o.keys.RIGHT:
            o.pan(-o.keyPanSpeed, 0), o.update();
        }
    }
    function j(a) {
        if (o.enabled !== !1) {
            switch (a.touches.length) {
              case 1:
                if (o.noRotate === !0) return;
                I = H.TOUCH_ROTATE, q.set(a.touches[0].pageX, a.touches[0].pageY);
                break;

              case 2:
                if (o.noZoom === !0) return;
                I = H.TOUCH_DOLLY;
                var b = a.touches[0].pageX - a.touches[1].pageX, c = a.touches[0].pageY - a.touches[1].pageY, d = Math.sqrt(b * b + c * c);
                y.set(0, d);
                break;

              case 3:
                if (o.noPan === !0) return;
                I = H.TOUCH_PAN, t.set(a.touches[0].pageX, a.touches[0].pageY);
                break;

              default:
                I = H.NONE;
            }
            I !== H.NONE && o.dispatchEvent && o.dispatchEvent(M);
        }
    }
    function k(a) {
        if (o.enabled !== !1) {
            a.preventDefault(), a.stopPropagation();
            var b = o.domElement === document ? o.domElement.body : o.domElement;
            switch (a.touches.length) {
              case 1:
                if (o.noRotate === !0) return;
                if (I !== H.TOUCH_ROTATE) return;
                r.set(a.touches[0].pageX, a.touches[0].pageY), s.subVectors(r, q), o.rotateLeft(2 * Math.PI * s.x / b.clientWidth * o.rotateSpeed), 
                o.rotateUp(2 * Math.PI * s.y / b.clientHeight * o.rotateSpeed), q.copy(r), o.update();
                break;

              case 2:
                if (o.noZoom === !0) return;
                if (I !== H.TOUCH_DOLLY) return;
                var c = a.touches[0].pageX - a.touches[1].pageX, d = a.touches[0].pageY - a.touches[1].pageY, e = Math.sqrt(c * c + d * d);
                z.set(0, e), A.subVectors(z, y), A.y > 0 ? o.dollyOut() : o.dollyIn(), y.copy(z), 
                o.update();
                break;

              case 3:
                if (o.noPan === !0) return;
                if (I !== H.TOUCH_PAN) return;
                u.set(a.touches[0].pageX, a.touches[0].pageY), v.subVectors(u, t), o.pan(v.x, v.y), 
                t.copy(u), o.update();
                break;

              default:
                I = H.NONE;
            }
        }
    }
    function l() {
        o.enabled !== !1 && (o.dispatchEvent && o.dispatchEvent(N), I = H.NONE);
    }
    this.object = a, this.domElement = void 0 !== b ? b : document, this.enabled = !0, 
    this.target = new THREE.Vector3(), this.center = this.target, this.noZoom = !1, 
    this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.noRotate = !1, 
    this.rotateSpeed = 1, this.noPan = !1, this.keyPanSpeed = 7, this.autoRotate = !1, 
    this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, 
    this.minAzimuthAngle = -(1 / 0), this.maxAzimuthAngle = 1 / 0, this.noKeys = !1, 
    this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
    }, this.mouseButtons = {
        ORBIT: THREE.MOUSE.LEFT,
        ZOOM: THREE.MOUSE.MIDDLE,
        PAN: THREE.MOUSE.RIGHT
    };
    var m, n, o = this, p = 1e-6, q = new THREE.Vector2(), r = new THREE.Vector2(), s = new THREE.Vector2(), t = new THREE.Vector2(), u = new THREE.Vector2(), v = new THREE.Vector2(), w = new THREE.Vector3(), x = new THREE.Vector3(), y = new THREE.Vector2(), z = new THREE.Vector2(), A = new THREE.Vector2(), B = 0, C = 0, D = 1, E = new THREE.Vector3(), F = new THREE.Vector3(), G = new THREE.Quaternion(), H = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5
    }, I = H.NONE;
    this.target0 = this.target.clone(), this.position0 = this.object.position.clone();
    var J = new THREE.Quaternion().setFromUnitVectors(a.up, new THREE.Vector3(0, 1, 0)), K = J.clone().inverse(), L = {
        type: "change"
    }, M = {
        type: "start"
    }, N = {
        type: "end"
    };
    this.rotateLeft = function(a) {
        void 0 === a && (a = c()), C -= a;
    }, this.rotateUp = function(a) {
        void 0 === a && (a = c()), B -= a;
    }, this.panLeft = function(a) {
        var b = this.object.matrix.elements;
        w.set(b[0], b[1], b[2]), w.multiplyScalar(-a), E.add(w);
    }, this.panUp = function(a) {
        var b = this.object.matrix.elements;
        w.set(b[4], b[5], b[6]), w.multiplyScalar(a), E.add(w);
    }, this.pan = function(a, b) {
        var c = o.domElement === document ? o.domElement.body : o.domElement;
        if (void 0 !== o.object.fov) {
            var d = o.object.position, e = d.clone().sub(o.target), f = e.length();
            f *= Math.tan(o.object.fov / 2 * Math.PI / 180), o.panLeft(2 * a * f / c.clientHeight), 
            o.panUp(2 * b * f / c.clientHeight);
        } else void 0 !== o.object.top ? (o.panLeft(a * (o.object.right - o.object.left) / c.clientWidth), 
        o.panUp(b * (o.object.top - o.object.bottom) / c.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
    }, this.dollyIn = function(a) {
        void 0 === a && (a = d()), D /= a;
    }, this.dollyOut = function(a) {
        void 0 === a && (a = d()), D *= a;
    }, this.update = function() {
        var a = this.object.position;
        x.copy(a).sub(this.target), x.applyQuaternion(J), m = Math.atan2(x.x, x.z), n = Math.atan2(Math.sqrt(x.x * x.x + x.z * x.z), x.y), 
        this.autoRotate && I === H.NONE && this.rotateLeft(c()), m += C, n += B, m = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, m)), 
        n = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, n)), n = Math.max(p, Math.min(Math.PI - p, n));
        var b = x.length() * D;
        b = Math.max(this.minDistance, Math.min(this.maxDistance, b)), this.target.add(E), 
        x.x = b * Math.sin(n) * Math.sin(m), x.y = b * Math.cos(n), x.z = b * Math.sin(n) * Math.cos(m), 
        x.applyQuaternion(K), a.copy(this.target).add(x), this.object.lookAt(this.target), 
        C = 0, B = 0, D = 1, E.set(0, 0, 0), (F.distanceToSquared(this.object.position) > p || 8 * (1 - G.dot(this.object.quaternion)) > p) && (this.dispatchEvent && this.dispatchEvent(L), 
        F.copy(this.object.position), G.copy(this.object.quaternion));
    }, this.reset = function() {
        I = H.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), 
        this.update();
    }, this.getPolarAngle = function() {
        return n;
    }, this.getAzimuthalAngle = function() {
        return m;
    }, this.domElement.addEventListener("contextmenu", function(a) {
        a.preventDefault();
    }, !1), this.domElement.addEventListener("mousedown", e, !1), this.domElement.addEventListener("mousewheel", h, !1), 
    this.domElement.addEventListener("DOMMouseScroll", h, !1), this.domElement.addEventListener("touchstart", j, !1), 
    this.domElement.addEventListener("touchend", l, !1), this.domElement.addEventListener("touchmove", k, !1), 
    window.addEventListener("keydown", i, !1), this.update();
}, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), 
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

var Animyst = {};

Animyst.LOGGING = !0, Animyst.DEBUG = !0, Animyst.Application = function() {
    this._appStateList = [], this._appStateLib = {}, this._stats = null, this._startParams = null, 
    this.appScope = new Animyst.AppScope(), this.initSignal = new signals.Signal(), 
    this.config = null, this.runtime = 0, this._lastFrame = 0;
}, Animyst.Application.prototype.startup = function(a) {
    Animyst.LOG.output("==================================================="), Animyst.LOG.output("   ----- AnimystJS: (v 0.0.0) by ~Saykrd -----   "), 
    Animyst.LOG.output("==================================================="), this._startParams = a, 
    Animyst.DataLoad.startup({}), Animyst.DataLoad.loadAsset({
        id: "config",
        src: "config.json"
    }, this._load.bind(this));
}, Animyst.Application.prototype._load = function(a, b) {
    if (a == Animyst.DataLoad.FILE_LOADED) switch (b.item.id) {
      case "config":
        Animyst.LOG.output("[Application] Config json loaded"), this.config = Animyst.DataLoad.getAsset("config"), 
        this.appScope.config = this.config, Animyst.DataLoad.loadFromManifest([ {
            id: "assets",
            src: this.config.assets
        }, {
            id: "strings",
            src: this.config.strings
        } ]);
        break;

      case "assets":
        Animyst.LOG.output("[Application] Assets json loaded");
        var c = Animyst.DataLoad.getAsset("assets");
        Animyst.DataLoad.listAssets(c.manifest), c.initialLoad && Animyst.DataLoad.loadFromManifest(c.initialLoad);
        break;

      case "strings":
        Animyst.LOG.output("[Application] Strings json loaded");
    } else a == Animyst.DataLoad.LOAD_COMPLETE && this._init();
}, Animyst.Application.prototype._init = function() {
    this._startParams;
    Animyst.LOGGING = this.config.settings.logging || !1, Animyst.DEBUG = this.config.settings.debug || !1, 
    Animyst.LOG.output("[Application] Application Started"), this.config.settings.debug && (window.Stats && (this._stats = new Stats(), 
    this._stats.domElement.style.position = "absolute", this._stats.domElement.style.left = "0px", 
    this._stats.domElement.style.top = "0px", document.body.appendChild(this._stats.domElement), 
    Animyst.LOG.output("[Application] Stats Enabled")), window.dat && (Animyst.datGUI = new dat.GUI()));
    var a = new Animyst.CoreProcess(Animyst.CoreProcess.ID);
    this.run(a), window.view ? window.view.onFrame = this.update.bind(this) : this._initFrame(), 
    this.initSignal.dispatch();
}, Animyst.Application.prototype.run = function(a) {
    this._appStateLib[a.id] || (this._appStateLib[a.id] = a, this._appStateList.push(a), 
    a.setScope(this.appScope), a.setup(), a.start());
}, Animyst.Application.prototype.halt = function(a) {
    this._appStateLib[appState.id] || this._appStateLib[appState.id].pause();
}, Animyst.Application.prototype.resume = function(a) {
    this._appStateLib[appState.id] || this._appStateLib[appState.id].resume();
}, Animyst.Application.prototype.end = function(a) {
    if (!this._appStateLib[b.id]) {
        var b = this._appStateLib[b.id];
        b.kill(), this._appStateLib[b.id] = null;
        for (var c = 0; c < this._appStateList.length; c++) {
            var d = this._appStateList[c];
            if (d.id == b.id) {
                this._appStateList.splice(c, 1);
                break;
            }
        }
    }
}, Animyst.Application.prototype.endAll = function() {
    for (var a in this._appStateLib) this.end(a);
}, Animyst.Application.prototype.update = function(a) {
    var b = 0, c = 0;
    a ? (b = a.delta, c = a.time) : (c = Date.now(), b = c - (this._lastFrame || Date.now()), 
    this._lastFrame = c), this.runtime += b, this._stats && this._stats.begin();
    for (var d = 0; d < this._appStateList.length; d++) {
        var e = this._appStateList[d];
        e.update(b, this.runtime);
    }
    this._stats && this._stats.end();
}, Animyst.Application.prototype._initFrame = function() {
    requestAnimationFrame(this._initFrame.bind(this)), this.update();
}, Animyst.AppScope = function() {
    this.databases = {}, this.config = null;
}, Animyst.AppScope.prototype = {}, Animyst.AppScope.prototype.addDatabase = function(a, b) {
    this.databases[a] = b;
}, Animyst.AppScope.prototype.getDatabase = function(a) {
    return this.databases[a];
}, Animyst.AppState = function(a) {
    this.id = a, this._systemList = [], this._systemLib = {}, this.active = !1, this.paused = !1, 
    this.appScope = null;
}, Animyst.AppState.prototype.setScope = function(a) {
    this.appScope = a;
}, Animyst.AppState.prototype.clearScope = function() {
    this.appScope = null;
}, Animyst.AppState.prototype.setup = function() {}, Animyst.AppState.prototype.start = function() {
    this.active = !0;
}, Animyst.AppState.prototype.stop = function() {
    this.active = !1;
    for (var a = 0; a < this._systemList.length; a++) {
        var b = this._systemList[a];
        b.shutdown();
    }
}, Animyst.AppState.prototype.update = function(a, b) {
    if (this.active && !this.paused) for (var c = 0; c < this._systemList.length; c++) {
        var d = this._systemList[c];
        d.started && !d.paused && d.update(a, b);
    }
}, Animyst.AppState.prototype.pause = function() {
    this.paused = !0;
}, Animyst.AppState.prototype.resume = function() {
    this.paused = !1;
}, Animyst.AppState.prototype.kill = function() {
    this.stop(), this.clearScope(), this._systemList = null, this._systemLib = null;
}, Animyst.AppState.prototype.restart = function() {}, Animyst.AppState.prototype.addSystem = function(a, b) {
    this._systemList[a] || (this._systemLib[a] = b, this._systemList.push(b));
}, Animyst.AppState.prototype.getSystem = function(a) {
    return this._systemList[a] ? void console.error("[AppState] !! No system found with ID: " + a) : this._systemLib[a];
}, Animyst.Database = function() {
    this.signal = new signals.Signal();
}, Animyst.Database.prototype.clear = function() {}, Animyst.Database.prototype.destroy = function() {}, 
Animyst.DataLoad = {}, Animyst.DataLoad._assetList = {}, Animyst.DataLoad._weakHandlers = [], 
Animyst.DataLoad._loadQueue = null, Animyst.DataLoad._loadSignal = null, Animyst.DataLoad._fileStartedSignal = null, 
Animyst.DataLoad._fileProgressSignal = null, Animyst.DataLoad._fileLoadedSignal = null, 
Animyst.DataLoad._fileErrorSignal = null, Animyst.DataLoad._queueStartedSignal = null, 
Animyst.DataLoad._queueProgressSignal = null, Animyst.DataLoad._queueLoadedSignal = null, 
Animyst.DataLoad._queueErrorSignal = null, Animyst.DataLoad._busy = !1, Animyst.DataLoad.LOAD_INITIALIZE = 0, 
Animyst.DataLoad.LOAD_STARTED = 1, Animyst.DataLoad.LOAD_PROGRESS = 2, Animyst.DataLoad.LOAD_COMPLETE = 3, 
Animyst.DataLoad.LOAD_ERROR = 4, Animyst.DataLoad.FILE_STARTED = 5, Animyst.DataLoad.FILE_PROGRESS = 6, 
Animyst.DataLoad.FILE_LOADED = 7, Animyst.DataLoad.FILE_ERROR = 8, Animyst.DataLoad.startup = function(a) {
    Animyst.DataLoad._loadQueue = new createjs.LoadQueue(!0), Animyst.DataLoad._loadSignal = new signals.Signal();
    var b = Animyst.DataLoad._loadQueue;
    b.on("fileload", Animyst.DataLoad.handleFileLoaded), b.on("complete", Animyst.DataLoad.handleLoadComplete), 
    b.on("fileerror", Animyst.DataLoad.handleFileError), b.on("error", Animyst.DataLoad.handleLoaderError), 
    b.on("filestart", Animyst.DataLoad.handleFileStart), b.on("initialize", Animyst.DataLoad.handleLoadInitialize), 
    b.on("loadstart", Animyst.DataLoad.handleLoadStart), b.on("fileprogress", Animyst.DataLoad.handleFileProgress), 
    b.on("progress", Animyst.DataLoad.handleOverallProgress), Animyst.DataLoad._fileStartedSignal = new signals.Signal(), 
    Animyst.DataLoad._fileProgressSignal = new signals.Signal(), Animyst.DataLoad._fileLoadedSignal = new signals.Signal(), 
    Animyst.DataLoad._fileErrorSignal = new signals.Signal(), Animyst.DataLoad._queueStartedSignal = new signals.Signal(), 
    Animyst.DataLoad._queueProgressSignal = new signals.Signal(), Animyst.DataLoad._queueLoadedSignal = new signals.Signal(), 
    Animyst.DataLoad._queueErrorSignal = new signals.Signal(), null != a.manifest;
}, Animyst.DataLoad.listAssets = function(a) {
    for (var b = Animyst.DataLoad._assetList, c = 0; c < a.length; c++) {
        var d = a[c];
        b[d.id] = d;
    }
}, Animyst.DataLoad.loadFromManifest = function(a, b, c) {
    for (var d = Animyst.DataLoad._loadQueue, e = [], f = 0; f < a.length; f++) {
        var g, h = a[f];
        g = "string" == typeof h ? {
            id: h,
            src: h
        } : {
            id: h.id,
            src: h.src
        }, Animyst.DataLoad._assetList[g.id] || (Animyst.DataLoad._assetList[g.id] = g), 
        e.push(Animyst.DataLoad._assetList[g.id]);
    }
    Animyst.DataLoad.addLoadHandler(b, c), Animyst.DataLoad._busy = !0, d.loadManifest(e);
}, Animyst.DataLoad.loadAsset = function(a, b, c) {
    var d, e = Animyst.DataLoad._loadQueue;
    d = "string" == typeof a ? {
        id: a,
        src: a
    } : {
        id: a.id,
        src: a.src
    }, Animyst.DataLoad._assetList[d.id] || (Animyst.DataLoad._assetList[d.id] = d), 
    Animyst.DataLoad.addLoadHandler(b, c), Animyst.DataLoad._busy = !0, e.loadFile(Animyst.DataLoad._assetList[d.id]);
}, Animyst.DataLoad.getAsset = function(a) {
    return Animyst.DataLoad._loadQueue.getResult(a);
}, Animyst.DataLoad.getData = function(a) {
    return Animyst.DataLoad._assetList[a];
}, Animyst.DataLoad.addLoadHandler = function(a, b) {
    a && (b || Animyst.DataLoad._weakHandlers.push(a), Animyst.DataLoad._loadSignal.add(a));
}, Animyst.DataLoad.removeLoadHandler = function(a) {
    for (var b = Animyst.DataLoad._weakHandlers.length - 1; b >= 0 && Animyst.DataLoad._weakHandlers.length > 0; b--) {
        var c = Animyst.DataLoad._weakHandlers[b];
        if (c == a) {
            Animyst.DataLoad._weakHandlers.splice(b, 1);
            break;
        }
    }
    Animyst.DataLoad._loadSignal.remove(a);
}, Animyst.DataLoad.removeWeakHandlers = function(a) {
    for (Animyst.DataLoad._loadSignal; a.length > 0; ) {
        var b = a.shift();
        Animyst.DataLoad.removeLoadHandler(b);
    }
}, Animyst.DataLoad.addCommand = function(a, b, c) {
    var d;
    switch (a) {
      case Animyst.DataLoad.LOAD_STARTED:
        d = Animyst.DataLoad._queueStartedSignal;
        break;

      case Animyst.DataLoad.FILE_STARTED:
        d = Animyst.DataLoad._fileStartedSignal;
        break;

      case Animyst.DataLoad.LOAD_PROGRESS:
        d = Animyst.DataLoad._queueProgressSignal;
        break;

      case Animyst.DataLoad.FILE_PROGRESS:
        d = Animyst.DataLoad._loadProgressSignal;
        break;

      case Animyst.DataLoad.LOAD_COMPLETE:
        d = Animyst.DataLoad._queueLoadedSignal;
        break;

      case Animyst.DataLoad.FILE_LOADED:
        d = Animyst.DataLoad._fileLoadedSignal;
        break;

      case Animyst.DataLoad.LOAD_ERROR:
        d = Animyst.DataLoad._queueErrorSignal;
        break;

      case Animyst.DataLoad.FILE_ERROR:
        d = Animyst.DataLoad._fileErrorSignal;
    }
    c ? d.addOnce(b) : d.add(b);
}, Animyst.DataLoad.removeCommand = function(a, b) {
    var c;
    switch (a) {
      case Animyst.DataLoad.LOAD_STARTED:
        c = Animyst.DataLoad._queueStartedSignal;
        break;

      case Animyst.DataLoad.FILE_STARTED:
        c = Animyst.DataLoad._fileStartedSignal;
        break;

      case Animyst.DataLoad.LOAD_PROGRESS:
        c = Animyst.DataLoad._queueProgressSignal;
        break;

      case Animyst.DataLoad.FILE_PROGRESS:
        c = Animyst.DataLoad._loadProgressSignal;
        break;

      case Animyst.DataLoad.LOAD_COMPLETE:
        c = Animyst.DataLoad._queueLoadedSignal;
        break;

      case Animyst.DataLoad.FILE_LOADED:
        c = Animyst.DataLoad._fileLoadedSignal;
        break;

      case Animyst.DataLoad.LOAD_ERROR:
        c = Animyst.DataLoad._queueErrorSignal;
        break;

      case Animyst.DataLoad.FILE_ERROR:
        c = Animyst.DataLoad._fileErrorSignal;
    }
    c.remove(b);
}, Animyst.DataLoad.handleLoadInitialize = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_INITIALIZE, a);
}, Animyst.DataLoad.handleLoadStart = function(a) {
    Animyst.LOG.output("[DataLoad] Load Started!");
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_STARTED, a), Animyst.DataLoad._queueStartedSignal.dispatch(a);
}, Animyst.DataLoad.handleFileStart = function(a) {
    Animyst.LOG.output("[DataLoad] Loading File:", a.item.id, "from:", a.item.src);
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_STARTED, a), Animyst.DataLoad._fileStartedSignal.dispatch(a);
}, Animyst.DataLoad.handleFileLoaded = function(a) {
    Animyst.LOG.output("[DataLoad] File Loaded:", a.item.id, "from:", a.item.src);
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_LOADED, a), Animyst.DataLoad._fileLoadedSignal.dispatch(a);
}, Animyst.DataLoad.handleLoadComplete = function(a) {
    Animyst.LOG.output("[DataLoad] Load Completed!");
    var b = Animyst.DataLoad._loadSignal, c = Animyst.DataLoad._weakHandlers.concat();
    b.dispatch(Animyst.DataLoad.LOAD_COMPLETE, a), Animyst.DataLoad._queueLoadedSignal.dispatch(a), 
    Animyst.DataLoad.removeWeakHandlers(c);
}, Animyst.DataLoad.handleFileProgress = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_PROGRESS, a), Animyst.DataLoad._fileProgressSignal.dispatch(a);
}, Animyst.DataLoad.handleOverallProgress = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_PROGRESS, a), Animyst.DataLoad._queueProgressSignal.dispatch(a);
}, Animyst.DataLoad.handleFileError = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_ERROR, a), Animyst.DataLoad._fileErrorSignal.dispatch(a);
}, Animyst.DataLoad.handleLoaderError = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_ERROR, a), Animyst.DataLoad._queueErrorSignal.dispatch(a);
}, Animyst.Entity = function(a, b, c, d) {
    Animyst.Entity.instances = (Animyst.Entity.instances || 0) + 1, this.id = a || "instance" + Animyst.Entity.instances, 
    this.type = b || EntityType.ENEMY, this["class"] = c, this.position = d || new Point(), 
    this.hitBox = null, this.mVector = new Point();
}, Animyst.Entity.prototype.update = function() {
    this.position = this.position.add(this.mVector), this.render();
}, Animyst.Entity.prototype.setHitBox = function() {
    this.hitBox = hitBox;
}, Animyst.EntityType = {
    PLAYER: 0,
    ENEMY: 1,
    PROJECTILE: 2
}, Animyst.EntityClass = {
    GENERIC: 0
}, Animyst.LOG = {}, Animyst.LOG.output = function() {
    if (Animyst.LOGGING) {
        var a = [];
        a.push("::[LOG]::");
        for (var b = 0; b < arguments.length; b++) a.push(arguments[b]);
        console.log.apply(console, a);
    }
}, Animyst.LOG.error = function() {
    if (Animyst.LOGGING) {
        var a = [];
        a.push("::[ERROR]::");
        for (var b = 0; b < arguments.length; b++) a.push(arguments[b]);
        console.error.apply(console, a);
    }
}, Animyst.System = function() {
    this.paused = !1, this.started = !1, this.startupParams = null;
}, Animyst.System.prototype.startup = function(a) {
    this.started = !0, this.startupParams = a;
}, Animyst.System.prototype.shutdown = function() {
    this.started = !1;
}, Animyst.System.prototype.update = function(a, b) {};

var ObjectUtil = {};

ObjectUtil.invert = function(a) {
    var b = {};
    for (var c in a) b[a[c]] = c;
    return b;
}, Animyst.ObjectUtil = ObjectUtil, Animyst.Window = {}, Animyst.Window.resizeSignal = new signals.Signal(), 
Animyst.Window.width = 0, Animyst.Window.height = 0, Animyst.Window._onResize = function(a) {
    Animyst.LOG.output("[Window] onResize!"), Animyst.Window.width = document.body.clientWidth, 
    Animyst.Window.height = document.body.clientHeight, Animyst.Window.resizeSignal.dispatch(a);
}, Animyst.Window._onWindowLoad = function(a) {
    Animyst.LOG.output("[Window] Window loaded:", "w:", Animyst.Window.width, "h:", Animyst.Window.height), 
    Animyst.Window.width = document.body.clientWidth, Animyst.Window.height = document.body.clientHeight;
}, Animyst.Window._setup = function() {
    window.addEventListener("resize", Animyst.Window._onResize), window.addEventListener("load", Animyst.Window._onWindowLoad);
}, Animyst.Window._setup(), Animyst.Sound = function() {}, Animyst.Sound.prototype = Object.create(Animyst.System.prototype), 
Animyst.Sound.prototype.startup = function(a) {
    Animyst.DataLoad.loadAsset("music", function(a, b) {
        if (a == Animyst.DataLoad.FILE_LOADED) {
            var c = new Howl({
                urls: [ Animyst.DataLoad.getData("music").src ]
            });
            c.play();
        }
    }), Animyst.System.prototype.startup.call(this, a);
}, Animyst.Sound.prototype.shutdown = function() {
    Animyst.System.prototype.shutdown.call(this);
}, Animyst.Sound.prototype.update = function(a, b) {}, Animyst.Graphics = {}, Animyst.Graphics.initialize = function() {
    console.log("[Graphics] Initalizing..."), Animyst.Graphics.PLAYER = new Shape.Rectangle(new Point(), new Size(50, 50)), 
    Animyst.Graphics.PLAYER.strokeColor = "#FF0011", Animyst.Graphics.PLAYER.visible = !1, 
    Animyst.Graphics.ENEMY = new Shape.Circle(new Point(), 50), Animyst.Graphics.ENEMY.strokeColor = "00FF11", 
    Animyst.Graphics.ENEMY.visible = !1;
}, Animyst.Graphics.getGraphic = function(a, b) {
    b = null == b ? !0 : b;
    var c = Animyst.Graphics.hasOwnProperty(a) ? Animyst.Graphics[a] : null;
    return c ? (c.visible = b, c) : null;
}, Animyst.PaperViewport = function() {
    Animyst.Database.call(this), this.canvas = null, this.layers = [];
}, Animyst.PaperViewport.prototype = Object.create(Animyst.Database.prototype), 
Animyst.PaperViewport.prototype.clear = function() {
    Animyst.Database.prototype.clear.call(this);
}, Animyst.PaperViewport.prototype.destroy = function() {
    Animyst.Database.prototype.destroy.call(this);
}, Animyst.SideScrollerWorld3D = function(a) {
    Animyst.System.call(this), this.threeDisplay = a;
}, Animyst.SideScrollerWorld3D.prototype = Object.create(Animyst.System.prototype), 
Animyst.SideScrollerWorld3D.prototype.startup = function(a) {
    var b = new THREE.JSONLoader(), c = b.parse(Animyst.DataLoad.getAsset("cube"));
    console.log(c);
    var d = new THREE.Mesh(c.geometry, new THREE.MeshLambertMaterial({
        color: 16711680
    }));
    this.threeDisplay.scene.add(d);
}, Animyst.SideScrollerWorld3D.prototype.shutdown = function() {
    Animyst.System.prototype.shutdown.call(this);
}, Animyst.SideScrollerWorld3D.prototype.update = function(a, b) {
    Animyst.System.prototype.update.call(this, a, b);
}, Animyst.SpriteSheetTexture = function(a) {
    THREE.Texture.call(this), this.sheetData = null, this.frames = [], this.stage = null, 
    this.renderer = null, this.playTime = 0, this.time = 0, this.loop = !0, this.currentFrame = 0, 
    this.currentFrameID = "", this.sprite = null, this.renderWidth = 0, this.renderHeight = 0, 
    this.sourceFile = "", this.addSheet(a);
}, Animyst.SpriteSheetTexture.prototype = Object.create(THREE.Texture.prototype), 
Animyst.SpriteSheetTexture.prototype._initSprite = function(a) {
    this.stage = new PIXI.Stage(16777215), this.renderer = new PIXI.WebGLRenderer(256, 256, {
        transparent: !0
    }), this.sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(a)), this.image = this.renderer.view, 
    this.stage.addChild(this.sprite), this.renderer.render(this.stage), this.needsUpdate = !0;
}, Animyst.SpriteSheetTexture.prototype.addSheet = function(a) {
    this.sheetData = a, this.frames = [];
    for (var b in a.frames) {
        var c = a.frames[b];
        c.frame.w > this.renderWidth && (this.renderWidth = c.frame.w % 2 == 0 ? c.frame.w : c.frame.w + 1), 
        c.frame.h > this.renderHeight && (this.renderHeight = c.frame.h % 2 == 0 ? c.frame.h : c.frame.h + 1), 
        this.frames.push(b);
    }
    this.sprite || (this._initSprite(this.frames[0]), this.currentFrameID = this.frames[0], 
    this.currentFrame = 0);
}, Animyst.SpriteSheetTexture.prototype.showFrame = function(a) {
    if (!(this.frames.length <= 0)) {
        a || (a = this.currentFrame || 0);
        var b;
        "string" == typeof a ? b = a : "number" == typeof a && (b = this.frames[a]), this.sprite.setTexture(PIXI.Texture.fromFrame(b)), 
        this.renderer.render(this.stage), this.needsUpdate = !0;
    }
}, Animyst.SpriteSheetTexture.prototype.play = function(a, b) {
    this.frames.length <= 0 || (this.playing = !0, this.loop = b, this.playTime = a, 
    this.time = 0);
}, Animyst.SpriteSheetTexture.prototype.stop = function() {
    this.playing = !1, this.timePassed = 0;
}, Animyst.SpriteSheetTexture.prototype.animate = function(a, b) {
    this.playing && (this.time >= this.playTime ? this.loop ? this.time = 0 : this.playing = !1 : (this.time += a, 
    this.currentFrame = Math.round(this.time / this.playTime * (this.frames.length - 1)), 
    this.currentFrame >= this.frames.length && (this.currentFrame = this.frames.length - 1), 
    this.showFrame()));
}, Animyst.Viewport3D = function(a, b, c) {
    Animyst.Database.call(this), this.width = b || 800, this.height = c || 600, this.VIEW_ANGLE = 45, 
    this.ASPECT = this.W / this.H, this.NEAR = .1, this.FAR = 1e4, this.scene = null, 
    this.renderer = null, this.camera = null, this.container = null, this.settings = null;
}, Animyst.Viewport3D.prototype = Object.create(Animyst.Database.prototype), Animyst.Viewport3D.prototype.clear = function() {
    Animyst.Database.prototype.clear.call(this);
}, Animyst.Viewport3D.prototype.destroy = function() {
    Animyst.Database.prototype.destroy.call(this);
}, Animyst.Viewport3D.prototype.initDisplay = function(a) {
    if (!a) return void Animyst.LOG.error("[Viewport3D] No initialization params specified");
    if (this.VIEW_ANGLE = a.viewAngle || this.VIEW_ANGLE, this.ASPECT = this.W / this.H, 
    this.NEAR = a.near || this.NEAR, this.FAR = a.far || this.far, this.scene = this.scene || new THREE.Scene(), 
    this.renderer = new THREE.WebGLRenderer(), this.camera = new THREE.PerspectiveCamera(this.VIEW_ANGLE, this.ASPECT, this.NEAR, this.FAR), 
    this.scene.add(this.camera), this.camera.lookAt(this.scene.position), a.container) {
        var b = document.getElementById(a.container);
        b ? b.appendChild(this.renderer.domElement) : Animyst.LOG.error("[Viewport3D] Container ID", a.container, "doesn't exist");
    }
    if (this.camera.position.x = a.cameraX || 0, this.camera.position.y = a.cameraY || 0, 
    this.camera.position.z = a.cameraZ || 0, this.camera.lookAt(this.scene.position), 
    this.renderer.setClearColor(a.rendererColor || 0), this.renderer.setSize(this.W, this.H), 
    this.renderer.shadowMapEnabled = !0, a.addAxis) {
        var c = new THREE.AxisHelper(20);
        this.scene.add(c);
    }
    if (a.debugControls) {
        THREE.OrbitControls(this.camera);
        if (Animyst.datGUI) {
            var d = Animyst.datGUI.addFolder("Viewport3D"), e = d.addFolder("camera");
            e.add(this.camera.position, "x", -1e3, 1e3).listen(), e.add(this.camera.position, "y", -1e3, 1e3).listen(), 
            e.add(this.camera.position, "z", -1e3, 1e3).listen();
        }
    }
}, Animyst.Viewport3D.prototype.append = function(a) {
    if (a) {
        var b = document.getElementById(a);
        b ? b.appendChild(this.renderer.domElement) : Animyst.LOG.error("[Viewport3D] Container ID", a, "doesn't exist");
    } else document.body.appendChild(this.renderer.domElement);
}, Animyst.Viewport3D.prototype.render = function() {
    this.renderer.render(this.scene, this.camera);
}, Animyst.Input = function(a) {
    Animyst.System.call(this), this.inputData = a, this.keyboardSettings = null;
}, Animyst.Input.KEY_DOWN = 0, Animyst.Input.KEY_UP = 1, Animyst.Input.TOUCH_START = 0, 
Animyst.Input.TOUCH_MOVE = 1, Animyst.Input.TOUCH_RELEASE = 2, Animyst.Input.TOUCH_ENTER = 3, 
Animyst.Input.TOUCH_LEAVE = 4, Animyst.Input.MOUSE_DOWN = 5, Animyst.Input.MOUSE_UP = 6, 
Animyst.Input.MOUSE_DRAG = 7, Animyst.Input.MOUSE_MOVE = 8, Animyst.Input.MOUSE_ENTER = 9, 
Animyst.Input.MOUSE_LEAVE = 10, Animyst.Input.MOUSE_CLICK = 11, Animyst.Input.prototype = Object.create(Animyst.System.prototype), 
Animyst.Input.prototype.startup = function(a) {
    var b = a.element, c = a.tool;
    this.keyboardSettings = a.keyboardSettings, c && (c.onKeyUp = this.onKeyUp.bind(this), 
    c.onKeyDown = this.onKeyDown.bind(this), c.onMouseDown = this.onMouseDown.bind(this), 
    c.onMouseUp = this.onMouseUp.bind(this), c.onMouseDrag = this.onMouseDrag.bind(this), 
    c.onMouseMove = this.onMouseMove.bind(this)), b && (b.addEventListener("touchstart", this.onTouchStart.bind(this)), 
    b.addEventListener("touchmove", this.onTouchMove.bind(this)), b.addEventListener("touchend", this.onTouchRelease.bind(this)), 
    b.addEventListener("touchenter", this.onTouchEnter.bind(this)), b.addEventListener("touchleave", this.onTouchLeave.bind(this)), 
    b.addEventListener("keydown", this.onKeyDown.bind(this)), b.addEventListener("keyup", this.onKeyUp.bind(this))), 
    Animyst.System.prototype.startup.call(this, a);
}, Animyst.Input.prototype.shutdown = function() {
    this.inputData = null, Animyst.System.prototype.shutdown.call(this);
}, Animyst.Input.prototype.update = function(a, b) {
    this.inputData.onTick(a);
}, Animyst.Input.prototype.onTouchStart = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Start!"), this.handleTouchInput(Animyst.Input.TOUCH_START, a);
}, Animyst.Input.prototype.onTouchMove = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Move!"), this.handleTouchInput(Animyst.Input.TOUCH_MOVE, a);
}, Animyst.Input.prototype.onTouchRelease = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Release!"), this.handleTouchInput(Animyst.Input.TOUCH_RELEASE, a);
}, Animyst.Input.prototype.onTouchEnter = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Enter!"), this.handleTouchInput(Animyst.Input.TOUCH_ENTER, a);
}, Animyst.Input.prototype.onTouchLeave = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Leave!"), this.handleTouchInput(Animyst.Input.TOUCH_LEAVE, a);
}, Animyst.Input.prototype.onClick = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Click!"), this.handleMouseInput(Animyst.Input.MOUSE_CLICK, a);
}, Animyst.Input.prototype.onMouseDown = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Down!"), this.handleMouseInput(Animyst.Input.MOUSE_DOWN, a);
}, Animyst.Input.prototype.onMouseDrag = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Drag!"), this.handleMouseInput(Animyst.Input.MOUSE_DRAG, a);
}, Animyst.Input.prototype.onMouseMove = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Move!"), this.handleMouseInput(Animyst.Input.MOUSE_MOVE, a);
}, Animyst.Input.prototype.onMouseUp = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Up!"), this.handleMouseInput(Animyst.Input.MOUSE_UP, a);
}, Animyst.Input.prototype.onMouseEnter = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Enter!"), this.handleMouseInput(Animyst.Input.MOUSE_ENTER, a);
}, Animyst.Input.prototype.onMouseLeave = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Leave!"), this.handleMouseInput(Animyst.Input.MOUSE_LEAVE, a);
}, Animyst.Input.prototype.onKeyUp = function(a) {
    Animyst.LOGGING && console.log("[Animyst.Input] Released Key:", a.key || Animyst.InputData.KEY_NAMES[a.keyCode]), 
    this.keyboardSettings.allowDefault[a.key || Animyst.InputData.KEY_NAMES[a.keyCode]] || a.preventDefault(), 
    this.handleKeyInput(Animyst.Input.KEY_UP, a.keyCode || Animyst.InputData.KEY_CODES[a.key]);
}, Animyst.Input.prototype.onKeyDown = function(a) {
    Animyst.LOGGING && console.log("[Animyst.Input] Pressed Key:", a.key || Animyst.InputData.KEY_NAMES[a.keyCode]), 
    this.keyboardSettings.allowDefault[a.key || Animyst.InputData.KEY_NAMES[a.keyCode]] || a.preventDefault(), 
    this.handleKeyInput(Animyst.Input.KEY_DOWN, a.keyCode || Animyst.InputData.KEY_CODES[a.key]);
}, Animyst.Input.prototype.handleMouseInput = function(a, b) {
    var c;
    (a == Animyst.Input.MOUSE_DOWN || a == Animyst.Input.MOUSE_DRAG) && (c = !0), (a == Animyst.Input.MOUSE_UP || a == Animyst.Input.MOUSE_LEAVE) && (c = !1), 
    this.inputData.setMouseInput(b, c);
}, Animyst.Input.prototype.handleKeyInput = function(a, b) {
    this.inputData.setKeyInput(b, a == Animyst.Input.KEY_DOWN);
}, Animyst.Input.prototype.handleTouchInput = function(a, b) {
    switch (a) {
      case Animyst.Input.TOUCH_START:
        this.inputData.addTouches(b.changedTouches);
        break;

      case Animyst.Input.TOUCH_MOVE:
        break;

      case Animyst.Input.TOUCH_RELEASE:
        this.inputData.removeTouches(b.touches);
        break;

      case Animyst.Input.TOUCH_ENTER:
        break;

      case Animyst.Input.TOUCH_LEAVE:    }
    this.inputData.updateTouches(b.changedTouches);
}, Animyst.InputData = function() {
    Animyst.Database.call(this), this.map = {}, this.touches = [], this.touchHistory = [], 
    this.mouse = {}, this.mouseHistory = [], this.totalTouchCount = 0, this.time = 0;
}, Animyst.InputData.TOUCH_HISTORY_LIMIT = 12, Animyst.InputData.TOUCH_PROPERTIES = [ "identifier", "screenX", "screenY", "clientX", "clientY", "pageX", "pageY", "radiusX", "radiusY", "rotationAngle", "force", "webkitForce", "target" ], 
Animyst.InputData.MOUSE_PROPERTIES = [ "clientX", "clientY", "screenX", "screenY", "type", "point", "lastPoint", "downPoint", "middlePoint", "count", "item", "modifiers" ], 
Animyst.InputData.KEY_CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    numlock: 144,
    esc: 27,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    leftarrow: 37,
    uparrow: 38,
    rightarrow: 39,
    downarrow: 40,
    insert: 45,
    "delete": 46,
    clear: 12,
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    numpad0: 96,
    numpad1: 97,
    numpad2: 98,
    numpad3: 99,
    numpad4: 100,
    numpad5: 101,
    numpad6: 102,
    numpad7: 103,
    numpad8: 104,
    numpad9: 105,
    multiply: 106,
    plus: 107,
    minus: 109,
    dot: 110,
    divide: 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    "=": 187,
    ",": 188,
    ".": 190,
    "/": 191,
    backslash: 220,
    ";": 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "-": 189,
    space: 32,
    "~": 192
}, Animyst.InputData.KEY_NAMES = Animyst.ObjectUtil.invert(Animyst.InputData.KEY_CODES), 
Animyst.InputData.MOUSE = 0, Animyst.InputData.TOUCH = 1, Animyst.InputData.KEY = 2, 
Animyst.InputData.TOUCH_ADDED = 0, Animyst.InputData.TOUCH_REMOVED = 1, Animyst.InputData.TOUCH_UPDATED = 2, 
Animyst.InputData.MOUSE_DOWN = 0, Animyst.InputData.MOUSE_UP = 1, Animyst.InputData.MOUSE_MOVE = 2, 
Animyst.InputData.KEY_ACTIVE = 0, Animyst.InputData.KEY_INACTIVE = 1, Animyst.InputData.prototype = Object.create(Animyst.Database.prototype), 
Animyst.InputData.prototype.clear = function() {
    this.map = {}, this.touches = [], this.touchHistory = [], this.totalTouchCount = 0, 
    Animyst.Database.prototype.clear.call(this);
}, Animyst.InputData.prototype.destroy = function() {
    this.map = null, this.touches = null, this.touchHistory = null, this.totalTouchCount = 0, 
    Animyst.Database.prototype.destroy.call(this);
}, Animyst.InputData.prototype.onTick = function(a) {
    this.time += a, this.mouse.down && (this.mouse.clickTime += a);
    for (var b in this.map) {
        var c = this.map[b];
        c.active && (c.time = (c.time || 0) + a);
    }
    for (var d = 0; d < this.touches.length; d++) {
        var e = this.touches[d];
        e.time += a;
    }
}, Animyst.InputData.prototype.isKeyDown = function(a) {
    var b = Animyst.InputData.KEY_CODES[a];
    return this.map[b] && this.map[b].active ? !0 : !1;
}, Animyst.InputData.prototype.setKeyInput = function(a, b) {
    var c, d = this.map[a] || {};
    b && !d.active && (d.time = 0, c = Animyst.InputData.KEY_ACTIVE), !b && d.active && (d.lastInput = {}, 
    d.lastInput.endTime = this.time, d.lastInput.duration = d.time, d.lastInput.startTime = this.time - d.time, 
    d.time = 0, c = Animyst.InputData.KEY_INACTIVE), d.active = b === !0, this.map[a] || (this.map[a] = d), 
    c && this.signal.dispatch(Animyst.InputData.KEY, c, d);
}, Animyst.InputData.prototype.setMouseInput = function(a, b) {
    this.touches.length > 0 && b && (b = !1), "boolean" != typeof b && (b = this.mouse.down);
    for (var c = this.mouse.down && !b ? this.mouse.lastClick || {} : null, d = !this.mouse.down && b ? {} : null, e = Animyst.InputData.MOUSE_MOVE, f = 0; f < Animyst.InputData.MOUSE_PROPERTIES.length; f++) {
        var g = Animyst.InputData.MOUSE_PROPERTIES[f];
        a[g] && (this.mouse[g] = a[g], c && (c[g] = a[g]), d && (d[g] = a[g]));
    }
    d && (Animyst.LOGGING && console.log("[InputData] Click Start!"), this.mouse.clickStart = d, 
    this.mouse.clickTime = 0, e = Animyst.InputData.MOUSE_DOWN), c && (Animyst.LOGGING && console.log("[InputData] Click Ended!", this.mouse.clickTime), 
    c.clickStart = this.mouse.clickStart, c.clickTime = this.mouse.clickTime, this.mouse.clickStart = null, 
    this.mouse.lastClick = c, e = Animyst.InputData.MOUSE_UP), this.mouse.down = b, 
    this.signal.dispatch(Animyst.InputData.MOUSE, e, this.mouse);
}, Animyst.InputData.prototype.getTouches = function() {
    return this.touches.splice();
}, Animyst.InputData.prototype.addTouches = function(a) {
    for (var b = 0; b < a.length; b++) {
        for (var c = a[b], d = !0, e = 0; e < this.touches.length; e++) if (this.touches[e].identifier == c.identifier) {
            d = !1;
            break;
        }
        if (d) {
            for (var f = {}, g = {}, e = 0; e < Animyst.InputData.TOUCH_PROPERTIES.length; e++) {
                var h = Animyst.InputData.TOUCH_PROPERTIES[e];
                f[h] = "object" != typeof c[h] || "target" == h ? c[h] : null, g[h] = "object" != typeof c[h] ? c[h] : null;
            }
            f.time = 0, f.timestamp = this.time, f.startData = g, f.uid = f.identifier + "" + this.totalTouchCount, 
            this.touches.push(f), this.totalTouchCount++, Animyst.LOGGING && console.log("[InputData] Adding Touch:", f.uid), 
            this.signal.dispatch(Animyst.InputData.TOUCH, Animyst.InputData.TOUCH_ADDED, f);
        }
    }
}, Animyst.InputData.prototype.removeTouches = function(a) {
    for (var b = this.touches.length - 1; b > -1 && this.touches.length > 0; b--) {
        for (var c = this.touches[b], d = !0, e = 0; e < a.length; e++) if (a[e].identifier == c.identifier) {
            d = !1;
            break;
        }
        d && (Animyst.LOGGING && console.log("[InputData] Removing Touch:", c.uid), this.touchHistory.shift(c), 
        this.touches.splice(b, 1), this.touchHistory.length > Animyst.InputData.TOUCH_HISTORY_LIMIT && this.touchHistory.pop(), 
        this.signal.dispatch(Animyst.InputData.TOUCH, Animyst.InputData.TOUCH_REMOVED, c));
    }
}, Animyst.InputData.prototype.updateTouches = function(a) {
    for (var b = 0; b < a.length; b++) {
        for (var c, d = a[b], e = 0; e < this.touches.length; e++) if (this.touches[e].identifier == d.identifier) {
            c = this.touches[e];
            break;
        }
        if (c) {
            for (var e = 0; e < Animyst.InputData.TOUCH_PROPERTIES.length; e++) {
                var f = Animyst.InputData.TOUCH_PROPERTIES[e];
                c[f] = d[f];
            }
            Animyst.LOGGING && console.log("[InputData] Updated Touch:", c.uid, Math.round(c.pageX), Math.round(c.pageY), Math.round(c.screenX), Math.round(c.screenY), c.force || c.webkitForce), 
            this.signal.dispatch(Animyst.InputData.TOUCH, Animyst.InputData.TOUCH_UPDATED, c);
        }
    }
}, Animyst.Physics = {}, Animyst.Physics.addVelocity = function(a, b) {
    a.mVector = a.mVector.add(b);
}, Animyst.Physics.applyFriction = function(a, b) {
    a.mVector = a.mVector.multiply(b);
}, Animyst.CoreProcess = function(a) {
    Animyst.AppState.call(this, a), this.inputData = null;
}, Animyst.CoreProcess.ID = "core", Animyst.CoreProcess.INPUT = "input", Animyst.CoreProcess.PAPER_VIEWPORT = "paperViewport", 
Animyst.CoreProcess.VIEWPORT_3D = "threeViewport", Animyst.CoreProcess.PIXI_VIEWPORT = "PIXIViewport", 
Animyst.CoreProcess.prototype = Object.create(Animyst.AppState.prototype), Animyst.CoreProcess.prototype.setup = function() {
    Animyst.LOG.output("[CoreProcess] Core Process Initialize"), Animyst.AppState.prototype.setup.call(this), 
    this.inputData = new Animyst.InputData();
    var a = this.appScope.config, b = new Animyst.Input(this.inputData);
    b.startup({
        element: document.body,
        keyboardSettings: a.settings.keyboard
    }), this.addSystem("input", b), this.appScope.addDatabase(Animyst.CoreProcess.INPUT, this.inputData);
}, Animyst.CoreProcess.prototype.start = function() {
    Animyst.LOG.output("[CoreProcess] Start"), Animyst.AppState.prototype.start.call(this);
}, Animyst.CoreProcess.prototype.update = function(a, b) {
    Animyst.AppState.prototype.update.call(this, a, b);
}, Animyst.CoreProcess.prototype.pause = function() {
    Animyst.AppState.prototype.pause.call(this);
}, Animyst.CoreProcess.prototype.resume = function() {
    Animyst.AppState.prototype.resume.call(this);
}, Animyst.CoreProcess.prototype.kill = function() {
    Animyst.AppState.prototype.kill.call(this);
}, Animyst.CoreProcess.prototype.restart = function() {
    Animyst.AppState.prototype.restart.call(this);
};