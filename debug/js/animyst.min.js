/*! animyst 2015-04-12 */
"use strict";

!function() {
    var a = {}, b = null, c = !0, d = !1;
    try {
        "undefined" != typeof AudioContext ? b = new AudioContext() : "undefined" != typeof webkitAudioContext ? b = new webkitAudioContext() : c = !1;
    } catch (e) {
        c = !1;
    }
    if (!c) if ("undefined" != typeof Audio) try {
        new Audio();
    } catch (e) {
        d = !0;
    } else d = !0;
    if (c) {
        var f = void 0 === b.createGain ? b.createGainNode() : b.createGain();
        f.gain.value = 1, f.connect(b.destination);
    }
    var g = function(a) {
        this._volume = 1, this._muted = !1, this.usingWebAudio = c, this.ctx = b, this.noAudio = d, 
        this._howls = [], this._codecs = a, this.iOSAutoEnable = !0;
    };
    g.prototype = {
        volume: function(a) {
            var b = this;
            if (a = parseFloat(a), a >= 0 && 1 >= a) {
                b._volume = a, c && (f.gain.value = a);
                for (var d in b._howls) if (b._howls.hasOwnProperty(d) && b._howls[d]._webAudio === !1) for (var e = 0; e < b._howls[d]._audioNode.length; e++) b._howls[d]._audioNode[e].volume = b._howls[d]._volume * b._volume;
                return b;
            }
            return c ? f.gain.value : b._volume;
        },
        mute: function() {
            return this._setMuted(!0), this;
        },
        unmute: function() {
            return this._setMuted(!1), this;
        },
        _setMuted: function(a) {
            var b = this;
            b._muted = a, c && (f.gain.value = a ? 0 : b._volume);
            for (var d in b._howls) if (b._howls.hasOwnProperty(d) && b._howls[d]._webAudio === !1) for (var e = 0; e < b._howls[d]._audioNode.length; e++) b._howls[d]._audioNode[e].muted = a;
        },
        codecs: function(a) {
            return this._codecs[a];
        },
        _enableiOSAudio: function() {
            var a = this;
            if (!b || !a._iOSEnabled && /iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                a._iOSEnabled = !1;
                var c = function() {
                    var d = b.createBuffer(1, 1, 22050), e = b.createBufferSource();
                    e.buffer = d, e.connect(b.destination), void 0 === e.start ? e.noteOn(0) : e.start(0), 
                    setTimeout(function() {
                        (e.playbackState === e.PLAYING_STATE || e.playbackState === e.FINISHED_STATE) && (a._iOSEnabled = !0, 
                        a.iOSAutoEnable = !1, window.removeEventListener("touchstart", c, !1));
                    }, 0);
                };
                return window.addEventListener("touchstart", c, !1), a;
            }
        }
    };
    var h = null, i = {};
    d || (h = new Audio(), i = {
        mp3: !!h.canPlayType("audio/mpeg;").replace(/^no$/, ""),
        opus: !!h.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
        ogg: !!h.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
        wav: !!h.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
        aac: !!h.canPlayType("audio/aac;").replace(/^no$/, ""),
        m4a: !!(h.canPlayType("audio/x-m4a;") || h.canPlayType("audio/m4a;") || h.canPlayType("audio/aac;")).replace(/^no$/, ""),
        mp4: !!(h.canPlayType("audio/x-mp4;") || h.canPlayType("audio/mp4;") || h.canPlayType("audio/aac;")).replace(/^no$/, ""),
        weba: !!h.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
    });
    var j = new g(i), k = function(a) {
        var d = this;
        d._autoplay = a.autoplay || !1, d._buffer = a.buffer || !1, d._duration = a.duration || 0, 
        d._format = a.format || null, d._loop = a.loop || !1, d._loaded = !1, d._sprite = a.sprite || {}, 
        d._src = a.src || "", d._pos3d = a.pos3d || [ 0, 0, -.5 ], d._volume = void 0 !== a.volume ? a.volume : 1, 
        d._urls = a.urls || [], d._rate = a.rate || 1, d._model = a.model || null, d._onload = [ a.onload || function() {} ], 
        d._onloaderror = [ a.onloaderror || function() {} ], d._onend = [ a.onend || function() {} ], 
        d._onpause = [ a.onpause || function() {} ], d._onplay = [ a.onplay || function() {} ], 
        d._onendTimer = [], d._webAudio = c && !d._buffer, d._audioNode = [], d._webAudio && d._setupAudioNode(), 
        void 0 !== b && b && j.iOSAutoEnable && j._enableiOSAudio(), j._howls.push(d), d.load();
    };
    if (k.prototype = {
        load: function() {
            var a = this, b = null;
            if (d) return void a.on("loaderror");
            for (var c = 0; c < a._urls.length; c++) {
                var e, f;
                if (a._format) e = a._format; else {
                    if (f = a._urls[c], e = /^data:audio\/([^;,]+);/i.exec(f), e || (e = /\.([^.]+)$/.exec(f.split("?", 1)[0])), 
                    !e) return void a.on("loaderror");
                    e = e[1].toLowerCase();
                }
                if (i[e]) {
                    b = a._urls[c];
                    break;
                }
            }
            if (!b) return void a.on("loaderror");
            if (a._src = b, a._webAudio) l(a, b); else {
                var h = new Audio();
                h.addEventListener("error", function() {
                    h.error && 4 === h.error.code && (g.noAudio = !0), a.on("loaderror", {
                        type: h.error ? h.error.code : 0
                    });
                }, !1), a._audioNode.push(h), h.src = b, h._pos = 0, h.preload = "auto", h.volume = j._muted ? 0 : a._volume * j.volume();
                var k = function() {
                    a._duration = Math.ceil(10 * h.duration) / 10, 0 === Object.getOwnPropertyNames(a._sprite).length && (a._sprite = {
                        _default: [ 0, 1e3 * a._duration ]
                    }), a._loaded || (a._loaded = !0, a.on("load")), a._autoplay && a.play(), h.removeEventListener("canplaythrough", k, !1);
                };
                h.addEventListener("canplaythrough", k, !1), h.load();
            }
            return a;
        },
        urls: function(a) {
            var b = this;
            return a ? (b.stop(), b._urls = "string" == typeof a ? [ a ] : a, b._loaded = !1, 
            b.load(), b) : b._urls;
        },
        play: function(a, c) {
            var d = this;
            return "function" == typeof a && (c = a), a && "function" != typeof a || (a = "_default"), 
            d._loaded ? d._sprite[a] ? (d._inactiveNode(function(e) {
                e._sprite = a;
                var f = e._pos > 0 ? e._pos : d._sprite[a][0] / 1e3, g = 0;
                d._webAudio ? (g = d._sprite[a][1] / 1e3 - e._pos, e._pos > 0 && (f = d._sprite[a][0] / 1e3 + f)) : g = d._sprite[a][1] / 1e3 - (f - d._sprite[a][0] / 1e3);
                var h, i = !(!d._loop && !d._sprite[a][2]), k = "string" == typeof c ? c : Math.round(Date.now() * Math.random()) + "";
                if (function() {
                    var b = {
                        id: k,
                        sprite: a,
                        loop: i
                    };
                    h = setTimeout(function() {
                        !d._webAudio && i && d.stop(b.id).play(a, b.id), d._webAudio && !i && (d._nodeById(b.id).paused = !0, 
                        d._nodeById(b.id)._pos = 0, d._clearEndTimer(b.id)), d._webAudio || i || d.stop(b.id), 
                        d.on("end", k);
                    }, 1e3 * g), d._onendTimer.push({
                        timer: h,
                        id: b.id
                    });
                }(), d._webAudio) {
                    var l = d._sprite[a][0] / 1e3, m = d._sprite[a][1] / 1e3;
                    e.id = k, e.paused = !1, o(d, [ i, l, m ], k), d._playStart = b.currentTime, e.gain.value = d._volume, 
                    void 0 === e.bufferSource.start ? e.bufferSource.noteGrainOn(0, f, g) : e.bufferSource.start(0, f, g);
                } else {
                    if (4 !== e.readyState && (e.readyState || !navigator.isCocoonJS)) return d._clearEndTimer(k), 
                    function() {
                        var b = d, f = a, g = c, h = e, i = function() {
                            b.play(f, g), h.removeEventListener("canplaythrough", i, !1);
                        };
                        h.addEventListener("canplaythrough", i, !1);
                    }(), d;
                    e.readyState = 4, e.id = k, e.currentTime = f, e.muted = j._muted || e.muted, e.volume = d._volume * j.volume(), 
                    setTimeout(function() {
                        e.play();
                    }, 0);
                }
                return d.on("play"), "function" == typeof c && c(k), d;
            }), d) : ("function" == typeof c && c(), d) : (d.on("load", function() {
                d.play(a, c);
            }), d);
        },
        pause: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.pause(a);
            }), b;
            b._clearEndTimer(a);
            var c = a ? b._nodeById(a) : b._activeNode();
            if (c) if (c._pos = b.pos(null, a), b._webAudio) {
                if (!c.bufferSource || c.paused) return b;
                c.paused = !0, void 0 === c.bufferSource.stop ? c.bufferSource.noteOff(0) : c.bufferSource.stop(0);
            } else c.pause();
            return b.on("pause"), b;
        },
        stop: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.stop(a);
            }), b;
            b._clearEndTimer(a);
            var c = a ? b._nodeById(a) : b._activeNode();
            if (c) if (c._pos = 0, b._webAudio) {
                if (!c.bufferSource || c.paused) return b;
                c.paused = !0, void 0 === c.bufferSource.stop ? c.bufferSource.noteOff(0) : c.bufferSource.stop(0);
            } else isNaN(c.duration) || (c.pause(), c.currentTime = 0);
            return b;
        },
        mute: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.mute(a);
            }), b;
            var c = a ? b._nodeById(a) : b._activeNode();
            return c && (b._webAudio ? c.gain.value = 0 : c.muted = !0), b;
        },
        unmute: function(a) {
            var b = this;
            if (!b._loaded) return b.on("play", function() {
                b.unmute(a);
            }), b;
            var c = a ? b._nodeById(a) : b._activeNode();
            return c && (b._webAudio ? c.gain.value = b._volume : c.muted = !1), b;
        },
        volume: function(a, b) {
            var c = this;
            if (a = parseFloat(a), a >= 0 && 1 >= a) {
                if (c._volume = a, !c._loaded) return c.on("play", function() {
                    c.volume(a, b);
                }), c;
                var d = b ? c._nodeById(b) : c._activeNode();
                return d && (c._webAudio ? d.gain.value = a : d.volume = a * j.volume()), c;
            }
            return c._volume;
        },
        loop: function(a) {
            var b = this;
            return "boolean" == typeof a ? (b._loop = a, b) : b._loop;
        },
        sprite: function(a) {
            var b = this;
            return "object" == typeof a ? (b._sprite = a, b) : b._sprite;
        },
        pos: function(a, c) {
            var d = this;
            if (!d._loaded) return d.on("load", function() {
                d.pos(a);
            }), "number" == typeof a ? d : d._pos || 0;
            a = parseFloat(a);
            var e = c ? d._nodeById(c) : d._activeNode();
            if (e) return a >= 0 ? (d.pause(c), e._pos = a, d.play(e._sprite, c), d) : d._webAudio ? e._pos + (b.currentTime - d._playStart) : e.currentTime;
            if (a >= 0) return d;
            for (var f = 0; f < d._audioNode.length; f++) if (d._audioNode[f].paused && 4 === d._audioNode[f].readyState) return d._webAudio ? d._audioNode[f]._pos : d._audioNode[f].currentTime;
        },
        pos3d: function(a, b, c, d) {
            var e = this;
            if (b = void 0 !== b && b ? b : 0, c = void 0 !== c && c ? c : -.5, !e._loaded) return e.on("play", function() {
                e.pos3d(a, b, c, d);
            }), e;
            if (!(a >= 0 || 0 > a)) return e._pos3d;
            if (e._webAudio) {
                var f = d ? e._nodeById(d) : e._activeNode();
                f && (e._pos3d = [ a, b, c ], f.panner.setPosition(a, b, c), f.panner.panningModel = e._model || "HRTF");
            }
            return e;
        },
        fade: function(a, b, c, d, e) {
            var f = this, g = Math.abs(a - b), h = a > b ? "down" : "up", i = g / .01, j = c / i;
            if (!f._loaded) return f.on("load", function() {
                f.fade(a, b, c, d, e);
            }), f;
            f.volume(a, e);
            for (var k = 1; i >= k; k++) !function() {
                var a = f._volume + ("up" === h ? .01 : -.01) * k, c = Math.round(1e3 * a) / 1e3, g = b;
                setTimeout(function() {
                    f.volume(c, e), c === g && d && d();
                }, j * k);
            }();
        },
        fadeIn: function(a, b, c) {
            return this.volume(0).play().fade(0, a, b, c);
        },
        fadeOut: function(a, b, c, d) {
            var e = this;
            return e.fade(e._volume, a, b, function() {
                c && c(), e.pause(d), e.on("end");
            }, d);
        },
        _nodeById: function(a) {
            for (var b = this, c = b._audioNode[0], d = 0; d < b._audioNode.length; d++) if (b._audioNode[d].id === a) {
                c = b._audioNode[d];
                break;
            }
            return c;
        },
        _activeNode: function() {
            for (var a = this, b = null, c = 0; c < a._audioNode.length; c++) if (!a._audioNode[c].paused) {
                b = a._audioNode[c];
                break;
            }
            return a._drainPool(), b;
        },
        _inactiveNode: function(a) {
            for (var b = this, c = null, d = 0; d < b._audioNode.length; d++) if (b._audioNode[d].paused && 4 === b._audioNode[d].readyState) {
                a(b._audioNode[d]), c = !0;
                break;
            }
            if (b._drainPool(), !c) {
                var e;
                if (b._webAudio) e = b._setupAudioNode(), a(e); else {
                    b.load(), e = b._audioNode[b._audioNode.length - 1];
                    var f = navigator.isCocoonJS ? "canplaythrough" : "loadedmetadata", g = function() {
                        e.removeEventListener(f, g, !1), a(e);
                    };
                    e.addEventListener(f, g, !1);
                }
            }
        },
        _drainPool: function() {
            var a, b = this, c = 0;
            for (a = 0; a < b._audioNode.length; a++) b._audioNode[a].paused && c++;
            for (a = b._audioNode.length - 1; a >= 0 && !(5 >= c); a--) b._audioNode[a].paused && (b._webAudio && b._audioNode[a].disconnect(0), 
            c--, b._audioNode.splice(a, 1));
        },
        _clearEndTimer: function(a) {
            for (var b = this, c = 0, d = 0; d < b._onendTimer.length; d++) if (b._onendTimer[d].id === a) {
                c = d;
                break;
            }
            var e = b._onendTimer[c];
            e && (clearTimeout(e.timer), b._onendTimer.splice(c, 1));
        },
        _setupAudioNode: function() {
            var a = this, c = a._audioNode, d = a._audioNode.length;
            return c[d] = void 0 === b.createGain ? b.createGainNode() : b.createGain(), c[d].gain.value = a._volume, 
            c[d].paused = !0, c[d]._pos = 0, c[d].readyState = 4, c[d].connect(f), c[d].panner = b.createPanner(), 
            c[d].panner.panningModel = a._model || "equalpower", c[d].panner.setPosition(a._pos3d[0], a._pos3d[1], a._pos3d[2]), 
            c[d].panner.connect(c[d]), c[d];
        },
        on: function(a, b) {
            var c = this, d = c["_on" + a];
            if ("function" == typeof b) d.push(b); else for (var e = 0; e < d.length; e++) b ? d[e].call(c, b) : d[e].call(c);
            return c;
        },
        off: function(a, b) {
            var c = this, d = c["_on" + a], e = b ? "" + b : null;
            if (e) {
                for (var f = 0; f < d.length; f++) if (e === "" + d[f]) {
                    d.splice(f, 1);
                    break;
                }
            } else c["_on" + a] = [];
            return c;
        },
        unload: function() {
            for (var b = this, c = b._audioNode, d = 0; d < b._audioNode.length; d++) c[d].paused || (b.stop(c[d].id), 
            b.on("end", c[d].id)), b._webAudio ? c[d].disconnect(0) : c[d].src = "";
            for (d = 0; d < b._onendTimer.length; d++) clearTimeout(b._onendTimer[d].timer);
            var e = j._howls.indexOf(b);
            null !== e && e >= 0 && j._howls.splice(e, 1), delete a[b._src], b = null;
        }
    }, c) var l = function(b, c) {
        if (c in a) return b._duration = a[c].duration, void n(b);
        if (/^data:[^;]+;base64,/.test(c)) {
            for (var d = atob(c.split(",")[1]), e = new Uint8Array(d.length), f = 0; f < d.length; ++f) e[f] = d.charCodeAt(f);
            m(e.buffer, b, c);
        } else {
            var g = new XMLHttpRequest();
            g.open("GET", c, !0), g.responseType = "arraybuffer", g.onload = function() {
                m(g.response, b, c);
            }, g.onerror = function() {
                b._webAudio && (b._buffer = !0, b._webAudio = !1, b._audioNode = [], delete b._gainNode, 
                delete a[c], b.load());
            };
            try {
                g.send();
            } catch (h) {
                g.onerror();
            }
        }
    }, m = function(c, d, e) {
        b.decodeAudioData(c, function(b) {
            b && (a[e] = b, n(d, b));
        }, function() {
            d.on("loaderror");
        });
    }, n = function(a, b) {
        a._duration = b ? b.duration : a._duration, 0 === Object.getOwnPropertyNames(a._sprite).length && (a._sprite = {
            _default: [ 0, 1e3 * a._duration ]
        }), a._loaded || (a._loaded = !0, a.on("load")), a._autoplay && a.play();
    }, o = function(c, d, e) {
        var f = c._nodeById(e);
        f.bufferSource = b.createBufferSource(), f.bufferSource.buffer = a[c._src], f.bufferSource.connect(f.panner), 
        f.bufferSource.loop = d[0], d[0] && (f.bufferSource.loopStart = d[1], f.bufferSource.loopEnd = d[1] + d[2]), 
        f.bufferSource.playbackRate.value = c._rate;
    };
    "function" == typeof define && define.amd && define(function() {
        return {
            Howler: j,
            Howl: k
        };
    }), "undefined" != typeof exports && (exports.Howler = j, exports.Howl = k), "undefined" != typeof window && (window.Howler = j, 
    window.Howl = k);
}();

var paper = new function(a) {
    var b = new function() {
        function c(a, c, d, e, g) {
            function h(f, h) {
                h = h || (h = j(c, f)) && (h.get ? h : h.value), "string" == typeof h && "#" === h[0] && (h = a[h.substring(1)] || h);
                var k, m = "function" == typeof h, n = h, o = g || m ? h && h.get ? f in a : a[f] : null;
                g && o || (m && o && (h.base = o), m && e !== !1 && (k = f.match(/^([gs]et|is)(([A-Z])(.*))$/)) && (i[k[3].toLowerCase() + k[4]] = k[2]), 
                n && !m && n.get && "function" == typeof n.get && b.isPlainObject(n) || (n = {
                    value: n,
                    writable: !0
                }), (j(a, f) || {
                    configurable: !0
                }).configurable && (n.configurable = !0, n.enumerable = d), l(a, f, n));
            }
            var i = {};
            if (c) {
                for (var k in c) c.hasOwnProperty(k) && !f.test(k) && h(k);
                for (var k in i) {
                    var m = i[k], n = a["set" + m], o = a["get" + m] || n && a["is" + m];
                    !o || e !== !0 && 0 !== o.length || h(k, {
                        get: o,
                        set: n
                    });
                }
            }
            return a;
        }
        function d(a, b, c) {
            return a && ("length" in a && !a.getLength && "number" == typeof a.length ? g : h).call(a, b, c = c || a), 
            c;
        }
        function e(a, b, c) {
            for (var d in b) !b.hasOwnProperty(d) || c && c[d] || (a[d] = b[d]);
            return a;
        }
        var f = /^(statics|enumerable|beans|preserve)$/, g = [].forEach || function(a, b) {
            for (var c = 0, d = this.length; d > c; c++) a.call(b, this[c], c, this);
        }, h = function(a, b) {
            for (var c in this) this.hasOwnProperty(c) && a.call(b, this[c], c, this);
        }, i = Object.create || function(a) {
            return {
                __proto__: a
            };
        }, j = Object.getOwnPropertyDescriptor || function(a, b) {
            var c = a.__lookupGetter__ && a.__lookupGetter__(b);
            return c ? {
                get: c,
                set: a.__lookupSetter__(b),
                enumerable: !0,
                configurable: !0
            } : a.hasOwnProperty(b) ? {
                value: a[b],
                enumerable: !0,
                configurable: !0,
                writable: !0
            } : null;
        }, k = Object.defineProperty || function(a, b, c) {
            return (c.get || c.set) && a.__defineGetter__ ? (c.get && a.__defineGetter__(b, c.get), 
            c.set && a.__defineSetter__(b, c.set)) : a[b] = c.value, a;
        }, l = function(a, b, c) {
            return delete a[b], k(a, b, c);
        };
        return c(function() {
            for (var a = 0, b = arguments.length; b > a; a++) e(this, arguments[a]);
        }, {
            inject: function(a) {
                if (a) {
                    var b = a.statics === !0 ? a : a.statics, d = a.beans, e = a.preserve;
                    b !== a && c(this.prototype, a, a.enumerable, d, e), c(this, b, !0, d, e);
                }
                for (var f = 1, g = arguments.length; g > f; f++) this.inject(arguments[f]);
                return this;
            },
            extend: function() {
                for (var a, b = this, d = 0, e = arguments.length; e > d && !(a = arguments[d].initialize); d++) ;
                return a = a || function() {
                    b.apply(this, arguments);
                }, a.prototype = i(this.prototype), a.base = b, l(a.prototype, "constructor", {
                    value: a,
                    writable: !0,
                    configurable: !0
                }), c(a, this, !0), arguments.length ? this.inject.apply(a, arguments) : a;
            }
        }, !0).inject({
            inject: function() {
                for (var a = 0, b = arguments.length; b > a; a++) {
                    var d = arguments[a];
                    d && c(this, d, d.enumerable, d.beans, d.preserve);
                }
                return this;
            },
            extend: function() {
                var a = i(this);
                return a.inject.apply(a, arguments);
            },
            each: function(a, b) {
                return d(this, a, b);
            },
            set: function(a) {
                return e(this, a);
            },
            clone: function() {
                return new this.constructor(this);
            },
            statics: {
                each: d,
                create: i,
                define: l,
                describe: j,
                set: e,
                clone: function(a) {
                    return e(new a.constructor(), a);
                },
                isPlainObject: function(a) {
                    var c = null != a && a.constructor;
                    return c && (c === Object || c === b || "Object" === c.name);
                },
                pick: function() {
                    for (var b = 0, c = arguments.length; c > b; b++) if (arguments[b] !== a) return arguments[b];
                }
            }
        });
    }();
    "undefined" != typeof module && (module.exports = b), Array.isArray || (Array.isArray = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a);
    }), document.head || (document.head = document.getElementsByTagName("head")[0]), 
    b.inject({
        toString: function() {
            return null != this._id ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + b.each(this, function(a, b) {
                if (!/^_/.test(b)) {
                    var c = typeof a;
                    this.push(b + ": " + ("number" === c ? f.instance.number(a) : "string" === c ? "'" + a + "'" : a));
                }
            }, []).join(", ") + " }";
        },
        exportJSON: function(a) {
            return b.exportJSON(this, a);
        },
        toJSON: function() {
            return b.serialize(this);
        },
        _set: function(c, d, e) {
            if (c && (e || b.isPlainObject(c))) {
                var f = c._filtering || c;
                for (var g in f) if (f.hasOwnProperty(g) && (!d || !d[g])) {
                    var h = c[g];
                    h !== a && (this[g] = h);
                }
                return !0;
            }
        },
        statics: {
            exports: {
                enumerable: !0
            },
            extend: function bb() {
                var a = bb.base.apply(this, arguments), c = a.prototype._class;
                return c && !b.exports[c] && (b.exports[c] = a), a;
            },
            equals: function(a, c) {
                function d(a, b) {
                    for (var c in a) if (a.hasOwnProperty(c) && !b.hasOwnProperty(c)) return !1;
                    return !0;
                }
                if (a === c) return !0;
                if (a && a.equals) return a.equals(c);
                if (c && c.equals) return c.equals(a);
                if (Array.isArray(a) && Array.isArray(c)) {
                    if (a.length !== c.length) return !1;
                    for (var e = 0, f = a.length; f > e; e++) if (!b.equals(a[e], c[e])) return !1;
                    return !0;
                }
                if (a && "object" == typeof a && c && "object" == typeof c) {
                    if (!d(a, c) || !d(c, a)) return !1;
                    for (var e in a) if (a.hasOwnProperty(e) && !b.equals(a[e], c[e])) return !1;
                    return !0;
                }
                return !1;
            },
            read: function(c, d, e, f) {
                if (this === b) {
                    var g = this.peek(c, d);
                    return c.__index++, g;
                }
                var h = this.prototype, i = h._readIndex, j = d || i && c.__index || 0;
                f || (f = c.length - j);
                var k = c[j];
                return k instanceof this || e && e.readNull && null == k && 1 >= f ? (i && (c.__index = j + 1), 
                k && e && e.clone ? k.clone() : k) : (k = b.create(this.prototype), i && (k.__read = !0), 
                k = k.initialize.apply(k, j > 0 || f < c.length ? Array.prototype.slice.call(c, j, j + f) : c) || k, 
                i && (c.__index = j + k.__read, k.__read = a), k);
            },
            peek: function(a, b) {
                return a[a.__index = b || a.__index || 0];
            },
            remain: function(a) {
                return a.length - (a.__index || 0);
            },
            readAll: function(a, b, c) {
                for (var d, e = [], f = b || 0, g = a.length; g > f; f++) e.push(Array.isArray(d = a[f]) ? this.read(d, 0, c) : this.read(a, f, c, 1));
                return e;
            },
            readNamed: function(c, d, e, f, g) {
                var h = this.getNamed(c, d), i = h !== a;
                if (i) {
                    var j = c._filtered;
                    j || (j = c._filtered = b.create(c[0]), j._filtering = c[0]), j[d] = a;
                }
                return this.read(i ? [ h ] : c, e, f, g);
            },
            getNamed: function(c, d) {
                var e = c[0];
                return c._hasObject === a && (c._hasObject = 1 === c.length && b.isPlainObject(e)), 
                c._hasObject ? d ? e[d] : c._filtered || e : void 0;
            },
            hasNamed: function(a, b) {
                return !!this.getNamed(a, b);
            },
            isPlainValue: function(a, b) {
                return this.isPlainObject(a) || Array.isArray(a) || b && "string" == typeof a;
            },
            serialize: function(a, c, d, e) {
                c = c || {};
                var g, h = !e;
                if (h && (c.formatter = new f(c.precision), e = {
                    length: 0,
                    definitions: {},
                    references: {},
                    add: function(a, b) {
                        var c = "#" + a._id, d = this.references[c];
                        if (!d) {
                            this.length++;
                            var e = b.call(a), f = a._class;
                            f && e[0] !== f && e.unshift(f), this.definitions[c] = e, d = this.references[c] = [ c ];
                        }
                        return d;
                    }
                }), a && a._serialize) {
                    g = a._serialize(c, e);
                    var i = a._class;
                    !i || d || g._compact || g[0] === i || g.unshift(i);
                } else if (Array.isArray(a)) {
                    g = [];
                    for (var j = 0, k = a.length; k > j; j++) g[j] = b.serialize(a[j], c, d, e);
                    d && (g._compact = !0);
                } else if (b.isPlainObject(a)) {
                    g = {};
                    for (var j in a) a.hasOwnProperty(j) && (g[j] = b.serialize(a[j], c, d, e));
                } else g = "number" == typeof a ? c.formatter.number(a, c.precision) : a;
                return h && e.length > 0 ? [ [ "dictionary", e.definitions ], g ] : g;
            },
            deserialize: function(a, c, d) {
                var e = a;
                if (d = d || {}, Array.isArray(a)) {
                    var f = a[0], g = "dictionary" === f;
                    if (!g) {
                        if (d.dictionary && 1 == a.length && /^#/.test(f)) return d.dictionary[f];
                        f = b.exports[f];
                    }
                    e = [];
                    for (var h = f ? 1 : 0, i = a.length; i > h; h++) e.push(b.deserialize(a[h], c, d));
                    if (g) d.dictionary = e[0]; else if (f) {
                        var j = e;
                        c ? e = c(f, j) : (e = b.create(f.prototype), f.apply(e, j));
                    }
                } else if (b.isPlainObject(a)) {
                    e = {};
                    for (var k in a) e[k] = b.deserialize(a[k], c, d);
                }
                return e;
            },
            exportJSON: function(a, c) {
                var d = b.serialize(a, c);
                return c && c.asString === !1 ? d : JSON.stringify(d);
            },
            importJSON: function(a, c) {
                return b.deserialize("string" == typeof a ? JSON.parse(a) : a, function(a, d) {
                    var e = c && c.constructor === a ? c : b.create(a.prototype), f = e === c;
                    if (1 === d.length && e instanceof t && (f || !(e instanceof v))) {
                        var g = d[0];
                        b.isPlainObject(g) && (g.insert = !1);
                    }
                    return a.apply(e, d), f && (c = null), e;
                });
            },
            splice: function(b, c, d, e) {
                var f = c && c.length, g = d === a;
                d = g ? b.length : d, d > b.length && (d = b.length);
                for (var h = 0; f > h; h++) c[h]._index = d + h;
                if (g) return b.push.apply(b, c), [];
                var i = [ d, e ];
                c && i.push.apply(i, c);
                for (var j = b.splice.apply(b, i), h = 0, k = j.length; k > h; h++) j[h]._index = a;
                for (var h = d + f, k = b.length; k > h; h++) b[h]._index = h;
                return j;
            },
            capitalize: function(a) {
                return a.replace(/\b[a-z]/g, function(a) {
                    return a.toUpperCase();
                });
            },
            camelize: function(a) {
                return a.replace(/-(.)/g, function(a, b) {
                    return b.toUpperCase();
                });
            },
            hyphenate: function(a) {
                return a.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
            }
        }
    });
    var c = {
        on: function(a, c) {
            if ("string" != typeof a) b.each(a, function(a, b) {
                this.on(b, a);
            }, this); else {
                var d = this._eventTypes[a];
                if (d) {
                    var e = this._callbacks = this._callbacks || {};
                    e = e[a] = e[a] || [], -1 === e.indexOf(c) && (e.push(c), d.install && 1 == e.length && d.install.call(this, a));
                }
            }
            return this;
        },
        off: function(a, c) {
            if ("string" != typeof a) return void b.each(a, function(a, b) {
                this.off(b, a);
            }, this);
            var d, e = this._eventTypes[a], f = this._callbacks && this._callbacks[a];
            return e && f && (!c || -1 !== (d = f.indexOf(c)) && 1 === f.length ? (e.uninstall && e.uninstall.call(this, a), 
            delete this._callbacks[a]) : -1 !== d && f.splice(d, 1)), this;
        },
        once: function(a, b) {
            return this.on(a, function() {
                b.apply(this, arguments), this.off(a, b);
            });
        },
        emit: function(a, b) {
            var c = this._callbacks && this._callbacks[a];
            if (!c) return !1;
            for (var d = [].slice.call(arguments, 1), e = 0, f = c.length; f > e; e++) if (c[e].apply(this, d) === !1 && b && b.stop) {
                b.stop();
                break;
            }
            return !0;
        },
        responds: function(a) {
            return !(!this._callbacks || !this._callbacks[a]);
        },
        attach: "#on",
        detach: "#off",
        fire: "#emit",
        _installEvents: function(a) {
            var b = this._callbacks, c = a ? "install" : "uninstall";
            for (var d in b) if (b[d].length > 0) {
                var e = this._eventTypes[d], f = e[c];
                f && f.call(this, d);
            }
        },
        statics: {
            inject: function cb(a) {
                var c = a._events;
                if (c) {
                    var d = {};
                    b.each(c, function(c, e) {
                        var f = "string" == typeof c, g = f ? c : e, h = b.capitalize(g), i = g.substring(2).toLowerCase();
                        d[i] = f ? {} : c, g = "_" + g, a["get" + h] = function() {
                            return this[g];
                        }, a["set" + h] = function(a) {
                            var b = this[g];
                            b && this.off(i, b), a && this.on(i, a), this[g] = a;
                        };
                    }), a._eventTypes = d;
                }
                return cb.base.apply(this, arguments);
            }
        }
    }, d = b.extend({
        _class: "PaperScope",
        initialize: function db() {
            paper = this, this.settings = new b({
                applyMatrix: !0,
                handleSize: 4,
                hitTolerance: 0
            }), this.project = null, this.projects = [], this.tools = [], this.palettes = [], 
            this._id = db._id++, db._scopes[this._id] = this;
            var a = db.prototype;
            if (!this.support) {
                var c = Z.getContext(1, 1);
                a.support = {
                    nativeDash: "setLineDash" in c || "mozDash" in c,
                    nativeBlendModes: $.nativeModes
                }, Z.release(c);
            }
            if (!this.browser) {
                var d = a.browser = {};
                navigator.userAgent.toLowerCase().replace(/(opera|chrome|safari|webkit|firefox|msie|trident)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g, function(a, b, c, e, f) {
                    if (!d.chrome) {
                        var g = "opera" === b ? e : c;
                        "trident" === b && (g = f, b = "msie"), d.version = g, d.versionNumber = parseFloat(g), 
                        d.name = b, d[b] = !0;
                    }
                }), d.chrome && delete d.webkit;
            }
        },
        version: "0.9.21",
        getView: function() {
            return this.project && this.project.getView();
        },
        getPaper: function() {
            return this;
        },
        execute: function(a, b, c) {
            paper.PaperScript.execute(a, this, b, c), R.updateFocus();
        },
        install: function(a) {
            var c = this;
            b.each([ "project", "view", "tool" ], function(d) {
                b.define(a, d, {
                    configurable: !0,
                    get: function() {
                        return c[d];
                    }
                });
            });
            for (var d in this) !/^_/.test(d) && this[d] && (a[d] = this[d]);
        },
        setup: function(a) {
            return paper = this, this.project = new r(a), this;
        },
        activate: function() {
            paper = this;
        },
        clear: function() {
            for (var a = this.projects.length - 1; a >= 0; a--) this.projects[a].remove();
            for (var a = this.tools.length - 1; a >= 0; a--) this.tools[a].remove();
            for (var a = this.palettes.length - 1; a >= 0; a--) this.palettes[a].remove();
        },
        remove: function() {
            this.clear(), delete d._scopes[this._id];
        },
        statics: new function() {
            function a(a) {
                return a += "Attribute", function(b, c) {
                    return b[a](c) || b[a]("data-paper-" + c);
                };
            }
            return {
                _scopes: {},
                _id: 0,
                get: function(a) {
                    return this._scopes[a] || null;
                },
                getAttribute: a("get"),
                hasAttribute: a("has")
            };
        }()
    }), e = b.extend(c, {
        initialize: function(a) {
            this._scope = paper, this._index = this._scope[this._list].push(this) - 1, (a || !this._scope[this._reference]) && this.activate();
        },
        activate: function() {
            if (!this._scope) return !1;
            var a = this._scope[this._reference];
            return a && a !== this && a.emit("deactivate"), this._scope[this._reference] = this, 
            this.emit("activate", a), !0;
        },
        isActive: function() {
            return this._scope[this._reference] === this;
        },
        remove: function() {
            return null == this._index ? !1 : (b.splice(this._scope[this._list], null, this._index, 1), 
            this._scope[this._reference] == this && (this._scope[this._reference] = null), this._scope = null, 
            !0);
        }
    }), f = b.extend({
        initialize: function(a) {
            this.precision = a || 5, this.multiplier = Math.pow(10, this.precision);
        },
        number: function(a) {
            return Math.round(a * this.multiplier) / this.multiplier;
        },
        pair: function(a, b, c) {
            return this.number(a) + (c || ",") + this.number(b);
        },
        point: function(a, b) {
            return this.number(a.x) + (b || ",") + this.number(a.y);
        },
        size: function(a, b) {
            return this.number(a.width) + (b || ",") + this.number(a.height);
        },
        rectangle: function(a, b) {
            return this.point(a, b) + (b || ",") + this.size(a, b);
        }
    });
    f.instance = new f();
    var g = new function() {
        function b(b, c, d) {
            var e = c === a, f = c - l, g = d + l, h = 0;
            return function(a) {
                return (e || a > f && g > a) && (b[h++] = c > a ? c : a > d ? d : a), h;
            };
        }
        var c = [ [ .5773502691896257 ], [ 0, .7745966692414834 ], [ .33998104358485626, .8611363115940526 ], [ 0, .5384693101056831, .906179845938664 ], [ .2386191860831969, .6612093864662645, .932469514203152 ], [ 0, .4058451513773972, .7415311855993945, .9491079123427585 ], [ .1834346424956498, .525532409916329, .7966664774136267, .9602898564975363 ], [ 0, .3242534234038089, .6133714327005904, .8360311073266358, .9681602395076261 ], [ .14887433898163122, .4333953941292472, .6794095682990244, .8650633666889845, .9739065285171717 ], [ 0, .26954315595234496, .5190961292068118, .7301520055740494, .8870625997680953, .978228658146057 ], [ .1252334085114689, .3678314989981802, .5873179542866175, .7699026741943047, .9041172563704749, .9815606342467192 ], [ 0, .2304583159551348, .44849275103644687, .6423493394403402, .8015780907333099, .9175983992229779, .9841830547185881 ], [ .10805494870734367, .31911236892788974, .5152486363581541, .6872929048116855, .827201315069765, .9284348836635735, .9862838086968123 ], [ 0, .20119409399743451, .3941513470775634, .5709721726085388, .7244177313601701, .8482065834104272, .937273392400706, .9879925180204854 ], [ .09501250983763744, .2816035507792589, .45801677765722737, .6178762444026438, .755404408355003, .8656312023878318, .9445750230732326, .9894009349916499 ] ], d = [ [ 1 ], [ .8888888888888888, .5555555555555556 ], [ .6521451548625461, .34785484513745385 ], [ .5688888888888889, .47862867049936647, .23692688505618908 ], [ .46791393457269104, .3607615730481386, .17132449237917036 ], [ .4179591836734694, .3818300505051189, .27970539148927664, .1294849661688697 ], [ .362683783378362, .31370664587788727, .22238103445337448, .10122853629037626 ], [ .3302393550012598, .31234707704000286, .26061069640293544, .1806481606948574, .08127438836157441 ], [ .29552422471475287, .26926671930999635, .21908636251598204, .1494513491505806, .06667134430868814 ], [ .2729250867779006, .26280454451024665, .23319376459199048, .18629021092773426, .1255803694649046, .05566856711617366 ], [ .24914704581340277, .2334925365383548, .20316742672306592, .16007832854334622, .10693932599531843, .04717533638651183 ], [ .2325515532308739, .22628318026289723, .2078160475368885, .17814598076194574, .13887351021978725, .09212149983772845, .04048400476531588 ], [ .2152638534631578, .2051984637212956, .18553839747793782, .15720316715819355, .12151857068790319, .08015808715976021, .03511946033175186 ], [ .2025782419255613, .19843148532711158, .1861610000155622, .16626920581699392, .13957067792615432, .10715922046717194, .07036604748810812, .03075324199611727 ], [ .1894506104550685, .18260341504492358, .16915651939500254, .14959598881657674, .12462897125553388, .09515851168249279, .062253523938647894, .027152459411754096 ] ], e = Math.abs, f = Math.sqrt, h = Math.pow, i = Math.cos, j = Math.PI, k = 1e-5, l = 1e-11;
        return {
            TOLERANCE: k,
            EPSILON: l,
            KAPPA: 4 * (f(2) - 1) / 3,
            isZero: function(a) {
                return e(a) <= l;
            },
            integrate: function(a, b, e, f) {
                for (var g = c[f - 2], h = d[f - 2], i = .5 * (e - b), j = i + b, k = 0, l = f + 1 >> 1, m = 1 & f ? h[k++] * a(j) : 0; l > k; ) {
                    var n = i * g[k];
                    m += h[k++] * (a(j + n) + a(j - n));
                }
                return i * m;
            },
            findRoot: function(a, b, c, d, f, g, h) {
                for (var i = 0; g > i; i++) {
                    var j = a(c), k = j / b(c), l = c - k;
                    if (e(k) < h) return l;
                    j > 0 ? (f = c, c = d >= l ? .5 * (d + f) : l) : (d = c, c = l >= f ? .5 * (d + f) : l);
                }
                return c;
            },
            solveQuadratic: function(a, c, d, g, h, i) {
                var j = b(g, h, i);
                if (e(a) < l) return e(c) >= l ? j(-d / c) : e(d) < l ? -1 : 0;
                var k = c / (2 * a), m = d / a, n = k * k;
                if (m - l > n) return 0;
                var o = n > m ? f(n - m) : 0, p = j(o - k);
                return o > 0 && (p = j(-o - k)), p;
            },
            solveCubic: function(a, c, d, k, m, n, o) {
                if (e(a) < l) return g.solveQuadratic(c, d, k, m, n, o);
                c /= a, d /= a, k /= a;
                var p = b(m, n, o), q = c * c, r = (q - 3 * d) / 9, s = (2 * q * c - 9 * c * d + 27 * k) / 54, t = r * r * r, u = s * s - t;
                if (c /= 3, e(u) < l) {
                    if (e(s) < l) return p(-c);
                    var v = f(r), w = s > 0 ? 1 : -1;
                    return p(2 * -w * v - c), p(w * v - c);
                }
                if (0 > u) {
                    var v = f(r), x = Math.acos(s / (v * v * v)) / 3, y = -2 * v, z = 2 * j / 3;
                    return p(y * i(x) - c), p(y * i(x + z) - c), p(y * i(x - z) - c);
                }
                var A = (s > 0 ? -1 : 1) * h(e(s) + f(u), 1 / 3);
                return p(A + r / A - c);
            }
        };
    }(), h = b.extend({
        _class: "Point",
        _readIndex: !0,
        initialize: function(a, b) {
            var c = typeof a;
            if ("number" === c) {
                var d = "number" == typeof b;
                this.x = a, this.y = d ? b : a, this.__read && (this.__read = d ? 2 : 1);
            } else "undefined" === c || null === a ? (this.x = this.y = 0, this.__read && (this.__read = null === a ? 1 : 0)) : (Array.isArray(a) ? (this.x = a[0], 
            this.y = a.length > 1 ? a[1] : a[0]) : null != a.x ? (this.x = a.x, this.y = a.y) : null != a.width ? (this.x = a.width, 
            this.y = a.height) : null != a.angle ? (this.x = a.length, this.y = 0, this.setAngle(a.angle)) : (this.x = this.y = 0, 
            this.__read && (this.__read = 0)), this.__read && (this.__read = 1));
        },
        set: function(a, b) {
            return this.x = a, this.y = b, this;
        },
        equals: function(a) {
            return this === a || a && (this.x === a.x && this.y === a.y || Array.isArray(a) && this.x === a[0] && this.y === a[1]) || !1;
        },
        clone: function() {
            return new h(this.x, this.y);
        },
        toString: function() {
            var a = f.instance;
            return "{ x: " + a.number(this.x) + ", y: " + a.number(this.y) + " }";
        },
        _serialize: function(a) {
            var b = a.formatter;
            return [ b.number(this.x), b.number(this.y) ];
        },
        getLength: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        setLength: function(a) {
            if (this.isZero()) {
                var b = this._angle || 0;
                this.set(Math.cos(b) * a, Math.sin(b) * a);
            } else {
                var c = a / this.getLength();
                g.isZero(c) && this.getAngle(), this.set(this.x * c, this.y * c);
            }
        },
        getAngle: function() {
            return 180 * this.getAngleInRadians.apply(this, arguments) / Math.PI;
        },
        setAngle: function(a) {
            this.setAngleInRadians.call(this, a * Math.PI / 180);
        },
        getAngleInDegrees: "#getAngle",
        setAngleInDegrees: "#setAngle",
        getAngleInRadians: function() {
            if (arguments.length) {
                var a = h.read(arguments), b = this.getLength() * a.getLength();
                if (g.isZero(b)) return 0/0;
                var c = this.dot(a) / b;
                return Math.acos(-1 > c ? -1 : c > 1 ? 1 : c);
            }
            return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
        },
        setAngleInRadians: function(a) {
            if (this._angle = a, !this.isZero()) {
                var b = this.getLength();
                this.set(Math.cos(a) * b, Math.sin(a) * b);
            }
        },
        getQuadrant: function() {
            return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
        }
    }, {
        beans: !1,
        getDirectedAngle: function() {
            var a = h.read(arguments);
            return 180 * Math.atan2(this.cross(a), this.dot(a)) / Math.PI;
        },
        getDistance: function() {
            var a = h.read(arguments), c = a.x - this.x, d = a.y - this.y, e = c * c + d * d, f = b.read(arguments);
            return f ? e : Math.sqrt(e);
        },
        normalize: function(b) {
            b === a && (b = 1);
            var c = this.getLength(), d = 0 !== c ? b / c : 0, e = new h(this.x * d, this.y * d);
            return d >= 0 && (e._angle = this._angle), e;
        },
        rotate: function(a, b) {
            if (0 === a) return this.clone();
            a = a * Math.PI / 180;
            var c = b ? this.subtract(b) : this, d = Math.sin(a), e = Math.cos(a);
            return c = new h(c.x * e - c.y * d, c.x * d + c.y * e), b ? c.add(b) : c;
        },
        transform: function(a) {
            return a ? a._transformPoint(this) : this;
        },
        add: function() {
            var a = h.read(arguments);
            return new h(this.x + a.x, this.y + a.y);
        },
        subtract: function() {
            var a = h.read(arguments);
            return new h(this.x - a.x, this.y - a.y);
        },
        multiply: function() {
            var a = h.read(arguments);
            return new h(this.x * a.x, this.y * a.y);
        },
        divide: function() {
            var a = h.read(arguments);
            return new h(this.x / a.x, this.y / a.y);
        },
        modulo: function() {
            var a = h.read(arguments);
            return new h(this.x % a.x, this.y % a.y);
        },
        negate: function() {
            return new h(-this.x, -this.y);
        },
        isInside: function() {
            return n.read(arguments).contains(this);
        },
        isClose: function(a, b) {
            return this.getDistance(a) < b;
        },
        isColinear: function(a) {
            return Math.abs(this.cross(a)) < 1e-5;
        },
        isOrthogonal: function(a) {
            return Math.abs(this.dot(a)) < 1e-5;
        },
        isZero: function() {
            return g.isZero(this.x) && g.isZero(this.y);
        },
        isNaN: function() {
            return isNaN(this.x) || isNaN(this.y);
        },
        dot: function() {
            var a = h.read(arguments);
            return this.x * a.x + this.y * a.y;
        },
        cross: function() {
            var a = h.read(arguments);
            return this.x * a.y - this.y * a.x;
        },
        project: function() {
            var a = h.read(arguments);
            if (a.isZero()) return new h(0, 0);
            var b = this.dot(a) / a.dot(a);
            return new h(a.x * b, a.y * b);
        },
        statics: {
            min: function() {
                var a = h.read(arguments), b = h.read(arguments);
                return new h(Math.min(a.x, b.x), Math.min(a.y, b.y));
            },
            max: function() {
                var a = h.read(arguments), b = h.read(arguments);
                return new h(Math.max(a.x, b.x), Math.max(a.y, b.y));
            },
            random: function() {
                return new h(Math.random(), Math.random());
            }
        }
    }, b.each([ "round", "ceil", "floor", "abs" ], function(a) {
        var b = Math[a];
        this[a] = function() {
            return new h(b(this.x), b(this.y));
        };
    }, {})), j = h.extend({
        initialize: function(a, b, c, d) {
            this._x = a, this._y = b, this._owner = c, this._setter = d;
        },
        set: function(a, b, c) {
            return this._x = a, this._y = b, c || this._owner[this._setter](this), this;
        },
        getX: function() {
            return this._x;
        },
        setX: function(a) {
            this._x = a, this._owner[this._setter](this);
        },
        getY: function() {
            return this._y;
        },
        setY: function(a) {
            this._y = a, this._owner[this._setter](this);
        }
    }), k = b.extend({
        _class: "Size",
        _readIndex: !0,
        initialize: function(a, b) {
            var c = typeof a;
            if ("number" === c) {
                var d = "number" == typeof b;
                this.width = a, this.height = d ? b : a, this.__read && (this.__read = d ? 2 : 1);
            } else "undefined" === c || null === a ? (this.width = this.height = 0, this.__read && (this.__read = null === a ? 1 : 0)) : (Array.isArray(a) ? (this.width = a[0], 
            this.height = a.length > 1 ? a[1] : a[0]) : null != a.width ? (this.width = a.width, 
            this.height = a.height) : null != a.x ? (this.width = a.x, this.height = a.y) : (this.width = this.height = 0, 
            this.__read && (this.__read = 0)), this.__read && (this.__read = 1));
        },
        set: function(a, b) {
            return this.width = a, this.height = b, this;
        },
        equals: function(a) {
            return a === this || a && (this.width === a.width && this.height === a.height || Array.isArray(a) && this.width === a[0] && this.height === a[1]) || !1;
        },
        clone: function() {
            return new k(this.width, this.height);
        },
        toString: function() {
            var a = f.instance;
            return "{ width: " + a.number(this.width) + ", height: " + a.number(this.height) + " }";
        },
        _serialize: function(a) {
            var b = a.formatter;
            return [ b.number(this.width), b.number(this.height) ];
        },
        add: function() {
            var a = k.read(arguments);
            return new k(this.width + a.width, this.height + a.height);
        },
        subtract: function() {
            var a = k.read(arguments);
            return new k(this.width - a.width, this.height - a.height);
        },
        multiply: function() {
            var a = k.read(arguments);
            return new k(this.width * a.width, this.height * a.height);
        },
        divide: function() {
            var a = k.read(arguments);
            return new k(this.width / a.width, this.height / a.height);
        },
        modulo: function() {
            var a = k.read(arguments);
            return new k(this.width % a.width, this.height % a.height);
        },
        negate: function() {
            return new k(-this.width, -this.height);
        },
        isZero: function() {
            return g.isZero(this.width) && g.isZero(this.height);
        },
        isNaN: function() {
            return isNaN(this.width) || isNaN(this.height);
        },
        statics: {
            min: function(a, b) {
                return new k(Math.min(a.width, b.width), Math.min(a.height, b.height));
            },
            max: function(a, b) {
                return new k(Math.max(a.width, b.width), Math.max(a.height, b.height));
            },
            random: function() {
                return new k(Math.random(), Math.random());
            }
        }
    }, b.each([ "round", "ceil", "floor", "abs" ], function(a) {
        var b = Math[a];
        this[a] = function() {
            return new k(b(this.width), b(this.height));
        };
    }, {})), m = k.extend({
        initialize: function(a, b, c, d) {
            this._width = a, this._height = b, this._owner = c, this._setter = d;
        },
        set: function(a, b, c) {
            return this._width = a, this._height = b, c || this._owner[this._setter](this), 
            this;
        },
        getWidth: function() {
            return this._width;
        },
        setWidth: function(a) {
            this._width = a, this._owner[this._setter](this);
        },
        getHeight: function() {
            return this._height;
        },
        setHeight: function(a) {
            this._height = a, this._owner[this._setter](this);
        }
    }), n = b.extend({
        _class: "Rectangle",
        _readIndex: !0,
        beans: !0,
        initialize: function(c, d, e, f) {
            var g = typeof c, i = 0;
            if ("number" === g ? (this.x = c, this.y = d, this.width = e, this.height = f, i = 4) : "undefined" === g || null === c ? (this.x = this.y = this.width = this.height = 0, 
            i = null === c ? 1 : 0) : 1 === arguments.length && (Array.isArray(c) ? (this.x = c[0], 
            this.y = c[1], this.width = c[2], this.height = c[3], i = 1) : c.x !== a || c.width !== a ? (this.x = c.x || 0, 
            this.y = c.y || 0, this.width = c.width || 0, this.height = c.height || 0, i = 1) : c.from === a && c.to === a && (this.x = this.y = this.width = this.height = 0, 
            this._set(c), i = 1)), !i) {
                var j = h.readNamed(arguments, "from"), l = b.peek(arguments);
                if (this.x = j.x, this.y = j.y, l && l.x !== a || b.hasNamed(arguments, "to")) {
                    var m = h.readNamed(arguments, "to");
                    this.width = m.x - j.x, this.height = m.y - j.y, this.width < 0 && (this.x = m.x, 
                    this.width = -this.width), this.height < 0 && (this.y = m.y, this.height = -this.height);
                } else {
                    var n = k.read(arguments);
                    this.width = n.width, this.height = n.height;
                }
                i = arguments.__index;
            }
            this.__read && (this.__read = i);
        },
        set: function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = c, this.height = d, this;
        },
        clone: function() {
            return new n(this.x, this.y, this.width, this.height);
        },
        equals: function(a) {
            var c = b.isPlainValue(a) ? n.read(arguments) : a;
            return c === this || c && this.x === c.x && this.y === c.y && this.width === c.width && this.height === c.height || !1;
        },
        toString: function() {
            var a = f.instance;
            return "{ x: " + a.number(this.x) + ", y: " + a.number(this.y) + ", width: " + a.number(this.width) + ", height: " + a.number(this.height) + " }";
        },
        _serialize: function(a) {
            var b = a.formatter;
            return [ b.number(this.x), b.number(this.y), b.number(this.width), b.number(this.height) ];
        },
        getPoint: function(a) {
            var b = a ? h : j;
            return new b(this.x, this.y, this, "setPoint");
        },
        setPoint: function() {
            var a = h.read(arguments);
            this.x = a.x, this.y = a.y;
        },
        getSize: function(a) {
            var b = a ? k : m;
            return new b(this.width, this.height, this, "setSize");
        },
        setSize: function() {
            var a = k.read(arguments);
            this._fixX && (this.x += (this.width - a.width) * this._fixX), this._fixY && (this.y += (this.height - a.height) * this._fixY), 
            this.width = a.width, this.height = a.height, this._fixW = 1, this._fixH = 1;
        },
        getLeft: function() {
            return this.x;
        },
        setLeft: function(a) {
            this._fixW || (this.width -= a - this.x), this.x = a, this._fixX = 0;
        },
        getTop: function() {
            return this.y;
        },
        setTop: function(a) {
            this._fixH || (this.height -= a - this.y), this.y = a, this._fixY = 0;
        },
        getRight: function() {
            return this.x + this.width;
        },
        setRight: function(b) {
            this._fixX !== a && 1 !== this._fixX && (this._fixW = 0), this._fixW ? this.x = b - this.width : this.width = b - this.x, 
            this._fixX = 1;
        },
        getBottom: function() {
            return this.y + this.height;
        },
        setBottom: function(b) {
            this._fixY !== a && 1 !== this._fixY && (this._fixH = 0), this._fixH ? this.y = b - this.height : this.height = b - this.y, 
            this._fixY = 1;
        },
        getCenterX: function() {
            return this.x + .5 * this.width;
        },
        setCenterX: function(a) {
            this.x = a - .5 * this.width, this._fixX = .5;
        },
        getCenterY: function() {
            return this.y + .5 * this.height;
        },
        setCenterY: function(a) {
            this.y = a - .5 * this.height, this._fixY = .5;
        },
        getCenter: function(a) {
            var b = a ? h : j;
            return new b(this.getCenterX(), this.getCenterY(), this, "setCenter");
        },
        setCenter: function() {
            var a = h.read(arguments);
            return this.setCenterX(a.x), this.setCenterY(a.y), this;
        },
        getArea: function() {
            return this.width * this.height;
        },
        isEmpty: function() {
            return 0 === this.width || 0 === this.height;
        },
        contains: function(b) {
            return b && b.width !== a || 4 == (Array.isArray(b) ? b : arguments).length ? this._containsRectangle(n.read(arguments)) : this._containsPoint(h.read(arguments));
        },
        _containsPoint: function(a) {
            var b = a.x, c = a.y;
            return b >= this.x && c >= this.y && b <= this.x + this.width && c <= this.y + this.height;
        },
        _containsRectangle: function(a) {
            var b = a.x, c = a.y;
            return b >= this.x && c >= this.y && b + a.width <= this.x + this.width && c + a.height <= this.y + this.height;
        },
        intersects: function() {
            var a = n.read(arguments);
            return a.x + a.width > this.x && a.y + a.height > this.y && a.x < this.x + this.width && a.y < this.y + this.height;
        },
        touches: function() {
            var a = n.read(arguments);
            return a.x + a.width >= this.x && a.y + a.height >= this.y && a.x <= this.x + this.width && a.y <= this.y + this.height;
        },
        intersect: function() {
            var a = n.read(arguments), b = Math.max(this.x, a.x), c = Math.max(this.y, a.y), d = Math.min(this.x + this.width, a.x + a.width), e = Math.min(this.y + this.height, a.y + a.height);
            return new n(b, c, d - b, e - c);
        },
        unite: function() {
            var a = n.read(arguments), b = Math.min(this.x, a.x), c = Math.min(this.y, a.y), d = Math.max(this.x + this.width, a.x + a.width), e = Math.max(this.y + this.height, a.y + a.height);
            return new n(b, c, d - b, e - c);
        },
        include: function() {
            var a = h.read(arguments), b = Math.min(this.x, a.x), c = Math.min(this.y, a.y), d = Math.max(this.x + this.width, a.x), e = Math.max(this.y + this.height, a.y);
            return new n(b, c, d - b, e - c);
        },
        expand: function() {
            var a = k.read(arguments), b = a.width, c = a.height;
            return new n(this.x - b / 2, this.y - c / 2, this.width + b, this.height + c);
        },
        scale: function(b, c) {
            return this.expand(this.width * b - this.width, this.height * (c === a ? b : c) - this.height);
        }
    }, b.each([ [ "Top", "Left" ], [ "Top", "Right" ], [ "Bottom", "Left" ], [ "Bottom", "Right" ], [ "Left", "Center" ], [ "Top", "Center" ], [ "Right", "Center" ], [ "Bottom", "Center" ] ], function(a, b) {
        var c = a.join(""), d = /^[RL]/.test(c);
        b >= 4 && (a[1] += d ? "Y" : "X");
        var e = a[d ? 0 : 1], f = a[d ? 1 : 0], g = "get" + e, i = "get" + f, k = "set" + e, l = "set" + f, m = "get" + c, n = "set" + c;
        this[m] = function(a) {
            var b = a ? h : j;
            return new b(this[g](), this[i](), this, n);
        }, this[n] = function() {
            var a = h.read(arguments);
            this[k](a.x), this[l](a.y);
        };
    }, {
        beans: !0
    })), o = n.extend({
        initialize: function(a, b, c, d, e, f) {
            this.set(a, b, c, d, !0), this._owner = e, this._setter = f;
        },
        set: function(a, b, c, d, e) {
            return this._x = a, this._y = b, this._width = c, this._height = d, e || this._owner[this._setter](this), 
            this;
        }
    }, new function() {
        var a = n.prototype;
        return b.each([ "x", "y", "width", "height" ], function(a) {
            var c = b.capitalize(a), d = "_" + a;
            this["get" + c] = function() {
                return this[d];
            }, this["set" + c] = function(a) {
                this[d] = a, this._dontNotify || this._owner[this._setter](this);
            };
        }, b.each([ "Point", "Size", "Center", "Left", "Top", "Right", "Bottom", "CenterX", "CenterY", "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter" ], function(b) {
            var c = "set" + b;
            this[c] = function() {
                this._dontNotify = !0, a[c].apply(this, arguments), this._dontNotify = !1, this._owner[this._setter](this);
            };
        }, {
            isSelected: function() {
                return this._owner._boundsSelected;
            },
            setSelected: function(a) {
                var b = this._owner;
                b.setSelected && (b._boundsSelected = a, b.setSelected(a || b._selectedSegmentState > 0));
            }
        }));
    }()), p = b.extend({
        _class: "Matrix",
        initialize: function eb(a) {
            var b = arguments.length, c = !0;
            if (6 === b ? this.set.apply(this, arguments) : 1 === b ? a instanceof eb ? this.set(a._a, a._c, a._b, a._d, a._tx, a._ty) : Array.isArray(a) ? this.set.apply(this, a) : c = !1 : 0 === b ? this.reset() : c = !1, 
            !c) throw new Error("Unsupported matrix parameters");
        },
        set: function(a, b, c, d, e, f, g) {
            return this._a = a, this._c = b, this._b = c, this._d = d, this._tx = e, this._ty = f, 
            g || this._changed(), this;
        },
        _serialize: function(a) {
            return b.serialize(this.getValues(), a);
        },
        _changed: function() {
            var a = this._owner;
            a && (a._applyMatrix ? a.transform(null, !0) : a._changed(9));
        },
        clone: function() {
            return new p(this._a, this._c, this._b, this._d, this._tx, this._ty);
        },
        equals: function(a) {
            return a === this || a && this._a === a._a && this._b === a._b && this._c === a._c && this._d === a._d && this._tx === a._tx && this._ty === a._ty || !1;
        },
        toString: function() {
            var a = f.instance;
            return "[[" + [ a.number(this._a), a.number(this._b), a.number(this._tx) ].join(", ") + "], [" + [ a.number(this._c), a.number(this._d), a.number(this._ty) ].join(", ") + "]]";
        },
        reset: function(a) {
            return this._a = this._d = 1, this._c = this._b = this._tx = this._ty = 0, a || this._changed(), 
            this;
        },
        apply: function() {
            var a = this._owner;
            return a ? (a.transform(null, !0), this.isIdentity()) : !1;
        },
        translate: function() {
            var a = h.read(arguments), b = a.x, c = a.y;
            return this._tx += b * this._a + c * this._b, this._ty += b * this._c + c * this._d, 
            this._changed(), this;
        },
        scale: function() {
            var a = h.read(arguments), b = h.read(arguments, 0, {
                readNull: !0
            });
            return b && this.translate(b), this._a *= a.x, this._c *= a.x, this._b *= a.y, this._d *= a.y, 
            b && this.translate(b.negate()), this._changed(), this;
        },
        rotate: function(a) {
            a *= Math.PI / 180;
            var b = h.read(arguments, 1), c = b.x, d = b.y, e = Math.cos(a), f = Math.sin(a), g = c - c * e + d * f, i = d - c * f - d * e, j = this._a, k = this._b, l = this._c, m = this._d;
            return this._a = e * j + f * k, this._b = -f * j + e * k, this._c = e * l + f * m, 
            this._d = -f * l + e * m, this._tx += g * j + i * k, this._ty += g * l + i * m, 
            this._changed(), this;
        },
        shear: function() {
            var a = h.read(arguments), b = h.read(arguments, 0, {
                readNull: !0
            });
            b && this.translate(b);
            var c = this._a, d = this._c;
            return this._a += a.y * this._b, this._c += a.y * this._d, this._b += a.x * c, this._d += a.x * d, 
            b && this.translate(b.negate()), this._changed(), this;
        },
        skew: function() {
            var a = h.read(arguments), b = h.read(arguments, 0, {
                readNull: !0
            }), c = Math.PI / 180, d = new h(Math.tan(a.x * c), Math.tan(a.y * c));
            return this.shear(d, b);
        },
        concatenate: function(a) {
            var b = this._a, c = this._b, d = this._c, e = this._d, f = a._a, g = a._b, h = a._c, i = a._d, j = a._tx, k = a._ty;
            return this._a = f * b + h * c, this._b = g * b + i * c, this._c = f * d + h * e, 
            this._d = g * d + i * e, this._tx += j * b + k * c, this._ty += j * d + k * e, this._changed(), 
            this;
        },
        preConcatenate: function(a) {
            var b = this._a, c = this._b, d = this._c, e = this._d, f = this._tx, g = this._ty, h = a._a, i = a._b, j = a._c, k = a._d, l = a._tx, m = a._ty;
            return this._a = h * b + i * d, this._b = h * c + i * e, this._c = j * b + k * d, 
            this._d = j * c + k * e, this._tx = h * f + i * g + l, this._ty = j * f + k * g + m, 
            this._changed(), this;
        },
        chain: function(a) {
            var b = this._a, c = this._b, d = this._c, e = this._d, f = this._tx, g = this._ty, h = a._a, i = a._b, j = a._c, k = a._d, l = a._tx, m = a._ty;
            return new p(h * b + j * c, h * d + j * e, i * b + k * c, i * d + k * e, f + l * b + m * c, g + l * d + m * e);
        },
        isIdentity: function() {
            return 1 === this._a && 0 === this._c && 0 === this._b && 1 === this._d && 0 === this._tx && 0 === this._ty;
        },
        orNullIfIdentity: function() {
            return this.isIdentity() ? null : this;
        },
        isInvertible: function() {
            return !!this._getDeterminant();
        },
        isSingular: function() {
            return !this._getDeterminant();
        },
        transform: function(a, b, c) {
            return arguments.length < 3 ? this._transformPoint(h.read(arguments)) : this._transformCoordinates(a, b, c);
        },
        _transformPoint: function(a, b, c) {
            var d = a.x, e = a.y;
            return b || (b = new h()), b.set(d * this._a + e * this._b + this._tx, d * this._c + e * this._d + this._ty, c);
        },
        _transformCoordinates: function(a, b, c) {
            for (var d = 0, e = 0, f = 2 * c; f > d; ) {
                var g = a[d++], h = a[d++];
                b[e++] = g * this._a + h * this._b + this._tx, b[e++] = g * this._c + h * this._d + this._ty;
            }
            return b;
        },
        _transformCorners: function(a) {
            var b = a.x, c = a.y, d = b + a.width, e = c + a.height, f = [ b, c, d, c, d, e, b, e ];
            return this._transformCoordinates(f, f, 4);
        },
        _transformBounds: function(a, b, c) {
            for (var d = this._transformCorners(a), e = d.slice(0, 2), f = d.slice(), g = 2; 8 > g; g++) {
                var h = d[g], i = 1 & g;
                h < e[i] ? e[i] = h : h > f[i] && (f[i] = h);
            }
            return b || (b = new n()), b.set(e[0], e[1], f[0] - e[0], f[1] - e[1], c);
        },
        inverseTransform: function() {
            return this._inverseTransform(h.read(arguments));
        },
        _getDeterminant: function() {
            var a = this._a * this._d - this._b * this._c;
            return isFinite(a) && !g.isZero(a) && isFinite(this._tx) && isFinite(this._ty) ? a : null;
        },
        _inverseTransform: function(a, b, c) {
            var d = this._getDeterminant();
            if (!d) return null;
            var e = a.x - this._tx, f = a.y - this._ty;
            return b || (b = new h()), b.set((e * this._d - f * this._b) / d, (f * this._a - e * this._c) / d, c);
        },
        decompose: function() {
            var a = this._a, b = this._b, c = this._c, d = this._d;
            if (g.isZero(a * d - b * c)) return null;
            var e = Math.sqrt(a * a + b * b);
            a /= e, b /= e;
            var f = a * c + b * d;
            c -= a * f, d -= b * f;
            var i = Math.sqrt(c * c + d * d);
            return c /= i, d /= i, f /= i, b * c > a * d && (a = -a, b = -b, f = -f, e = -e), 
            {
                scaling: new h(e, i),
                rotation: 180 * -Math.atan2(b, a) / Math.PI,
                shearing: f
            };
        },
        getValues: function() {
            return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
        },
        getTranslation: function() {
            return new h(this._tx, this._ty);
        },
        getScaling: function() {
            return (this.decompose() || {}).scaling;
        },
        getRotation: function() {
            return (this.decompose() || {}).rotation;
        },
        inverted: function() {
            var a = this._getDeterminant();
            return a && new p(this._d / a, -this._c / a, -this._b / a, this._a / a, (this._b * this._ty - this._d * this._tx) / a, (this._c * this._tx - this._a * this._ty) / a);
        },
        shiftless: function() {
            return new p(this._a, this._c, this._b, this._d, 0, 0);
        },
        applyToContext: function(a) {
            a.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
        }
    }, b.each([ "a", "c", "b", "d", "tx", "ty" ], function(a) {
        var c = b.capitalize(a), d = "_" + a;
        this["get" + c] = function() {
            return this[d];
        }, this["set" + c] = function(a) {
            this[d] = a, this._changed();
        };
    }, {})), q = b.extend({
        _class: "Line",
        initialize: function(a, b, c, d, e) {
            var f = !1;
            arguments.length >= 4 ? (this._px = a, this._py = b, this._vx = c, this._vy = d, 
            f = e) : (this._px = a.x, this._py = a.y, this._vx = b.x, this._vy = b.y, f = c), 
            f || (this._vx -= this._px, this._vy -= this._py);
        },
        getPoint: function() {
            return new h(this._px, this._py);
        },
        getVector: function() {
            return new h(this._vx, this._vy);
        },
        getLength: function() {
            return this.getVector().getLength();
        },
        intersect: function(a, b) {
            return q.intersect(this._px, this._py, this._vx, this._vy, a._px, a._py, a._vx, a._vy, !0, b);
        },
        getSide: function(a) {
            return q.getSide(this._px, this._py, this._vx, this._vy, a.x, a.y, !0);
        },
        getDistance: function(a) {
            return Math.abs(q.getSignedDistance(this._px, this._py, this._vx, this._vy, a.x, a.y, !0));
        },
        statics: {
            intersect: function(a, b, c, d, e, f, i, j, k, l) {
                k || (c -= a, d -= b, i -= e, j -= f);
                var m = c * j - d * i;
                if (!g.isZero(m)) {
                    var n = a - e, o = b - f, p = (i * o - j * n) / m, q = (c * o - d * n) / m;
                    if (l || p >= 0 && 1 >= p && q >= 0 && 1 >= q) return new h(a + p * c, b + p * d);
                }
            },
            getSide: function(a, b, c, d, e, f, g) {
                g || (c -= a, d -= b);
                var h = e - a, i = f - b, j = h * d - i * c;
                return 0 === j && (j = h * c + i * d, j > 0 && (h -= c, i -= d, j = h * c + i * d, 
                0 > j && (j = 0))), 0 > j ? -1 : j > 0 ? 1 : 0;
            },
            getSignedDistance: function(a, b, c, d, e, f, h) {
                if (h || (c -= a, d -= b), g.isZero(c)) return e - a;
                var i = d / c, j = b - i * a;
                return (f - i * e - j) / Math.sqrt(i * i + 1);
            }
        }
    }), r = e.extend({
        _class: "Project",
        _list: "projects",
        _reference: "project",
        initialize: function(a) {
            e.call(this, !0), this.layers = [], this._activeLayer = null, this.symbols = [], 
            this._currentStyle = new O(null, null, this), this._view = R.create(this, a || Z.getCanvas(1, 1)), 
            this._selectedItems = {}, this._selectedItemCount = 0, this._updateVersion = 0;
        },
        _serialize: function(a, c) {
            return b.serialize(this.layers, a, !0, c);
        },
        clear: function() {
            for (var a = this.layers.length - 1; a >= 0; a--) this.layers[a].remove();
            this.symbols = [];
        },
        isEmpty: function() {
            return 0 === this.layers.length;
        },
        remove: function fb() {
            return fb.base.call(this) ? (this._view && this._view.remove(), !0) : !1;
        },
        getView: function() {
            return this._view;
        },
        getCurrentStyle: function() {
            return this._currentStyle;
        },
        setCurrentStyle: function(a) {
            this._currentStyle.initialize(a);
        },
        getIndex: function() {
            return this._index;
        },
        getOptions: function() {
            return this._scope.settings;
        },
        getActiveLayer: function() {
            return this._activeLayer || new v({
                project: this
            });
        },
        getSelectedItems: function() {
            var a = [];
            for (var b in this._selectedItems) {
                var c = this._selectedItems[b];
                c.isInserted() && a.push(c);
            }
            return a;
        },
        addChild: function(a) {
            return a instanceof v ? (b.splice(this.layers, [ a ]), this._activeLayer || (this._activeLayer = a)) : a instanceof t ? (this._activeLayer || this.addChild(new v(t.NO_INSERT))).addChild(a) : a = null, 
            a;
        },
        _updateSelection: function(a) {
            var b = a._id, c = this._selectedItems;
            a._selected ? c[b] !== a && (this._selectedItemCount++, c[b] = a) : c[b] === a && (this._selectedItemCount--, 
            delete c[b]);
        },
        selectAll: function() {
            for (var a = this.layers, b = 0, c = a.length; c > b; b++) a[b].setFullySelected(!0);
        },
        deselectAll: function() {
            var a = this._selectedItems;
            for (var b in a) a[b].setFullySelected(!1);
        },
        hitTest: function() {
            for (var a = h.read(arguments), c = z.getOptions(b.read(arguments)), d = this.layers.length - 1; d >= 0; d--) {
                var e = this.layers[d]._hitTest(a, c);
                if (e) return e;
            }
            return null;
        },
        getItems: function(a) {
            return t._getItems(this.layers, a);
        },
        getItem: function(a) {
            return t._getItems(this.layers, a, null, null, !0)[0] || null;
        },
        importJSON: function(a) {
            this.activate();
            var c = this._activeLayer;
            return b.importJSON(a, c && c.isEmpty() && c);
        },
        draw: function(a, c, d) {
            this._updateVersion++, a.save(), c.applyToContext(a);
            for (var e = new b({
                offset: new h(0, 0),
                pixelRatio: d,
                viewMatrix: c.isIdentity() ? null : c,
                matrices: [ new p() ],
                updateMatrix: !0
            }), f = 0, g = this.layers, i = g.length; i > f; f++) g[f].draw(a, e);
            if (a.restore(), this._selectedItemCount > 0) {
                a.save(), a.strokeWidth = 1;
                var j = this._selectedItems, k = this._scope.settings.handleSize, l = this._updateVersion;
                for (var m in j) j[m]._drawSelection(a, c, k, j, l);
                a.restore();
            }
        }
    }), s = b.extend({
        _class: "Symbol",
        initialize: function gb(a, b) {
            this._id = gb._id = (gb._id || 0) + 1, this.project = paper.project, this.project.symbols.push(this), 
            a && this.setDefinition(a, b);
        },
        _serialize: function(a, c) {
            return c.add(this, function() {
                return b.serialize([ this._class, this._definition ], a, !1, c);
            });
        },
        _changed: function(a) {
            8 & a && t._clearBoundsCache(this), 1 & a && (this.project._needsUpdate = !0);
        },
        getDefinition: function() {
            return this._definition;
        },
        setDefinition: function(a, b) {
            a._parentSymbol && (a = a.clone()), this._definition && (this._definition._parentSymbol = null), 
            this._definition = a, a.remove(), a.setSelected(!1), b || a.setPosition(new h()), 
            a._parentSymbol = this, this._changed(9);
        },
        place: function(a) {
            return new y(this, a);
        },
        clone: function() {
            return new s(this._definition.clone(!1));
        }
    }), t = b.extend(c, {
        statics: {
            extend: function hb(a) {
                return a._serializeFields && (a._serializeFields = new b(this.prototype._serializeFields, a._serializeFields)), 
                hb.base.apply(this, arguments);
            },
            NO_INSERT: {
                insert: !1
            }
        },
        _class: "Item",
        _applyMatrix: !0,
        _canApplyMatrix: !0,
        _boundsSelected: !1,
        _selectChildren: !1,
        _serializeFields: {
            name: null,
            applyMatrix: null,
            matrix: new p(),
            pivot: null,
            locked: !1,
            visible: !0,
            blendMode: "normal",
            opacity: 1,
            guide: !1,
            selected: !1,
            clipMask: !1,
            data: {}
        },
        initialize: function() {},
        _initialize: function(a, c) {
            var d = a && b.isPlainObject(a), e = d && a.internal === !0, f = this._matrix = new p(), g = d && a.project || paper.project;
            return e || (this._id = t._id = (t._id || 0) + 1), this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix, 
            c && f.translate(c), f._owner = this, this._style = new O(g._currentStyle, this, g), 
            this._project || (e || d && a.insert === !1 ? this._setProject(g) : d && a.parent ? this.setParent(a.parent) : (g._activeLayer || new v()).addChild(this)), 
            d && a !== t.NO_INSERT && this._set(a, {
                insert: !0,
                parent: !0
            }, !0), d;
        },
        _events: new function() {
            var a = {
                mousedown: {
                    mousedown: 1,
                    mousedrag: 1,
                    click: 1,
                    doubleclick: 1
                },
                mouseup: {
                    mouseup: 1,
                    mousedrag: 1,
                    click: 1,
                    doubleclick: 1
                },
                mousemove: {
                    mousedrag: 1,
                    mousemove: 1,
                    mouseenter: 1,
                    mouseleave: 1
                }
            }, c = {
                install: function(b) {
                    var c = this.getView()._eventCounters;
                    if (c) for (var d in a) c[d] = (c[d] || 0) + (a[d][b] || 0);
                },
                uninstall: function(b) {
                    var c = this.getView()._eventCounters;
                    if (c) for (var d in a) c[d] -= a[d][b] || 0;
                }
            };
            return b.each([ "onMouseDown", "onMouseUp", "onMouseDrag", "onClick", "onDoubleClick", "onMouseMove", "onMouseEnter", "onMouseLeave" ], function(a) {
                this[a] = c;
            }, {
                onFrame: {
                    install: function() {
                        this._animateItem(!0);
                    },
                    uninstall: function() {
                        this._animateItem(!1);
                    }
                },
                onLoad: {}
            });
        }(),
        _animateItem: function(a) {
            this.getView()._animateItem(this, a);
        },
        _serialize: function(a, c) {
            function d(d) {
                for (var g in d) {
                    var h = f[g];
                    b.equals(h, "leading" === g ? 1.2 * d.fontSize : d[g]) || (e[g] = b.serialize(h, a, "data" !== g, c));
                }
            }
            var e = {}, f = this;
            return d(this._serializeFields), this instanceof u || d(this._style._defaults), 
            [ this._class, e ];
        },
        _changed: function(b) {
            var c = this._parentSymbol, d = this._parent || c, e = this._project;
            if (8 & b && (this._bounds = this._position = this._decomposed = this._globalMatrix = this._currentPath = a), 
            d && 40 & b && t._clearBoundsCache(d), 2 & b && t._clearBoundsCache(this), e && (1 & b && (e._needsUpdate = !0), 
            e._changes)) {
                var f = e._changesById[this._id];
                f ? f.flags |= b : (f = {
                    item: this,
                    flags: b
                }, e._changesById[this._id] = f, e._changes.push(f));
            }
            c && c._changed(b);
        },
        set: function(a) {
            return a && this._set(a), this;
        },
        getId: function() {
            return this._id;
        },
        getClassName: function() {
            return this._class;
        },
        getName: function() {
            return this._name;
        },
        setName: function(b, c) {
            if (this._name && this._removeNamed(), b === +b + "") throw new Error("Names consisting only of numbers are not supported.");
            var d = this._parent;
            if (b && d) {
                for (var e = d._children, f = d._namedChildren, g = b, h = 1; c && e[b]; ) b = g + " " + h++;
                (f[b] = f[b] || []).push(this), e[b] = this;
            }
            this._name = b || a, this._changed(128);
        },
        getStyle: function() {
            return this._style;
        },
        setStyle: function(a) {
            this.getStyle().set(a);
        }
    }, b.each([ "locked", "visible", "blendMode", "opacity", "guide" ], function(a) {
        var c = b.capitalize(a), a = "_" + a;
        this["get" + c] = function() {
            return this[a];
        }, this["set" + c] = function(b) {
            b != this[a] && (this[a] = b, this._changed("_locked" === a ? 128 : 129));
        };
    }, {}), {
        beans: !0,
        _locked: !1,
        _visible: !0,
        _blendMode: "normal",
        _opacity: 1,
        _guide: !1,
        isSelected: function() {
            if (this._selectChildren) for (var a = this._children, b = 0, c = a.length; c > b; b++) if (a[b].isSelected()) return !0;
            return this._selected;
        },
        setSelected: function(a, b) {
            if (!b && this._selectChildren) for (var c = this._children, d = 0, e = c.length; e > d; d++) c[d].setSelected(a);
            (a = !!a) ^ this._selected && (this._selected = a, this._project._updateSelection(this), 
            this._changed(129));
        },
        _selected: !1,
        isFullySelected: function() {
            var a = this._children;
            if (a && this._selected) {
                for (var b = 0, c = a.length; c > b; b++) if (!a[b].isFullySelected()) return !1;
                return !0;
            }
            return this._selected;
        },
        setFullySelected: function(a) {
            var b = this._children;
            if (b) for (var c = 0, d = b.length; d > c; c++) b[c].setFullySelected(a);
            this.setSelected(a, !0);
        },
        isClipMask: function() {
            return this._clipMask;
        },
        setClipMask: function(a) {
            this._clipMask != (a = !!a) && (this._clipMask = a, a && (this.setFillColor(null), 
            this.setStrokeColor(null)), this._changed(129), this._parent && this._parent._changed(1024));
        },
        _clipMask: !1,
        getData: function() {
            return this._data || (this._data = {}), this._data;
        },
        setData: function(a) {
            this._data = a;
        },
        getPosition: function(a) {
            var b = this._position, c = a ? h : j;
            if (!b) {
                var d = this._pivot;
                b = this._position = d ? this._matrix._transformPoint(d) : this.getBounds().getCenter(!0);
            }
            return new c(b.x, b.y, this, "setPosition");
        },
        setPosition: function() {
            this.translate(h.read(arguments).subtract(this.getPosition(!0)));
        },
        getPivot: function(a) {
            var b = this._pivot;
            if (b) {
                var c = a ? h : j;
                b = new c(b.x, b.y, this, "setPivot");
            }
            return b;
        },
        setPivot: function() {
            this._pivot = h.read(arguments), this._position = a;
        },
        _pivot: null,
        getRegistration: "#getPivot",
        setRegistration: "#setPivot"
    }, b.each([ "bounds", "strokeBounds", "handleBounds", "roughBounds", "internalBounds", "internalRoughBounds" ], function(a) {
        var c = "get" + b.capitalize(a), d = a.match(/^internal(.*)$/), e = d ? "get" + d[1] : null;
        this[c] = function(b) {
            var d = this._boundsGetter, f = !e && ("string" == typeof d ? d : d && d[c]) || c, g = this._getCachedBounds(f, b, this, e);
            return "bounds" === a ? new o(g.x, g.y, g.width, g.height, this, "setBounds") : g;
        };
    }, {
        beans: !0,
        _getBounds: function(a, b, c) {
            var d = this._children;
            if (!d || 0 == d.length) return new n();
            for (var e = 1/0, f = -e, g = e, h = f, i = 0, j = d.length; j > i; i++) {
                var k = d[i];
                if (k._visible && !k.isEmpty()) {
                    var l = k._getCachedBounds(a, b && b.chain(k._matrix), c);
                    e = Math.min(l.x, e), g = Math.min(l.y, g), f = Math.max(l.x + l.width, f), h = Math.max(l.y + l.height, h);
                }
            }
            return isFinite(e) ? new n(e, g, f - e, h - g) : new n();
        },
        setBounds: function() {
            var a = n.read(arguments), b = this.getBounds(), c = new p(), d = a.getCenter();
            c.translate(d), (a.width != b.width || a.height != b.height) && c.scale(0 != b.width ? a.width / b.width : 1, 0 != b.height ? a.height / b.height : 1), 
            d = b.getCenter(), c.translate(-d.x, -d.y), this.transform(c);
        },
        _getCachedBounds: function(a, b, c, d) {
            b = b && b.orNullIfIdentity();
            var e = d ? null : this._matrix.orNullIfIdentity(), f = (!b || b.equals(e)) && a, g = this._parent || this._parentSymbol;
            if (g) {
                var h = c._id, i = g._boundsCache = g._boundsCache || {
                    ids: {},
                    list: []
                };
                i.ids[h] || (i.list.push(c), i.ids[h] = c);
            }
            if (f && this._bounds && this._bounds[f]) return this._bounds[f].clone();
            var j = this._getBounds(d || a, b || e, c);
            if (f) {
                this._bounds || (this._bounds = {});
                var k = this._bounds[f] = j.clone();
                k._internal = !!d;
            }
            return j;
        },
        statics: {
            _clearBoundsCache: function(b) {
                var c = b._boundsCache;
                if (c) {
                    b._bounds = b._position = b._boundsCache = a;
                    for (var d = 0, e = c.list, f = e.length; f > d; d++) {
                        var g = e[d];
                        g !== b && (g._bounds = g._position = a, g._boundsCache && t._clearBoundsCache(g));
                    }
                }
            }
        }
    }), {
        beans: !0,
        _decompose: function() {
            return this._decomposed = this._matrix.decompose();
        },
        getRotation: function() {
            var a = this._decomposed || this._decompose();
            return a && a.rotation;
        },
        setRotation: function(a) {
            var b = this.getRotation();
            if (null != b && null != a) {
                var c = this._decomposed;
                this.rotate(a - b), c.rotation = a, this._decomposed = c;
            }
        },
        getScaling: function(a) {
            var b = this._decomposed || this._decompose(), c = b && b.scaling, d = a ? h : j;
            return c && new d(c.x, c.y, this, "setScaling");
        },
        setScaling: function() {
            var a = this.getScaling();
            if (a) {
                var b = h.read(arguments, 0, {
                    clone: !0
                }), c = this._decomposed;
                this.scale(b.x / a.x, b.y / a.y), c.scaling = b, this._decomposed = c;
            }
        },
        getMatrix: function() {
            return this._matrix;
        },
        setMatrix: function(a) {
            this._matrix.initialize(a), this._applyMatrix ? this.transform(null, !0) : this._changed(9);
        },
        getGlobalMatrix: function(a) {
            var b = this._globalMatrix, c = this._project._updateVersion;
            if (b && b._updateVersion !== c && (b = null), !b) {
                b = this._globalMatrix = this._matrix.clone();
                var d = this._parent;
                d && b.preConcatenate(d.getGlobalMatrix(!0)), b._updateVersion = c;
            }
            return a ? b : b.clone();
        },
        getApplyMatrix: function() {
            return this._applyMatrix;
        },
        setApplyMatrix: function(a) {
            (this._applyMatrix = this._canApplyMatrix && !!a) && this.transform(null, !0);
        },
        getTransformContent: "#getApplyMatrix",
        setTransformContent: "#setApplyMatrix"
    }, {
        getProject: function() {
            return this._project;
        },
        _setProject: function(a, b) {
            if (this._project !== a) {
                this._project && this._installEvents(!1), this._project = a;
                for (var c = this._children, d = 0, e = c && c.length; e > d; d++) c[d]._setProject(a);
                b = !0;
            }
            b && this._installEvents(!0);
        },
        getView: function() {
            return this._project.getView();
        },
        _installEvents: function ib(a) {
            ib.base.call(this, a);
            for (var b = this._children, c = 0, d = b && b.length; d > c; c++) b[c]._installEvents(a);
        },
        getLayer: function() {
            for (var a = this; a = a._parent; ) if (a instanceof v) return a;
            return null;
        },
        getParent: function() {
            return this._parent;
        },
        setParent: function(a) {
            return a.addChild(this);
        },
        getChildren: function() {
            return this._children;
        },
        setChildren: function(a) {
            this.removeChildren(), this.addChildren(a);
        },
        getFirstChild: function() {
            return this._children && this._children[0] || null;
        },
        getLastChild: function() {
            return this._children && this._children[this._children.length - 1] || null;
        },
        getNextSibling: function() {
            return this._parent && this._parent._children[this._index + 1] || null;
        },
        getPreviousSibling: function() {
            return this._parent && this._parent._children[this._index - 1] || null;
        },
        getIndex: function() {
            return this._index;
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && this._style.equals(a._style) && this._matrix.equals(a._matrix) && this._locked === a._locked && this._visible === a._visible && this._blendMode === a._blendMode && this._opacity === a._opacity && this._clipMask === a._clipMask && this._guide === a._guide && this._equals(a) || !1;
        },
        _equals: function(a) {
            return b.equals(this._children, a._children);
        },
        clone: function(a) {
            return this._clone(new this.constructor(t.NO_INSERT), a);
        },
        _clone: function(c, d) {
            if (c.setStyle(this._style), this._children) for (var e = 0, f = this._children.length; f > e; e++) c.addChild(this._children[e].clone(!1), !0);
            (d || d === a) && c.insertAbove(this);
            for (var g = [ "_locked", "_visible", "_blendMode", "_opacity", "_clipMask", "_guide", "_applyMatrix" ], e = 0, f = g.length; f > e; e++) {
                var h = g[e];
                this.hasOwnProperty(h) && (c[h] = this[h]);
            }
            return c._matrix.initialize(this._matrix), c._data = this._data ? b.clone(this._data) : null, 
            c.setSelected(this._selected), this._name && c.setName(this._name, !0), c;
        },
        copyTo: function(a) {
            return a.addChild(this.clone(!1));
        },
        rasterize: function(a) {
            var c = this.getStrokeBounds(), d = (a || this.getView().getResolution()) / 72, e = c.getTopLeft().floor(), f = c.getBottomRight().ceil(), g = new k(f.subtract(e)), h = Z.getCanvas(g.multiply(d)), i = h.getContext("2d"), j = new p().scale(d).translate(e.negate());
            i.save(), j.applyToContext(i), this.draw(i, new b({
                matrices: [ j ]
            })), i.restore();
            var l = new x(t.NO_INSERT);
            return l.setCanvas(h), l.transform(new p().translate(e.add(g.divide(2))).scale(1 / d)), 
            l.insertAbove(this), l;
        },
        contains: function() {
            return !!this._contains(this._matrix._inverseTransform(h.read(arguments)));
        },
        _contains: function(a) {
            if (this._children) {
                for (var b = this._children.length - 1; b >= 0; b--) if (this._children[b].contains(a)) return !0;
                return !1;
            }
            return a.isInside(this.getInternalBounds());
        },
        isInside: function() {
            return n.read(arguments).contains(this.getBounds());
        },
        _asPathItem: function() {
            return new F.Rectangle({
                rectangle: this.getInternalBounds(),
                matrix: this._matrix,
                insert: !1
            });
        },
        intersects: function(a, b) {
            return a instanceof t ? this._asPathItem().getIntersections(a._asPathItem(), b || a._matrix).length > 0 : !1;
        },
        hitTest: function() {
            return this._hitTest(h.read(arguments), z.getOptions(b.read(arguments)));
        },
        _hitTest: function(a, c) {
            function d(c, d) {
                var e = n["get" + d]();
                return a.subtract(e).divide(i).length <= 1 ? new z(c, m, {
                    name: b.hyphenate(d),
                    point: e
                }) : void 0;
            }
            if (this._locked || !this._visible || this._guide && !c.guides || this.isEmpty()) return null;
            var e = this._matrix, f = c._totalMatrix, g = this.getView(), h = c._totalMatrix = f ? f.chain(e) : this.getGlobalMatrix().preConcatenate(g._matrix), i = c._tolerancePadding = new k(F._getPenPadding(1, h.inverted())).multiply(Math.max(c.tolerance, 1e-5));
            if (a = e._inverseTransform(a), !this._children && !this.getInternalRoughBounds().expand(i.multiply(2))._containsPoint(a)) return null;
            var j, l = !(c.guides && !this._guide || c.selected && !this._selected || c.type && c.type !== b.hyphenate(this._class) || c["class"] && !(this instanceof c["class"])), m = this;
            if (l && (c.center || c.bounds) && this._parent) {
                var n = this.getInternalBounds();
                if (c.center && (j = d("center", "Center")), !j && c.bounds) for (var o = [ "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter" ], p = 0; 8 > p && !j; p++) j = d("bounds", o[p]);
            }
            var q = !j && this._children;
            if (q) for (var r = this._getChildHitTestOptions(c), p = q.length - 1; p >= 0 && !j; p--) j = q[p]._hitTest(a, r);
            return !j && l && (j = this._hitTestSelf(a, c)), j && j.point && (j.point = e.transform(j.point)), 
            c._totalMatrix = f, j;
        },
        _getChildHitTestOptions: function(a) {
            return a;
        },
        _hitTestSelf: function(a, b) {
            return b.fill && this.hasFill() && this._contains(a) ? new z("fill", this) : void 0;
        },
        matches: function(a, c) {
            function d(a, c) {
                for (var e in a) if (a.hasOwnProperty(e)) {
                    var f = a[e], g = c[e];
                    if (b.isPlainObject(f) && b.isPlainObject(g)) {
                        if (!d(f, g)) return !1;
                    } else if (!b.equals(f, g)) return !1;
                }
                return !0;
            }
            if ("object" == typeof a) {
                for (var e in a) if (a.hasOwnProperty(e) && !this.matches(e, a[e])) return !1;
            } else {
                var f = /^(empty|editable)$/.test(a) ? this["is" + b.capitalize(a)]() : "type" === a ? b.hyphenate(this._class) : this[a];
                if (/^(constructor|class)$/.test(a)) {
                    if (!(this instanceof c)) return !1;
                } else if (c instanceof RegExp) {
                    if (!c.test(f)) return !1;
                } else if ("function" == typeof c) {
                    if (!c(f)) return !1;
                } else if (b.isPlainObject(c)) {
                    if (!d(c, f)) return !1;
                } else if (!b.equals(f, c)) return !1;
            }
            return !0;
        },
        getItems: function(a) {
            return t._getItems(this._children, a, this._matrix);
        },
        getItem: function(a) {
            return t._getItems(this._children, a, this._matrix, null, !0)[0] || null;
        },
        statics: {
            _getItems: function jb(a, c, d, e, f) {
                if (!e) {
                    var g = c.overlapping, h = c.inside, i = g || h, j = i && n.read([ i ]);
                    e = {
                        items: [],
                        inside: j,
                        overlapping: g && new F.Rectangle({
                            rectangle: j,
                            insert: !1
                        })
                    }, i && (c = b.set({}, c, {
                        inside: !0,
                        overlapping: !0
                    }));
                }
                var k = e.items, h = e.inside, g = e.overlapping;
                d = h && (d || new p());
                for (var l = 0, m = a && a.length; m > l; l++) {
                    var o = a[l], q = d && d.chain(o._matrix), r = !0;
                    if (h) {
                        var i = o.getBounds(q);
                        if (!h.intersects(i)) continue;
                        h && h.contains(i) || g && g.intersects(o, q) || (r = !1);
                    }
                    if (r && o.matches(c) && (k.push(o), f)) break;
                    if (jb(o._children, c, q, e, f), f && k.length > 0) break;
                }
                return k;
            }
        }
    }, {
        importJSON: function(a) {
            var c = b.importJSON(a, this);
            return c !== this ? this.addChild(c) : c;
        },
        addChild: function(b, c) {
            return this.insertChild(a, b, c);
        },
        insertChild: function(a, b, c) {
            var d = this.insertChildren(a, [ b ], c);
            return d && d[0];
        },
        addChildren: function(a, b) {
            return this.insertChildren(this._children.length, a, b);
        },
        insertChildren: function(a, c, d, e) {
            var f = this._children;
            if (f && c && c.length > 0) {
                c = Array.prototype.slice.apply(c);
                for (var g = c.length - 1; g >= 0; g--) {
                    var h = c[g];
                    !e || h instanceof e ? h._remove(!1, !0) : c.splice(g, 1);
                }
                b.splice(f, c, a, 0);
                for (var i = this._project, j = i && i._changes, g = 0, k = c.length; k > g; g++) {
                    var h = c[g];
                    h._parent = this, h._setProject(this._project, !0), h._name && h.setName(h._name), 
                    j && this._changed(5);
                }
                this._changed(11);
            } else c = null;
            return c;
        },
        _insert: function(a, b, c) {
            if (!b._parent) return null;
            var d = b._index + (a ? 1 : 0);
            return b._parent === this._parent && d > this._index && d--, b._parent.insertChild(d, this, c);
        },
        insertAbove: function(a, b) {
            return this._insert(!0, a, b);
        },
        insertBelow: function(a, b) {
            return this._insert(!1, a, b);
        },
        sendToBack: function() {
            return this._parent.insertChild(0, this);
        },
        bringToFront: function() {
            return this._parent.addChild(this);
        },
        appendTop: "#addChild",
        appendBottom: function(a) {
            return this.insertChild(0, a);
        },
        moveAbove: "#insertAbove",
        moveBelow: "#insertBelow",
        reduce: function() {
            if (this._children && 1 === this._children.length) {
                var a = this._children[0].reduce();
                return a.insertAbove(this), a.setStyle(this._style), this.remove(), a;
            }
            return this;
        },
        _removeNamed: function() {
            var a = this._parent;
            if (a) {
                var b = a._children, c = a._namedChildren, d = this._name, e = c[d], f = e ? e.indexOf(this) : -1;
                -1 !== f && (b[d] == this && delete b[d], e.splice(f, 1), e.length ? b[d] = e[e.length - 1] : delete c[d]);
            }
        },
        _remove: function(a, c) {
            var d = this._parent;
            if (d) {
                if (this._name && this._removeNamed(), null != this._index && b.splice(d._children, null, this._index, 1), 
                this._installEvents(!1), a) {
                    var e = this._project;
                    e && e._changes && this._changed(5);
                }
                return c && d._changed(11), this._parent = null, !0;
            }
            return !1;
        },
        remove: function() {
            return this._remove(!0, !0);
        },
        replaceWith: function(a) {
            var b = a && a.insertBelow(this);
            return b && this.remove(), b;
        },
        removeChildren: function(a, c) {
            if (!this._children) return null;
            a = a || 0, c = b.pick(c, this._children.length);
            for (var d = b.splice(this._children, null, a, c - a), e = d.length - 1; e >= 0; e--) d[e]._remove(!0, !1);
            return d.length > 0 && this._changed(11), d;
        },
        clear: "#removeChildren",
        reverseChildren: function() {
            if (this._children) {
                this._children.reverse();
                for (var a = 0, b = this._children.length; b > a; a++) this._children[a]._index = a;
                this._changed(11);
            }
        },
        isEmpty: function() {
            return !this._children || 0 === this._children.length;
        },
        isEditable: function() {
            for (var a = this; a; ) {
                if (!a._visible || a._locked) return !1;
                a = a._parent;
            }
            return !0;
        },
        hasFill: function() {
            return this.getStyle().hasFill();
        },
        hasStroke: function() {
            return this.getStyle().hasStroke();
        },
        hasShadow: function() {
            return this.getStyle().hasShadow();
        },
        _getOrder: function(a) {
            function b(a) {
                var b = [];
                do b.unshift(a); while (a = a._parent);
                return b;
            }
            for (var c = b(this), d = b(a), e = 0, f = Math.min(c.length, d.length); f > e; e++) if (c[e] != d[e]) return c[e]._index < d[e]._index ? 1 : -1;
            return 0;
        },
        hasChildren: function() {
            return this._children && this._children.length > 0;
        },
        isInserted: function() {
            return this._parent ? this._parent.isInserted() : !1;
        },
        isAbove: function(a) {
            return -1 === this._getOrder(a);
        },
        isBelow: function(a) {
            return 1 === this._getOrder(a);
        },
        isParent: function(a) {
            return this._parent === a;
        },
        isChild: function(a) {
            return a && a._parent === this;
        },
        isDescendant: function(a) {
            for (var b = this; b = b._parent; ) if (b == a) return !0;
            return !1;
        },
        isAncestor: function(a) {
            return a ? a.isDescendant(this) : !1;
        },
        isGroupedWith: function(a) {
            for (var b = this._parent; b; ) {
                if (b._parent && /^(Group|Layer|CompoundPath)$/.test(b._class) && a.isDescendant(b)) return !0;
                b = b._parent;
            }
            return !1;
        },
        translate: function() {
            var a = new p();
            return this.transform(a.translate.apply(a, arguments));
        },
        rotate: function(a) {
            return this.transform(new p().rotate(a, h.read(arguments, 1, {
                readNull: !0
            }) || this.getPosition(!0)));
        }
    }, b.each([ "scale", "shear", "skew" ], function(a) {
        this[a] = function() {
            var b = h.read(arguments), c = h.read(arguments, 0, {
                readNull: !0
            });
            return this.transform(new p()[a](b, c || this.getPosition(!0)));
        };
    }, {}), {
        transform: function(a, b) {
            a && a.isIdentity() && (a = null);
            var c = this._matrix, d = (b || this._applyMatrix) && (!c.isIdentity() || a);
            if (!a && !d) return this;
            if (a && c.preConcatenate(a), d = d && this._transformContent(c)) {
                var e = this._pivot, f = this._style, g = f.getFillColor(!0), h = f.getStrokeColor(!0);
                e && c._transformPoint(e, e, !0), g && g.transform(c), h && h.transform(c), c.reset(!0);
            }
            var i = this._bounds, j = this._position;
            this._changed(9);
            var k = i && a && a.decompose();
            if (k && !k.shearing && k.rotation % 90 === 0) {
                for (var l in i) {
                    var m = i[l];
                    (d || !m._internal) && a._transformBounds(m, m);
                }
                var n = this._boundsGetter, m = i[n && n.getBounds || n || "getBounds"];
                m && (this._position = m.getCenter(!0)), this._bounds = i;
            } else a && j && (this._position = a._transformPoint(j, j));
            return this;
        },
        _transformContent: function(a) {
            var b = this._children;
            if (b) {
                for (var c = 0, d = b.length; d > c; c++) b[c].transform(a, !0);
                return !0;
            }
        },
        globalToLocal: function() {
            return this.getGlobalMatrix(!0)._inverseTransform(h.read(arguments));
        },
        localToGlobal: function() {
            return this.getGlobalMatrix(!0)._transformPoint(h.read(arguments));
        },
        parentToLocal: function() {
            return this._matrix._inverseTransform(h.read(arguments));
        },
        localToParent: function() {
            return this._matrix._transformPoint(h.read(arguments));
        },
        fitBounds: function(a, b) {
            a = n.read(arguments);
            var c = this.getBounds(), d = c.height / c.width, e = a.height / a.width, f = (b ? d > e : e > d) ? a.width / c.width : a.height / c.height, g = new n(new h(), new k(c.width * f, c.height * f));
            g.setCenter(a.getCenter()), this.setBounds(g);
        },
        _setStyles: function(a) {
            var b = this._style, c = b.getFillColor(), d = b.getStrokeColor(), e = b.getShadowColor();
            if (c && (a.fillStyle = c.toCanvasStyle(a)), d) {
                var f = b.getStrokeWidth();
                if (f > 0) {
                    a.strokeStyle = d.toCanvasStyle(a), a.lineWidth = f;
                    var g = b.getStrokeJoin(), h = b.getStrokeCap(), i = b.getMiterLimit();
                    if (g && (a.lineJoin = g), h && (a.lineCap = h), i && (a.miterLimit = i), paper.support.nativeDash) {
                        var j = b.getDashArray(), k = b.getDashOffset();
                        j && j.length && ("setLineDash" in a ? (a.setLineDash(j), a.lineDashOffset = k) : (a.mozDash = j, 
                        a.mozDashOffset = k));
                    }
                }
            }
            if (e) {
                var l = b.getShadowBlur();
                if (l > 0) {
                    a.shadowColor = e.toCanvasStyle(a), a.shadowBlur = l;
                    var m = this.getShadowOffset();
                    a.shadowOffsetX = m.x, a.shadowOffsetY = m.y;
                }
            }
        },
        draw: function(a, b, c) {
            function d(a) {
                return g ? g.chain(a) : a;
            }
            var e = this._updateVersion = this._project._updateVersion;
            if (this._visible && 0 !== this._opacity) {
                var f = b.matrices, g = b.viewMatrix, h = this._matrix, i = f[f.length - 1].chain(h);
                if (i.isInvertible()) {
                    f.push(i), b.updateMatrix && (i._updateVersion = e, this._globalMatrix = i);
                    var j, k, l, m = this._blendMode, n = this._opacity, o = "normal" === m, p = $.nativeModes[m], q = o && 1 === n || b.dontStart || b.clip || (p || o && 1 > n) && this._canComposite(), r = b.pixelRatio;
                    if (!q) {
                        var s = this.getStrokeBounds(d(i));
                        if (!s.width || !s.height) return;
                        l = b.offset, k = b.offset = s.getTopLeft().floor(), j = a, a = Z.getContext(s.getSize().ceil().add(1).multiply(r)), 
                        1 !== r && a.scale(r, r);
                    }
                    a.save();
                    var t = c ? c.chain(h) : !this.getStrokeScaling(!0) && d(i), u = !q && b.clipItem, v = !t || u;
                    if (q ? (a.globalAlpha = n, p && (a.globalCompositeOperation = m)) : v && a.translate(-k.x, -k.y), 
                    v && (q ? h : d(i)).applyToContext(a), u && b.clipItem.draw(a, b.extend({
                        clip: !0
                    })), t) {
                        a.setTransform(r, 0, 0, r, 0, 0);
                        var w = b.offset;
                        w && a.translate(-w.x, -w.y);
                    }
                    this._draw(a, b, t), a.restore(), f.pop(), b.clip && !b.dontFinish && a.clip(), 
                    q || ($.process(m, a, j, n, k.subtract(l).multiply(r)), Z.release(a), b.offset = l);
                }
            }
        },
        _isUpdated: function(a) {
            var b = this._parent;
            if (b instanceof G) return b._isUpdated(a);
            var c = this._updateVersion === a;
            return !c && b && b._visible && b._isUpdated(a) && (this._updateVersion = a, c = !0), 
            c;
        },
        _drawSelection: function(a, b, c, d, e) {
            if ((this._drawSelected || this._boundsSelected) && this._isUpdated(e)) {
                var f = this.getSelectedColor(!0) || this.getLayer().getSelectedColor(!0), g = b.chain(this.getGlobalMatrix(!0));
                if (a.strokeStyle = a.fillStyle = f ? f.toCanvasStyle(a) : "#009dec", this._drawSelected && this._drawSelected(a, g, d), 
                this._boundsSelected) {
                    var h = c / 2;
                    coords = g._transformCorners(this.getInternalBounds()), a.beginPath();
                    for (var i = 0; 8 > i; i++) a[0 === i ? "moveTo" : "lineTo"](coords[i], coords[++i]);
                    a.closePath(), a.stroke();
                    for (var i = 0; 8 > i; i++) a.fillRect(coords[i] - h, coords[++i] - h, c, c);
                }
            }
        },
        _canComposite: function() {
            return !1;
        }
    }, b.each([ "down", "drag", "up", "move" ], function(a) {
        this["removeOn" + b.capitalize(a)] = function() {
            var b = {};
            return b[a] = !0, this.removeOn(b);
        };
    }, {
        removeOn: function(a) {
            for (var b in a) if (a[b]) {
                var c = "mouse" + b, d = this._project, e = d._removeSets = d._removeSets || {};
                e[c] = e[c] || {}, e[c][this._id] = this;
            }
            return this;
        }
    })), u = t.extend({
        _class: "Group",
        _selectChildren: !0,
        _serializeFields: {
            children: []
        },
        initialize: function(a) {
            this._children = [], this._namedChildren = {}, this._initialize(a) || this.addChildren(Array.isArray(a) ? a : arguments);
        },
        _changed: function kb(b) {
            kb.base.call(this, b), 1026 & b && (this._clipItem = a);
        },
        _getClipItem: function() {
            var b = this._clipItem;
            if (b === a) {
                b = null;
                for (var c = 0, d = this._children.length; d > c; c++) {
                    var e = this._children[c];
                    if (e._clipMask) {
                        b = e;
                        break;
                    }
                }
                this._clipItem = b;
            }
            return b;
        },
        isClipped: function() {
            return !!this._getClipItem();
        },
        setClipped: function(a) {
            var b = this.getFirstChild();
            b && b.setClipMask(a);
        },
        _draw: function(a, b) {
            var c = b.clip, d = !c && this._getClipItem(), e = !0;
            if (b = b.extend({
                clipItem: d,
                clip: !1
            }), c ? this._currentPath ? (a.currentPath = this._currentPath, e = !1) : (a.beginPath(), 
            b.dontStart = b.dontFinish = !0) : d && d.draw(a, b.extend({
                clip: !0
            })), e) for (var f = 0, g = this._children.length; g > f; f++) {
                var h = this._children[f];
                h !== d && h.draw(a, b);
            }
            c && (this._currentPath = a.currentPath);
        }
    }), v = u.extend({
        _class: "Layer",
        initialize: function(c) {
            var d = b.isPlainObject(c) ? new b(c) : {
                children: Array.isArray(c) ? c : arguments
            }, e = d.insert;
            d.insert = !1, u.call(this, d), (e || e === a) && (this._project.addChild(this), 
            this.activate());
        },
        _remove: function lb(a) {
            if (this._parent) return lb.base.call(this, a);
            if (null != this._index) {
                var c = this._project;
                return c._activeLayer === this && (c._activeLayer = this.getNextSibling() || this.getPreviousSibling()), 
                b.splice(c.layers, null, this._index, 1), this._installEvents(!1), c._needsUpdate = !0, 
                !0;
            }
            return !1;
        },
        getNextSibling: function mb() {
            return this._parent ? mb.base.call(this) : this._project.layers[this._index + 1] || null;
        },
        getPreviousSibling: function nb() {
            return this._parent ? nb.base.call(this) : this._project.layers[this._index - 1] || null;
        },
        isInserted: function ob() {
            return this._parent ? ob.base.call(this) : null != this._index;
        },
        activate: function() {
            this._project._activeLayer = this;
        },
        _insert: function pb(a, c, d) {
            return c instanceof v && !c._parent ? (this._remove(!0, !0), b.splice(c._project.layers, [ this ], c._index + (a ? 1 : 0), 0), 
            this._setProject(c._project, !0), this) : pb.base.call(this, a, c, d);
        }
    }), w = t.extend({
        _class: "Shape",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsSelected: !0,
        _serializeFields: {
            type: null,
            size: null,
            radius: null
        },
        initialize: function(a) {
            this._initialize(a);
        },
        _equals: function(a) {
            return this._type === a._type && this._size.equals(a._size) && b.equals(this._radius, a._radius);
        },
        clone: function(a) {
            var b = new w(t.NO_INSERT);
            return b.setType(this._type), b.setSize(this._size), b.setRadius(this._radius), 
            this._clone(b, a);
        },
        getType: function() {
            return this._type;
        },
        setType: function(a) {
            this._type = a;
        },
        getShape: "#getType",
        setShape: "#setType",
        getSize: function() {
            var a = this._size;
            return new m(a.width, a.height, this, "setSize");
        },
        setSize: function() {
            var a = k.read(arguments);
            if (this._size) {
                if (!this._size.equals(a)) {
                    var b = this._type, c = a.width, d = a.height;
                    if ("rectangle" === b) {
                        var e = k.min(this._radius, a.divide(2));
                        this._radius.set(e.width, e.height);
                    } else "circle" === b ? (c = d = (c + d) / 2, this._radius = c / 2) : "ellipse" === b && this._radius.set(c / 2, d / 2);
                    this._size.set(c, d), this._changed(9);
                }
            } else this._size = a.clone();
        },
        getRadius: function() {
            var a = this._radius;
            return "circle" === this._type ? a : new m(a.width, a.height, this, "setRadius");
        },
        setRadius: function(a) {
            var b = this._type;
            if ("circle" === b) {
                if (a === this._radius) return;
                var c = 2 * a;
                this._radius = a, this._size.set(c, c);
            } else if (a = k.read(arguments), this._radius) {
                if (this._radius.equals(a)) return;
                if (this._radius.set(a.width, a.height), "rectangle" === b) {
                    var c = k.max(this._size, a.multiply(2));
                    this._size.set(c.width, c.height);
                } else "ellipse" === b && this._size.set(2 * a.width, 2 * a.height);
            } else this._radius = a.clone();
            this._changed(9);
        },
        isEmpty: function() {
            return !1;
        },
        toPath: function(c) {
            var d = new (F[b.capitalize(this._type)])({
                center: new h(),
                size: this._size,
                radius: this._radius,
                insert: !1
            });
            return d.setStyle(this._style), d.transform(this._matrix), (c || c === a) && d.insertAbove(this), 
            d;
        },
        _draw: function(a, b, c) {
            var d = this._style, e = d.hasFill(), f = d.hasStroke(), g = b.dontFinish || b.clip, h = !c;
            if (e || f || g) {
                var i = this._type, j = this._radius, k = "circle" === i;
                if (b.dontStart || a.beginPath(), h && k) a.arc(0, 0, j, 0, 2 * Math.PI, !0); else {
                    var l = k ? j : j.width, m = k ? j : j.height, n = this._size, o = n.width, p = n.height;
                    if (h && "rect" === i && 0 === l && 0 === m) a.rect(-o / 2, -p / 2, o, p); else {
                        var q = o / 2, r = p / 2, s = .44771525016920644, t = l * s, u = m * s, v = [ -q, -r + m, -q, -r + u, -q + t, -r, -q + l, -r, q - l, -r, q - t, -r, q, -r + u, q, -r + m, q, r - m, q, r - u, q - t, r, q - l, r, -q + l, r, -q + t, r, -q, r - u, -q, r - m ];
                        c && c.transform(v, v, 32), a.moveTo(v[0], v[1]), a.bezierCurveTo(v[2], v[3], v[4], v[5], v[6], v[7]), 
                        q !== l && a.lineTo(v[8], v[9]), a.bezierCurveTo(v[10], v[11], v[12], v[13], v[14], v[15]), 
                        r !== m && a.lineTo(v[16], v[17]), a.bezierCurveTo(v[18], v[19], v[20], v[21], v[22], v[23]), 
                        q !== l && a.lineTo(v[24], v[25]), a.bezierCurveTo(v[26], v[27], v[28], v[29], v[30], v[31]);
                    }
                }
                a.closePath();
            }
            g || !e && !f || (this._setStyles(a), e && (a.fill(d.getWindingRule()), a.shadowColor = "rgba(0,0,0,0)"), 
            f && a.stroke());
        },
        _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
        },
        _getBounds: function(a, b) {
            var c = new n(this._size).setCenter(0, 0);
            return "getBounds" !== a && this.hasStroke() && (c = c.expand(this.getStrokeWidth())), 
            b ? b._transformBounds(c) : c;
        }
    }, new function() {
        function a(a, b, c) {
            var d = a._radius;
            if (!d.isZero()) for (var e = a._size.divide(2), f = 0; 4 > f; f++) {
                var g = new h(1 & f ? 1 : -1, f > 1 ? 1 : -1), i = g.multiply(e), j = i.subtract(g.multiply(d)), k = new n(i, j);
                if ((c ? k.expand(c) : k).contains(b)) return j;
            }
        }
        function b(a, b) {
            var c = a.getAngleInRadians(), d = 2 * b.width, e = 2 * b.height, f = d * Math.sin(c), g = e * Math.cos(c);
            return d * e / (2 * Math.sqrt(f * f + g * g));
        }
        return {
            _contains: function c(b) {
                if ("rectangle" === this._type) {
                    var d = a(this, b);
                    return d ? b.subtract(d).divide(this._radius).getLength() <= 1 : c.base.call(this, b);
                }
                return b.divide(this.size).getLength() <= .5;
            },
            _hitTestSelf: function d(c, e) {
                var f = !1;
                if (this.hasStroke()) {
                    var g = this._type, h = this._radius, i = this.getStrokeWidth() + 2 * e.tolerance;
                    if ("rectangle" === g) {
                        var j = a(this, c, i);
                        if (j) {
                            var k = c.subtract(j);
                            f = 2 * Math.abs(k.getLength() - b(k, h)) <= i;
                        } else {
                            var l = new n(this._size).setCenter(0, 0), m = l.expand(i), o = l.expand(-i);
                            f = m._containsPoint(c) && !o._containsPoint(c);
                        }
                    } else "ellipse" === g && (h = b(c, h)), f = 2 * Math.abs(c.getLength() - h) <= i;
                }
                return f ? new z("stroke", this) : d.base.apply(this, arguments);
            }
        };
    }(), {
        statics: new function() {
            function a(a, c, d, e, f) {
                var g = new w(b.getNamed(f));
                return g._type = a, g._size = d, g._radius = e, g.translate(c);
            }
            return {
                Circle: function() {
                    var c = h.readNamed(arguments, "center"), d = b.readNamed(arguments, "radius");
                    return a("circle", c, new k(2 * d), d, arguments);
                },
                Rectangle: function() {
                    var b = n.readNamed(arguments, "rectangle"), c = k.min(k.readNamed(arguments, "radius"), b.getSize(!0).divide(2));
                    return a("rectangle", b.getCenter(!0), b.getSize(!0), c, arguments);
                },
                Ellipse: function() {
                    var b = w._readEllipse(arguments), c = b.radius;
                    return a("ellipse", b.center, c.multiply(2), c, arguments);
                },
                _readEllipse: function(a) {
                    var c, d;
                    if (b.hasNamed(a, "radius")) c = h.readNamed(a, "center"), d = k.readNamed(a, "radius"); else {
                        var e = n.readNamed(a, "rectangle");
                        c = e.getCenter(!0), d = e.getSize(!0).divide(2);
                    }
                    return {
                        center: c,
                        radius: d
                    };
                }
            };
        }()
    }), x = t.extend({
        _class: "Raster",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsGetter: "getBounds",
        _boundsSelected: !0,
        _serializeFields: {
            source: null
        },
        initialize: function(b, c) {
            this._initialize(b, c !== a && h.read(arguments, 1)) || ("string" == typeof b ? this.setSource(b) : this.setImage(b)), 
            this._size || (this._size = new k());
        },
        _equals: function(a) {
            return this.getSource() === a.getSource();
        },
        clone: function(a) {
            var b = new x(t.NO_INSERT), c = this._image, d = this._canvas;
            if (c) b.setImage(c); else if (d) {
                var e = Z.getCanvas(this._size);
                e.getContext("2d").drawImage(d, 0, 0), b.setCanvas(e);
            }
            return this._clone(b, a);
        },
        getSize: function() {
            var a = this._size;
            return new m(a.width, a.height, this, "setSize");
        },
        setSize: function() {
            var a = k.read(arguments);
            if (!this._size.equals(a)) {
                var b = this.getElement();
                this.setCanvas(Z.getCanvas(a)), b && this.getContext(!0).drawImage(b, 0, 0, a.width, a.height);
            }
        },
        getWidth: function() {
            return this._size.width;
        },
        getHeight: function() {
            return this._size.height;
        },
        isEmpty: function() {
            return 0 === this._size.width && 0 === this._size.height;
        },
        getResolution: function() {
            var a = this._matrix, b = new h(0, 0).transform(a), c = new h(1, 0).transform(a).subtract(b), d = new h(0, 1).transform(a).subtract(b);
            return new k(72 / c.getLength(), 72 / d.getLength());
        },
        getPpi: "#getResolution",
        getImage: function() {
            return this._image;
        },
        setImage: function(a) {
            this._canvas && Z.release(this._canvas), a && a.getContext ? (this._image = null, 
            this._canvas = a) : (this._image = a, this._canvas = null), this._size = new k(a ? a.naturalWidth || a.width : 0, a ? a.naturalHeight || a.height : 0), 
            this._context = null, this._changed(521);
        },
        getCanvas: function() {
            if (!this._canvas) {
                var a = Z.getContext(this._size);
                try {
                    this._image && a.drawImage(this._image, 0, 0), this._canvas = a.canvas;
                } catch (b) {
                    Z.release(a);
                }
            }
            return this._canvas;
        },
        setCanvas: "#setImage",
        getContext: function(a) {
            return this._context || (this._context = this.getCanvas().getContext("2d")), a && (this._image = null, 
            this._changed(513)), this._context;
        },
        setContext: function(a) {
            this._context = a;
        },
        getSource: function() {
            return this._image && this._image.src || this.toDataURL();
        },
        setSource: function(a) {
            function b() {
                var a = d.getView();
                a && (paper = a._scope, d.setImage(c), d.emit("load"), a.update());
            }
            var c, d = this;
            c = document.getElementById(a) || new Image(), c.naturalWidth && c.naturalHeight ? setTimeout(b, 0) : (Q.add(c, {
                load: b
            }), c.src || (c.src = a)), this.setImage(c);
        },
        getElement: function() {
            return this._canvas || this._image;
        }
    }, {
        beans: !1,
        getSubCanvas: function() {
            var a = n.read(arguments), b = Z.getContext(a.getSize());
            return b.drawImage(this.getCanvas(), a.x, a.y, a.width, a.height, 0, 0, a.width, a.height), 
            b.canvas;
        },
        getSubRaster: function() {
            var a = n.read(arguments), b = new x(t.NO_INSERT);
            return b.setCanvas(this.getSubCanvas(a)), b.translate(a.getCenter().subtract(this.getSize().divide(2))), 
            b._matrix.preConcatenate(this._matrix), b.insertAbove(this), b;
        },
        toDataURL: function() {
            var a = this._image && this._image.src;
            if (/^data:/.test(a)) return a;
            var b = this.getCanvas();
            return b ? b.toDataURL() : null;
        },
        drawImage: function(a) {
            var b = h.read(arguments, 1);
            this.getContext(!0).drawImage(a, b.x, b.y);
        },
        getAverageColor: function(a) {
            var c, d;
            a ? a instanceof E ? (d = a, c = a.getBounds()) : a.width ? c = new n(a) : a.x && (c = new n(a.x - .5, a.y - .5, 1, 1)) : c = this.getBounds();
            var e = 32, f = Math.min(c.width, e), g = Math.min(c.height, e), h = x._sampleContext;
            h ? h.clearRect(0, 0, e + 1, e + 1) : h = x._sampleContext = Z.getContext(new k(e)), 
            h.save();
            var i = new p().scale(f / c.width, g / c.height).translate(-c.x, -c.y);
            i.applyToContext(h), d && d.draw(h, new b({
                clip: !0,
                matrices: [ i ]
            })), this._matrix.applyToContext(h), h.drawImage(this.getElement(), -this._size.width / 2, -this._size.height / 2), 
            h.restore();
            for (var j = h.getImageData(.5, .5, Math.ceil(f), Math.ceil(g)).data, l = [ 0, 0, 0 ], m = 0, o = 0, q = j.length; q > o; o += 4) {
                var r = j[o + 3];
                m += r, r /= 255, l[0] += j[o] * r, l[1] += j[o + 1] * r, l[2] += j[o + 2] * r;
            }
            for (var o = 0; 3 > o; o++) l[o] /= m;
            return m ? L.read(l) : null;
        },
        getPixel: function() {
            var a = h.read(arguments), b = this.getContext().getImageData(a.x, a.y, 1, 1).data;
            return new L("rgb", [ b[0] / 255, b[1] / 255, b[2] / 255 ], b[3] / 255);
        },
        setPixel: function() {
            var a = h.read(arguments), b = L.read(arguments), c = b._convert("rgb"), d = b._alpha, e = this.getContext(!0), f = e.createImageData(1, 1), g = f.data;
            g[0] = 255 * c[0], g[1] = 255 * c[1], g[2] = 255 * c[2], g[3] = null != d ? 255 * d : 255, 
            e.putImageData(f, a.x, a.y);
        },
        createImageData: function() {
            var a = k.read(arguments);
            return this.getContext().createImageData(a.width, a.height);
        },
        getImageData: function() {
            var a = n.read(arguments);
            return a.isEmpty() && (a = new n(this._size)), this.getContext().getImageData(a.x, a.y, a.width, a.height);
        },
        setImageData: function(a) {
            var b = h.read(arguments, 1);
            this.getContext(!0).putImageData(a, b.x, b.y);
        },
        _getBounds: function(a, b) {
            var c = new n(this._size).setCenter(0, 0);
            return b ? b._transformBounds(c) : c;
        },
        _hitTestSelf: function(a) {
            if (this._contains(a)) {
                var b = this;
                return new z("pixel", b, {
                    offset: a.add(b._size.divide(2)).round(),
                    color: {
                        get: function() {
                            return b.getPixel(this.offset);
                        }
                    }
                });
            }
        },
        _draw: function(a) {
            var b = this.getElement();
            b && (a.globalAlpha = this._opacity, a.drawImage(b, -this._size.width / 2, -this._size.height / 2));
        },
        _canComposite: function() {
            return !0;
        }
    }), y = t.extend({
        _class: "PlacedSymbol",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsGetter: {
            getBounds: "getStrokeBounds"
        },
        _boundsSelected: !0,
        _serializeFields: {
            symbol: null
        },
        initialize: function(b, c) {
            this._initialize(b, c !== a && h.read(arguments, 1)) || this.setSymbol(b instanceof s ? b : new s(b));
        },
        _equals: function(a) {
            return this._symbol === a._symbol;
        },
        getSymbol: function() {
            return this._symbol;
        },
        setSymbol: function(a) {
            this._symbol = a, this._changed(9);
        },
        clone: function(a) {
            var b = new y(t.NO_INSERT);
            return b.setSymbol(this._symbol), this._clone(b, a);
        },
        isEmpty: function() {
            return this._symbol._definition.isEmpty();
        },
        _getBounds: function(a, b, c) {
            var d = this.symbol._definition;
            return d._getCachedBounds(a, b && b.chain(d._matrix), c);
        },
        _hitTestSelf: function(a, b) {
            var c = this._symbol._definition._hitTest(a, b);
            return c && (c.item = this), c;
        },
        _draw: function(a, b) {
            this.symbol._definition.draw(a, b);
        }
    }), z = b.extend({
        _class: "HitResult",
        initialize: function(a, b, c) {
            this.type = a, this.item = b, c && (c.enumerable = !0, this.inject(c));
        },
        statics: {
            getOptions: function(a) {
                return new b({
                    type: null,
                    tolerance: paper.settings.hitTolerance,
                    fill: !a,
                    stroke: !a,
                    segments: !a,
                    handles: !1,
                    ends: !1,
                    center: !1,
                    bounds: !1,
                    guides: !1,
                    selected: !1
                }, a);
            }
        }
    }), A = b.extend({
        _class: "Segment",
        beans: !0,
        initialize: function(b, c, d, e, f, g) {
            var h, i, j, k = arguments.length;
            0 === k || (1 === k ? b.point ? (h = b.point, i = b.handleIn, j = b.handleOut) : h = b : 2 === k && "number" == typeof b ? h = arguments : 3 >= k ? (h = b, 
            i = c, j = d) : (h = b !== a ? [ b, c ] : null, i = d !== a ? [ d, e ] : null, j = f !== a ? [ f, g ] : null)), 
            new B(h, this, "_point"), new B(i, this, "_handleIn"), new B(j, this, "_handleOut");
        },
        _serialize: function(a) {
            return b.serialize(this.isLinear() ? this._point : [ this._point, this._handleIn, this._handleOut ], a, !0);
        },
        _changed: function(a) {
            var b = this._path;
            if (b) {
                var c, d = b._curves, e = this._index;
                d && (a && a !== this._point && a !== this._handleIn || !(c = e > 0 ? d[e - 1] : b._closed ? d[d.length - 1] : null) || c._changed(), 
                a && a !== this._point && a !== this._handleOut || !(c = d[e]) || c._changed()), 
                b._changed(25);
            }
        },
        getPoint: function() {
            return this._point;
        },
        setPoint: function() {
            var a = h.read(arguments);
            this._point.set(a.x, a.y);
        },
        getHandleIn: function() {
            return this._handleIn;
        },
        setHandleIn: function() {
            var a = h.read(arguments);
            this._handleIn.set(a.x, a.y);
        },
        getHandleOut: function() {
            return this._handleOut;
        },
        setHandleOut: function() {
            var a = h.read(arguments);
            this._handleOut.set(a.x, a.y);
        },
        isLinear: function() {
            return this._handleIn.isZero() && this._handleOut.isZero();
        },
        setLinear: function(a) {
            a && (this._handleIn.set(0, 0), this._handleOut.set(0, 0));
        },
        isColinear: function(a) {
            var b = this.getNext(), c = a.getNext();
            return this._handleOut.isZero() && b._handleIn.isZero() && a._handleOut.isZero() && c._handleIn.isZero() && b._point.subtract(this._point).isColinear(c._point.subtract(a._point));
        },
        isOrthogonal: function() {
            var a = this.getPrevious(), b = this.getNext();
            return a._handleOut.isZero() && this._handleIn.isZero() && this._handleOut.isZero() && b._handleIn.isZero() && this._point.subtract(a._point).isOrthogonal(b._point.subtract(this._point));
        },
        isArc: function() {
            var a = this.getNext(), b = this._handleOut, c = a._handleIn, d = .5522847498307936;
            if (b.isOrthogonal(c)) {
                var e = this._point, f = a._point, h = new q(e, b, !0).intersect(new q(f, c, !0), !0);
                return h && g.isZero(b.getLength() / h.subtract(e).getLength() - d) && g.isZero(c.getLength() / h.subtract(f).getLength() - d);
            }
            return !1;
        },
        _selectionState: 0,
        isSelected: function(a) {
            var b = this._selectionState;
            return a ? a === this._point ? !!(4 & b) : a === this._handleIn ? !!(1 & b) : a === this._handleOut ? !!(2 & b) : !1 : !!(7 & b);
        },
        setSelected: function(a, b) {
            var c = this._path, a = !!a, d = this._selectionState, e = d, f = b ? b === this._point ? 4 : b === this._handleIn ? 1 : b === this._handleOut ? 2 : 0 : 7;
            a ? d |= f : d &= ~f, this._selectionState = d, c && d !== e && (c._updateSelection(this, e, d), 
            c._changed(129));
        },
        getIndex: function() {
            return this._index !== a ? this._index : null;
        },
        getPath: function() {
            return this._path || null;
        },
        getCurve: function() {
            var a = this._path, b = this._index;
            return a ? (b > 0 && !a._closed && b === a._segments.length - 1 && b--, a.getCurves()[b] || null) : null;
        },
        getLocation: function() {
            var a = this.getCurve();
            return a ? new D(a, this === a._segment1 ? 0 : 1) : null;
        },
        getNext: function() {
            var a = this._path && this._path._segments;
            return a && (a[this._index + 1] || this._path._closed && a[0]) || null;
        },
        getPrevious: function() {
            var a = this._path && this._path._segments;
            return a && (a[this._index - 1] || this._path._closed && a[a.length - 1]) || null;
        },
        reverse: function() {
            return new A(this._point, this._handleOut, this._handleIn);
        },
        remove: function() {
            return this._path ? !!this._path.removeSegment(this._index) : !1;
        },
        clone: function() {
            return new A(this._point, this._handleIn, this._handleOut);
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && this._point.equals(a._point) && this._handleIn.equals(a._handleIn) && this._handleOut.equals(a._handleOut) || !1;
        },
        toString: function() {
            var a = [ "point: " + this._point ];
            return this._handleIn.isZero() || a.push("handleIn: " + this._handleIn), this._handleOut.isZero() || a.push("handleOut: " + this._handleOut), 
            "{ " + a.join(", ") + " }";
        },
        transform: function(a) {
            this._transformCoordinates(a, new Array(6), !0), this._changed();
        },
        _transformCoordinates: function(a, b, c) {
            var d = this._point, e = c && this._handleIn.isZero() ? null : this._handleIn, f = c && this._handleOut.isZero() ? null : this._handleOut, g = d._x, h = d._y, i = 2;
            return b[0] = g, b[1] = h, e && (b[i++] = e._x + g, b[i++] = e._y + h), f && (b[i++] = f._x + g, 
            b[i++] = f._y + h), a && (a._transformCoordinates(b, b, i / 2), g = b[0], h = b[1], 
            c ? (d._x = g, d._y = h, i = 2, e && (e._x = b[i++] - g, e._y = b[i++] - h), f && (f._x = b[i++] - g, 
            f._y = b[i++] - h)) : (e || (b[i++] = g, b[i++] = h), f || (b[i++] = g, b[i++] = h))), 
            b;
        }
    }), B = h.extend({
        initialize: function(b, c, d) {
            var e, f, g;
            if (b) if ((e = b[0]) !== a) f = b[1]; else {
                var i = b;
                (e = i.x) === a && (i = h.read(arguments), e = i.x), f = i.y, g = i.selected;
            } else e = f = 0;
            this._x = e, this._y = f, this._owner = c, c[d] = this, g && this.setSelected(!0);
        },
        set: function(a, b) {
            return this._x = a, this._y = b, this._owner._changed(this), this;
        },
        _serialize: function(a) {
            var b = a.formatter, c = b.number(this._x), d = b.number(this._y);
            return this.isSelected() ? {
                x: c,
                y: d,
                selected: !0
            } : [ c, d ];
        },
        getX: function() {
            return this._x;
        },
        setX: function(a) {
            this._x = a, this._owner._changed(this);
        },
        getY: function() {
            return this._y;
        },
        setY: function(a) {
            this._y = a, this._owner._changed(this);
        },
        isZero: function() {
            return g.isZero(this._x) && g.isZero(this._y);
        },
        setSelected: function(a) {
            this._owner.setSelected(a, this);
        },
        isSelected: function() {
            return this._owner.isSelected(this);
        }
    }), C = b.extend({
        _class: "Curve",
        initialize: function(a, b, c, d, e, f, g, h) {
            var i = arguments.length;
            if (3 === i) this._path = a, this._segment1 = b, this._segment2 = c; else if (0 === i) this._segment1 = new A(), 
            this._segment2 = new A(); else if (1 === i) this._segment1 = new A(a.segment1), 
            this._segment2 = new A(a.segment2); else if (2 === i) this._segment1 = new A(a), 
            this._segment2 = new A(b); else {
                var j, k, l, m;
                4 === i ? (j = a, k = b, l = c, m = d) : 8 === i && (j = [ a, b ], m = [ g, h ], 
                k = [ c - a, d - b ], l = [ e - g, f - h ]), this._segment1 = new A(j, null, k), 
                this._segment2 = new A(m, l, null);
            }
        },
        _changed: function() {
            this._length = this._bounds = a;
        },
        getPoint1: function() {
            return this._segment1._point;
        },
        setPoint1: function() {
            var a = h.read(arguments);
            this._segment1._point.set(a.x, a.y);
        },
        getPoint2: function() {
            return this._segment2._point;
        },
        setPoint2: function() {
            var a = h.read(arguments);
            this._segment2._point.set(a.x, a.y);
        },
        getHandle1: function() {
            return this._segment1._handleOut;
        },
        setHandle1: function() {
            var a = h.read(arguments);
            this._segment1._handleOut.set(a.x, a.y);
        },
        getHandle2: function() {
            return this._segment2._handleIn;
        },
        setHandle2: function() {
            var a = h.read(arguments);
            this._segment2._handleIn.set(a.x, a.y);
        },
        getSegment1: function() {
            return this._segment1;
        },
        getSegment2: function() {
            return this._segment2;
        },
        getPath: function() {
            return this._path;
        },
        getIndex: function() {
            return this._segment1._index;
        },
        getNext: function() {
            var a = this._path && this._path._curves;
            return a && (a[this._segment1._index + 1] || this._path._closed && a[0]) || null;
        },
        getPrevious: function() {
            var a = this._path && this._path._curves;
            return a && (a[this._segment1._index - 1] || this._path._closed && a[a.length - 1]) || null;
        },
        isSelected: function() {
            return this.getPoint1().isSelected() && this.getHandle2().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
        },
        setSelected: function(a) {
            this.getPoint1().setSelected(a), this.getHandle1().setSelected(a), this.getHandle2().setSelected(a), 
            this.getPoint2().setSelected(a);
        },
        getValues: function(a) {
            return C.getValues(this._segment1, this._segment2, a);
        },
        getPoints: function() {
            for (var a = this.getValues(), b = [], c = 0; 8 > c; c += 2) b.push(new h(a[c], a[c + 1]));
            return b;
        },
        getLength: function() {
            return null == this._length && (this._length = this.isLinear() ? this._segment2._point.getDistance(this._segment1._point) : C.getLength(this.getValues(), 0, 1)), 
            this._length;
        },
        getArea: function() {
            return C.getArea(this.getValues());
        },
        getPart: function(a, b) {
            return new C(C.getPart(this.getValues(), a, b));
        },
        getPartLength: function(a, b) {
            return C.getLength(this.getValues(), a, b);
        },
        isLinear: function() {
            return this._segment1._handleOut.isZero() && this._segment2._handleIn.isZero();
        },
        isHorizontal: function() {
            return this.isLinear() && g.isZero(this._segment1._point._y - this._segment2._point._y);
        },
        getIntersections: function(a) {
            return C.getIntersections(this.getValues(), a.getValues(), this, a, []);
        },
        _getParameter: function(b, c) {
            return c ? b : b && b.curve === this ? b.parameter : b === a && c === a ? .5 : this.getParameterAt(b, 0);
        },
        divide: function(a, b, c) {
            var d = this._getParameter(a, b), e = 1e-5, f = null;
            if (d > e && 1 - e > d) {
                var g = C.subdivide(this.getValues(), d), i = c ? !1 : this.isLinear(), j = g[0], k = g[1];
                i || (this._segment1._handleOut.set(j[2] - j[0], j[3] - j[1]), this._segment2._handleIn.set(k[4] - k[6], k[5] - k[7]));
                var l = j[6], m = j[7], n = new A(new h(l, m), !i && new h(j[4] - l, j[5] - m), !i && new h(k[2] - l, k[3] - m));
                if (this._path) this._segment1._index > 0 && 0 === this._segment2._index ? this._path.add(n) : this._path.insert(this._segment2._index, n), 
                f = this; else {
                    var o = this._segment2;
                    this._segment2 = n, f = new C(n, o);
                }
            }
            return f;
        },
        split: function(a, b) {
            return this._path ? this._path.split(this._segment1._index, this._getParameter(a, b)) : null;
        },
        reverse: function() {
            return new C(this._segment2.reverse(), this._segment1.reverse());
        },
        remove: function() {
            var a = !1;
            if (this._path) {
                var b = this._segment2, c = b._handleOut;
                a = b.remove(), a && this._segment1._handleOut.set(c.x, c.y);
            }
            return a;
        },
        clone: function() {
            return new C(this._segment1, this._segment2);
        },
        toString: function() {
            var a = [ "point1: " + this._segment1._point ];
            return this._segment1._handleOut.isZero() || a.push("handle1: " + this._segment1._handleOut), 
            this._segment2._handleIn.isZero() || a.push("handle2: " + this._segment2._handleIn), 
            a.push("point2: " + this._segment2._point), "{ " + a.join(", ") + " }";
        },
        statics: {
            getValues: function(a, b, c) {
                var d = a._point, e = a._handleOut, f = b._handleIn, g = b._point, h = [ d._x, d._y, d._x + e._x, d._y + e._y, g._x + f._x, g._y + f._y, g._x, g._y ];
                return c && c._transformCoordinates(h, h, 4), h;
            },
            evaluate: function(a, b, c) {
                var d, e, f = a[0], g = a[1], i = a[2], j = a[3], k = a[4], l = a[5], m = a[6], n = a[7], o = 1e-5;
                if (0 === c && (o > b || b > 1 - o)) {
                    var p = o > b;
                    d = p ? f : m, e = p ? g : n;
                } else {
                    var q = 3 * (i - f), r = 3 * (k - i) - q, s = m - f - q - r, t = 3 * (j - g), u = 3 * (l - j) - t, v = n - g - t - u;
                    if (0 === c) d = ((s * b + r) * b + q) * b + f, e = ((v * b + u) * b + t) * b + g; else if (o > b && i === f && j === g || b > 1 - o && k === m && l === n ? (d = k - i, 
                    e = l - j) : o > b ? (d = q, e = t) : b > 1 - o ? (d = 3 * (m - k), e = 3 * (n - l)) : (d = (3 * s * b + 2 * r) * b + q, 
                    e = (3 * v * b + 2 * u) * b + t), 3 === c) {
                        var w = 6 * s * b + 2 * r, x = 6 * v * b + 2 * u;
                        return (d * x - e * w) / Math.pow(d * d + e * e, 1.5);
                    }
                }
                return 2 === c ? new h(e, -d) : new h(d, e);
            },
            subdivide: function(b, c) {
                var d = b[0], e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7];
                c === a && (c = .5);
                var l = 1 - c, m = l * d + c * f, n = l * e + c * g, o = l * f + c * h, p = l * g + c * i, q = l * h + c * j, r = l * i + c * k, s = l * m + c * o, t = l * n + c * p, u = l * o + c * q, v = l * p + c * r, w = l * s + c * u, x = l * t + c * v;
                return [ [ d, e, m, n, s, t, w, x ], [ w, x, u, v, q, r, j, k ] ];
            },
            solveCubic: function(a, b, c, d, e, f) {
                var h = a[b], i = a[b + 2], j = a[b + 4], k = a[b + 6], l = 3 * (i - h), m = 3 * (j - i) - l, n = k - h - l - m;
                return g.solveCubic(n, m, l, h - c, d, e, f);
            },
            getParameterOf: function(a, b, c) {
                var d = 1e-5;
                if (Math.abs(a[0] - b) < d && Math.abs(a[1] - c) < d) return 0;
                if (Math.abs(a[6] - b) < d && Math.abs(a[7] - c) < d) return 1;
                for (var e, f, g = [], h = [], i = C.solveCubic(a, 0, b, g, 0, 1), j = C.solveCubic(a, 1, c, h, 0, 1), k = 0; -1 == i || i > k; ) if (-1 == i || (e = g[k++]) >= 0 && 1 >= e) {
                    for (var l = 0; -1 == j || j > l; ) if ((-1 == j || (f = h[l++]) >= 0 && 1 >= f) && (-1 == i ? e = f : -1 == j && (f = e), 
                    Math.abs(e - f) < d)) return .5 * (e + f);
                    if (-1 == i) break;
                }
                return null;
            },
            getPart: function(a, b, c) {
                return b > 0 && (a = C.subdivide(a, b)[1]), 1 > c && (a = C.subdivide(a, (c - b) / (1 - b))[0]), 
                a;
            },
            isLinear: function(a) {
                var b = g.isZero;
                return b(a[0] - a[2]) && b(a[1] - a[3]) && b(a[4] - a[6]) && b(a[5] - a[7]);
            },
            isFlatEnough: function(a, b) {
                var c = a[0], d = a[1], e = a[2], f = a[3], g = a[4], h = a[5], i = a[6], j = a[7], k = 3 * e - 2 * c - i, l = 3 * f - 2 * d - j, m = 3 * g - 2 * i - c, n = 3 * h - 2 * j - d;
                return Math.max(k * k, m * m) + Math.max(l * l, n * n) < 10 * b * b;
            },
            getArea: function(a) {
                var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7];
                return (3 * e * b - 1.5 * e * f - 1.5 * e * h - 3 * c * d - 1.5 * c * f - .5 * c * h + 1.5 * g * b + 1.5 * g * d - 3 * g * h + .5 * i * b + 1.5 * i * d + 3 * i * f) / 10;
            },
            getBounds: function(a) {
                for (var b = a.slice(0, 2), c = b.slice(), d = [ 0, 0 ], e = 0; 2 > e; e++) C._addBounds(a[e], a[e + 2], a[e + 4], a[e + 6], e, 0, b, c, d);
                return new n(b[0], b[1], c[0] - b[0], c[1] - b[1]);
            },
            _addBounds: function(a, b, c, d, e, f, h, i, j) {
                function k(a, b) {
                    var c = a - b, d = a + b;
                    c < h[e] && (h[e] = c), d > i[e] && (i[e] = d);
                }
                var l = 3 * (b - c) - a + d, m = 2 * (a + c) - 4 * b, n = b - a, o = g.solveQuadratic(l, m, n, j), p = 1e-5, q = 1 - p;
                k(d, 0);
                for (var r = 0; o > r; r++) {
                    var s = j[r], t = 1 - s;
                    s > p && q > s && k(t * t * t * a + 3 * t * t * s * b + 3 * t * s * s * c + s * s * s * d, f);
                }
            }
        }
    }, b.each([ "getBounds", "getStrokeBounds", "getHandleBounds", "getRoughBounds" ], function(a) {
        this[a] = function() {
            this._bounds || (this._bounds = {});
            var b = this._bounds[a];
            return b || (b = this._bounds[a] = F[a]([ this._segment1, this._segment2 ], !1, this._path.getStyle())), 
            b.clone();
        };
    }, {}), b.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(a, b) {
        this[a + "At"] = function(a, c) {
            var d = this.getValues();
            return C.evaluate(d, c ? a : C.getParameterAt(d, a, 0), b);
        }, this[a] = function(a) {
            return C.evaluate(this.getValues(), a, b);
        };
    }, {
        beans: !1,
        getParameterAt: function(a, b) {
            return C.getParameterAt(this.getValues(), a, b);
        },
        getParameterOf: function() {
            var a = h.read(arguments);
            return C.getParameterOf(this.getValues(), a.x, a.y);
        },
        getLocationAt: function(a, b) {
            return b || (a = this.getParameterAt(a)), a >= 0 && 1 >= a && new D(this, a);
        },
        getLocationOf: function() {
            return this.getLocationAt(this.getParameterOf(h.read(arguments)), !0);
        },
        getOffsetOf: function() {
            var a = this.getLocationOf.apply(this, arguments);
            return a ? a.getOffset() : null;
        },
        getNearestLocation: function() {
            function a(a) {
                if (a >= 0 && 1 >= a) {
                    var d = b.getDistance(C.evaluate(c, a, 0), !0);
                    if (e > d) return e = d, f = a, !0;
                }
            }
            for (var b = h.read(arguments), c = this.getValues(), d = 100, e = 1/0, f = 0, g = 0; d >= g; g++) a(g / d);
            for (var i = 1 / (2 * d); i > 1e-5; ) a(f - i) || a(f + i) || (i /= 2);
            var j = C.evaluate(c, f, 0);
            return new D(this, f, j, null, null, null, b.getDistance(j));
        },
        getNearestPoint: function() {
            return this.getNearestLocation.apply(this, arguments).getPoint();
        }
    }), new function() {
        function b(a) {
            var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], j = 9 * (d - f) + 3 * (h - b), k = 6 * (b + f) - 12 * d, l = 3 * (d - b), m = 9 * (e - g) + 3 * (i - c), n = 6 * (c + g) - 12 * e, o = 3 * (e - c);
            return function(a) {
                var b = (j * a + k) * a + l, c = (m * a + n) * a + o;
                return Math.sqrt(b * b + c * c);
            };
        }
        function c(a, b) {
            return Math.max(2, Math.min(16, Math.ceil(32 * Math.abs(b - a))));
        }
        return {
            statics: !0,
            getLength: function(d, e, f) {
                e === a && (e = 0), f === a && (f = 1);
                var h = g.isZero;
                if (0 === e && 1 === f && h(d[0] - d[2]) && h(d[1] - d[3]) && h(d[6] - d[4]) && h(d[7] - d[5])) {
                    var i = d[6] - d[0], j = d[7] - d[1];
                    return Math.sqrt(i * i + j * j);
                }
                var k = b(d);
                return g.integrate(k, e, f, c(e, f));
            },
            getParameterAt: function(d, e, f) {
                function h(a) {
                    return o += g.integrate(l, f, a, c(f, a)), f = a, o - e;
                }
                if (f === a && (f = 0 > e ? 1 : 0), 0 === e) return f;
                var i = e > 0, j = i ? f : 0, k = i ? 1 : f, l = b(d), m = g.integrate(l, j, k, c(j, k));
                if (Math.abs(e) >= m) return i ? k : j;
                var n = e / m, o = 0;
                return g.findRoot(h, l, f + n, j, k, 16, 1e-5);
            }
        };
    }(), new function() {
        function a(a, b, c, d, e, f, g, h) {
            var i = new D(c, d, e, f, g, h);
            (!b || b(i)) && a.push(i);
        }
        function b(e, f, g, h, i, j, k, l, m, n, o, p, r) {
            if (!(r > 20)) {
                var s, t, u, v = f[0], w = f[1], x = f[6], y = f[7], z = 1e-5, A = 1e-9, B = q.getSignedDistance, D = B(v, w, x, y, f[2], f[3]) || 0, E = B(v, w, x, y, f[4], f[5]) || 0, F = D * E > 0 ? .75 : 4 / 9, G = F * Math.min(0, D, E), H = F * Math.max(0, D, E), I = B(v, w, x, y, e[0], e[1]), J = B(v, w, x, y, e[2], e[3]), K = B(v, w, x, y, e[4], e[5]), L = B(v, w, x, y, e[6], e[7]);
                if (v === x && A >= n - m && r > 3) s = (l + k) / 2, t = s, u = 0; else {
                    var M, N, O = c(I, J, K, L), P = O[0], Q = O[1];
                    if (M = d(P, Q, G, H), P.reverse(), Q.reverse(), N = d(P, Q, G, H), null == M || null == N) return !1;
                    e = C.getPart(e, M, N), u = N - M, s = l * M + k * (1 - M), t = l * N + k * (1 - N);
                }
                if (o > .8 && u > .8) if (t - s > n - m) {
                    var R = C.subdivide(e, .5), S = s + (t - s) / 2;
                    b(f, R[0], h, g, i, j, m, n, s, S, u, !p, ++r), b(f, R[1], h, g, i, j, m, n, S, t, u, !p, r);
                } else {
                    var R = C.subdivide(f, .5), S = m + (n - m) / 2;
                    b(R[0], e, h, g, i, j, m, S, s, t, u, !p, ++r), b(R[1], e, h, g, i, j, S, n, s, t, u, !p, r);
                } else if (Math.max(n - m, t - s) < z) {
                    var T = s + (t - s) / 2, U = m + (n - m) / 2;
                    p ? a(i, j, h, U, C.evaluate(f, U, 0), g, T, C.evaluate(e, T, 0)) : a(i, j, g, T, C.evaluate(e, T, 0), h, U, C.evaluate(f, U, 0));
                } else b(f, e, h, g, i, j, m, n, s, t, u, !p, ++r);
            }
        }
        function c(a, b, c, d) {
            var e, f = [ 0, a ], g = [ 1 / 3, b ], h = [ 2 / 3, c ], i = [ 1, d ], j = q.getSignedDistance, k = j(0, a, 1, d, 1 / 3, b), l = j(0, a, 1, d, 2 / 3, c), m = !1;
            if (0 > k * l) e = [ [ f, g, i ], [ f, h, i ] ], m = 0 > k; else {
                var n, o = 0, p = 0 === k || 0 === l;
                Math.abs(k) > Math.abs(l) ? (n = g, o = (d - c - (d - a) / 3) * (2 * (d - c) - d + b) / 3) : (n = h, 
                o = (b - a + (a - d) / 3) * (-2 * (a - b) + a - c) / 3), e = 0 > o || p ? [ [ f, n, i ], [ f, i ] ] : [ [ f, g, h, i ], [ f, i ] ], 
                m = k ? 0 > k : 0 > l;
            }
            return m ? e.reverse() : e;
        }
        function d(a, b, c, d) {
            for (var e, f, g, h, i, j = null, k = 0, l = b.length - 1; l > k; k++) {
                if (g = b[k][1], i = b[k + 1][1], i > g) e = null; else {
                    if (!(d >= i)) continue;
                    f = b[k][0], h = b[k + 1][0], e = f + (d - g) * (h - f) / (i - g);
                }
                break;
            }
            a[0][1] <= d && (e = a[0][0]);
            for (var k = 0, l = a.length - 1; l > k; k++) {
                if (g = a[k][1], i = a[k + 1][1], g >= c) j = e; else if (g > i) j = null; else {
                    if (!(i >= c)) continue;
                    f = a[k][0], h = a[k + 1][0], j = f + (c - g) * (h - f) / (i - g);
                }
                break;
            }
            return j;
        }
        function e(b, c, d, e, f, g) {
            for (var h = C.isLinear(b), i = h ? c : b, j = h ? b : c, k = j[0], l = j[1], m = j[6], n = j[7], o = m - k, p = n - l, q = Math.atan2(-p, o), r = Math.sin(q), s = Math.cos(q), t = o * s - p * r, u = [ 0, 0, 0, 0, t, 0, t, 0 ], v = [], w = 0; 8 > w; w += 2) {
                var x = i[w] - k, y = i[w + 1] - l;
                v.push(x * s - y * r, y * s + x * r);
            }
            for (var z = [], A = C.solveCubic(v, 1, 0, z, 0, 1), w = 0; A > w; w++) {
                var B = z[w], x = C.evaluate(v, B, 0).x;
                if (x >= 0 && t >= x) {
                    var D = C.getParameterOf(u, x, 0), E = h ? D : B, F = h ? B : D;
                    a(f, g, d, E, C.evaluate(b, E, 0), e, F, C.evaluate(c, F, 0));
                }
            }
        }
        function f(b, c, d, e, f, g) {
            var h = q.intersect(b[0], b[1], b[6], b[7], c[0], c[1], c[6], c[7]);
            if (h) {
                var i = h.x, j = h.y;
                a(f, g, d, C.getParameterOf(b, i, j), h, e, C.getParameterOf(c, i, j), h);
            }
        }
        return {
            statics: {
                getIntersections: function(a, c, d, g, h, i) {
                    var j = C.isLinear(a), k = C.isLinear(c);
                    return (j && k ? f : j || k ? e : b)(a, c, d, g, h, i, 0, 1, 0, 1, 0, !1, 0), h;
                }
            }
        };
    }()), D = b.extend({
        _class: "CurveLocation",
        beans: !0,
        initialize: function qb(a, b, c, d, e, f, g) {
            this._id = qb._id = (qb._id || 0) + 1, this._curve = a, this._segment1 = a._segment1, 
            this._segment2 = a._segment2, this._parameter = b, this._point = c, this._curve2 = d, 
            this._parameter2 = e, this._point2 = f, this._distance = g;
        },
        getSegment: function(a) {
            if (!this._segment) {
                var b = this.getCurve(), c = this.getParameter();
                if (1 === c) this._segment = b._segment2; else if (0 === c || a) this._segment = b._segment1; else {
                    if (null == c) return null;
                    this._segment = b.getPartLength(0, c) < b.getPartLength(c, 1) ? b._segment1 : b._segment2;
                }
            }
            return this._segment;
        },
        getCurve: function(a) {
            return (!this._curve || a) && (this._curve = this._segment1.getCurve(), null == this._curve.getParameterOf(this._point) && (this._curve = this._segment2.getPrevious().getCurve())), 
            this._curve;
        },
        getIntersection: function() {
            var a = this._intersection;
            if (!a && this._curve2) {
                var b = this._parameter2;
                this._intersection = a = new D(this._curve2, b, this._point2 || this._point, this), 
                a._intersection = this;
            }
            return a;
        },
        getPath: function() {
            var a = this.getCurve();
            return a && a._path;
        },
        getIndex: function() {
            var a = this.getCurve();
            return a && a.getIndex();
        },
        getOffset: function() {
            var a = this.getPath();
            return a ? a._getOffset(this) : this.getCurveOffset();
        },
        getCurveOffset: function() {
            var a = this.getCurve(), b = this.getParameter();
            return null != b && a && a.getPartLength(0, b);
        },
        getParameter: function(a) {
            if ((null == this._parameter || a) && this._point) {
                var b = this.getCurve(a);
                this._parameter = b && b.getParameterOf(this._point);
            }
            return this._parameter;
        },
        getPoint: function(a) {
            if ((!this._point || a) && null != this._parameter) {
                var b = this.getCurve(a);
                this._point = b && b.getPointAt(this._parameter, !0);
            }
            return this._point;
        },
        getDistance: function() {
            return this._distance;
        },
        divide: function() {
            var a = this.getCurve(!0);
            return a && a.divide(this.getParameter(!0), !0);
        },
        split: function() {
            var a = this.getCurve(!0);
            return a && a.split(this.getParameter(!0), !0);
        },
        equals: function(a) {
            var b = g.isZero;
            return this === a || a && this._curve === a._curve && this._curve2 === a._curve2 && b(this._parameter - a._parameter) && b(this._parameter2 - a._parameter2) || !1;
        },
        toString: function() {
            var a = [], b = this.getPoint(), c = f.instance;
            b && a.push("point: " + b);
            var d = this.getIndex();
            null != d && a.push("index: " + d);
            var e = this.getParameter();
            return null != e && a.push("parameter: " + c.number(e)), null != this._distance && a.push("distance: " + c.number(this._distance)), 
            "{ " + a.join(", ") + " }";
        }
    }, b.each([ "getTangent", "getNormal", "getCurvature" ], function(a) {
        var b = a + "At";
        this[a] = function() {
            var a = this.getParameter(), c = this.getCurve();
            return null != a && c && c[b](a, !0);
        };
    }, {})), E = t.extend({
        _class: "PathItem",
        initialize: function() {},
        getIntersections: function(a, b, c) {
            function d(a, b) {
                var c = a.getPath(), d = b.getPath();
                return c === d ? a.getIndex() + a.getParameter() - (b.getIndex() + b.getParameter()) : c._id - d._id;
            }
            this === a && (a = null);
            var e = [], f = this.getCurves(), g = a ? a.getCurves() : f, h = this._matrix.orNullIfIdentity(), i = a ? (b || a._matrix).orNullIfIdentity() : h, j = f.length, k = a ? g.length : j, l = [], m = 1e-11, n = 1 - 1e-11;
            if (a && !this.getBounds(h).touches(a.getBounds(i))) return [];
            for (var o = 0; k > o; o++) l[o] = g[o].getValues(i);
            for (var o = 0; j > o; o++) {
                var p = f[o], r = a ? p.getValues(h) : l[o];
                if (!a) {
                    var s = p.getSegment1(), t = p.getSegment2(), u = s._handleOut, v = t._handleIn;
                    if (new q(s._point.subtract(u), u.multiply(2), !0).intersect(new q(t._point.subtract(v), v.multiply(2), !0), !1)) {
                        var w = C.subdivide(r);
                        C.getIntersections(w[0], w[1], p, p, e, function(a) {
                            return a._parameter <= n ? (a._parameter /= 2, a._parameter2 = .5 + a._parameter2 / 2, 
                            !0) : void 0;
                        });
                    }
                }
                for (var x = a ? 0 : o + 1; k > x; x++) C.getIntersections(r, l[x], p, g[x], e, !a && (x === o + 1 || x === k - 1 && 0 === o) && function(a) {
                    var b = a._parameter;
                    return b >= m && n >= b;
                });
            }
            for (var y = e.length - 1, o = y; o >= 0; o--) {
                var z = e[o], A = z._curve.getNext(), B = z._curve2.getNext();
                A && z._parameter >= n && (z._parameter = 0, z._curve = A), B && z._parameter2 >= n && (z._parameter2 = 0, 
                z._curve2 = B);
            }
            if (y > 0) {
                e.sort(d);
                for (var o = y; o >= 1; o--) e[o].equals(e[0 === o ? y : o - 1]) && (e.splice(o, 1), 
                y--);
            }
            if (c) {
                for (var o = y; o >= 0; o--) e.push(e[o].getIntersection());
                e.sort(d);
            }
            return e;
        },
        _asPathItem: function() {
            return this;
        },
        setPathData: function(a) {
            function b(a, b) {
                var c = +d[a];
                return i && (c += j[b]), c;
            }
            function c(a) {
                return new h(b(a, "x"), b(a + 1, "y"));
            }
            var d, e, f, g = a.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/gi), i = !1, j = new h(), l = new h();
            this.clear();
            for (var m = 0, n = g.length; n > m; m++) {
                var o = g[m], p = o[0], q = p.toLowerCase();
                d = o.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
                var r = d && d.length;
                switch (i = p === q, "z" !== e || /[mz]/.test(q) || this.moveTo(j = l), q) {
                  case "m":
                  case "l":
                    var s = "m" === q;
                    s && e && "z" !== e && this.closePath(!0);
                    for (var t = 0; r > t; t += 2) this[0 === t && s ? "moveTo" : "lineTo"](j = c(t));
                    f = j, s && (l = j);
                    break;

                  case "h":
                  case "v":
                    for (var u = "h" === q ? "x" : "y", t = 0; r > t; t++) j[u] = b(t, u), this.lineTo(j);
                    f = j;
                    break;

                  case "c":
                    for (var t = 0; r > t; t += 6) this.cubicCurveTo(c(t), f = c(t + 2), j = c(t + 4));
                    break;

                  case "s":
                    for (var t = 0; r > t; t += 4) this.cubicCurveTo(/[cs]/.test(e) ? j.multiply(2).subtract(f) : j, f = c(t), j = c(t + 2)), 
                    e = q;
                    break;

                  case "q":
                    for (var t = 0; r > t; t += 4) this.quadraticCurveTo(f = c(t), j = c(t + 2));
                    break;

                  case "t":
                    for (var t = 0; r > t; t += 2) this.quadraticCurveTo(f = /[qt]/.test(e) ? j.multiply(2).subtract(f) : j, j = c(t)), 
                    e = q;
                    break;

                  case "a":
                    for (var t = 0; r > t; t += 7) this.arcTo(j = c(t + 5), new k(+d[0], +d[1]), +d[2], +d[4], +d[3]);
                    break;

                  case "z":
                    this.closePath(!0);
                }
                e = q;
            }
        },
        _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
        },
        _contains: function(a) {
            var b = this._getWinding(a, !1, !0);
            return !!("evenodd" === this.getWindingRule() ? 1 & b : b);
        }
    }), F = E.extend({
        _class: "Path",
        _serializeFields: {
            segments: [],
            closed: !1
        },
        initialize: function(b) {
            this._closed = !1, this._segments = [];
            var c = Array.isArray(b) ? "object" == typeof b[0] ? b : arguments : !b || b.size !== a || b.x === a && b.point === a ? null : arguments;
            c && c.length > 0 ? this.setSegments(c) : (this._curves = a, this._selectedSegmentState = 0, 
            c || "string" != typeof b || (this.setPathData(b), b = null)), this._initialize(!c && b);
        },
        _equals: function(a) {
            return b.equals(this._segments, a._segments);
        },
        clone: function(b) {
            var c = new F(t.NO_INSERT);
            return c.setSegments(this._segments), c._closed = this._closed, this._clockwise !== a && (c._clockwise = this._clockwise), 
            this._clone(c, b);
        },
        _changed: function rb(b) {
            if (rb.base.call(this, b), 8 & b) {
                var c = this._parent;
                if (c && (c._currentPath = a), this._length = this._clockwise = a, this._curves && !(16 & b)) for (var d = 0, e = this._curves.length; e > d; d++) this._curves[d]._changed();
                this._monoCurves = a;
            } else 32 & b && (this._bounds = a);
        },
        getStyle: function() {
            var a = this._parent;
            return (a instanceof G ? a : this)._style;
        },
        getSegments: function() {
            return this._segments;
        },
        setSegments: function(b) {
            var c = this.isFullySelected();
            this._segments.length = 0, this._selectedSegmentState = 0, this._curves = a, b && b.length > 0 && this._add(A.readAll(b)), 
            c && this.setFullySelected(!0);
        },
        getFirstSegment: function() {
            return this._segments[0];
        },
        getLastSegment: function() {
            return this._segments[this._segments.length - 1];
        },
        getCurves: function() {
            var a = this._curves, b = this._segments;
            if (!a) {
                var c = this._countCurves();
                a = this._curves = new Array(c);
                for (var d = 0; c > d; d++) a[d] = new C(this, b[d], b[d + 1] || b[0]);
            }
            return a;
        },
        getFirstCurve: function() {
            return this.getCurves()[0];
        },
        getLastCurve: function() {
            var a = this.getCurves();
            return a[a.length - 1];
        },
        isClosed: function() {
            return this._closed;
        },
        setClosed: function(a) {
            if (this._closed != (a = !!a)) {
                if (this._closed = a, this._curves) {
                    var b = this._curves.length = this._countCurves();
                    a && (this._curves[b - 1] = new C(this, this._segments[b - 1], this._segments[0]));
                }
                this._changed(25);
            }
        }
    }, {
        beans: !0,
        getPathData: function(a, b) {
            function c(b, c) {
                b._transformCoordinates(a, p, !1), d = p[0], e = p[1], q ? (r.push("M" + o.pair(d, e)), 
                q = !1) : (i = p[2], j = p[3], i === d && j === e && k === g && l === h ? c || r.push("l" + o.pair(d - g, e - h)) : r.push("c" + o.pair(k - g, l - h) + " " + o.pair(i - g, j - h) + " " + o.pair(d - g, e - h))), 
                g = d, h = e, k = p[4], l = p[5];
            }
            var d, e, g, h, i, j, k, l, m = this._segments, n = m.length, o = new f(b), p = new Array(6), q = !0, r = [];
            if (0 === n) return "";
            for (var s = 0; n > s; s++) c(m[s]);
            return this._closed && n > 0 && (c(m[0], !0), r.push("z")), r.join("");
        }
    }, {
        isEmpty: function() {
            return 0 === this._segments.length;
        },
        isPolygon: function() {
            for (var a = 0, b = this._segments.length; b > a; a++) if (!this._segments[a].isLinear()) return !1;
            return !0;
        },
        _transformContent: function(a) {
            for (var b = new Array(6), c = 0, d = this._segments.length; d > c; c++) this._segments[c]._transformCoordinates(a, b, !0);
            return !0;
        },
        _add: function(a, b) {
            for (var c = this._segments, d = this._curves, e = a.length, f = null == b, b = f ? c.length : b, g = 0; e > g; g++) {
                var h = a[g];
                h._path && (h = a[g] = h.clone()), h._path = this, h._index = b + g, h._selectionState && this._updateSelection(h, 0, h._selectionState);
            }
            if (f) c.push.apply(c, a); else {
                c.splice.apply(c, [ b, 0 ].concat(a));
                for (var g = b + e, i = c.length; i > g; g++) c[g]._index = g;
            }
            if (d || a._curves) {
                d || (d = this._curves = []);
                var j = b > 0 ? b - 1 : b, k = j, l = Math.min(j + e, this._countCurves());
                a._curves && (d.splice.apply(d, [ j, 0 ].concat(a._curves)), k += a._curves.length);
                for (var g = k; l > g; g++) d.splice(g, 0, new C(this, null, null));
                this._adjustCurves(j, l);
            }
            return this._changed(25), a;
        },
        _adjustCurves: function(a, b) {
            for (var c, d = this._segments, e = this._curves, f = a; b > f; f++) c = e[f], c._path = this, 
            c._segment1 = d[f], c._segment2 = d[f + 1] || d[0], c._changed();
            (c = e[this._closed && 0 === a ? d.length - 1 : a - 1]) && (c._segment2 = d[a] || d[0], 
            c._changed()), (c = e[b]) && (c._segment1 = d[b], c._changed());
        },
        _countCurves: function() {
            var a = this._segments.length;
            return !this._closed && a > 0 ? a - 1 : a;
        },
        add: function(a) {
            return arguments.length > 1 && "number" != typeof a ? this._add(A.readAll(arguments)) : this._add([ A.read(arguments) ])[0];
        },
        insert: function(a, b) {
            return arguments.length > 2 && "number" != typeof b ? this._add(A.readAll(arguments, 1), a) : this._add([ A.read(arguments, 1) ], a)[0];
        },
        addSegment: function() {
            return this._add([ A.read(arguments) ])[0];
        },
        insertSegment: function(a) {
            return this._add([ A.read(arguments, 1) ], a)[0];
        },
        addSegments: function(a) {
            return this._add(A.readAll(a));
        },
        insertSegments: function(a, b) {
            return this._add(A.readAll(b), a);
        },
        removeSegment: function(a) {
            return this.removeSegments(a, a + 1)[0] || null;
        },
        removeSegments: function(a, c, d) {
            a = a || 0, c = b.pick(c, this._segments.length);
            var e = this._segments, f = this._curves, g = e.length, h = e.splice(a, c - a), i = h.length;
            if (!i) return h;
            for (var j = 0; i > j; j++) {
                var k = h[j];
                k._selectionState && this._updateSelection(k, k._selectionState, 0), k._index = k._path = null;
            }
            for (var j = a, l = e.length; l > j; j++) e[j]._index = j;
            if (f) {
                var m = a > 0 && c === g + (this._closed ? 1 : 0) ? a - 1 : a, f = f.splice(m, i);
                d && (h._curves = f.slice(1)), this._adjustCurves(m, m);
            }
            return this._changed(25), h;
        },
        clear: "#removeSegments",
        getLength: function() {
            if (null == this._length) {
                var a = this.getCurves();
                this._length = 0;
                for (var b = 0, c = a.length; c > b; b++) this._length += a[b].getLength();
            }
            return this._length;
        },
        getArea: function() {
            for (var a = this.getCurves(), b = 0, c = 0, d = a.length; d > c; c++) b += a[c].getArea();
            return b;
        },
        isFullySelected: function() {
            var a = this._segments.length;
            return this._selected && a > 0 && this._selectedSegmentState === 7 * a;
        },
        setFullySelected: function(a) {
            a && this._selectSegments(!0), this.setSelected(a);
        },
        setSelected: function sb(a) {
            a || this._selectSegments(!1), sb.base.call(this, a);
        },
        _selectSegments: function(a) {
            var b = this._segments.length;
            this._selectedSegmentState = a ? 7 * b : 0;
            for (var c = 0; b > c; c++) this._segments[c]._selectionState = a ? 7 : 0;
        },
        _updateSelection: function(a, b, c) {
            a._selectionState = c;
            var d = this._selectedSegmentState += c - b;
            d > 0 && this.setSelected(!0);
        },
        flatten: function(a) {
            for (var b = new H(this, 64, .1), c = 0, d = b.length / Math.ceil(b.length / a), e = b.length + (this._closed ? -d : d) / 2, f = []; e >= c; ) f.push(new A(b.evaluate(c, 0))), 
            c += d;
            this.setSegments(f);
        },
        reduce: function() {
            for (var a = this.getCurves(), b = a.length - 1; b >= 0; b--) {
                var c = a[b];
                c.isLinear() && 0 === c.getLength() && c.remove();
            }
            return this;
        },
        simplify: function(a) {
            if (this._segments.length > 2) {
                var b = new I(this, a || 2.5);
                this.setSegments(b.fit());
            }
        },
        split: function(a, b) {
            if (null !== b) {
                if (1 === arguments.length) {
                    var c = a;
                    "number" == typeof c && (c = this.getLocationAt(c)), a = c.index, b = c.parameter;
                }
                var d = 1e-5;
                b >= 1 - d && (a++, b--);
                var e = this.getCurves();
                if (a >= 0 && a < e.length) {
                    b > d && e[a++].divide(b, !0);
                    var f, g = this.removeSegments(a, this._segments.length, !0);
                    return this._closed ? (this.setClosed(!1), f = this) : a > 0 && (f = this._clone(new F().insertAbove(this, !0))), 
                    f._add(g, 0), this.addSegment(g[0]), f;
                }
                return null;
            }
        },
        isClockwise: function() {
            return this._clockwise !== a ? this._clockwise : F.isClockwise(this._segments);
        },
        setClockwise: function(a) {
            this.isClockwise() != (a = !!a) && this.reverse(), this._clockwise = a;
        },
        reverse: function() {
            this._segments.reverse();
            for (var b = 0, c = this._segments.length; c > b; b++) {
                var d = this._segments[b], e = d._handleIn;
                d._handleIn = d._handleOut, d._handleOut = e, d._index = b;
            }
            this._curves = null, this._clockwise !== a && (this._clockwise = !this._clockwise), 
            this._changed(9);
        },
        join: function(a) {
            if (a) {
                var b = a._segments, c = this.getLastSegment(), d = a.getLastSegment();
                c._point.equals(d._point) && a.reverse();
                var e, f = a.getFirstSegment();
                c._point.equals(f._point) ? (c.setHandleOut(f._handleOut), this._add(b.slice(1))) : (e = this.getFirstSegment(), 
                e._point.equals(f._point) && a.reverse(), d = a.getLastSegment(), e._point.equals(d._point) ? (e.setHandleIn(d._handleIn), 
                this._add(b.slice(0, b.length - 1), 0)) : this._add(b.slice())), a.closed && this._add([ b[0] ]), 
                a.remove();
            }
            var g = this.getFirstSegment(), h = this.getLastSegment();
            g !== h && g._point.equals(h._point) && (g.setHandleIn(h._handleIn), h.remove(), 
            this.setClosed(!0));
        },
        toShape: function(b) {
            function c(a, b) {
                return m[a].isColinear(m[b]);
            }
            function d(a) {
                return m[a].isOrthogonal();
            }
            function e(a) {
                return m[a].isArc();
            }
            function f(a, b) {
                return m[a]._point.getDistance(m[b]._point);
            }
            if (!this._closed) return null;
            var h, i, j, l, m = this._segments;
            if (this.isPolygon() && 4 === m.length && c(0, 2) && c(1, 3) && d(1) ? (h = w.Rectangle, 
            i = new k(f(0, 3), f(0, 1)), l = m[1]._point.add(m[2]._point).divide(2)) : 8 === m.length && e(0) && e(2) && e(4) && e(6) && c(1, 5) && c(3, 7) ? (h = w.Rectangle, 
            i = new k(f(1, 6), f(0, 3)), j = i.subtract(new k(f(0, 7), f(1, 2))).divide(2), 
            l = m[3]._point.add(m[4]._point).divide(2)) : 4 === m.length && e(0) && e(1) && e(2) && e(3) && (g.isZero(f(0, 2) - f(1, 3)) ? (h = w.Circle, 
            j = f(0, 2) / 2) : (h = w.Ellipse, j = new k(f(2, 0) / 2, f(3, 1) / 2)), l = m[1]._point), 
            h) {
                var n = this.getPosition(!0), o = new h({
                    center: n,
                    size: i,
                    radius: j,
                    insert: !1
                });
                return o.rotate(l.subtract(n).getAngle() + 90), o.setStyle(this._style), (b || b === a) && o.insertAbove(this), 
                o;
            }
            return null;
        },
        _hitTestSelf: function(a, b) {
            function c(b, c) {
                return a.subtract(b).divide(c).length <= 1;
            }
            function d(a, d, e) {
                if (!b.selected || d.isSelected()) {
                    var f = a._point;
                    if (d !== f && (d = d.add(f)), c(d, u)) return new z(e, o, {
                        segment: a,
                        point: d
                    });
                }
            }
            function e(a, c) {
                return (c || b.segments) && d(a, a._point, "segment") || !c && b.handles && (d(a, a._handleIn, "handle-in") || d(a, a._handleOut, "handle-out"));
            }
            function f(a) {
                l.add(a);
            }
            function g(b) {
                if (("round" !== i || "round" !== j) && (l = new F({
                    internal: !0,
                    closed: !0
                }), s || b._index > 0 && b._index < r - 1 ? "round" !== i && (b._handleIn.isZero() || b._handleOut.isZero()) && F._addBevelJoin(b, i, y, k, f, !0) : "round" !== j && F._addSquareCap(b, j, y, f, !0), 
                !l.isEmpty())) {
                    var d;
                    return l.contains(a) || (d = l.getNearestLocation(a)) && c(d.getPoint(), t);
                }
                return c(b._point, u);
            }
            var i, j, k, l, m, n, o = this, p = this.getStyle(), q = this._segments, r = q.length, s = this._closed, t = b._tolerancePadding, u = t, v = b.stroke && p.hasStroke(), w = b.fill && p.hasFill(), x = b.curves, y = v ? p.getStrokeWidth() / 2 : w && b.tolerance > 0 || x ? 0 : null;
            if (null !== y && (y > 0 ? (i = p.getStrokeJoin(), j = p.getStrokeCap(), k = y * p.getMiterLimit(), 
            u = t.add(new h(y, y))) : i = j = "round"), !b.ends || b.segments || s) {
                if (b.segments || b.handles) for (var A = 0; r > A; A++) if (n = e(q[A])) return n;
            } else if (n = e(q[0], !0) || e(q[r - 1], !0)) return n;
            if (null !== y) {
                if (m = this.getNearestLocation(a)) {
                    var B = m.getParameter();
                    0 === B || 1 === B && r > 1 ? g(m.getSegment()) || (m = null) : c(m.getPoint(), u) || (m = null);
                }
                if (!m && "miter" === i && r > 1) for (var A = 0; r > A; A++) {
                    var C = q[A];
                    if (a.getDistance(C._point) <= k && g(C)) {
                        m = C.getLocation();
                        break;
                    }
                }
            }
            return !m && w && this._contains(a) || m && !v && !x ? new z("fill", this) : m ? new z(v ? "stroke" : "curve", this, {
                location: m,
                point: m.getPoint()
            }) : null;
        }
    }, b.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(a) {
        this[a + "At"] = function(b, c) {
            var d = this.getLocationAt(b, c);
            return d && d[a]();
        };
    }, {
        beans: !1,
        _getOffset: function(a) {
            var b = a && a.getIndex();
            if (null != b) {
                for (var c = this.getCurves(), d = 0, e = 0; b > e; e++) d += c[e].getLength();
                var f = c[b], g = a.getParameter();
                return g > 0 && (d += f.getPartLength(0, g)), d;
            }
            return null;
        },
        getLocationOf: function() {
            for (var a = h.read(arguments), b = this.getCurves(), c = 0, d = b.length; d > c; c++) {
                var e = b[c].getLocationOf(a);
                if (e) return e;
            }
            return null;
        },
        getOffsetOf: function() {
            var a = this.getLocationOf.apply(this, arguments);
            return a ? a.getOffset() : null;
        },
        getLocationAt: function(a, b) {
            var c = this.getCurves(), d = 0;
            if (b) {
                var e = ~~a;
                return c[e].getLocationAt(a - e, !0);
            }
            for (var f = 0, g = c.length; g > f; f++) {
                var h = d, i = c[f];
                if (d += i.getLength(), d > a) return i.getLocationAt(a - h);
            }
            return a <= this.getLength() ? new D(c[c.length - 1], 1) : null;
        },
        getNearestLocation: function() {
            for (var a = h.read(arguments), b = this.getCurves(), c = 1/0, d = null, e = 0, f = b.length; f > e; e++) {
                var g = b[e].getNearestLocation(a);
                g._distance < c && (c = g._distance, d = g);
            }
            return d;
        },
        getNearestPoint: function() {
            return this.getNearestLocation.apply(this, arguments).getPoint();
        }
    }), new function() {
        function a(a, b, c, d) {
            function e(b) {
                var c = g[b], d = g[b + 1];
                (l != c || m != d) && (a.beginPath(), a.moveTo(l, m), a.lineTo(c, d), a.stroke(), 
                a.beginPath(), a.arc(c, d, f, 0, 2 * Math.PI, !0), a.fill());
            }
            for (var f = d / 2, g = new Array(6), h = 0, i = b.length; i > h; h++) {
                var j = b[h];
                j._transformCoordinates(c, g, !1);
                var k = j._selectionState, l = g[0], m = g[1];
                if (1 & k && e(2), 2 & k && e(4), a.fillRect(l - f, m - f, d, d), !(4 & k)) {
                    var n = a.fillStyle;
                    a.fillStyle = "#ffffff", a.fillRect(l - f + 1, m - f + 1, d - 2, d - 2), a.fillStyle = n;
                }
            }
        }
        function b(a, b, c) {
            function d(b) {
                if (c) b._transformCoordinates(c, o, !1), e = o[0], f = o[1]; else {
                    var d = b._point;
                    e = d._x, f = d._y;
                }
                if (p) a.moveTo(e, f), p = !1; else {
                    if (c) i = o[2], j = o[3]; else {
                        var m = b._handleIn;
                        i = e + m._x, j = f + m._y;
                    }
                    i === e && j === f && k === g && l === h ? a.lineTo(e, f) : a.bezierCurveTo(k, l, i, j, e, f);
                }
                if (g = e, h = f, c) k = o[4], l = o[5]; else {
                    var m = b._handleOut;
                    k = g + m._x, l = h + m._y;
                }
            }
            for (var e, f, g, h, i, j, k, l, m = b._segments, n = m.length, o = new Array(6), p = !0, q = 0; n > q; q++) d(m[q]);
            b._closed && n > 0 && d(m[0]);
        }
        return {
            _draw: function(a, c, d) {
                function e(a) {
                    return k[(a % l + l) % l];
                }
                var f = c.dontStart, g = c.dontFinish || c.clip, h = this.getStyle(), i = h.hasFill(), j = h.hasStroke(), k = h.getDashArray(), l = !paper.support.nativeDash && j && k && k.length;
                if (f || a.beginPath(), !f && this._currentPath ? a.currentPath = this._currentPath : (i || j && !l || g) && (b(a, this, d), 
                this._closed && a.closePath(), f || (this._currentPath = a.currentPath)), !g && (i || j) && (this._setStyles(a), 
                i && (a.fill(h.getWindingRule()), a.shadowColor = "rgba(0,0,0,0)"), j)) {
                    if (l) {
                        f || a.beginPath();
                        var m, n = new H(this, 32, .25, d), o = n.length, p = -h.getDashOffset(), q = 0;
                        for (p %= o; p > 0; ) p -= e(q--) + e(q--);
                        for (;o > p; ) m = p + e(q++), (p > 0 || m > 0) && n.drawPart(a, Math.max(p, 0), Math.max(m, 0)), 
                        p = m + e(q++);
                    }
                    a.stroke();
                }
            },
            _drawSelected: function(c, d) {
                c.beginPath(), b(c, this, d), c.stroke(), a(c, this._segments, d, paper.settings.handleSize);
            }
        };
    }(), new function() {
        function a(a) {
            var b = a.length, c = [], d = [], e = 2;
            c[0] = a[0] / e;
            for (var f = 1; b > f; f++) d[f] = 1 / e, e = (b - 1 > f ? 4 : 2) - d[f], c[f] = (a[f] - c[f - 1]) / e;
            for (var f = 1; b > f; f++) c[b - f - 1] -= d[b - f] * c[b - f];
            return c;
        }
        return {
            smooth: function() {
                var b = this._segments, c = b.length, d = this._closed, e = c, f = 0;
                if (!(2 >= c)) {
                    d && (f = Math.min(c, 4), e += 2 * Math.min(c, f));
                    for (var g = [], i = 0; c > i; i++) g[i + f] = b[i]._point;
                    if (d) for (var i = 0; f > i; i++) g[i] = b[i + c - f]._point, g[i + c + f] = b[i]._point; else e--;
                    for (var j = [], i = 1; e - 1 > i; i++) j[i] = 4 * g[i]._x + 2 * g[i + 1]._x;
                    j[0] = g[0]._x + 2 * g[1]._x, j[e - 1] = 3 * g[e - 1]._x;
                    for (var k = a(j), i = 1; e - 1 > i; i++) j[i] = 4 * g[i]._y + 2 * g[i + 1]._y;
                    j[0] = g[0]._y + 2 * g[1]._y, j[e - 1] = 3 * g[e - 1]._y;
                    var l = a(j);
                    if (d) {
                        for (var i = 0, m = c; f > i; i++, m++) {
                            var n = i / f, o = 1 - n, p = i + f, q = m + f;
                            k[m] = k[i] * n + k[m] * o, l[m] = l[i] * n + l[m] * o, k[q] = k[p] * o + k[q] * n, 
                            l[q] = l[p] * o + l[q] * n;
                        }
                        e--;
                    }
                    for (var r = null, i = f; e - f >= i; i++) {
                        var s = b[i - f];
                        r && s.setHandleIn(r.subtract(s._point)), e > i && (s.setHandleOut(new h(k[i], l[i]).subtract(s._point)), 
                        r = e - 1 > i ? new h(2 * g[i + 1]._x - k[i + 1], 2 * g[i + 1]._y - l[i + 1]) : new h((g[e]._x + k[e - 1]) / 2, (g[e]._y + l[e - 1]) / 2));
                    }
                    if (d && r) {
                        var s = this._segments[0];
                        s.setHandleIn(r.subtract(s._point));
                    }
                }
            }
        };
    }(), new function() {
        function a(a) {
            var b = a._segments;
            if (0 === b.length) throw new Error("Use a moveTo() command first");
            return b[b.length - 1];
        }
        return {
            moveTo: function() {
                var a = this._segments;
                1 === a.length && this.removeSegment(0), a.length || this._add([ new A(h.read(arguments)) ]);
            },
            moveBy: function() {
                throw new Error("moveBy() is unsupported on Path items.");
            },
            lineTo: function() {
                this._add([ new A(h.read(arguments)) ]);
            },
            cubicCurveTo: function() {
                var b = h.read(arguments), c = h.read(arguments), d = h.read(arguments), e = a(this);
                e.setHandleOut(b.subtract(e._point)), this._add([ new A(d, c.subtract(d)) ]);
            },
            quadraticCurveTo: function() {
                var b = h.read(arguments), c = h.read(arguments), d = a(this)._point;
                this.cubicCurveTo(b.add(d.subtract(b).multiply(1 / 3)), b.add(c.subtract(b).multiply(1 / 3)), c);
            },
            curveTo: function() {
                var c = h.read(arguments), d = h.read(arguments), e = b.pick(b.read(arguments), .5), f = 1 - e, g = a(this)._point, i = c.subtract(g.multiply(f * f)).subtract(d.multiply(e * e)).divide(2 * e * f);
                if (i.isNaN()) throw new Error("Cannot put a curve through points with parameter = " + e);
                this.quadraticCurveTo(i, d);
            },
            arcTo: function() {
                var c, d, e, f, g, i = a(this), j = i._point, l = h.read(arguments), m = b.peek(arguments), n = b.pick(m, !0);
                if ("boolean" == typeof n) var o = j.add(l).divide(2), c = o.add(o.subtract(j).rotate(n ? -90 : 90)); else if (b.remain(arguments) <= 2) c = l, 
                l = h.read(arguments); else {
                    var r = k.read(arguments);
                    if (r.isZero()) return this.lineTo(l);
                    var s = b.read(arguments), n = !!b.read(arguments), t = !!b.read(arguments), o = j.add(l).divide(2), u = j.subtract(o).rotate(-s), v = u.x, w = u.y, x = Math.abs, y = 1e-11, z = x(r.width), B = x(r.height), C = z * z, D = B * B, E = v * v, F = w * w, G = Math.sqrt(E / C + F / D);
                    if (G > 1 && (z *= G, B *= G, C = z * z, D = B * B), G = (C * D - C * F - D * E) / (C * F + D * E), 
                    x(G) < y && (G = 0), 0 > G) throw new Error("Cannot create an arc with the given arguments");
                    d = new h(z * w / B, -B * v / z).multiply((t === n ? -1 : 1) * Math.sqrt(G)).rotate(s).add(o), 
                    g = new p().translate(d).rotate(s).scale(z, B), f = g._inverseTransform(j), e = f.getDirectedAngle(g._inverseTransform(l)), 
                    !n && e > 0 ? e -= 360 : n && 0 > e && (e += 360);
                }
                if (c) {
                    var H = new q(j.add(c).divide(2), c.subtract(j).rotate(90), !0), I = new q(c.add(l).divide(2), l.subtract(c).rotate(90), !0), J = new q(j, l), K = J.getSide(c);
                    if (d = H.intersect(I, !0), !d) {
                        if (!K) return this.lineTo(l);
                        throw new Error("Cannot create an arc with the given arguments");
                    }
                    f = j.subtract(d), e = f.getDirectedAngle(l.subtract(d));
                    var L = J.getSide(d);
                    0 === L ? e = K * Math.abs(e) : K === L && (e += 0 > e ? 360 : -360);
                }
                for (var M = Math.abs(e), N = M >= 360 ? 4 : Math.ceil(M / 90), O = e / N, P = O * Math.PI / 360, Q = 4 / 3 * Math.sin(P) / (1 + Math.cos(P)), R = [], S = 0; N >= S; S++) {
                    var u = l, T = null;
                    if (N > S && (T = f.rotate(90).multiply(Q), g ? (u = g._transformPoint(f), T = g._transformPoint(f.add(T)).subtract(u)) : u = d.add(f)), 
                    0 === S) i.setHandleOut(T); else {
                        var U = f.rotate(-90).multiply(Q);
                        g && (U = g._transformPoint(f.add(U)).subtract(u)), R.push(new A(u, U, T));
                    }
                    f = f.rotate(O);
                }
                this._add(R);
            },
            lineBy: function() {
                var b = h.read(arguments), c = a(this)._point;
                this.lineTo(c.add(b));
            },
            curveBy: function() {
                var c = h.read(arguments), d = h.read(arguments), e = b.read(arguments), f = a(this)._point;
                this.curveTo(f.add(c), f.add(d), e);
            },
            cubicCurveBy: function() {
                var b = h.read(arguments), c = h.read(arguments), d = h.read(arguments), e = a(this)._point;
                this.cubicCurveTo(e.add(b), e.add(c), e.add(d));
            },
            quadraticCurveBy: function() {
                var b = h.read(arguments), c = h.read(arguments), d = a(this)._point;
                this.quadraticCurveTo(d.add(b), d.add(c));
            },
            arcBy: function() {
                var c = a(this)._point, d = c.add(h.read(arguments)), e = b.pick(b.peek(arguments), !0);
                "boolean" == typeof e ? this.arcTo(d, e) : this.arcTo(d, c.add(h.read(arguments)));
            },
            closePath: function(a) {
                this.setClosed(!0), a && this.join();
            }
        };
    }(), {
        _getBounds: function(a, b) {
            return F[a](this._segments, this._closed, this.getStyle(), b);
        },
        statics: {
            isClockwise: function(a) {
                for (var b = 0, c = 0, d = a.length; d > c; c++) for (var e = C.getValues(a[c], a[d > c + 1 ? c + 1 : 0]), f = 2; 8 > f; f += 2) b += (e[f - 2] - e[f]) * (e[f + 1] + e[f - 1]);
                return b > 0;
            },
            getBounds: function(a, b, c, d, e) {
                function f(a) {
                    a._transformCoordinates(d, h, !1);
                    for (var b = 0; 2 > b; b++) C._addBounds(i[b], i[b + 4], h[b + 2], h[b], b, e ? e[b] : 0, j, k, l);
                    var c = i;
                    i = h, h = c;
                }
                var g = a[0];
                if (!g) return new n();
                for (var h = new Array(6), i = g._transformCoordinates(d, new Array(6), !1), j = i.slice(0, 2), k = j.slice(), l = new Array(2), m = 1, o = a.length; o > m; m++) f(a[m]);
                return b && f(g), new n(j[0], j[1], k[0] - j[0], k[1] - j[1]);
            },
            getStrokeBounds: function(a, b, c, d) {
                function e(a) {
                    m = m.include(d ? d._transformPoint(a, a) : a);
                }
                function f(a) {
                    m = m.unite(r.setCenter(d ? d._transformPoint(a._point) : a._point));
                }
                function g(a, b) {
                    var c = a._handleIn, d = a._handleOut;
                    "round" === b || !c.isZero() && !d.isZero() && c.isColinear(d) ? f(a) : F._addBevelJoin(a, b, j, q, e);
                }
                function h(a, b) {
                    "round" === b ? f(a) : F._addSquareCap(a, b, j, e);
                }
                if (!c.hasStroke()) return F.getBounds(a, b, c, d);
                for (var i = a.length - (b ? 0 : 1), j = c.getStrokeWidth() / 2, l = F._getPenPadding(j, d), m = F.getBounds(a, b, c, d, l), o = c.getStrokeJoin(), p = c.getStrokeCap(), q = j * c.getMiterLimit(), r = new n(new k(l).multiply(2)), s = 1; i > s; s++) g(a[s], o);
                return b ? g(a[0], o) : i > 0 && (h(a[0], p), h(a[a.length - 1], p)), m;
            },
            _getPenPadding: function(a, b) {
                if (!b) return [ a, a ];
                var c = b.shiftless(), d = c.transform(new h(a, 0)), e = c.transform(new h(0, a)), f = d.getAngleInRadians(), g = d.getLength(), i = e.getLength(), j = Math.sin(f), k = Math.cos(f), l = Math.tan(f), m = -Math.atan(i * l / g), n = Math.atan(i / (l * g));
                return [ Math.abs(g * Math.cos(m) * k - i * Math.sin(m) * j), Math.abs(i * Math.sin(n) * k + g * Math.cos(n) * j) ];
            },
            _addBevelJoin: function(a, b, c, d, e, f) {
                var g = a.getCurve(), i = g.getPrevious(), j = g.getPointAt(0, !0), k = i.getNormalAt(1, !0), l = g.getNormalAt(0, !0), m = k.getDirectedAngle(l) < 0 ? -c : c;
                if (k.setLength(m), l.setLength(m), f && (e(j), e(j.add(k))), "miter" === b) {
                    var n = new q(j.add(k), new h(-k.y, k.x), !0).intersect(new q(j.add(l), new h(-l.y, l.x), !0), !0);
                    if (n && j.getDistance(n) <= d && (e(n), !f)) return;
                }
                f || e(j.add(k)), e(j.add(l));
            },
            _addSquareCap: function(a, b, c, d, e) {
                var f = a._point, g = a.getLocation(), h = g.getNormal().normalize(c);
                e && (d(f.subtract(h)), d(f.add(h))), "square" === b && (f = f.add(h.rotate(0 === g.getParameter() ? -90 : 90))), 
                d(f.add(h)), d(f.subtract(h));
            },
            getHandleBounds: function(a, b, c, d, e, f) {
                for (var g = new Array(6), h = 1/0, i = -h, j = h, k = i, l = 0, m = a.length; m > l; l++) {
                    var o = a[l];
                    o._transformCoordinates(d, g, !1);
                    for (var p = 0; 6 > p; p += 2) {
                        var q = 0 === p ? f : e, r = q ? q[0] : 0, s = q ? q[1] : 0, t = g[p], u = g[p + 1], v = t - r, w = t + r, x = u - s, y = u + s;
                        h > v && (h = v), w > i && (i = w), j > x && (j = x), y > k && (k = y);
                    }
                }
                return new n(h, j, i - h, k - j);
            },
            getRoughBounds: function(a, b, c, d) {
                var e = c.hasStroke() ? c.getStrokeWidth() / 2 : 0, f = e;
                return e > 0 && ("miter" === c.getStrokeJoin() && (f = e * c.getMiterLimit()), "square" === c.getStrokeCap() && (f = Math.max(f, e * Math.sqrt(2)))), 
                F.getHandleBounds(a, b, c, d, F._getPenPadding(e, d), F._getPenPadding(f, d));
            }
        }
    });
    F.inject({
        statics: new function() {
            function a(a, c, d) {
                var e = b.getNamed(d), f = new F(e && e.insert === !1 && t.NO_INSERT);
                return f._add(a), f._closed = c, f.set(e);
            }
            function c(b, c, d) {
                for (var f = new Array(4), g = 0; 4 > g; g++) {
                    var h = e[g];
                    f[g] = new A(h._point.multiply(c).add(b), h._handleIn.multiply(c), h._handleOut.multiply(c));
                }
                return a(f, !0, d);
            }
            var d = .5522847498307936, e = [ new A([ -1, 0 ], [ 0, d ], [ 0, -d ]), new A([ 0, -1 ], [ -d, 0 ], [ d, 0 ]), new A([ 1, 0 ], [ 0, -d ], [ 0, d ]), new A([ 0, 1 ], [ d, 0 ], [ -d, 0 ]) ];
            return {
                Line: function() {
                    return a([ new A(h.readNamed(arguments, "from")), new A(h.readNamed(arguments, "to")) ], !1, arguments);
                },
                Circle: function() {
                    var a = h.readNamed(arguments, "center"), d = b.readNamed(arguments, "radius");
                    return c(a, new k(d), arguments);
                },
                Rectangle: function() {
                    var b, c = n.readNamed(arguments, "rectangle"), e = k.readNamed(arguments, "radius", 0, {
                        readNull: !0
                    }), f = c.getBottomLeft(!0), g = c.getTopLeft(!0), h = c.getTopRight(!0), i = c.getBottomRight(!0);
                    if (!e || e.isZero()) b = [ new A(f), new A(g), new A(h), new A(i) ]; else {
                        e = k.min(e, c.getSize(!0).divide(2));
                        var j = e.width, l = e.height, m = j * d, o = l * d;
                        b = [ new A(f.add(j, 0), null, [ -m, 0 ]), new A(f.subtract(0, l), [ 0, o ]), new A(g.add(0, l), null, [ 0, -o ]), new A(g.add(j, 0), [ -m, 0 ], null), new A(h.subtract(j, 0), null, [ m, 0 ]), new A(h.add(0, l), [ 0, -o ], null), new A(i.subtract(0, l), null, [ 0, o ]), new A(i.subtract(j, 0), [ m, 0 ]) ];
                    }
                    return a(b, !0, arguments);
                },
                RoundRectangle: "#Rectangle",
                Ellipse: function() {
                    var a = w._readEllipse(arguments);
                    return c(a.center, a.radius, arguments);
                },
                Oval: "#Ellipse",
                Arc: function() {
                    var a = h.readNamed(arguments, "from"), c = h.readNamed(arguments, "through"), d = h.readNamed(arguments, "to"), e = b.getNamed(arguments), f = new F(e && e.insert === !1 && t.NO_INSERT);
                    return f.moveTo(a), f.arcTo(c, d), f.set(e);
                },
                RegularPolygon: function() {
                    for (var c = h.readNamed(arguments, "center"), d = b.readNamed(arguments, "sides"), e = b.readNamed(arguments, "radius"), f = 360 / d, g = !(d % 3), i = new h(0, g ? -e : e), j = g ? -1 : .5, k = new Array(d), l = 0; d > l; l++) k[l] = new A(c.add(i.rotate((l + j) * f)));
                    return a(k, !0, arguments);
                },
                Star: function() {
                    for (var c = h.readNamed(arguments, "center"), d = 2 * b.readNamed(arguments, "points"), e = b.readNamed(arguments, "radius1"), f = b.readNamed(arguments, "radius2"), g = 360 / d, i = new h(0, -1), j = new Array(d), k = 0; d > k; k++) j[k] = new A(c.add(i.rotate(g * k).multiply(k % 2 ? f : e)));
                    return a(j, !0, arguments);
                }
            };
        }()
    });
    var G = E.extend({
        _class: "CompoundPath",
        _serializeFields: {
            children: []
        },
        initialize: function(a) {
            this._children = [], this._namedChildren = {}, this._initialize(a) || ("string" == typeof a ? this.setPathData(a) : this.addChildren(Array.isArray(a) ? a : arguments));
        },
        insertChildren: function tb(b, c, d) {
            c = tb.base.call(this, b, c, d, F);
            for (var e = 0, f = !d && c && c.length; f > e; e++) {
                var g = c[e];
                g._clockwise === a && g.setClockwise(0 === g._index);
            }
            return c;
        },
        reverse: function() {
            for (var a = this._children, b = 0, c = a.length; c > b; b++) a[b].reverse();
        },
        smooth: function() {
            for (var a = 0, b = this._children.length; b > a; a++) this._children[a].smooth();
        },
        isClockwise: function() {
            var a = this.getFirstChild();
            return a && a.isClockwise();
        },
        setClockwise: function(a) {
            this.isClockwise() !== !!a && this.reverse();
        },
        getFirstSegment: function() {
            var a = this.getFirstChild();
            return a && a.getFirstSegment();
        },
        getLastSegment: function() {
            var a = this.getLastChild();
            return a && a.getLastSegment();
        },
        getCurves: function() {
            for (var a = this._children, b = [], c = 0, d = a.length; d > c; c++) b.push.apply(b, a[c].getCurves());
            return b;
        },
        getFirstCurve: function() {
            var a = this.getFirstChild();
            return a && a.getFirstCurve();
        },
        getLastCurve: function() {
            var a = this.getLastChild();
            return a && a.getFirstCurve();
        },
        getArea: function() {
            for (var a = this._children, b = 0, c = 0, d = a.length; d > c; c++) b += a[c].getArea();
            return b;
        }
    }, {
        beans: !0,
        getPathData: function(a, b) {
            for (var c = this._children, d = [], e = 0, f = c.length; f > e; e++) {
                var g = c[e], h = g._matrix;
                d.push(g.getPathData(a && !h.isIdentity() ? a.chain(h) : h, b));
            }
            return d.join(" ");
        }
    }, {
        _getChildHitTestOptions: function(a) {
            return a["class"] === F || "path" === a.type ? a : new b(a, {
                fill: !1
            });
        },
        _draw: function(a, b, c) {
            var d = this._children;
            if (0 !== d.length) {
                if (this._currentPath) a.currentPath = this._currentPath; else {
                    b = b.extend({
                        dontStart: !0,
                        dontFinish: !0
                    }), a.beginPath();
                    for (var e = 0, f = d.length; f > e; e++) d[e].draw(a, b, c);
                    this._currentPath = a.currentPath;
                }
                if (!b.clip) {
                    this._setStyles(a);
                    var g = this._style;
                    g.hasFill() && (a.fill(g.getWindingRule()), a.shadowColor = "rgba(0,0,0,0)"), g.hasStroke() && a.stroke();
                }
            }
        },
        _drawSelected: function(a, b, c) {
            for (var d = this._children, e = 0, f = d.length; f > e; e++) {
                var g = d[e], h = g._matrix;
                c[g._id] || g._drawSelected(a, h.isIdentity() ? b : b.chain(h));
            }
        }
    }, new function() {
        function a(a, b) {
            var c = a._children;
            if (b && 0 === c.length) throw new Error("Use a moveTo() command first");
            return c[c.length - 1];
        }
        var c = {
            moveTo: function() {
                var b = a(this), c = b && b.isEmpty() ? b : new F();
                c !== b && this.addChild(c), c.moveTo.apply(c, arguments);
            },
            moveBy: function() {
                var b = a(this, !0), c = b && b.getLastSegment(), d = h.read(arguments);
                this.moveTo(c ? d.add(c._point) : d);
            },
            closePath: function(b) {
                a(this, !0).closePath(b);
            }
        };
        return b.each([ "lineTo", "cubicCurveTo", "quadraticCurveTo", "curveTo", "arcTo", "lineBy", "cubicCurveBy", "quadraticCurveBy", "curveBy", "arcBy" ], function(b) {
            c[b] = function() {
                var c = a(this, !0);
                c[b].apply(c, arguments);
            };
        }), c;
    }());
    E.inject(new function() {
        function a(a, e, f, g) {
            function h(a) {
                return a.clone(!1).reduce().reorient().transform(null, !0);
            }
            function i(a) {
                for (var b = 0, c = a.length; c > b; b++) {
                    var d = a[b];
                    o.push.apply(o, d._segments), p.push.apply(p, d._getMonoCurves());
                }
            }
            var j = h(a), k = e && a !== e && h(e);
            j.isClockwise() || j.reverse(), !k || g ^ k.isClockwise() || k.reverse(), b(j.getIntersections(k, null, !0));
            var l = [], m = [], n = [], o = [], p = [];
            i(j._children || [ j ]), k && i(k._children || [ k ]), o.sort(function(a, b) {
                var c = a._intersection, d = b._intersection;
                return !c && !d || c && d ? 0 : c ? -1 : 1;
            });
            for (var q = 0, r = o.length; r > q; q++) {
                var s = o[q];
                if (null == s._winding) {
                    l.length = m.length = n.length = 0;
                    var t = 0, u = s;
                    do l.push(s), n.push(t += s.getCurve().getLength()), s = s.getNext(); while (s && !s._intersection && s !== u);
                    for (var v = 0; 3 > v; v++) {
                        var w = t * Math.random(), x = n.length, y = 0;
                        do if (n[y] >= w) {
                            y > 0 && (w -= n[y - 1]);
                            break;
                        } while (++y < x);
                        var z = l[y].getCurve(), A = z.getPointAt(w), B = z.isHorizontal(), C = z._path;
                        C._parent instanceof G && (C = C._parent), m[v] = g && k && (C === j && k._getWinding(A, B) || C === k && !j._getWinding(A, B)) ? 0 : c(A, p, B);
                    }
                    m.sort();
                    for (var D = m[1], v = l.length - 1; v >= 0; v--) l[v]._winding = D;
                }
            }
            var E = new G();
            return E.addChildren(d(o, f), !0), j.remove(), k && k.remove(), E = E.reduce(), 
            E.setStyle(a._style), E;
        }
        function b(a) {
            function b() {
                for (var a = 0, b = c.length; b > a; a++) {
                    var d = c[a];
                    d._handleOut.set(0, 0), d._handleIn.set(0, 0);
                }
            }
            for (var c, d, e, f = 1e-5, g = a.length - 1; g >= 0; g--) {
                var h = a[g], i = h._parameter;
                e && e._curve === h._curve && e._parameter > 0 ? i /= e._parameter : (c && b(), 
                d = h._curve, c = d.isLinear() && []);
                var j, k;
                (j = d.divide(i, !0, !0)) ? (k = j._segment1, d = j.getPrevious()) : k = f > i ? d._segment1 : i > 1 - f ? d._segment2 : d.getPartLength(0, i) < d.getPartLength(i, 1) ? d._segment1 : d._segment2, 
                k._intersection = h.getIntersection(), h._segment = k, c && c.push(k), e = h;
            }
            c && b();
        }
        function c(a, b, d, e) {
            var f = 1e-5, g = a.x, i = a.y, j = 0, k = 0, l = [], m = Math.abs, n = 1 - f;
            if (d) {
                for (var o = -1/0, p = 1/0, q = i - f, r = i + f, s = 0, t = b.length; t > s; s++) {
                    var u = b[s].values;
                    if (C.solveCubic(u, 0, g, l, 0, 1) > 0) for (var v = l.length - 1; v >= 0; v--) {
                        var w = C.evaluate(u, l[v], 0).y;
                        q > w && w > o ? o = w : w > r && p > w && (p = w);
                    }
                }
                o = (o + i) / 2, p = (p + i) / 2, o > -1/0 && (j = c(new h(g, o), b)), 1/0 > p && (k = c(new h(g, p), b));
            } else for (var x = g - f, y = g + f, s = 0, t = b.length; t > s; s++) {
                var z = b[s], u = z.values, A = z.winding, B = z.next;
                if (A && (1 === A && i >= u[1] && i <= u[7] || i >= u[7] && i <= u[1]) && 1 === C.solveCubic(u, 1, i, l, 0, B.winding || B.values[1] !== i ? n : 1)) {
                    var D = l[0], E = C.evaluate(u, D, 0).x, F = C.evaluate(u, D, 1).y;
                    m(F) < f && !C.isLinear(u) || f > D && F * C.evaluate(z.previous.values, D, 1).y < 0 ? e && E >= x && y >= E && (++j, 
                    ++k) : x >= E ? j += A : E >= y && (k += A);
                }
            }
            return Math.max(m(j), m(k));
        }
        function d(a, b, c) {
            b = b || function() {
                return !0;
            };
            for (var d, e, f = [], g = .001, h = .999, i = 0, j = a.length; j > i; i++) if (d = e = a[i], 
            !d._visited && b(d._winding)) {
                var k = new F(t.NO_INSERT), l = d._intersection, m = l && l._segment, n = !1, o = 1;
                do {
                    var p, q = o > 0 ? d._handleIn : d._handleOut, r = o > 0 ? d._handleOut : d._handleIn;
                    if (n && (!b(d._winding) || c) && (l = d._intersection) && (p = l._segment) && p !== e) {
                        if (c) d._visited = p._visited, d = p, o = 1; else {
                            var s = d.getCurve();
                            o > 0 && (s = s.getPrevious());
                            var u = s.getTangentAt(1 > o ? g : h, !0), v = p.getCurve(), w = v.getPrevious(), x = w.getTangentAt(h, !0), y = v.getTangentAt(g, !0), z = u.cross(x), B = u.cross(y);
                            if (z * B !== 0) {
                                var C = B > z ? w : v, D = b(C._segment1._winding) ? C : B > z ? v : w, E = D._segment1;
                                o = D === w ? -1 : 1, E._visited && d._path !== E._path || !b(E._winding) ? o = 1 : (d._visited = p._visited, 
                                d = p, E._visited && (o = 1));
                            } else o = 1;
                        }
                        r = o > 0 ? d._handleOut : d._handleIn;
                    }
                    k.add(new A(d._point, n && q, r)), n = !0, d._visited = !0, d = o > 0 ? d.getNext() : d.getPrevious();
                } while (d && !d._visited && d !== e && d !== m && (d._intersection || b(d._winding)));
                !d || d !== e && d !== m ? k.lastSegment._handleOut.set(0, 0) : (k.firstSegment.setHandleIn((d === m ? m : d)._handleIn), 
                k.setClosed(!0)), k._segments.length > (k._closed ? k.isPolygon() ? 2 : 0 : 1) && f.push(k);
            }
            return f;
        }
        return {
            _getWinding: function(a, b, d) {
                return c(a, this._getMonoCurves(), b, d);
            },
            unite: function(b) {
                return a(this, b, function(a) {
                    return 1 === a || 0 === a;
                }, !1);
            },
            intersect: function(b) {
                return a(this, b, function(a) {
                    return 2 === a;
                }, !1);
            },
            subtract: function(b) {
                return a(this, b, function(a) {
                    return 1 === a;
                }, !0);
            },
            exclude: function(a) {
                return new u([ this.subtract(a), a.subtract(this) ]);
            },
            divide: function(a) {
                return new u([ this.subtract(a), this.intersect(a) ]);
            }
        };
    }()), F.inject({
        _getMonoCurves: function() {
            function a(a) {
                var b = a[1], e = a[7], f = {
                    values: a,
                    winding: b === e ? 0 : b > e ? -1 : 1,
                    previous: c,
                    next: null
                };
                c && (c.next = f), d.push(f), c = f;
            }
            function b(b) {
                if (0 !== C.getLength(b)) {
                    var c = b[1], d = b[3], e = b[5], f = b[7];
                    if (C.isLinear(b)) a(b); else {
                        var h = 3 * (d - e) - c + f, i = 2 * (c + e) - 4 * d, j = d - c, k = 1e-5, l = [], m = g.solveQuadratic(h, i, j, l, k, 1 - k);
                        if (0 === m) a(b); else {
                            l.sort();
                            var n = l[0], o = C.subdivide(b, n);
                            a(o[0]), m > 1 && (n = (l[1] - n) / (1 - n), o = C.subdivide(o[1], n), a(o[0])), 
                            a(o[1]);
                        }
                    }
                }
            }
            var c, d = this._monoCurves;
            if (!d) {
                d = this._monoCurves = [];
                for (var e = this.getCurves(), f = this._segments, h = 0, i = e.length; i > h; h++) b(e[h].getValues());
                if (!this._closed && f.length > 1) {
                    var j = f[f.length - 1]._point, k = f[0]._point, l = j._x, m = j._y, n = k._x, o = k._y;
                    b([ l, m, l, m, n, o, n, o ]);
                }
                if (d.length > 0) {
                    var p = d[0], q = d[d.length - 1];
                    p.previous = q, q.next = p;
                }
            }
            return d;
        },
        getInteriorPoint: function() {
            var a = this.getBounds(), b = a.getCenter(!0);
            if (!this.contains(b)) {
                for (var c = this._getMonoCurves(), d = [], e = b.y, f = [], g = 0, h = c.length; h > g; g++) {
                    var i = c[g].values;
                    if ((1 === c[g].winding && e >= i[1] && e <= i[7] || e >= i[7] && e <= i[1]) && C.solveCubic(i, 1, e, d, 0, 1) > 0) for (var j = d.length - 1; j >= 0; j--) f.push(C.evaluate(i, d[j], 0).x);
                    if (f.length > 1) break;
                }
                b.x = (f[0] + f[1]) / 2;
            }
            return b;
        },
        reorient: function() {
            return this.setClockwise(!0), this;
        }
    }), G.inject({
        _getMonoCurves: function() {
            for (var a = this._children, b = [], c = 0, d = a.length; d > c; c++) b.push.apply(b, a[c]._getMonoCurves());
            return b;
        },
        reorient: function() {
            var a = this.removeChildren().sort(function(a, b) {
                return b.getBounds().getArea() - a.getBounds().getArea();
            });
            this.addChildren(a);
            for (var b = a[0].isClockwise(), c = 1, d = a.length; d > c; c++) {
                for (var e = a[c].getInteriorPoint(), f = 0, g = c - 1; g >= 0; g--) a[g].contains(e) && f++;
                a[c].setClockwise(f % 2 === 0 && b);
            }
            return this;
        }
    });
    var H = b.extend({
        _class: "PathIterator",
        initialize: function(a, b, c, d) {
            function e(a, b) {
                var c = C.getValues(a, b, d);
                h.push(c), f(c, a._index, 0, 1);
            }
            function f(a, b, d, e) {
                if (e - d > k && !C.isFlatEnough(a, c || .25)) {
                    var g = C.subdivide(a), h = (d + e) / 2;
                    f(g[0], b, d, h), f(g[1], b, h, e);
                } else {
                    var l = a[6] - a[0], m = a[7] - a[1], n = Math.sqrt(l * l + m * m);
                    n > 1e-5 && (j += n, i.push({
                        offset: j,
                        value: e,
                        index: b
                    }));
                }
            }
            for (var g, h = [], i = [], j = 0, k = 1 / (b || 32), l = a._segments, m = l[0], n = 1, o = l.length; o > n; n++) g = l[n], 
            e(m, g), m = g;
            a._closed && e(g, l[0]), this.curves = h, this.parts = i, this.length = j, this.index = 0;
        },
        getParameterAt: function(a) {
            for (var b, c = this.index; b = c, !(0 == c || this.parts[--c].offset < a); ) ;
            for (var d = this.parts.length; d > b; b++) {
                var e = this.parts[b];
                if (e.offset >= a) {
                    this.index = b;
                    var f = this.parts[b - 1], g = f && f.index == e.index ? f.value : 0, h = f ? f.offset : 0;
                    return {
                        value: g + (e.value - g) * (a - h) / (e.offset - h),
                        index: e.index
                    };
                }
            }
            var e = this.parts[this.parts.length - 1];
            return {
                value: 1,
                index: e.index
            };
        },
        evaluate: function(a, b) {
            var c = this.getParameterAt(a);
            return C.evaluate(this.curves[c.index], c.value, b);
        },
        drawPart: function(a, b, c) {
            b = this.getParameterAt(b), c = this.getParameterAt(c);
            for (var d = b.index; d <= c.index; d++) {
                var e = C.getPart(this.curves[d], d == b.index ? b.value : 0, d == c.index ? c.value : 1);
                d == b.index && a.moveTo(e[0], e[1]), a.bezierCurveTo.apply(a, e.slice(2));
            }
        }
    }, b.each([ "getPoint", "getTangent", "getNormal", "getCurvature" ], function(a, b) {
        this[a + "At"] = function(a) {
            return this.evaluate(a, b);
        };
    }, {})), I = b.extend({
        initialize: function(a, b) {
            this.points = [];
            for (var c, d = a._segments, e = 0, f = d.length; f > e; e++) {
                var g = d[e].point.clone();
                c && c.equals(g) || (this.points.push(g), c = g);
            }
            this.error = b;
        },
        fit: function() {
            var a = this.points, b = a.length;
            return this.segments = b > 0 ? [ new A(a[0]) ] : [], b > 1 && this.fitCubic(0, b - 1, a[1].subtract(a[0]).normalize(), a[b - 2].subtract(a[b - 1]).normalize()), 
            this.segments;
        },
        fitCubic: function(a, b, c, d) {
            if (b - a == 1) {
                var e = this.points[a], f = this.points[b], g = e.getDistance(f) / 3;
                return void this.addCurve([ e, e.add(c.normalize(g)), f.add(d.normalize(g)), f ]);
            }
            for (var h, i = this.chordLengthParameterize(a, b), j = Math.max(this.error, this.error * this.error), k = 0; 4 >= k; k++) {
                var l = this.generateBezier(a, b, i, c, d), m = this.findMaxError(a, b, l, i);
                if (m.error < this.error) return void this.addCurve(l);
                if (h = m.index, m.error >= j) break;
                this.reparameterize(a, b, i, l), j = m.error;
            }
            var n = this.points[h - 1].subtract(this.points[h]), o = this.points[h].subtract(this.points[h + 1]), p = n.add(o).divide(2).normalize();
            this.fitCubic(a, h, c, p), this.fitCubic(h, b, p.negate(), d);
        },
        addCurve: function(a) {
            var b = this.segments[this.segments.length - 1];
            b.setHandleOut(a[1].subtract(a[0])), this.segments.push(new A(a[3], a[2].subtract(a[3])));
        },
        generateBezier: function(a, b, c, d, e) {
            for (var f = 1e-11, g = this.points[a], h = this.points[b], i = [ [ 0, 0 ], [ 0, 0 ] ], j = [ 0, 0 ], k = 0, l = b - a + 1; l > k; k++) {
                var m = c[k], n = 1 - m, o = 3 * m * n, p = n * n * n, q = o * n, r = o * m, s = m * m * m, t = d.normalize(q), u = e.normalize(r), v = this.points[a + k].subtract(g.multiply(p + q)).subtract(h.multiply(r + s));
                i[0][0] += t.dot(t), i[0][1] += t.dot(u), i[1][0] = i[0][1], i[1][1] += u.dot(u), 
                j[0] += t.dot(v), j[1] += u.dot(v);
            }
            var w, x, y = i[0][0] * i[1][1] - i[1][0] * i[0][1];
            if (Math.abs(y) > f) {
                var z = i[0][0] * j[1] - i[1][0] * j[0], A = j[0] * i[1][1] - j[1] * i[0][1];
                w = A / y, x = z / y;
            } else {
                var B = i[0][0] + i[0][1], C = i[1][0] + i[1][1];
                w = x = Math.abs(B) > f ? j[0] / B : Math.abs(C) > f ? j[1] / C : 0;
            }
            var D = h.getDistance(g);
            return f *= D, (f > w || f > x) && (w = x = D / 3), [ g, g.add(d.normalize(w)), h.add(e.normalize(x)), h ];
        },
        reparameterize: function(a, b, c, d) {
            for (var e = a; b >= e; e++) c[e - a] = this.findRoot(d, this.points[e], c[e - a]);
        },
        findRoot: function(a, b, c) {
            for (var d = [], e = [], f = 0; 2 >= f; f++) d[f] = a[f + 1].subtract(a[f]).multiply(3);
            for (var f = 0; 1 >= f; f++) e[f] = d[f + 1].subtract(d[f]).multiply(2);
            var g = this.evaluate(3, a, c), h = this.evaluate(2, d, c), i = this.evaluate(1, e, c), j = g.subtract(b), k = h.dot(h) + j.dot(i);
            return Math.abs(k) < 1e-5 ? c : c - j.dot(h) / k;
        },
        evaluate: function(a, b, c) {
            for (var d = b.slice(), e = 1; a >= e; e++) for (var f = 0; a - e >= f; f++) d[f] = d[f].multiply(1 - c).add(d[f + 1].multiply(c));
            return d[0];
        },
        chordLengthParameterize: function(a, b) {
            for (var c = [ 0 ], d = a + 1; b >= d; d++) c[d - a] = c[d - a - 1] + this.points[d].getDistance(this.points[d - 1]);
            for (var d = 1, e = b - a; e >= d; d++) c[d] /= c[e];
            return c;
        },
        findMaxError: function(a, b, c, d) {
            for (var e = Math.floor((b - a + 1) / 2), f = 0, g = a + 1; b > g; g++) {
                var h = this.evaluate(3, c, d[g - a]), i = h.subtract(this.points[g]), j = i.x * i.x + i.y * i.y;
                j >= f && (f = j, e = g);
            }
            return {
                error: f,
                index: e
            };
        }
    }), J = t.extend({
        _class: "TextItem",
        _boundsSelected: !0,
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _serializeFields: {
            content: null
        },
        _boundsGetter: "getBounds",
        initialize: function(c) {
            this._content = "", this._lines = [];
            var d = c && b.isPlainObject(c) && c.x === a && c.y === a;
            this._initialize(d && c, !d && h.read(arguments));
        },
        _equals: function(a) {
            return this._content === a._content;
        },
        _clone: function ub(a) {
            return a.setContent(this._content), ub.base.call(this, a);
        },
        getContent: function() {
            return this._content;
        },
        setContent: function(a) {
            this._content = "" + a, this._lines = this._content.split(/\r\n|\n|\r/gm), this._changed(265);
        },
        isEmpty: function() {
            return !this._content;
        },
        getCharacterStyle: "#getStyle",
        setCharacterStyle: "#setStyle",
        getParagraphStyle: "#getStyle",
        setParagraphStyle: "#setStyle"
    }), K = J.extend({
        _class: "PointText",
        initialize: function() {
            J.apply(this, arguments);
        },
        clone: function(a) {
            return this._clone(new K(t.NO_INSERT), a);
        },
        getPoint: function() {
            var a = this._matrix.getTranslation();
            return new j(a.x, a.y, this, "setPoint");
        },
        setPoint: function() {
            var a = h.read(arguments);
            this.translate(a.subtract(this._matrix.getTranslation()));
        },
        _draw: function(a) {
            if (this._content) {
                this._setStyles(a);
                var b = this._style, c = this._lines, d = b.getLeading(), e = a.shadowColor;
                a.font = b.getFontStyle(), a.textAlign = b.getJustification();
                for (var f = 0, g = c.length; g > f; f++) {
                    a.shadowColor = e;
                    var h = c[f];
                    b.hasFill() && (a.fillText(h, 0, 0), a.shadowColor = "rgba(0,0,0,0)"), b.hasStroke() && a.strokeText(h, 0, 0), 
                    a.translate(0, d);
                }
            }
        },
        _getBounds: function(a, b) {
            var c = this._style, d = this._lines, e = d.length, f = c.getJustification(), g = c.getLeading(), h = this.getView().getTextWidth(c.getFontStyle(), d), i = 0;
            "left" !== f && (i -= h / ("center" === f ? 2 : 1));
            var j = new n(i, e ? -.75 * g : 0, h, e * g);
            return b ? b._transformBounds(j, j) : j;
        }
    }), L = b.extend(new function() {
        function a(a) {
            var b, d = a.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/);
            if (d) {
                b = [ 0, 0, 0 ];
                for (var e = 0; 3 > e; e++) {
                    var f = d[e + 1];
                    b[e] = parseInt(1 == f.length ? f + f : f, 16) / 255;
                }
            } else if (d = a.match(/^rgba?\((.*)\)$/)) {
                b = d[1].split(",");
                for (var e = 0, h = b.length; h > e; e++) {
                    var f = +b[e];
                    b[e] = 3 > e ? f / 255 : f;
                }
            } else {
                var i = g[a];
                if (!i) {
                    c || (c = Z.getContext(1, 1), c.globalCompositeOperation = "copy"), c.fillStyle = "rgba(0,0,0,0)", 
                    c.fillStyle = a, c.fillRect(0, 0, 1, 1);
                    var j = c.getImageData(0, 0, 1, 1).data;
                    i = g[a] = [ j[0] / 255, j[1] / 255, j[2] / 255 ];
                }
                b = i.slice();
            }
            return b;
        }
        var c, d = {
            gray: [ "gray" ],
            rgb: [ "red", "green", "blue" ],
            hsb: [ "hue", "saturation", "brightness" ],
            hsl: [ "hue", "saturation", "lightness" ],
            gradient: [ "gradient", "origin", "destination", "highlight" ]
        }, e = {}, g = {}, i = [ [ 0, 3, 1 ], [ 2, 0, 1 ], [ 1, 0, 3 ], [ 1, 2, 0 ], [ 3, 1, 0 ], [ 0, 1, 2 ] ], j = {
            "rgb-hsb": function(a, b, c) {
                var d = Math.max(a, b, c), e = Math.min(a, b, c), f = d - e, g = 0 === f ? 0 : 60 * (d == a ? (b - c) / f + (c > b ? 6 : 0) : d == b ? (c - a) / f + 2 : (a - b) / f + 4);
                return [ g, 0 === d ? 0 : f / d, d ];
            },
            "hsb-rgb": function(a, b, c) {
                a = (a / 60 % 6 + 6) % 6;
                var d = Math.floor(a), e = a - d, d = i[d], f = [ c, c * (1 - b), c * (1 - b * e), c * (1 - b * (1 - e)) ];
                return [ f[d[0]], f[d[1]], f[d[2]] ];
            },
            "rgb-hsl": function(a, b, c) {
                var d = Math.max(a, b, c), e = Math.min(a, b, c), f = d - e, g = 0 === f, h = g ? 0 : 60 * (d == a ? (b - c) / f + (c > b ? 6 : 0) : d == b ? (c - a) / f + 2 : (a - b) / f + 4), i = (d + e) / 2, j = g ? 0 : .5 > i ? f / (d + e) : f / (2 - d - e);
                return [ h, j, i ];
            },
            "hsl-rgb": function(a, b, c) {
                if (a = (a / 360 % 1 + 1) % 1, 0 === b) return [ c, c, c ];
                for (var d = [ a + 1 / 3, a, a - 1 / 3 ], e = .5 > c ? c * (1 + b) : c + b - c * b, f = 2 * c - e, g = [], h = 0; 3 > h; h++) {
                    var i = d[h];
                    0 > i && (i += 1), i > 1 && (i -= 1), g[h] = 1 > 6 * i ? f + 6 * (e - f) * i : 1 > 2 * i ? e : 2 > 3 * i ? f + (e - f) * (2 / 3 - i) * 6 : f;
                }
                return g;
            },
            "rgb-gray": function(a, b, c) {
                return [ .2989 * a + .587 * b + .114 * c ];
            },
            "gray-rgb": function(a) {
                return [ a, a, a ];
            },
            "gray-hsb": function(a) {
                return [ 0, 0, a ];
            },
            "gray-hsl": function(a) {
                return [ 0, 0, a ];
            },
            "gradient-rgb": function() {
                return [];
            },
            "rgb-gradient": function() {
                return [];
            }
        };
        return b.each(d, function(a, c) {
            e[c] = [], b.each(a, function(a, f) {
                var g = b.capitalize(a), i = /^(hue|saturation)$/.test(a), j = e[c][f] = "gradient" === a ? function(a) {
                    var b = this._components[0];
                    return a = M.read(Array.isArray(a) ? a : arguments, 0, {
                        readNull: !0
                    }), b !== a && (b && b._removeOwner(this), a && a._addOwner(this)), a;
                } : "gradient" === c ? function() {
                    return h.read(arguments, 0, {
                        readNull: "highlight" === a,
                        clone: !0
                    });
                } : function(a) {
                    return null == a || isNaN(a) ? 0 : a;
                };
                this["get" + g] = function() {
                    return this._type === c || i && /^hs[bl]$/.test(this._type) ? this._components[f] : this._convert(c)[f];
                }, this["set" + g] = function(a) {
                    this._type === c || i && /^hs[bl]$/.test(this._type) || (this._components = this._convert(c), 
                    this._properties = d[c], this._type = c), a = j.call(this, a), null != a && (this._components[f] = a, 
                    this._changed());
                };
            }, this);
        }, {
            _class: "Color",
            _readIndex: !0,
            initialize: function k(b) {
                var c, f, g, h, i = Array.prototype.slice, j = arguments, l = 0;
                Array.isArray(b) && (j = b, b = j[0]);
                var m = null != b && typeof b;
                if ("string" === m && b in d && (c = b, b = j[1], Array.isArray(b) ? (f = b, g = j[2]) : (this.__read && (l = 1), 
                j = i.call(j, 1), m = typeof b)), !f) {
                    if (h = "number" === m ? j : "object" === m && null != b.length ? b : null) {
                        c || (c = h.length >= 3 ? "rgb" : "gray");
                        var n = d[c].length;
                        g = h[n], this.__read && (l += h === arguments ? n + (null != g ? 1 : 0) : 1), h.length > n && (h = i.call(h, 0, n));
                    } else if ("string" === m) c = "rgb", f = a(b), 4 === f.length && (g = f[3], f.length--); else if ("object" === m) if (b.constructor === k) {
                        if (c = b._type, f = b._components.slice(), g = b._alpha, "gradient" === c) for (var o = 1, p = f.length; p > o; o++) {
                            var q = f[o];
                            q && (f[o] = q.clone());
                        }
                    } else if (b.constructor === M) c = "gradient", h = j; else {
                        c = "hue" in b ? "lightness" in b ? "hsl" : "hsb" : "gradient" in b || "stops" in b || "radial" in b ? "gradient" : "gray" in b ? "gray" : "rgb";
                        var r = d[c];
                        t = e[c], this._components = f = [];
                        for (var o = 0, p = r.length; p > o; o++) {
                            var s = b[r[o]];
                            null == s && 0 === o && "gradient" === c && "stops" in b && (s = {
                                stops: b.stops,
                                radial: b.radial
                            }), s = t[o].call(this, s), null != s && (f[o] = s);
                        }
                        g = b.alpha;
                    }
                    this.__read && c && (l = 1);
                }
                if (this._type = c || "rgb", "gradient" === c && (this._id = k._id = (k._id || 0) + 1), 
                !f) {
                    this._components = f = [];
                    for (var t = e[this._type], o = 0, p = t.length; p > o; o++) {
                        var s = t[o].call(this, h && h[o]);
                        null != s && (f[o] = s);
                    }
                }
                this._components = f, this._properties = d[this._type], this._alpha = g, this.__read && (this.__read = l);
            },
            _serialize: function(a, c) {
                var d = this.getComponents();
                return b.serialize(/^(gray|rgb)$/.test(this._type) ? d : [ this._type ].concat(d), a, !0, c);
            },
            _changed: function() {
                this._canvasStyle = null, this._owner && this._owner._changed(65);
            },
            _convert: function(a) {
                var b;
                return this._type === a ? this._components.slice() : (b = j[this._type + "-" + a]) ? b.apply(this, this._components) : j["rgb-" + a].apply(this, j[this._type + "-rgb"].apply(this, this._components));
            },
            convert: function(a) {
                return new L(a, this._convert(a), this._alpha);
            },
            getType: function() {
                return this._type;
            },
            setType: function(a) {
                this._components = this._convert(a), this._properties = d[a], this._type = a;
            },
            getComponents: function() {
                var a = this._components.slice();
                return null != this._alpha && a.push(this._alpha), a;
            },
            getAlpha: function() {
                return null != this._alpha ? this._alpha : 1;
            },
            setAlpha: function(a) {
                this._alpha = null == a ? null : Math.min(Math.max(a, 0), 1), this._changed();
            },
            hasAlpha: function() {
                return null != this._alpha;
            },
            equals: function(a) {
                var c = b.isPlainValue(a, !0) ? L.read(arguments) : a;
                return c === this || c && this._class === c._class && this._type === c._type && this._alpha === c._alpha && b.equals(this._components, c._components) || !1;
            },
            toString: function() {
                for (var a = this._properties, b = [], c = "gradient" === this._type, d = f.instance, e = 0, g = a.length; g > e; e++) {
                    var h = this._components[e];
                    null != h && b.push(a[e] + ": " + (c ? h : d.number(h)));
                }
                return null != this._alpha && b.push("alpha: " + d.number(this._alpha)), "{ " + b.join(", ") + " }";
            },
            toCSS: function(a) {
                function b(a) {
                    return Math.round(255 * (0 > a ? 0 : a > 1 ? 1 : a));
                }
                var c = this._convert("rgb"), d = a || null == this._alpha ? 1 : this._alpha;
                return c = [ b(c[0]), b(c[1]), b(c[2]) ], 1 > d && c.push(0 > d ? 0 : d), a ? "#" + ((1 << 24) + (c[0] << 16) + (c[1] << 8) + c[2]).toString(16).slice(1) : (4 == c.length ? "rgba(" : "rgb(") + c.join(",") + ")";
            },
            toCanvasStyle: function(a) {
                if (this._canvasStyle) return this._canvasStyle;
                if ("gradient" !== this._type) return this._canvasStyle = this.toCSS();
                var b, c = this._components, d = c[0], e = d._stops, f = c[1], g = c[2];
                if (d._radial) {
                    var h = g.getDistance(f), i = c[3];
                    if (i) {
                        var j = i.subtract(f);
                        j.getLength() > h && (i = f.add(j.normalize(h - .1)));
                    }
                    var k = i || f;
                    b = a.createRadialGradient(k.x, k.y, 0, f.x, f.y, h);
                } else b = a.createLinearGradient(f.x, f.y, g.x, g.y);
                for (var l = 0, m = e.length; m > l; l++) {
                    var n = e[l];
                    b.addColorStop(n._rampPoint, n._color.toCanvasStyle());
                }
                return this._canvasStyle = b;
            },
            transform: function(a) {
                if ("gradient" === this._type) {
                    for (var b = this._components, c = 1, d = b.length; d > c; c++) {
                        var e = b[c];
                        a._transformPoint(e, e, !0);
                    }
                    this._changed();
                }
            },
            statics: {
                _types: d,
                random: function() {
                    var a = Math.random;
                    return new L(a(), a(), a());
                }
            }
        });
    }(), new function() {
        var a = {
            add: function(a, b) {
                return a + b;
            },
            subtract: function(a, b) {
                return a - b;
            },
            multiply: function(a, b) {
                return a * b;
            },
            divide: function(a, b) {
                return a / b;
            }
        };
        return b.each(a, function(a, b) {
            this[b] = function(b) {
                b = L.read(arguments);
                for (var c = this._type, d = this._components, e = b._convert(c), f = 0, g = d.length; g > f; f++) e[f] = a(d[f], e[f]);
                return new L(c, e, null != this._alpha ? a(this._alpha, b.getAlpha()) : null);
            };
        }, {});
    }());
    b.each(L._types, function(a, c) {
        var d = this[b.capitalize(c) + "Color"] = function(a) {
            var b = null != a && typeof a, d = "object" === b && null != a.length ? a : "string" === b ? null : arguments;
            return d ? new L(c, d) : new L(a);
        };
        if (3 == c.length) {
            var e = c.toUpperCase();
            L[e] = this[e + "Color"] = d;
        }
    }, b.exports);
    var M = b.extend({
        _class: "Gradient",
        initialize: function vb(a, b) {
            this._id = vb._id = (vb._id || 0) + 1, a && this._set(a) && (a = b = null), this._stops || this.setStops(a || [ "white", "black" ]), 
            null == this._radial && this.setRadial("string" == typeof b && "radial" === b || b || !1);
        },
        _serialize: function(a, c) {
            return c.add(this, function() {
                return b.serialize([ this._stops, this._radial ], a, !0, c);
            });
        },
        _changed: function() {
            for (var a = 0, b = this._owners && this._owners.length; b > a; a++) this._owners[a]._changed();
        },
        _addOwner: function(a) {
            this._owners || (this._owners = []), this._owners.push(a);
        },
        _removeOwner: function(b) {
            var c = this._owners ? this._owners.indexOf(b) : -1;
            -1 != c && (this._owners.splice(c, 1), 0 === this._owners.length && (this._owners = a));
        },
        clone: function() {
            for (var a = [], b = 0, c = this._stops.length; c > b; b++) a[b] = this._stops[b].clone();
            return new M(a);
        },
        getStops: function() {
            return this._stops;
        },
        setStops: function(b) {
            if (this.stops) for (var c = 0, d = this._stops.length; d > c; c++) this._stops[c]._owner = a;
            if (b.length < 2) throw new Error("Gradient stop list needs to contain at least two stops.");
            this._stops = N.readAll(b, 0, {
                clone: !0
            });
            for (var c = 0, d = this._stops.length; d > c; c++) {
                var e = this._stops[c];
                e._owner = this, e._defaultRamp && e.setRampPoint(c / (d - 1));
            }
            this._changed();
        },
        getRadial: function() {
            return this._radial;
        },
        setRadial: function(a) {
            this._radial = a, this._changed();
        },
        equals: function(a) {
            if (a === this) return !0;
            if (a && this._class === a._class && this._stops.length === a._stops.length) {
                for (var b = 0, c = this._stops.length; c > b; b++) if (!this._stops[b].equals(a._stops[b])) return !1;
                return !0;
            }
            return !1;
        }
    }), N = b.extend({
        _class: "GradientStop",
        initialize: function(b, c) {
            if (b) {
                var d, e;
                c === a && Array.isArray(b) ? (d = b[0], e = b[1]) : b.color ? (d = b.color, e = b.rampPoint) : (d = b, 
                e = c), this.setColor(d), this.setRampPoint(e);
            }
        },
        clone: function() {
            return new N(this._color.clone(), this._rampPoint);
        },
        _serialize: function(a, c) {
            return b.serialize([ this._color, this._rampPoint ], a, !0, c);
        },
        _changed: function() {
            this._owner && this._owner._changed(65);
        },
        getRampPoint: function() {
            return this._rampPoint;
        },
        setRampPoint: function(a) {
            this._defaultRamp = null == a, this._rampPoint = a || 0, this._changed();
        },
        getColor: function() {
            return this._color;
        },
        setColor: function(a) {
            this._color = L.read(arguments), this._color === a && (this._color = a.clone()), 
            this._color._owner = this, this._changed();
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && this._color.equals(a._color) && this._rampPoint == a._rampPoint || !1;
        }
    }), O = b.extend(new function() {
        var c = {
            fillColor: a,
            strokeColor: a,
            strokeWidth: 1,
            strokeCap: "butt",
            strokeJoin: "miter",
            strokeScaling: !0,
            miterLimit: 10,
            dashOffset: 0,
            dashArray: [],
            windingRule: "nonzero",
            shadowColor: a,
            shadowBlur: 0,
            shadowOffset: new h(),
            selectedColor: a,
            fontFamily: "sans-serif",
            fontWeight: "normal",
            fontSize: 12,
            font: "sans-serif",
            leading: null,
            justification: "left"
        }, d = {
            strokeWidth: 97,
            strokeCap: 97,
            strokeJoin: 97,
            strokeScaling: 105,
            miterLimit: 97,
            fontFamily: 9,
            fontWeight: 9,
            fontSize: 9,
            font: 9,
            leading: 9,
            justification: 9
        }, e = {
            beans: !0
        }, f = {
            _defaults: c,
            _textDefaults: new b(c, {
                fillColor: new L()
            }),
            beans: !0
        };
        return b.each(c, function(c, g) {
            var i = /Color$/.test(g), j = "shadowOffset" === g, k = b.capitalize(g), l = d[g], m = "set" + k, n = "get" + k;
            f[m] = function(b) {
                var c = this._owner, d = c && c._children;
                if (d && d.length > 0 && !(c instanceof G)) for (var e = 0, f = d.length; f > e; e++) d[e]._style[m](b); else {
                    var h = this._values[g];
                    h != b && (i && (h && (h._owner = a), b && b.constructor === L && (b._owner && (b = b.clone()), 
                    b._owner = c)), this._values[g] = b, c && c._changed(l || 65));
                }
            }, f[n] = function(c) {
                var d, e = this._owner, f = e && e._children;
                if (!f || 0 === f.length || c || e instanceof G) {
                    var d = this._values[g];
                    if (d === a) d = this._defaults[g], d && d.clone && (d = d.clone()), this._values[g] = d; else {
                        var k = i ? L : j ? h : null;
                        !k || d && d.constructor === k || (this._values[g] = d = k.read([ d ], 0, {
                            readNull: !0,
                            clone: !0
                        }), d && i && (d._owner = e));
                    }
                    return d;
                }
                for (var l = 0, m = f.length; m > l; l++) {
                    var o = f[l]._style[n]();
                    if (0 === l) d = o; else if (!b.equals(d, o)) return a;
                }
                return d;
            }, e[n] = function(a) {
                return this._style[n](a);
            }, e[m] = function(a) {
                this._style[m](a);
            };
        }), t.inject(e), f;
    }(), {
        _class: "Style",
        initialize: function(a, b, c) {
            this._values = {}, this._owner = b, this._project = b && b._project || c || paper.project, 
            b instanceof J && (this._defaults = this._textDefaults), a && this.set(a);
        },
        set: function(a) {
            var b = a instanceof O, c = b ? a._values : a;
            if (c) for (var d in c) if (d in this._defaults) {
                var e = c[d];
                this[d] = e && b && e.clone ? e.clone() : e;
            }
        },
        equals: function(a) {
            return a === this || a && this._class === a._class && b.equals(this._values, a._values) || !1;
        },
        hasFill: function() {
            return !!this.getFillColor();
        },
        hasStroke: function() {
            return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
        },
        hasShadow: function() {
            return !!this.getShadowColor() && this.getShadowBlur() > 0;
        },
        getView: function() {
            return this._project.getView();
        },
        getFontStyle: function() {
            var a = this.getFontSize();
            return this.getFontWeight() + " " + a + (/[a-z]/i.test(a + "") ? " " : "px ") + this.getFontFamily();
        },
        getFont: "#getFontFamily",
        setFont: "#setFontFamily",
        getLeading: function wb() {
            var a = wb.base.call(this), b = this.getFontSize();
            return /pt|em|%|px/.test(b) && (b = this.getView().getPixelSize(b)), null != a ? a : 1.2 * b;
        }
    }), P = new function() {
        function a(a, b, c, d) {
            for (var e = [ "", "webkit", "moz", "Moz", "ms", "o" ], f = b[0].toUpperCase() + b.substring(1), g = 0; 6 > g; g++) {
                var h = e[g], i = h ? h + f : b;
                if (i in a) {
                    if (!c) return a[i];
                    a[i] = d;
                    break;
                }
            }
        }
        return {
            getStyles: function(a) {
                var b = a && 9 !== a.nodeType ? a.ownerDocument : a, c = b && b.defaultView;
                return c && c.getComputedStyle(a, "");
            },
            getBounds: function(a, b) {
                var c, d = a.ownerDocument, e = d.body, f = d.documentElement;
                try {
                    c = a.getBoundingClientRect();
                } catch (g) {
                    c = {
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0
                    };
                }
                var h = c.left - (f.clientLeft || e.clientLeft || 0), i = c.top - (f.clientTop || e.clientTop || 0);
                if (!b) {
                    var j = d.defaultView;
                    h += j.pageXOffset || f.scrollLeft || e.scrollLeft, i += j.pageYOffset || f.scrollTop || e.scrollTop;
                }
                return new n(h, i, c.width, c.height);
            },
            getViewportBounds: function(a) {
                var b = a.ownerDocument, c = b.defaultView, d = b.documentElement;
                return new n(0, 0, c.innerWidth || d.clientWidth, c.innerHeight || d.clientHeight);
            },
            getOffset: function(a, b) {
                return P.getBounds(a, b).getPoint();
            },
            getSize: function(a) {
                return P.getBounds(a, !0).getSize();
            },
            isInvisible: function(a) {
                return P.getSize(a).equals(new k(0, 0));
            },
            isInView: function(a) {
                return !P.isInvisible(a) && P.getViewportBounds(a).intersects(P.getBounds(a, !0));
            },
            getPrefixed: function(b, c) {
                return a(b, c);
            },
            setPrefixed: function(b, c, d) {
                if ("object" == typeof c) for (var e in c) a(b, e, !0, c[e]); else a(b, c, !0, d);
            }
        };
    }(), Q = {
        add: function(a, b) {
            for (var c in b) for (var d = b[c], e = c.split(/[\s,]+/g), f = 0, g = e.length; g > f; f++) a.addEventListener(e[f], d, !1);
        },
        remove: function(a, b) {
            for (var c in b) for (var d = b[c], e = c.split(/[\s,]+/g), f = 0, g = e.length; g > f; f++) a.removeEventListener(e[f], d, !1);
        },
        getPoint: function(a) {
            var b = a.targetTouches ? a.targetTouches.length ? a.targetTouches[0] : a.changedTouches[0] : a;
            return new h(b.pageX || b.clientX + document.documentElement.scrollLeft, b.pageY || b.clientY + document.documentElement.scrollTop);
        },
        getTarget: function(a) {
            return a.target || a.srcElement;
        },
        getRelatedTarget: function(a) {
            return a.relatedTarget || a.toElement;
        },
        getOffset: function(a, b) {
            return Q.getPoint(a).subtract(P.getOffset(b || Q.getTarget(a)));
        },
        stop: function(a) {
            a.stopPropagation(), a.preventDefault();
        }
    };
    Q.requestAnimationFrame = new function() {
        function a() {
            for (var b = f.length - 1; b >= 0; b--) {
                var h = f[b], i = h[0], j = h[1];
                (!j || ("true" == d.getAttribute(j, "keepalive") || g) && P.isInView(j)) && (f.splice(b, 1), 
                i());
            }
            c && (f.length ? c(a) : e = !1);
        }
        var b, c = P.getPrefixed(window, "requestAnimationFrame"), e = !1, f = [], g = !0;
        return Q.add(window, {
            focus: function() {
                g = !0;
            },
            blur: function() {
                g = !1;
            }
        }), function(d, g) {
            f.push([ d, g ]), c ? e || (c(a), e = !0) : b || (b = setInterval(a, 1e3 / 60));
        };
    }();
    var R = b.extend(c, {
        _class: "View",
        initialize: function xb(a, b) {
            this._project = a, this._scope = a._scope, this._element = b;
            var c;
            this._pixelRatio || (this._pixelRatio = window.devicePixelRatio || 1), this._id = b.getAttribute("id"), 
            null == this._id && b.setAttribute("id", this._id = "view-" + xb._id++), Q.add(b, this._viewEvents);
            var e = "none";
            if (P.setPrefixed(b.style, {
                userSelect: e,
                touchAction: e,
                touchCallout: e,
                contentZooming: e,
                userDrag: e,
                tapHighlightColor: "rgba(0,0,0,0)"
            }), d.hasAttribute(b, "resize")) {
                var f = P.getOffset(b, !0), g = this;
                c = P.getViewportBounds(b).getSize().subtract(f), this._windowEvents = {
                    resize: function() {
                        P.isInvisible(b) || (f = P.getOffset(b, !0)), g.setViewSize(P.getViewportBounds(b).getSize().subtract(f));
                    }
                }, Q.add(window, this._windowEvents);
            } else if (c = P.getSize(b), c.isNaN() || c.isZero()) {
                var h = function(a) {
                    return b[a] || parseInt(b.getAttribute(a), 10);
                };
                c = new k(h("width"), h("height"));
            }
            if (this._setViewSize(c), d.hasAttribute(b, "stats") && "undefined" != typeof Stats) {
                this._stats = new Stats();
                var i = this._stats.domElement, j = i.style, f = P.getOffset(b);
                j.position = "absolute", j.left = f.x + "px", j.top = f.y + "px", document.body.appendChild(i);
            }
            xb._views.push(this), xb._viewsById[this._id] = this, this._viewSize = c, (this._matrix = new p())._owner = this, 
            this._zoom = 1, xb._focused || (xb._focused = this), this._frameItems = {}, this._frameItemCount = 0;
        },
        remove: function() {
            return this._project ? (R._focused === this && (R._focused = null), R._views.splice(R._views.indexOf(this), 1), 
            delete R._viewsById[this._id], this._project._view === this && (this._project._view = null), 
            Q.remove(this._element, this._viewEvents), Q.remove(window, this._windowEvents), 
            this._element = this._project = null, this.off("frame"), this._animate = !1, this._frameItems = {}, 
            !0) : !1;
        },
        _events: {
            onFrame: {
                install: function() {
                    this.play();
                },
                uninstall: function() {
                    this.pause();
                }
            },
            onResize: {}
        },
        _animate: !1,
        _time: 0,
        _count: 0,
        _requestFrame: function() {
            var a = this;
            Q.requestAnimationFrame(function() {
                a._requested = !1, a._animate && (a._requestFrame(), a._handleFrame());
            }, this._element), this._requested = !0;
        },
        _handleFrame: function() {
            paper = this._scope;
            var a = Date.now() / 1e3, c = this._before ? a - this._before : 0;
            this._before = a, this._handlingFrame = !0, this.emit("frame", new b({
                delta: c,
                time: this._time += c,
                count: this._count++
            })), this._stats && this._stats.update(), this._handlingFrame = !1, this.update();
        },
        _animateItem: function(a, b) {
            var c = this._frameItems;
            b ? (c[a._id] = {
                item: a,
                time: 0,
                count: 0
            }, 1 === ++this._frameItemCount && this.on("frame", this._handleFrameItems)) : (delete c[a._id], 
            0 === --this._frameItemCount && this.off("frame", this._handleFrameItems));
        },
        _handleFrameItems: function(a) {
            for (var c in this._frameItems) {
                var d = this._frameItems[c];
                d.item.emit("frame", new b(a, {
                    time: d.time += a.delta,
                    count: d.count++
                }));
            }
        },
        _update: function() {
            this._project._needsUpdate = !0, this._handlingFrame || (this._animate ? this._handleFrame() : this.update());
        },
        _changed: function(a) {
            1 & a && (this._project._needsUpdate = !0);
        },
        _transform: function(a) {
            this._matrix.concatenate(a), this._bounds = null, this._update();
        },
        getElement: function() {
            return this._element;
        },
        getPixelRatio: function() {
            return this._pixelRatio;
        },
        getResolution: function() {
            return 72 * this._pixelRatio;
        },
        getViewSize: function() {
            var a = this._viewSize;
            return new m(a.width, a.height, this, "setViewSize");
        },
        setViewSize: function() {
            var a = k.read(arguments), b = a.subtract(this._viewSize);
            b.isZero() || (this._viewSize.set(a.width, a.height), this._setViewSize(a), this._bounds = null, 
            this.emit("resize", {
                size: a,
                delta: b
            }), this._update());
        },
        _setViewSize: function(a) {
            var b = this._element;
            b.width = a.width, b.height = a.height;
        },
        getBounds: function() {
            return this._bounds || (this._bounds = this._matrix.inverted()._transformBounds(new n(new h(), this._viewSize))), 
            this._bounds;
        },
        getSize: function() {
            return this.getBounds().getSize();
        },
        getCenter: function() {
            return this.getBounds().getCenter();
        },
        setCenter: function() {
            var a = h.read(arguments);
            this.scrollBy(a.subtract(this.getCenter()));
        },
        getZoom: function() {
            return this._zoom;
        },
        setZoom: function(a) {
            this._transform(new p().scale(a / this._zoom, this.getCenter())), this._zoom = a;
        },
        isVisible: function() {
            return P.isInView(this._element);
        },
        scrollBy: function() {
            this._transform(new p().translate(h.read(arguments).negate()));
        },
        play: function() {
            this._animate = !0, this._requested || this._requestFrame();
        },
        pause: function() {
            this._animate = !1;
        },
        draw: function() {
            this.update();
        },
        projectToView: function() {
            return this._matrix._transformPoint(h.read(arguments));
        },
        viewToProject: function() {
            return this._matrix._inverseTransform(h.read(arguments));
        }
    }, {
        statics: {
            _views: [],
            _viewsById: {},
            _id: 0,
            create: function(a, b) {
                return "string" == typeof b && (b = document.getElementById(b)), new S(a, b);
            }
        }
    }, new function() {
        function a(a) {
            var b = Q.getTarget(a);
            return b.getAttribute && R._viewsById[b.getAttribute("id")];
        }
        function b(a, b) {
            return a.viewToProject(Q.getOffset(b, a._element));
        }
        function c() {
            if (!R._focused || !R._focused.isVisible()) for (var a = 0, b = R._views.length; b > a; a++) {
                var c = R._views[a];
                if (c && c.isVisible()) {
                    R._focused = g = c;
                    break;
                }
            }
        }
        function d(a, b, c) {
            a._handleEvent("mousemove", b, c);
            var d = a._scope.tool;
            return d && d._handleEvent(k && d.responds("mousedrag") ? "mousedrag" : "mousemove", b, c), 
            a.update(), d;
        }
        var e, f, g, h, i, j, k = !1, l = window.navigator;
        l.pointerEnabled || l.msPointerEnabled ? (h = "pointerdown MSPointerDown", i = "pointermove MSPointerMove", 
        j = "pointerup pointercancel MSPointerUp MSPointerCancel") : (h = "touchstart", 
        i = "touchmove", j = "touchend touchcancel", "ontouchstart" in window && l.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i) || (h += " mousedown", 
        i += " mousemove", j += " mouseup"));
        var m = {
            "selectstart dragstart": function(a) {
                k && a.preventDefault();
            }
        }, n = {
            mouseout: function(a) {
                var c = R._focused, e = Q.getRelatedTarget(a);
                !c || e && "HTML" !== e.nodeName || d(c, b(c, a), a);
            },
            scroll: c
        };
        return m[h] = function(c) {
            var d = R._focused = a(c), f = b(d, c);
            k = !0, d._handleEvent("mousedown", f, c), (e = d._scope.tool) && e._handleEvent("mousedown", f, c), 
            d.update();
        }, n[i] = function(h) {
            var i = R._focused;
            if (!k) {
                var j = a(h);
                j ? (i !== j && d(i, b(i, h), h), f = i, i = R._focused = g = j) : g && g === i && (i = R._focused = f, 
                c());
            }
            if (i) {
                var l = b(i, h);
                (k || i.getBounds().contains(l)) && (e = d(i, l, h));
            }
        }, n[j] = function(a) {
            var c = R._focused;
            if (c && k) {
                var d = b(c, a);
                k = !1, c._handleEvent("mouseup", d, a), e && e._handleEvent("mouseup", d, a), c.update();
            }
        }, Q.add(document, n), Q.add(window, {
            load: c
        }), {
            _viewEvents: m,
            _handleEvent: function() {},
            statics: {
                updateFocus: c
            }
        };
    }()), S = R.extend({
        _class: "CanvasView",
        initialize: function(a, b) {
            if (!(b instanceof HTMLCanvasElement)) {
                var c = k.read(arguments);
                if (c.isZero()) throw new Error("Cannot create CanvasView with the provided argument: " + [].slice.call(arguments, 1));
                b = Z.getCanvas(c);
            }
            if (this._context = b.getContext("2d"), this._eventCounters = {}, this._pixelRatio = 1, 
            !/^off|false$/.test(d.getAttribute(b, "hidpi"))) {
                var e = window.devicePixelRatio || 1, f = P.getPrefixed(this._context, "backingStorePixelRatio") || 1;
                this._pixelRatio = e / f;
            }
            R.call(this, a, b);
        },
        _setViewSize: function(a) {
            var b = a.width, c = a.height, d = this._pixelRatio, e = this._element, f = e.style;
            e.width = b * d, e.height = c * d, 1 !== d && (f.width = b + "px", f.height = c + "px", 
            this._context.scale(d, d));
        },
        getPixelSize: function(a) {
            var b = this._context, c = b.font;
            return b.font = a + " serif", a = parseFloat(b.font), b.font = c, a;
        },
        getTextWidth: function(a, b) {
            var c = this._context, d = c.font, e = 0;
            c.font = a;
            for (var f = 0, g = b.length; g > f; f++) e = Math.max(e, c.measureText(b[f]).width);
            return c.font = d, e;
        },
        update: function() {
            var a = this._project;
            if (!a || !a._needsUpdate) return !1;
            var b = this._context, c = this._viewSize;
            return b.clearRect(0, 0, c.width + 1, c.height + 1), a.draw(b, this._matrix, this._pixelRatio), 
            a._needsUpdate = !1, !0;
        }
    }, new function() {
        function a(a, b, c, d, e, f) {
            function g(a) {
                return a.responds(b) && (h || (h = new W(b, c, d, e, f ? d.subtract(f) : null)), 
                a.emit(b, h) && h.isStopped) ? (c.preventDefault(), !0) : void 0;
            }
            for (var h, i = e; i; ) {
                if (g(i)) return !0;
                i = i.getParent();
            }
            return g(a) ? !0 : !1;
        }
        var b, c, d, e, f, g, h, i, j;
        return {
            _handleEvent: function(k, l, m) {
                if (this._eventCounters[k]) {
                    var n = this._project, o = n.hitTest(l, {
                        tolerance: 0,
                        fill: !0,
                        stroke: !0
                    }), p = o && o.item, q = !1;
                    switch (k) {
                      case "mousedown":
                        for (q = a(this, k, m, l, p), i = f == p && Date.now() - j < 300, e = f = p, b = c = d = l, 
                        h = !q && p; h && !h.responds("mousedrag"); ) h = h._parent;
                        break;

                      case "mouseup":
                        q = a(this, k, m, l, p, b), h && (c && !c.equals(l) && a(this, "mousedrag", m, l, h, c), 
                        p !== h && (d = l, a(this, "mousemove", m, l, p, d))), !q && p && p === e && (j = Date.now(), 
                        a(this, i && e.responds("doubleclick") ? "doubleclick" : "click", m, b, p), i = !1), 
                        e = h = null;
                        break;

                      case "mousemove":
                        h && (q = a(this, "mousedrag", m, l, h, c)), q || (p !== g && (d = l), q = a(this, k, m, l, p, d)), 
                        c = d = l, p !== g && (a(this, "mouseleave", m, l, g), g = p, a(this, "mouseenter", m, l, p));
                    }
                    return q;
                }
            }
        };
    }()), T = b.extend({
        _class: "Event",
        initialize: function(a) {
            this.event = a;
        },
        isPrevented: !1,
        isStopped: !1,
        preventDefault: function() {
            this.isPrevented = !0, this.event.preventDefault();
        },
        stopPropagation: function() {
            this.isStopped = !0, this.event.stopPropagation();
        },
        stop: function() {
            this.stopPropagation(), this.preventDefault();
        },
        getModifiers: function() {
            return V.modifiers;
        }
    }), U = T.extend({
        _class: "KeyEvent",
        initialize: function(a, b, c, d) {
            T.call(this, d), this.type = a ? "keydown" : "keyup", this.key = b, this.character = c;
        },
        toString: function() {
            return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
        }
    }), V = new function() {
        function a(a, c, e, i) {
            var j, k = e ? String.fromCharCode(e) : "", l = d[c], m = l || k.toLowerCase(), n = a ? "keydown" : "keyup", o = R._focused, p = o && o.isVisible() && o._scope, q = p && p.tool;
            h[m] = a, l && (j = b.camelize(l)) in f && (f[j] = a), a ? g[c] = e : delete g[c], 
            q && q.responds(n) && (paper = p, q.emit(n, new U(a, m, k, i)), o && o.update());
        }
        var c, d = {
            8: "backspace",
            9: "tab",
            13: "enter",
            16: "shift",
            17: "control",
            18: "option",
            19: "pause",
            20: "caps-lock",
            27: "escape",
            32: "space",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            46: "delete",
            91: "command",
            93: "command",
            224: "command"
        }, e = {
            9: !0,
            13: !0,
            32: !0
        }, f = new b({
            shift: !1,
            control: !1,
            option: !1,
            command: !1,
            capsLock: !1,
            space: !1
        }), g = {}, h = {};
        return Q.add(document, {
            keydown: function(b) {
                var g = b.which || b.keyCode;
                g in d || f.command ? a(!0, g, g in e || f.command ? g : 0, b) : c = g;
            },
            keypress: function(b) {
                null != c && (a(!0, c, b.which || b.keyCode, b), c = null);
            },
            keyup: function(b) {
                var c = b.which || b.keyCode;
                c in g && a(!1, c, g[c], b);
            }
        }), Q.add(window, {
            blur: function(b) {
                for (var c in g) a(!1, c, g[c], b);
            }
        }), {
            modifiers: f,
            isDown: function(a) {
                return !!h[a];
            }
        };
    }(), W = T.extend({
        _class: "MouseEvent",
        initialize: function(a, b, c, d, e) {
            T.call(this, b), this.type = a, this.point = c, this.target = d, this.delta = e;
        },
        toString: function() {
            return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }";
        }
    }), X = T.extend({
        _class: "ToolEvent",
        _item: null,
        initialize: function(a, b, c) {
            this.tool = a, this.type = b, this.event = c;
        },
        _choosePoint: function(a, b) {
            return a ? a : b ? b.clone() : null;
        },
        getPoint: function() {
            return this._choosePoint(this._point, this.tool._point);
        },
        setPoint: function(a) {
            this._point = a;
        },
        getLastPoint: function() {
            return this._choosePoint(this._lastPoint, this.tool._lastPoint);
        },
        setLastPoint: function(a) {
            this._lastPoint = a;
        },
        getDownPoint: function() {
            return this._choosePoint(this._downPoint, this.tool._downPoint);
        },
        setDownPoint: function(a) {
            this._downPoint = a;
        },
        getMiddlePoint: function() {
            return !this._middlePoint && this.tool._lastPoint ? this.tool._point.add(this.tool._lastPoint).divide(2) : this._middlePoint;
        },
        setMiddlePoint: function(a) {
            this._middlePoint = a;
        },
        getDelta: function() {
            return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
        },
        setDelta: function(a) {
            this._delta = a;
        },
        getCount: function() {
            return /^mouse(down|up)$/.test(this.type) ? this.tool._downCount : this.tool._count;
        },
        setCount: function(a) {
            this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = a;
        },
        getItem: function() {
            if (!this._item) {
                var a = this.tool._scope.project.hitTest(this.getPoint());
                if (a) {
                    for (var b = a.item, c = b._parent; /^(Group|CompoundPath)$/.test(c._class); ) b = c, 
                    c = c._parent;
                    this._item = b;
                }
            }
            return this._item;
        },
        setItem: function(a) {
            this._item = a;
        },
        toString: function() {
            return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }";
        }
    }), Y = (e.extend({
        _class: "Tool",
        _list: "tools",
        _reference: "tool",
        _events: [ "onActivate", "onDeactivate", "onEditOptions", "onMouseDown", "onMouseUp", "onMouseDrag", "onMouseMove", "onKeyDown", "onKeyUp" ],
        initialize: function(a) {
            e.call(this), this._firstMove = !0, this._count = 0, this._downCount = 0, this._set(a);
        },
        getMinDistance: function() {
            return this._minDistance;
        },
        setMinDistance: function(a) {
            this._minDistance = a, null != this._minDistance && null != this._maxDistance && this._minDistance > this._maxDistance && (this._maxDistance = this._minDistance);
        },
        getMaxDistance: function() {
            return this._maxDistance;
        },
        setMaxDistance: function(a) {
            this._maxDistance = a, null != this._minDistance && null != this._maxDistance && this._maxDistance < this._minDistance && (this._minDistance = a);
        },
        getFixedDistance: function() {
            return this._minDistance == this._maxDistance ? this._minDistance : null;
        },
        setFixedDistance: function(a) {
            this._minDistance = a, this._maxDistance = a;
        },
        _updateEvent: function(a, b, c, d, e, f, g) {
            if (!e) {
                if (null != c || null != d) {
                    var h = null != c ? c : 0, i = b.subtract(this._point), j = i.getLength();
                    if (h > j) return !1;
                    var k = null != d ? d : 0;
                    if (0 != k) if (j > k) b = this._point.add(i.normalize(k)); else if (g) return !1;
                }
                if (f && b.equals(this._point)) return !1;
            }
            switch (this._lastPoint = e && "mousemove" == a ? b : this._point, this._point = b, 
            a) {
              case "mousedown":
                this._lastPoint = this._downPoint, this._downPoint = this._point, this._downCount++;
                break;

              case "mouseup":
                this._lastPoint = this._downPoint;
            }
            return this._count = e ? 0 : this._count + 1, !0;
        },
        _fireEvent: function(a, b) {
            var c = paper.project._removeSets;
            if (c) {
                "mouseup" === a && (c.mousedrag = null);
                var d = c[a];
                if (d) {
                    for (var e in d) {
                        var f = d[e];
                        for (var g in c) {
                            var h = c[g];
                            h && h != d && delete h[f._id];
                        }
                        f.remove();
                    }
                    c[a] = null;
                }
            }
            return this.responds(a) && this.emit(a, new X(this, a, b));
        },
        _handleEvent: function(a, b, c) {
            paper = this._scope;
            var d = !1;
            switch (a) {
              case "mousedown":
                this._updateEvent(a, b, null, null, !0, !1, !1), d = this._fireEvent(a, c);
                break;

              case "mousedrag":
                for (var e = !1, f = !1; this._updateEvent(a, b, this.minDistance, this.maxDistance, !1, e, f); ) d = this._fireEvent(a, c) || d, 
                e = !0, f = !0;
                break;

              case "mouseup":
                !b.equals(this._point) && this._updateEvent("mousedrag", b, this.minDistance, this.maxDistance, !1, !1, !1) && (d = this._fireEvent("mousedrag", c)), 
                this._updateEvent(a, b, null, this.maxDistance, !1, !1, !1), d = this._fireEvent(a, c) || d, 
                this._updateEvent(a, b, null, null, !0, !1, !1), this._firstMove = !0;
                break;

              case "mousemove":
                for (;this._updateEvent(a, b, this.minDistance, this.maxDistance, this._firstMove, !0, !1); ) d = this._fireEvent(a, c) || d, 
                this._firstMove = !1;
            }
            return d && c.preventDefault(), d;
        }
    }), {
        request: function(a, b, c) {
            var d = new (window.ActiveXObject || XMLHttpRequest)("Microsoft.XMLHTTP");
            return d.open(a.toUpperCase(), b, !0), "overrideMimeType" in d && d.overrideMimeType("text/plain"), 
            d.onreadystatechange = function() {
                if (4 === d.readyState) {
                    var a = d.status;
                    if (0 !== a && 200 !== a) throw new Error("Could not load " + b + " (Error " + a + ")");
                    c.call(d, d.responseText);
                }
            }, d.send(null);
        }
    }), Z = {
        canvases: [],
        getCanvas: function(a, b) {
            var c, d = !0;
            "object" == typeof a && (b = a.height, a = a.width), c = this.canvases.length ? this.canvases.pop() : document.createElement("canvas");
            var e = c.getContext("2d");
            return c.width === a && c.height === b ? d && e.clearRect(0, 0, a + 1, b + 1) : (c.width = a, 
            c.height = b), e.save(), c;
        },
        getContext: function(a, b) {
            return this.getCanvas(a, b).getContext("2d");
        },
        release: function(a) {
            var b = a.canvas ? a.canvas : a;
            b.getContext("2d").restore(), this.canvases.push(b);
        }
    }, $ = new function() {
        function a(a, b, c) {
            return .2989 * a + .587 * b + .114 * c;
        }
        function c(b, c, d, e) {
            var f = e - a(b, c, d);
            n = b + f, o = c + f, p = d + f;
            var e = a(n, o, p), g = q(n, o, p), h = r(n, o, p);
            if (0 > g) {
                var i = e - g;
                n = e + (n - e) * e / i, o = e + (o - e) * e / i, p = e + (p - e) * e / i;
            }
            if (h > 255) {
                var j = 255 - e, k = h - e;
                n = e + (n - e) * j / k, o = e + (o - e) * j / k, p = e + (p - e) * j / k;
            }
        }
        function d(a, b, c) {
            return r(a, b, c) - q(a, b, c);
        }
        function e(a, b, c, d) {
            var e, f = [ a, b, c ], g = r(a, b, c), h = q(a, b, c);
            h = h === a ? 0 : h === b ? 1 : 2, g = g === a ? 0 : g === b ? 1 : 2, e = 0 === q(h, g) ? 1 === r(h, g) ? 2 : 1 : 0, 
            f[g] > f[h] ? (f[e] = (f[e] - f[h]) * d / (f[g] - f[h]), f[g] = d) : f[e] = f[g] = 0, 
            f[h] = 0, n = f[0], o = f[1], p = f[2];
        }
        var f, g, h, i, j, k, l, m, n, o, p, q = Math.min, r = Math.max, s = Math.abs, t = {
            multiply: function() {
                n = j * f / 255, o = k * g / 255, p = l * h / 255;
            },
            screen: function() {
                n = j + f - j * f / 255, o = k + g - k * g / 255, p = l + h - l * h / 255;
            },
            overlay: function() {
                n = 128 > j ? 2 * j * f / 255 : 255 - 2 * (255 - j) * (255 - f) / 255, o = 128 > k ? 2 * k * g / 255 : 255 - 2 * (255 - k) * (255 - g) / 255, 
                p = 128 > l ? 2 * l * h / 255 : 255 - 2 * (255 - l) * (255 - h) / 255;
            },
            "soft-light": function() {
                var a = f * j / 255;
                n = a + j * (255 - (255 - j) * (255 - f) / 255 - a) / 255, a = g * k / 255, o = a + k * (255 - (255 - k) * (255 - g) / 255 - a) / 255, 
                a = h * l / 255, p = a + l * (255 - (255 - l) * (255 - h) / 255 - a) / 255;
            },
            "hard-light": function() {
                n = 128 > f ? 2 * f * j / 255 : 255 - 2 * (255 - f) * (255 - j) / 255, o = 128 > g ? 2 * g * k / 255 : 255 - 2 * (255 - g) * (255 - k) / 255, 
                p = 128 > h ? 2 * h * l / 255 : 255 - 2 * (255 - h) * (255 - l) / 255;
            },
            "color-dodge": function() {
                n = 0 === j ? 0 : 255 === f ? 255 : q(255, 255 * j / (255 - f)), o = 0 === k ? 0 : 255 === g ? 255 : q(255, 255 * k / (255 - g)), 
                p = 0 === l ? 0 : 255 === h ? 255 : q(255, 255 * l / (255 - h));
            },
            "color-burn": function() {
                n = 255 === j ? 255 : 0 === f ? 0 : r(0, 255 - 255 * (255 - j) / f), o = 255 === k ? 255 : 0 === g ? 0 : r(0, 255 - 255 * (255 - k) / g), 
                p = 255 === l ? 255 : 0 === h ? 0 : r(0, 255 - 255 * (255 - l) / h);
            },
            darken: function() {
                n = f > j ? j : f, o = g > k ? k : g, p = h > l ? l : h;
            },
            lighten: function() {
                n = j > f ? j : f, o = k > g ? k : g, p = l > h ? l : h;
            },
            difference: function() {
                n = j - f, 0 > n && (n = -n), o = k - g, 0 > o && (o = -o), p = l - h, 0 > p && (p = -p);
            },
            exclusion: function() {
                n = j + f * (255 - j - j) / 255, o = k + g * (255 - k - k) / 255, p = l + h * (255 - l - l) / 255;
            },
            hue: function() {
                e(f, g, h, d(j, k, l)), c(n, o, p, a(j, k, l));
            },
            saturation: function() {
                e(j, k, l, d(f, g, h)), c(n, o, p, a(j, k, l));
            },
            luminosity: function() {
                c(j, k, l, a(f, g, h));
            },
            color: function() {
                c(f, g, h, a(j, k, l));
            },
            add: function() {
                n = q(j + f, 255), o = q(k + g, 255), p = q(l + h, 255);
            },
            subtract: function() {
                n = r(j - f, 0), o = r(k - g, 0), p = r(l - h, 0);
            },
            average: function() {
                n = (j + f) / 2, o = (k + g) / 2, p = (l + h) / 2;
            },
            negation: function() {
                n = 255 - s(255 - f - j), o = 255 - s(255 - g - k), p = 255 - s(255 - h - l);
            }
        }, u = this.nativeModes = b.each([ "source-over", "source-in", "source-out", "source-atop", "destination-over", "destination-in", "destination-out", "destination-atop", "lighter", "darker", "copy", "xor" ], function(a) {
            this[a] = !0;
        }, {}), v = Z.getContext(1, 1);
        b.each(t, function(a, b) {
            var c = "darken" === b, d = !1;
            v.save();
            try {
                v.fillStyle = c ? "#300" : "#a00", v.fillRect(0, 0, 1, 1), v.globalCompositeOperation = b, 
                v.globalCompositeOperation === b && (v.fillStyle = c ? "#a00" : "#300", v.fillRect(0, 0, 1, 1), 
                d = v.getImageData(0, 0, 1, 1).data[0] !== c ? 170 : 51);
            } catch (e) {}
            v.restore(), u[b] = d;
        }), Z.release(v), this.process = function(a, b, c, d, e) {
            var q = b.canvas, r = "normal" === a;
            if (r || u[a]) c.save(), c.setTransform(1, 0, 0, 1, 0, 0), c.globalAlpha = d, r || (c.globalCompositeOperation = a), 
            c.drawImage(q, e.x, e.y), c.restore(); else {
                var s = t[a];
                if (!s) return;
                for (var v = c.getImageData(e.x, e.y, q.width, q.height), w = v.data, x = b.getImageData(0, 0, q.width, q.height).data, y = 0, z = w.length; z > y; y += 4) {
                    f = x[y], j = w[y], g = x[y + 1], k = w[y + 1], h = x[y + 2], l = w[y + 2], i = x[y + 3], 
                    m = w[y + 3], s();
                    var A = i * d / 255, B = 1 - A;
                    w[y] = A * n + B * j, w[y + 1] = A * o + B * k, w[y + 2] = A * p + B * l, w[y + 3] = i * d + B * m;
                }
                c.putImageData(v, e.x, e.y);
            }
        };
    }(), _ = b.each({
        fillColor: [ "fill", "color" ],
        strokeColor: [ "stroke", "color" ],
        strokeWidth: [ "stroke-width", "number" ],
        strokeCap: [ "stroke-linecap", "string" ],
        strokeJoin: [ "stroke-linejoin", "string" ],
        strokeScaling: [ "vector-effect", "lookup", {
            "true": "none",
            "false": "non-scaling-stroke"
        }, function(a, b) {
            return !b && (a instanceof E || a instanceof w || a instanceof J);
        } ],
        miterLimit: [ "stroke-miterlimit", "number" ],
        dashArray: [ "stroke-dasharray", "array" ],
        dashOffset: [ "stroke-dashoffset", "number" ],
        fontFamily: [ "font-family", "string" ],
        fontWeight: [ "font-weight", "string" ],
        fontSize: [ "font-size", "number" ],
        justification: [ "text-anchor", "lookup", {
            left: "start",
            center: "middle",
            right: "end"
        } ],
        opacity: [ "opacity", "number" ],
        blendMode: [ "mix-blend-mode", "string" ]
    }, function(a, c) {
        var d = b.capitalize(c), e = a[2];
        this[c] = {
            type: a[1],
            property: c,
            attribute: a[0],
            toSVG: e,
            fromSVG: e && b.each(e, function(a, b) {
                this[a] = b;
            }, {}),
            exportFilter: a[3],
            get: "get" + d,
            set: "set" + d
        };
    }, {}), ab = {
        href: "http://www.w3.org/1999/xlink",
        xlink: "http://www.w3.org/2000/xmlns"
    };
    return new function() {
        function a(a, b) {
            for (var c in b) {
                var d = b[c], e = ab[c];
                "number" == typeof d && (d = y.number(d)), e ? a.setAttributeNS(e, c, d) : a.setAttribute(c, d);
            }
            return a;
        }
        function c(b, c) {
            return a(document.createElementNS("http://www.w3.org/2000/svg", b), c);
        }
        function d(a, c, d) {
            var e = new b(), f = a.getTranslation();
            if (c) {
                a = a.shiftless();
                var h = a._inverseTransform(f);
                e[d ? "cx" : "x"] = h.x, e[d ? "cy" : "y"] = h.y, f = null;
            }
            if (!a.isIdentity()) {
                var i = a.decompose();
                if (i && !i.shearing) {
                    var j = [], k = i.rotation, l = i.scaling;
                    f && !f.isZero() && j.push("translate(" + y.point(f) + ")"), k && j.push("rotate(" + y.number(k) + ")"), 
                    g.isZero(l.x - 1) && g.isZero(l.y - 1) || j.push("scale(" + y.point(l) + ")"), e.transform = j.join(" ");
                } else e.transform = "matrix(" + a.getValues().join(",") + ")";
            }
            return e;
        }
        function e(b, e) {
            for (var f = d(b._matrix), g = b._children, h = c("g", f), i = 0, j = g.length; j > i; i++) {
                var k = g[i], l = w(k, e);
                if (l) if (k.isClipMask()) {
                    var m = c("clipPath");
                    m.appendChild(l), u(k, m, "clip"), a(h, {
                        "clip-path": "url(#" + m.id + ")"
                    });
                } else h.appendChild(l);
            }
            return h;
        }
        function h(a) {
            var b = d(a._matrix, !0), e = a.getSize();
            return b.x -= e.width / 2, b.y -= e.height / 2, b.width = e.width, b.height = e.height, 
            b.href = a.toDataURL(), c("image", b);
        }
        function j(a, b) {
            if (b.matchShapes) {
                var e = a.toShape(!1);
                if (e) return k(e, b);
            }
            var f, g = a._segments, h = d(a._matrix);
            if (0 === g.length) return null;
            if (a.isPolygon()) if (g.length >= 3) {
                f = a._closed ? "polygon" : "polyline";
                var j = [];
                for (i = 0, l = g.length; i < l; i++) j.push(y.point(g[i]._point));
                h.points = j.join(" ");
            } else {
                f = "line";
                var m = g[0]._point, n = g[g.length - 1]._point;
                h.set({
                    x1: m.x,
                    y1: m.y,
                    x2: n.x,
                    y2: n.y
                });
            } else f = "path", h.d = a.getPathData(null, b.precision);
            return c(f, h);
        }
        function k(a) {
            var b = a._type, e = a._radius, f = d(a._matrix, !0, "rectangle" !== b);
            if ("rectangle" === b) {
                b = "rect";
                var g = a._size, h = g.width, i = g.height;
                f.x -= h / 2, f.y -= i / 2, f.width = h, f.height = i, e.isZero() && (e = null);
            }
            return e && ("circle" === b ? f.r = e : (f.rx = e.width, f.ry = e.height)), c(b, f);
        }
        function m(a, b) {
            var e = d(a._matrix), f = a.getPathData(null, b.precision);
            return f && (e.d = f), c("path", e);
        }
        function n(a, b) {
            var e = d(a._matrix, !0), f = a.getSymbol(), g = s(f, "symbol"), h = f.getDefinition(), i = h.getBounds();
            return g || (g = c("symbol", {
                viewBox: y.rectangle(i)
            }), g.appendChild(w(h, b)), u(f, g, "symbol")), e.href = "#" + g.id, e.x += i.x, 
            e.y += i.y, e.width = y.number(i.width), e.height = y.number(i.height), c("use", e);
        }
        function o(a) {
            var b = s(a, "color");
            if (!b) {
                var d, e = a.getGradient(), f = e._radial, g = a.getOrigin().transform(), h = a.getDestination().transform();
                if (f) {
                    d = {
                        cx: g.x,
                        cy: g.y,
                        r: g.getDistance(h)
                    };
                    var i = a.getHighlight();
                    i && (i = i.transform(), d.fx = i.x, d.fy = i.y);
                } else d = {
                    x1: g.x,
                    y1: g.y,
                    x2: h.x,
                    y2: h.y
                };
                d.gradientUnits = "userSpaceOnUse", b = c((f ? "radial" : "linear") + "Gradient", d);
                for (var j = e._stops, k = 0, l = j.length; l > k; k++) {
                    var m = j[k], n = m._color, o = n.getAlpha();
                    d = {
                        offset: m._rampPoint,
                        "stop-color": n.toCSS(!0)
                    }, 1 > o && (d["stop-opacity"] = o), b.appendChild(c("stop", d));
                }
                u(a, b, "color");
            }
            return "url(#" + b.id + ")";
        }
        function p(a) {
            var b = c("text", d(a._matrix, !0));
            return b.textContent = a._content, b;
        }
        function q(c, d, e) {
            var f = {}, g = !e && c.getParent();
            return null != c._name && (f.id = c._name), b.each(_, function(a) {
                var d = a.get, e = a.type, h = c[d]();
                if (a.exportFilter ? a.exportFilter(c, h) : !g || !b.equals(g[d](), h)) {
                    if ("color" === e && null != h) {
                        var i = h.getAlpha();
                        1 > i && (f[a.attribute + "-opacity"] = i);
                    }
                    f[a.attribute] = null == h ? "none" : "number" === e ? y.number(h) : "color" === e ? h.gradient ? o(h, c) : h.toCSS(!0) : "array" === e ? h.join(",") : "lookup" === e ? a.toSVG[h] : h;
                }
            }), 1 === f.opacity && delete f.opacity, c._visible || (f.visibility = "hidden"), 
            a(d, f);
        }
        function s(a, b) {
            return z || (z = {
                ids: {},
                svgs: {}
            }), a && z.svgs[b + "-" + a._id];
        }
        function u(a, b, c) {
            z || s();
            var d = z.ids[c] = (z.ids[c] || 0) + 1;
            b.id = c + "-" + d, z.svgs[c + "-" + a._id] = b;
        }
        function v(a, b) {
            var d = a, e = null;
            if (z) {
                d = "svg" === a.nodeName.toLowerCase() && a;
                for (var f in z.svgs) e || (d || (d = c("svg"), d.appendChild(a)), e = d.insertBefore(c("defs"), d.firstChild)), 
                e.appendChild(z.svgs[f]);
                z = null;
            }
            return b.asString ? new XMLSerializer().serializeToString(d) : d;
        }
        function w(a, b, c) {
            var d = A[a._class], e = d && d(a, b);
            if (e) {
                var f = b.onExport;
                f && (e = f(a, e, b) || e);
                var g = JSON.stringify(a._data);
                g && "{}" !== g && e.setAttribute("data-paper-data", g);
            }
            return e && q(a, e, c);
        }
        function x(a) {
            return a || (a = {}), y = new f(a.precision), a;
        }
        var y, z, A = {
            Group: e,
            Layer: e,
            Raster: h,
            Path: j,
            Shape: k,
            CompoundPath: m,
            PlacedSymbol: n,
            PointText: p
        };
        t.inject({
            exportSVG: function(a) {
                return a = x(a), v(w(this, a, !0), a);
            }
        }), r.inject({
            exportSVG: function(a) {
                a = x(a);
                var b = this.layers, e = this.getView(), f = e.getViewSize(), g = c("svg", {
                    x: 0,
                    y: 0,
                    width: f.width,
                    height: f.height,
                    version: "1.1",
                    xmlns: "http://www.w3.org/2000/svg",
                    "xmlns:xlink": "http://www.w3.org/1999/xlink"
                }), h = g, i = e._matrix;
                i.isIdentity() || (h = g.appendChild(c("g", d(i))));
                for (var j = 0, k = b.length; k > j; j++) h.appendChild(w(b[j], a, !0));
                return v(g, a);
            }
        });
    }(), new function() {
        function c(a, b, c, d) {
            var e = ab[b], f = e ? a.getAttributeNS(e, b) : a.getAttribute(b);
            return "null" === f && (f = null), null == f ? d ? null : c ? "" : 0 : c ? f : parseFloat(f);
        }
        function d(a, b, d, e) {
            return b = c(a, b, !1, e), d = c(a, d, !1, e), !e || null != b && null != d ? new h(b, d) : null;
        }
        function e(a, b, d, e) {
            return b = c(a, b, !1, e), d = c(a, d, !1, e), !e || null != b && null != d ? new k(b, d) : null;
        }
        function f(a, b, c) {
            return "none" === a ? null : "number" === b ? parseFloat(a) : "array" === b ? a ? a.split(/[\s,]+/g).map(parseFloat) : [] : "color" === b ? y(a) || a : "lookup" === b ? c[a] : a;
        }
        function g(a, b, c, d) {
            var e = a.childNodes, f = "clippath" === b, g = new u(), h = g._project, i = h._currentStyle, j = [];
            f || (g = v(g, a, d), h._currentStyle = g._style.clone());
            for (var k = 0, l = e.length; l > k; k++) {
                var m, n = e[k];
                1 !== n.nodeType || !(m = z(n, c, !1)) || m instanceof s || j.push(m);
            }
            return g.addChildren(j), f && (g = v(g.reduce(), a, d)), h._currentStyle = i, (f || "defs" === b) && (g.remove(), 
            g = null), g;
        }
        function i(a, b) {
            for (var c = a.getAttribute("points").match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g), d = [], e = 0, f = c.length; f > e; e += 2) d.push(new h(parseFloat(c[e]), parseFloat(c[e + 1])));
            var g = new F(d);
            return "polygon" === b && g.closePath(), g;
        }
        function j(a) {
            var b = a.getAttribute("d"), c = {
                pathData: b
            };
            return (b.match(/m/gi) || []).length > 1 || /z\S+/i.test(b) ? new G(c) : new F(c);
        }
        function l(a, b) {
            var e, f = (c(a, "href", !0) || "").substring(1), g = "radialgradient" === b;
            if (f) e = C[f].getGradient(); else {
                for (var h = a.childNodes, i = [], j = 0, k = h.length; k > j; j++) {
                    var l = h[j];
                    1 === l.nodeType && i.push(v(new N(), l));
                }
                e = new M(i, g);
            }
            var m, n, o;
            return g ? (m = d(a, "cx", "cy"), n = m.add(c(a, "r"), 0), o = d(a, "fx", "fy", !0)) : (m = d(a, "x1", "y1"), 
            n = d(a, "x2", "y2")), v(new L(e, m, n, o), a), null;
        }
        function m(a, b, c, d) {
            for (var e = (d.getAttribute(c) || "").split(/\)\s*/g), f = new p(), g = 0, h = e.length; h > g; g++) {
                var i = e[g];
                if (!i) break;
                for (var j = i.split(/\(\s*/), k = j[0], l = j[1].split(/[\s,]+/g), m = 0, n = l.length; n > m; m++) l[m] = parseFloat(l[m]);
                switch (k) {
                  case "matrix":
                    f.concatenate(new p(l[0], l[1], l[2], l[3], l[4], l[5]));
                    break;

                  case "rotate":
                    f.rotate(l[0], l[1], l[2]);
                    break;

                  case "translate":
                    f.translate(l[0], l[1]);
                    break;

                  case "scale":
                    f.scale(l);
                    break;

                  case "skewX":
                    f.skew(l[0], 0);
                    break;

                  case "skewY":
                    f.skew(0, l[0]);
                }
            }
            a.transform(f);
        }
        function o(a, b, c) {
            var d = a["fill-opacity" === c ? "getFillColor" : "getStrokeColor"]();
            d && d.setAlpha(parseFloat(b));
        }
        function q(c, d, e) {
            var f = c.attributes[d], g = f && f.value;
            if (!g) {
                var h = b.camelize(d);
                g = c.style[h], g || e.node[h] === e.parent[h] || (g = e.node[h]);
            }
            return g ? "none" === g ? null : g : a;
        }
        function v(c, d, e) {
            var f = {
                node: P.getStyles(d) || {},
                parent: !e && P.getStyles(d.parentNode) || {}
            };
            return b.each(B, function(e, g) {
                var h = q(d, g, f);
                h !== a && (c = b.pick(e(c, h, g, d, f), c));
            }), c;
        }
        function y(a) {
            var b = a && a.match(/\((?:#|)([^)']+)/);
            return b && C[b[1]];
        }
        function z(a, b, c) {
            function d(a) {
                paper = f;
                var d = z(a, b, c), e = b.onLoad, g = f.project && f.getView();
                e && e.call(this, d), g.update();
            }
            if (!a) return null;
            b ? "function" == typeof b && (b = {
                onLoad: b
            }) : b = {};
            var e = a, f = paper;
            if (c) if ("string" != typeof a || /^.*</.test(a)) {
                if ("undefined" != typeof File && a instanceof File) {
                    var g = new FileReader();
                    return g.onload = function() {
                        d(g.result);
                    }, g.readAsText(a);
                }
            } else {
                if (e = document.getElementById(a), !e) return Y.request("get", a, d);
                a = null;
            }
            if ("string" == typeof a && (e = new DOMParser().parseFromString(a, "image/svg+xml")), 
            !e.nodeName) throw new Error("Unsupported SVG source: " + a);
            var h, i = e.nodeName.toLowerCase(), j = A[i], k = e.getAttribute && e.getAttribute("data-paper-data"), l = f.settings, m = l.applyMatrix;
            if (l.applyMatrix = !1, h = j && j(e, i, b, c) || null, l.applyMatrix = m, h) {
                "#document" === i || h instanceof u || (h = v(h, e, c));
                var n = b.onImport;
                n && (h = n(e, h, b) || h), b.expandShapes && h instanceof w && (h.remove(), h = h.toPath()), 
                k && (h._data = JSON.parse(k));
            }
            return c && (C = {}), h;
        }
        var A = {
            "#document": function(a, b, c, d) {
                for (var e = a.childNodes, f = 0, g = e.length; g > f; f++) {
                    var h = e[f];
                    if (1 === h.nodeType) {
                        var i = h.nextSibling;
                        document.body.appendChild(h);
                        var j = z(h, c, d);
                        return i ? a.insertBefore(h, i) : a.appendChild(h), j;
                    }
                }
            },
            g: g,
            svg: g,
            clippath: g,
            polygon: i,
            polyline: i,
            path: j,
            lineargradient: l,
            radialgradient: l,
            image: function(a) {
                var b = new x(c(a, "href", !0));
                return b.on("load", function() {
                    var b = e(a, "width", "height");
                    this.setSize(b);
                    var c = this._matrix._transformPoint(d(a, "x", "y").add(b.divide(2)));
                    this.translate(c);
                }), b;
            },
            symbol: function(a, b, c, d) {
                return new s(g(a, b, c, d), !0);
            },
            defs: g,
            use: function(a) {
                var b = (c(a, "href", !0) || "").substring(1), e = C[b], f = d(a, "x", "y");
                return e ? e instanceof s ? e.place(f) : e.clone().translate(f) : null;
            },
            circle: function(a) {
                return new w.Circle(d(a, "cx", "cy"), c(a, "r"));
            },
            ellipse: function(a) {
                return new w.Ellipse({
                    center: d(a, "cx", "cy"),
                    radius: e(a, "rx", "ry")
                });
            },
            rect: function(a) {
                var b = d(a, "x", "y"), c = e(a, "width", "height"), f = e(a, "rx", "ry");
                return new w.Rectangle(new n(b, c), f);
            },
            line: function(a) {
                return new F.Line(d(a, "x1", "y1"), d(a, "x2", "y2"));
            },
            text: function(a) {
                var b = new K(d(a, "x", "y").add(d(a, "dx", "dy")));
                return b.setContent(a.textContent.trim() || ""), b;
            }
        }, B = b.each(_, function(a) {
            this[a.attribute] = function(b, c) {
                if (b[a.set](f(c, a.type, a.fromSVG)), "color" === a.type && b instanceof w) {
                    var d = b[a.get]();
                    d && d.transform(new p().translate(b.getPosition(!0).negate()));
                }
            };
        }, {
            id: function(a, b) {
                C[b] = a, a.setName && a.setName(b);
            },
            "clip-path": function(a, b) {
                var c = y(b);
                if (c) {
                    if (c = c.clone(), c.setClipMask(!0), !(a instanceof u)) return new u(c, a);
                    a.insertChild(0, c);
                }
            },
            gradientTransform: m,
            transform: m,
            "fill-opacity": o,
            "stroke-opacity": o,
            visibility: function(a, b) {
                a.setVisible("visible" === b);
            },
            display: function(a, b) {
                a.setVisible(null !== b);
            },
            "stop-color": function(a, b) {
                a.setColor && a.setColor(b);
            },
            "stop-opacity": function(a, b) {
                a._color && a._color.setAlpha(parseFloat(b));
            },
            offset: function(a, b) {
                var c = b.match(/(.*)%$/);
                a.setRampPoint(c ? c[1] / 100 : parseFloat(b));
            },
            viewBox: function(a, b, c, d, g) {
                var h = new n(f(b, "array")), i = e(d, "width", "height", !0);
                if (a instanceof u) {
                    var j = i ? h.getSize().divide(i) : 1, k = new p().translate(h.getPoint()).scale(j);
                    a.transform(k.inverted());
                } else if (a instanceof s) {
                    i && h.setSize(i);
                    var l = "visible" != q(d, "overflow", g), m = a._definition;
                    l && !h.contains(m.getBounds()) && (l = new w.Rectangle(h).transform(m._matrix), 
                    l.setClipMask(!0), m.addChild(l));
                }
            }
        }), C = {};
        t.inject({
            importSVG: function(a, b) {
                return this.addChild(z(a, b, !0));
            }
        }), r.inject({
            importSVG: function(a, b) {
                return this.activate(), z(a, b, !0);
            }
        });
    }(), paper = new (d.inject(b.exports, {
        enumerable: !0,
        Base: b,
        Numerical: g,
        Key: V
    }))(), "function" == typeof define && define.amd ? define("paper", paper) : "object" == typeof module && module && (module.exports = paper), 
    paper;
}();

this.createjs = this.createjs || {}, function() {
    var a = createjs.PreloadJS = createjs.PreloadJS || {};
    a.version = "0.6.0", a.buildDate = "Thu, 11 Dec 2014 23:32:09 GMT";
}(), this.createjs = this.createjs || {}, createjs.extend = function(a, b) {
    function c() {
        this.constructor = a;
    }
    return c.prototype = b.prototype, a.prototype = new c();
}, this.createjs = this.createjs || {}, createjs.promote = function(a, b) {
    var c = a.prototype, d = Object.getPrototypeOf && Object.getPrototypeOf(c) || c.__proto__;
    if (d) {
        c[(b += "_") + "constructor"] = d.constructor;
        for (var e in d) c.hasOwnProperty(e) && "function" == typeof d[e] && (c[b + e] = d[e]);
    }
    return a;
}, this.createjs = this.createjs || {}, createjs.indexOf = function(a, b) {
    for (var c = 0, d = a.length; d > c; c++) if (b === a[c]) return c;
    return -1;
}, this.createjs = this.createjs || {}, function() {
    createjs.proxy = function(a, b) {
        var c = Array.prototype.slice.call(arguments, 2);
        return function() {
            return a.apply(b, Array.prototype.slice.call(arguments, 0).concat(c));
        };
    };
}(), this.createjs = this.createjs || {}, function() {
    function a() {
        throw "BrowserDetect cannot be instantiated";
    }
    var b = a.agent = window.navigator.userAgent;
    a.isWindowPhone = b.indexOf("IEMobile") > -1 || b.indexOf("Windows Phone") > -1, 
    a.isFirefox = b.indexOf("Firefox") > -1, a.isOpera = null != window.opera, a.isChrome = b.indexOf("Chrome") > -1, 
    a.isIOS = (b.indexOf("iPod") > -1 || b.indexOf("iPhone") > -1 || b.indexOf("iPad") > -1) && !a.isWindowPhone, 
    a.isAndroid = b.indexOf("Android") > -1 && !a.isWindowPhone, a.isBlackberry = b.indexOf("Blackberry") > -1, 
    createjs.BrowserDetect = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.type = a, this.target = null, this.currentTarget = null, this.eventPhase = 0, 
        this.bubbles = !!b, this.cancelable = !!c, this.timeStamp = new Date().getTime(), 
        this.defaultPrevented = !1, this.propagationStopped = !1, this.immediatePropagationStopped = !1, 
        this.removed = !1;
    }
    var b = a.prototype;
    b.preventDefault = function() {
        this.defaultPrevented = this.cancelable && !0;
    }, b.stopPropagation = function() {
        this.propagationStopped = !0;
    }, b.stopImmediatePropagation = function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
    }, b.remove = function() {
        this.removed = !0;
    }, b.clone = function() {
        return new a(this.type, this.bubbles, this.cancelable);
    }, b.set = function(a) {
        for (var b in a) this[b] = a[b];
        return this;
    }, b.toString = function() {
        return "[Event (type=" + this.type + ")]";
    }, createjs.Event = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.Event_constructor("error"), this.title = a, this.message = b, this.data = c;
    }
    var b = createjs.extend(a, createjs.Event);
    b.clone = function() {
        return new createjs.ErrorEvent(this.title, this.message, this.data);
    }, createjs.ErrorEvent = createjs.promote(a, "Event");
}(), this.createjs = this.createjs || {}, function() {
    function a() {
        this._listeners = null, this._captureListeners = null;
    }
    var b = a.prototype;
    a.initialize = function(a) {
        a.addEventListener = b.addEventListener, a.on = b.on, a.removeEventListener = a.off = b.removeEventListener, 
        a.removeAllEventListeners = b.removeAllEventListeners, a.hasEventListener = b.hasEventListener, 
        a.dispatchEvent = b.dispatchEvent, a._dispatchEvent = b._dispatchEvent, a.willTrigger = b.willTrigger;
    }, b.addEventListener = function(a, b, c) {
        var d;
        d = c ? this._captureListeners = this._captureListeners || {} : this._listeners = this._listeners || {};
        var e = d[a];
        return e && this.removeEventListener(a, b, c), e = d[a], e ? e.push(b) : d[a] = [ b ], 
        b;
    }, b.on = function(a, b, c, d, e, f) {
        return b.handleEvent && (c = c || b, b = b.handleEvent), c = c || this, this.addEventListener(a, function(a) {
            b.call(c, a, e), d && a.remove();
        }, f);
    }, b.removeEventListener = function(a, b, c) {
        var d = c ? this._captureListeners : this._listeners;
        if (d) {
            var e = d[a];
            if (e) for (var f = 0, g = e.length; g > f; f++) if (e[f] == b) {
                1 == g ? delete d[a] : e.splice(f, 1);
                break;
            }
        }
    }, b.off = b.removeEventListener, b.removeAllEventListeners = function(a) {
        a ? (this._listeners && delete this._listeners[a], this._captureListeners && delete this._captureListeners[a]) : this._listeners = this._captureListeners = null;
    }, b.dispatchEvent = function(a) {
        if ("string" == typeof a) {
            var b = this._listeners;
            if (!b || !b[a]) return !1;
            a = new createjs.Event(a);
        } else a.target && a.clone && (a = a.clone());
        try {
            a.target = this;
        } catch (c) {}
        if (a.bubbles && this.parent) {
            for (var d = this, e = [ d ]; d.parent; ) e.push(d = d.parent);
            var f, g = e.length;
            for (f = g - 1; f >= 0 && !a.propagationStopped; f--) e[f]._dispatchEvent(a, 1 + (0 == f));
            for (f = 1; g > f && !a.propagationStopped; f++) e[f]._dispatchEvent(a, 3);
        } else this._dispatchEvent(a, 2);
        return a.defaultPrevented;
    }, b.hasEventListener = function(a) {
        var b = this._listeners, c = this._captureListeners;
        return !!(b && b[a] || c && c[a]);
    }, b.willTrigger = function(a) {
        for (var b = this; b; ) {
            if (b.hasEventListener(a)) return !0;
            b = b.parent;
        }
        return !1;
    }, b.toString = function() {
        return "[EventDispatcher]";
    }, b._dispatchEvent = function(a, b) {
        var c, d = 1 == b ? this._captureListeners : this._listeners;
        if (a && d) {
            var e = d[a.type];
            if (!e || !(c = e.length)) return;
            try {
                a.currentTarget = this;
            } catch (f) {}
            try {
                a.eventPhase = b;
            } catch (f) {}
            a.removed = !1, e = e.slice();
            for (var g = 0; c > g && !a.immediatePropagationStopped; g++) {
                var h = e[g];
                h.handleEvent ? h.handleEvent(a) : h(a), a.removed && (this.off(a.type, h, 1 == b), 
                a.removed = !1);
            }
        }
    }, createjs.EventDispatcher = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.Event_constructor("progress"), this.loaded = a, this.total = null == b ? 1 : b, 
        this.progress = 0 == b ? 0 : this.loaded / this.total;
    }
    var b = createjs.extend(a, createjs.Event);
    b.clone = function() {
        return new createjs.ProgressEvent(this.loaded, this.total);
    }, createjs.ProgressEvent = createjs.promote(a, "Event");
}(window), function() {
    function a(b, d) {
        function f(a) {
            if (f[a] !== q) return f[a];
            var b;
            if ("bug-string-char-index" == a) b = "a" != "a"[0]; else if ("json" == a) b = f("json-stringify") && f("json-parse"); else {
                var c, e = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                if ("json-stringify" == a) {
                    var i = d.stringify, k = "function" == typeof i && t;
                    if (k) {
                        (c = function() {
                            return 1;
                        }).toJSON = c;
                        try {
                            k = "0" === i(0) && "0" === i(new g()) && '""' == i(new h()) && i(s) === q && i(q) === q && i() === q && "1" === i(c) && "[1]" == i([ c ]) && "[null]" == i([ q ]) && "null" == i(null) && "[null,null,null]" == i([ q, s, null ]) && i({
                                a: [ c, !0, !1, null, "\x00\b\n\f\r	" ]
                            }) == e && "1" === i(null, c) && "[\n 1,\n 2\n]" == i([ 1, 2 ], null, 1) && '"-271821-04-20T00:00:00.000Z"' == i(new j(-864e13)) && '"+275760-09-13T00:00:00.000Z"' == i(new j(864e13)) && '"-000001-01-01T00:00:00.000Z"' == i(new j(-621987552e5)) && '"1969-12-31T23:59:59.999Z"' == i(new j(-1));
                        } catch (l) {
                            k = !1;
                        }
                    }
                    b = k;
                }
                if ("json-parse" == a) {
                    var m = d.parse;
                    if ("function" == typeof m) try {
                        if (0 === m("0") && !m(!1)) {
                            c = m(e);
                            var n = 5 == c.a.length && 1 === c.a[0];
                            if (n) {
                                try {
                                    n = !m('"	"');
                                } catch (l) {}
                                if (n) try {
                                    n = 1 !== m("01");
                                } catch (l) {}
                                if (n) try {
                                    n = 1 !== m("1.");
                                } catch (l) {}
                            }
                        }
                    } catch (l) {
                        n = !1;
                    }
                    b = n;
                }
            }
            return f[a] = !!b;
        }
        b || (b = e.Object()), d || (d = e.Object());
        var g = b.Number || e.Number, h = b.String || e.String, i = b.Object || e.Object, j = b.Date || e.Date, k = b.SyntaxError || e.SyntaxError, l = b.TypeError || e.TypeError, m = b.Math || e.Math, n = b.JSON || e.JSON;
        "object" == typeof n && n && (d.stringify = n.stringify, d.parse = n.parse);
        var o, p, q, r = i.prototype, s = r.toString, t = new j(-0xc782b5b800cec);
        try {
            t = -109252 == t.getUTCFullYear() && 0 === t.getUTCMonth() && 1 === t.getUTCDate() && 10 == t.getUTCHours() && 37 == t.getUTCMinutes() && 6 == t.getUTCSeconds() && 708 == t.getUTCMilliseconds();
        } catch (u) {}
        if (!f("json")) {
            var v = "[object Function]", w = "[object Date]", x = "[object Number]", y = "[object String]", z = "[object Array]", A = "[object Boolean]", B = f("bug-string-char-index");
            if (!t) var C = m.floor, D = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], E = function(a, b) {
                return D[b] + 365 * (a - 1970) + C((a - 1969 + (b = +(b > 1))) / 4) - C((a - 1901 + b) / 100) + C((a - 1601 + b) / 400);
            };
            if ((o = r.hasOwnProperty) || (o = function(a) {
                var b, c = {};
                return (c.__proto__ = null, c.__proto__ = {
                    toString: 1
                }, c).toString != s ? o = function(a) {
                    var b = this.__proto__, c = a in (this.__proto__ = null, this);
                    return this.__proto__ = b, c;
                } : (b = c.constructor, o = function(a) {
                    var c = (this.constructor || b).prototype;
                    return a in this && !(a in c && this[a] === c[a]);
                }), c = null, o.call(this, a);
            }), p = function(a, b) {
                var d, e, f, g = 0;
                (d = function() {
                    this.valueOf = 0;
                }).prototype.valueOf = 0, e = new d();
                for (f in e) o.call(e, f) && g++;
                return d = e = null, g ? p = 2 == g ? function(a, b) {
                    var c, d = {}, e = s.call(a) == v;
                    for (c in a) e && "prototype" == c || o.call(d, c) || !(d[c] = 1) || !o.call(a, c) || b(c);
                } : function(a, b) {
                    var c, d, e = s.call(a) == v;
                    for (c in a) e && "prototype" == c || !o.call(a, c) || (d = "constructor" === c) || b(c);
                    (d || o.call(a, c = "constructor")) && b(c);
                } : (e = [ "valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor" ], 
                p = function(a, b) {
                    var d, f, g = s.call(a) == v, h = !g && "function" != typeof a.constructor && c[typeof a.hasOwnProperty] && a.hasOwnProperty || o;
                    for (d in a) g && "prototype" == d || !h.call(a, d) || b(d);
                    for (f = e.length; d = e[--f]; h.call(a, d) && b(d)) ;
                }), p(a, b);
            }, !f("json-stringify")) {
                var F = {
                    92: "\\\\",
                    34: '\\"',
                    8: "\\b",
                    12: "\\f",
                    10: "\\n",
                    13: "\\r",
                    9: "\\t"
                }, G = "000000", H = function(a, b) {
                    return (G + (b || 0)).slice(-a);
                }, I = "\\u00", J = function(a) {
                    for (var b = '"', c = 0, d = a.length, e = !B || d > 10, f = e && (B ? a.split("") : a); d > c; c++) {
                        var g = a.charCodeAt(c);
                        switch (g) {
                          case 8:
                          case 9:
                          case 10:
                          case 12:
                          case 13:
                          case 34:
                          case 92:
                            b += F[g];
                            break;

                          default:
                            if (32 > g) {
                                b += I + H(2, g.toString(16));
                                break;
                            }
                            b += e ? f[c] : a.charAt(c);
                        }
                    }
                    return b + '"';
                }, K = function(a, b, c, d, e, f, g) {
                    var h, i, j, k, m, n, r, t, u, v, B, D, F, G, I, L;
                    try {
                        h = b[a];
                    } catch (M) {}
                    if ("object" == typeof h && h) if (i = s.call(h), i != w || o.call(h, "toJSON")) "function" == typeof h.toJSON && (i != x && i != y && i != z || o.call(h, "toJSON")) && (h = h.toJSON(a)); else if (h > -1 / 0 && 1 / 0 > h) {
                        if (E) {
                            for (m = C(h / 864e5), j = C(m / 365.2425) + 1970 - 1; E(j + 1, 0) <= m; j++) ;
                            for (k = C((m - E(j, 0)) / 30.42); E(j, k + 1) <= m; k++) ;
                            m = 1 + m - E(j, k), n = (h % 864e5 + 864e5) % 864e5, r = C(n / 36e5) % 24, t = C(n / 6e4) % 60, 
                            u = C(n / 1e3) % 60, v = n % 1e3;
                        } else j = h.getUTCFullYear(), k = h.getUTCMonth(), m = h.getUTCDate(), r = h.getUTCHours(), 
                        t = h.getUTCMinutes(), u = h.getUTCSeconds(), v = h.getUTCMilliseconds();
                        h = (0 >= j || j >= 1e4 ? (0 > j ? "-" : "+") + H(6, 0 > j ? -j : j) : H(4, j)) + "-" + H(2, k + 1) + "-" + H(2, m) + "T" + H(2, r) + ":" + H(2, t) + ":" + H(2, u) + "." + H(3, v) + "Z";
                    } else h = null;
                    if (c && (h = c.call(b, a, h)), null === h) return "null";
                    if (i = s.call(h), i == A) return "" + h;
                    if (i == x) return h > -1 / 0 && 1 / 0 > h ? "" + h : "null";
                    if (i == y) return J("" + h);
                    if ("object" == typeof h) {
                        for (G = g.length; G--; ) if (g[G] === h) throw l();
                        if (g.push(h), B = [], I = f, f += e, i == z) {
                            for (F = 0, G = h.length; G > F; F++) D = K(F, h, c, d, e, f, g), B.push(D === q ? "null" : D);
                            L = B.length ? e ? "[\n" + f + B.join(",\n" + f) + "\n" + I + "]" : "[" + B.join(",") + "]" : "[]";
                        } else p(d || h, function(a) {
                            var b = K(a, h, c, d, e, f, g);
                            b !== q && B.push(J(a) + ":" + (e ? " " : "") + b);
                        }), L = B.length ? e ? "{\n" + f + B.join(",\n" + f) + "\n" + I + "}" : "{" + B.join(",") + "}" : "{}";
                        return g.pop(), L;
                    }
                };
                d.stringify = function(a, b, d) {
                    var e, f, g, h;
                    if (c[typeof b] && b) if ((h = s.call(b)) == v) f = b; else if (h == z) {
                        g = {};
                        for (var i, j = 0, k = b.length; k > j; i = b[j++], h = s.call(i), (h == y || h == x) && (g[i] = 1)) ;
                    }
                    if (d) if ((h = s.call(d)) == x) {
                        if ((d -= d % 1) > 0) for (e = "", d > 10 && (d = 10); e.length < d; e += " ") ;
                    } else h == y && (e = d.length <= 10 ? d : d.slice(0, 10));
                    return K("", (i = {}, i[""] = a, i), f, g, e, "", []);
                };
            }
            if (!f("json-parse")) {
                var L, M, N = h.fromCharCode, O = {
                    92: "\\",
                    34: '"',
                    47: "/",
                    98: "\b",
                    116: "	",
                    110: "\n",
                    102: "\f",
                    114: "\r"
                }, P = function() {
                    throw L = M = null, k();
                }, Q = function() {
                    for (var a, b, c, d, e, f = M, g = f.length; g > L; ) switch (e = f.charCodeAt(L)) {
                      case 9:
                      case 10:
                      case 13:
                      case 32:
                        L++;
                        break;

                      case 123:
                      case 125:
                      case 91:
                      case 93:
                      case 58:
                      case 44:
                        return a = B ? f.charAt(L) : f[L], L++, a;

                      case 34:
                        for (a = "@", L++; g > L; ) if (e = f.charCodeAt(L), 32 > e) P(); else if (92 == e) switch (e = f.charCodeAt(++L)) {
                          case 92:
                          case 34:
                          case 47:
                          case 98:
                          case 116:
                          case 110:
                          case 102:
                          case 114:
                            a += O[e], L++;
                            break;

                          case 117:
                            for (b = ++L, c = L + 4; c > L; L++) e = f.charCodeAt(L), e >= 48 && 57 >= e || e >= 97 && 102 >= e || e >= 65 && 70 >= e || P();
                            a += N("0x" + f.slice(b, L));
                            break;

                          default:
                            P();
                        } else {
                            if (34 == e) break;
                            for (e = f.charCodeAt(L), b = L; e >= 32 && 92 != e && 34 != e; ) e = f.charCodeAt(++L);
                            a += f.slice(b, L);
                        }
                        if (34 == f.charCodeAt(L)) return L++, a;
                        P();

                      default:
                        if (b = L, 45 == e && (d = !0, e = f.charCodeAt(++L)), e >= 48 && 57 >= e) {
                            for (48 == e && (e = f.charCodeAt(L + 1), e >= 48 && 57 >= e) && P(), d = !1; g > L && (e = f.charCodeAt(L), 
                            e >= 48 && 57 >= e); L++) ;
                            if (46 == f.charCodeAt(L)) {
                                for (c = ++L; g > c && (e = f.charCodeAt(c), e >= 48 && 57 >= e); c++) ;
                                c == L && P(), L = c;
                            }
                            if (e = f.charCodeAt(L), 101 == e || 69 == e) {
                                for (e = f.charCodeAt(++L), (43 == e || 45 == e) && L++, c = L; g > c && (e = f.charCodeAt(c), 
                                e >= 48 && 57 >= e); c++) ;
                                c == L && P(), L = c;
                            }
                            return +f.slice(b, L);
                        }
                        if (d && P(), "true" == f.slice(L, L + 4)) return L += 4, !0;
                        if ("false" == f.slice(L, L + 5)) return L += 5, !1;
                        if ("null" == f.slice(L, L + 4)) return L += 4, null;
                        P();
                    }
                    return "$";
                }, R = function(a) {
                    var b, c;
                    if ("$" == a && P(), "string" == typeof a) {
                        if ("@" == (B ? a.charAt(0) : a[0])) return a.slice(1);
                        if ("[" == a) {
                            for (b = []; a = Q(), "]" != a; c || (c = !0)) c && ("," == a ? (a = Q(), "]" == a && P()) : P()), 
                            "," == a && P(), b.push(R(a));
                            return b;
                        }
                        if ("{" == a) {
                            for (b = {}; a = Q(), "}" != a; c || (c = !0)) c && ("," == a ? (a = Q(), "}" == a && P()) : P()), 
                            ("," == a || "string" != typeof a || "@" != (B ? a.charAt(0) : a[0]) || ":" != Q()) && P(), 
                            b[a.slice(1)] = R(Q());
                            return b;
                        }
                        P();
                    }
                    return a;
                }, S = function(a, b, c) {
                    var d = T(a, b, c);
                    d === q ? delete a[b] : a[b] = d;
                }, T = function(a, b, c) {
                    var d, e = a[b];
                    if ("object" == typeof e && e) if (s.call(e) == z) for (d = e.length; d--; ) S(e, d, c); else p(e, function(a) {
                        S(e, a, c);
                    });
                    return c.call(a, b, e);
                };
                d.parse = function(a, b) {
                    var c, d;
                    return L = 0, M = "" + a, c = R(Q()), "$" != Q() && P(), L = M = null, b && s.call(b) == v ? T((d = {}, 
                    d[""] = c, d), "", b) : c;
                };
            }
        }
        return d.runInContext = a, d;
    }
    var b = "function" == typeof define && define.amd, c = {
        "function": !0,
        object: !0
    }, d = c[typeof exports] && exports && !exports.nodeType && exports, e = c[typeof window] && window || this, f = d && c[typeof module] && module && !module.nodeType && "object" == typeof global && global;
    if (!f || f.global !== f && f.window !== f && f.self !== f || (e = f), d && !b) a(e, d); else {
        var g = e.JSON, h = e.JSON3, i = !1, j = a(e, e.JSON3 = {
            noConflict: function() {
                return i || (i = !0, e.JSON = g, e.JSON3 = h, g = h = null), j;
            }
        });
        e.JSON = {
            parse: j.parse,
            stringify: j.stringify
        };
    }
    b && define(function() {
        return j;
    });
}.call(this), function() {
    var a = {};
    a.parseXML = function(a, b) {
        var c = null;
        try {
            if (window.DOMParser) {
                var d = new DOMParser();
                c = d.parseFromString(a, b);
            } else c = new ActiveXObject("Microsoft.XMLDOM"), c.async = !1, c.loadXML(a);
        } catch (e) {}
        return c;
    }, a.parseJSON = function(a) {
        if (null == a) return null;
        try {
            return JSON.parse(a);
        } catch (b) {
            throw b;
        }
    }, createjs.DataUtils = a;
}(), this.createjs = this.createjs || {}, function() {
    function a() {
        this.src = null, this.type = null, this.id = null, this.maintainOrder = !1, this.callback = null, 
        this.data = null, this.method = createjs.LoadItem.GET, this.values = null, this.headers = null, 
        this.withCredentials = !1, this.mimeType = null, this.crossOrigin = null, this.loadTimeout = 8e3;
    }
    var b = a.prototype = {}, c = a;
    c.create = function(b) {
        if ("string" == typeof b) {
            var d = new a();
            return d.src = b, d;
        }
        if (b instanceof c) return b;
        if (b instanceof Object) return b;
        throw new Error("Type not recognized.");
    }, b.set = function(a) {
        for (var b in a) this[b] = a[b];
        return this;
    }, createjs.LoadItem = c;
}(), function() {
    var a = {};
    a.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i, a.RELATIVE_PATT = /^[./]*?\//i, a.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i, 
    a.parseURI = function(b) {
        var c = {
            absolute: !1,
            relative: !1
        };
        if (null == b) return c;
        var d = b.indexOf("?");
        d > -1 && (b = b.substr(0, d));
        var e;
        return a.ABSOLUTE_PATT.test(b) ? c.absolute = !0 : a.RELATIVE_PATT.test(b) && (c.relative = !0), 
        (e = b.match(a.EXTENSION_PATT)) && (c.extension = e[1].toLowerCase()), c;
    }, a.formatQueryString = function(a, b) {
        if (null == a) throw new Error("You must specify data.");
        var c = [];
        for (var d in a) c.push(d + "=" + escape(a[d]));
        return b && (c = c.concat(b)), c.join("&");
    }, a.buildPath = function(a, b) {
        if (null == b) return a;
        var c = [], d = a.indexOf("?");
        if (-1 != d) {
            var e = a.slice(d + 1);
            c = c.concat(e.split("&"));
        }
        return -1 != d ? a.slice(0, d) + "?" + this._formatQueryString(b, c) : a + "?" + this._formatQueryString(b, c);
    }, a.isCrossDomain = function(a) {
        var b = document.createElement("a");
        b.href = a.src;
        var c = document.createElement("a");
        c.href = location.href;
        var d = "" != b.hostname && (b.port != c.port || b.protocol != c.protocol || b.hostname != c.hostname);
        return d;
    }, a.isLocal = function(a) {
        var b = document.createElement("a");
        return b.href = a.src, "" == b.hostname && "file:" == b.protocol;
    }, a.isBinary = function(a) {
        switch (a) {
          case createjs.AbstractLoader.IMAGE:
          case createjs.AbstractLoader.BINARY:
            return !0;

          default:
            return !1;
        }
    }, a.isImageTag = function(a) {
        return a instanceof HTMLImageElement;
    }, a.isAudioTag = function(a) {
        return window.HTMLAudioElement ? a instanceof HTMLAudioElement : !1;
    }, a.isVideoTag = function(a) {
        return window.HTMLVideoElement ? a instanceof HTMLVideoElement : void 0;
    }, a.isText = function(a) {
        switch (a) {
          case createjs.AbstractLoader.TEXT:
          case createjs.AbstractLoader.JSON:
          case createjs.AbstractLoader.MANIFEST:
          case createjs.AbstractLoader.XML:
          case createjs.AbstractLoader.CSS:
          case createjs.AbstractLoader.SVG:
          case createjs.AbstractLoader.JAVASCRIPT:
            return !0;

          default:
            return !1;
        }
    }, a.getTypeByExtension = function(a) {
        if (null == a) return createjs.AbstractLoader.TEXT;
        switch (a.toLowerCase()) {
          case "jpeg":
          case "jpg":
          case "gif":
          case "png":
          case "webp":
          case "bmp":
            return createjs.AbstractLoader.IMAGE;

          case "ogg":
          case "mp3":
          case "webm":
            return createjs.AbstractLoader.SOUND;

          case "mp4":
          case "webm":
          case "ts":
            return createjs.AbstractLoader.VIDEO;

          case "json":
            return createjs.AbstractLoader.JSON;

          case "xml":
            return createjs.AbstractLoader.XML;

          case "css":
            return createjs.AbstractLoader.CSS;

          case "js":
            return createjs.AbstractLoader.JAVASCRIPT;

          case "svg":
            return createjs.AbstractLoader.SVG;

          default:
            return createjs.AbstractLoader.TEXT;
        }
    }, createjs.RequestUtils = a;
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.EventDispatcher_constructor(), this.loaded = !1, this.canceled = !1, this.progress = 0, 
        this.type = c, this.resultFormatter = null, this._item = a ? createjs.LoadItem.create(a) : null, 
        this._preferXHR = b, this._result = null, this._rawResult = null, this._loadedItems = null, 
        this._tagSrcAttribute = null, this._tag = null;
    }
    var b = createjs.extend(a, createjs.EventDispatcher), c = a;
    c.POST = "POST", c.GET = "GET", c.BINARY = "binary", c.CSS = "css", c.IMAGE = "image", 
    c.JAVASCRIPT = "javascript", c.JSON = "json", c.JSONP = "jsonp", c.MANIFEST = "manifest", 
    c.SOUND = "sound", c.VIDEO = "video", c.SPRITESHEET = "spritesheet", c.SVG = "svg", 
    c.TEXT = "text", c.XML = "xml", b.getItem = function() {
        return this._item;
    }, b.getResult = function(a) {
        return a ? this._rawResult : this._result;
    }, b.getTag = function() {
        return this._tag;
    }, b.setTag = function(a) {
        this._tag = a;
    }, b.load = function() {
        this._createRequest(), this._request.on("complete", this, this), this._request.on("progress", this, this), 
        this._request.on("loadStart", this, this), this._request.on("abort", this, this), 
        this._request.on("timeout", this, this), this._request.on("error", this, this);
        var a = new createjs.Event("initialize");
        a.loader = this._request, this.dispatchEvent(a), this._request.load();
    }, b.cancel = function() {
        this.canceled = !0, this.destroy();
    }, b.destroy = function() {
        this._request && (this._request.removeAllEventListeners(), this._request.destroy()), 
        this._request = null, this._item = null, this._rawResult = null, this._result = null, 
        this._loadItems = null, this.removeAllEventListeners();
    }, b.getLoadedItems = function() {
        return this._loadedItems;
    }, b._createRequest = function() {
        this._request = this._preferXHR ? new createjs.XHRRequest(this._item) : new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
    }, b._createTag = function() {
        return null;
    }, b._sendLoadStart = function() {
        this._isCanceled() || this.dispatchEvent("loadstart");
    }, b._sendProgress = function(a) {
        if (!this._isCanceled()) {
            var b = null;
            "number" == typeof a ? (this.progress = a, b = new createjs.ProgressEvent(this.progress)) : (b = a, 
            this.progress = a.loaded / a.total, b.progress = this.progress, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0)), 
            this.hasEventListener("progress") && this.dispatchEvent(b);
        }
    }, b._sendComplete = function() {
        if (!this._isCanceled()) {
            this.loaded = !0;
            var a = new createjs.Event("complete");
            a.rawResult = this._rawResult, null != this._result && (a.result = this._result), 
            this.dispatchEvent(a);
        }
    }, b._sendError = function(a) {
        !this._isCanceled() && this.hasEventListener("error") && (null == a && (a = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY")), 
        this.dispatchEvent(a));
    }, b._isCanceled = function() {
        return null == window.createjs || this.canceled ? !0 : !1;
    }, b.resultFormatter = null, b.handleEvent = function(a) {
        switch (a.type) {
          case "complete":
            this._rawResult = a.target._response;
            var b = this.resultFormatter && this.resultFormatter(this), c = this;
            b instanceof Function ? b(function(a) {
                c._result = a, c._sendComplete();
            }) : (this._result = b || this._rawResult, this._sendComplete());
            break;

          case "progress":
            this._sendProgress(a);
            break;

          case "error":
            this._sendError(a);
            break;

          case "loadstart":
            this._sendLoadStart();
            break;

          case "abort":
          case "timeout":
            this._isCanceled() || this.dispatchEvent(a.type);
        }
    }, b.buildPath = function(a, b) {
        return createjs.RequestUtils.buildPath(a, b);
    }, b.toString = function() {
        return "[PreloadJS AbstractLoader]";
    }, createjs.AbstractLoader = createjs.promote(a, "EventDispatcher");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractLoader_constructor(a, b, c), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "src";
    }
    var b = createjs.extend(a, createjs.AbstractLoader);
    b.load = function() {
        this._tag || (this._tag = this._createTag(this._item.src)), this._tag.preload = "auto", 
        this._tag.load(), this.AbstractLoader_load();
    }, b._createTag = function() {}, b._createRequest = function() {
        this._request = this._preferXHR ? new createjs.XHRRequest(this._item) : new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
    }, b._formatResult = function(a) {
        return this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler), 
        this._tag.onstalled = null, this._preferXHR && (a.getTag().src = a.getResult(!0)), 
        a.getTag();
    }, createjs.AbstractMediaLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    var a = function(a) {
        this._item = a;
    }, b = createjs.extend(a, createjs.EventDispatcher);
    b.load = function() {}, b.destroy = function() {}, b.cancel = function() {}, createjs.AbstractRequest = createjs.promote(a, "EventDispatcher");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractRequest_constructor(a), this._tag = b, this._tagSrcAttribute = c, this._loadedHandler = createjs.proxy(this._handleTagComplete, this), 
        this._addedToDOM = !1, this._startTagVisibility = null;
    }
    var b = createjs.extend(a, createjs.AbstractRequest);
    b.load = function() {
        null == this._tag.parentNode && (window.document.body.appendChild(this._tag), this._addedToDOM = !0), 
        this._tag.onload = createjs.proxy(this._handleTagComplete, this), this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
        var a = new createjs.Event("initialize");
        a.loader = this._tag, this.dispatchEvent(a), this._hideTag(), this._tag[this._tagSrcAttribute] = this._item.src;
    }, b.destroy = function() {
        this._clean(), this._tag = null, this.AbstractRequest_destroy();
    }, b._handleReadyStateChange = function() {
        clearTimeout(this._loadTimeout);
        var a = this._tag;
        ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete();
    }, b._handleTagComplete = function() {
        this._rawResult = this._tag, this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult, 
        this._clean(), this._showTag(), this.dispatchEvent("complete");
    }, b._clean = function() {
        this._tag.onload = null, this._tag.onreadystatechange = null, this._addedToDOM && null != this._tag.parentNode && this._tag.parentNode.removeChild(this._tag);
    }, b._hideTag = function() {
        this._startTagVisibility = this._tag.style.visibility, this._tag.style.visibility = "hidden";
    }, b._showTag = function() {
        this._tag.style.visibility = this._startTagVisibility;
    }, b._handleStalled = function() {}, createjs.TagRequest = createjs.promote(a, "AbstractRequest");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractRequest_constructor(a), this._tag = b, this._tagSrcAttribute = c, this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
    }
    var b = createjs.extend(a, createjs.TagRequest);
    b.load = function() {
        this._tag.onstalled = createjs.proxy(this._handleStalled, this), this._tag.onprogress = createjs.proxy(this._handleProgress, this), 
        this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, !1), 
        this.TagRequest_load();
    }, b._handleReadyStateChange = function() {
        clearTimeout(this._loadTimeout);
        var a = this._tag;
        ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete();
    }, b._handleStalled = function() {}, b._handleProgress = function(a) {
        if (a && !(a.loaded > 0 && 0 == a.total)) {
            var b = new createjs.ProgressEvent(a.loaded, a.total);
            this.dispatchEvent(b);
        }
    }, b._clean = function() {
        this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler), 
        this._tag.onstalled = null, this._tag.onprogress = null, this.TagRequest__clean();
    }, createjs.MediaTagRequest = createjs.promote(a, "TagRequest");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractRequest_constructor(a), this._request = null, this._loadTimeout = null, 
        this._xhrLevel = 1, this._response = null, this._rawResponse = null, this._canceled = !1, 
        this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this), this._handleProgressProxy = createjs.proxy(this._handleProgress, this), 
        this._handleAbortProxy = createjs.proxy(this._handleAbort, this), this._handleErrorProxy = createjs.proxy(this._handleError, this), 
        this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this), this._handleLoadProxy = createjs.proxy(this._handleLoad, this), 
        this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this), 
        !this._createXHR(a);
    }
    var b = createjs.extend(a, createjs.AbstractRequest);
    a.ACTIVEX_VERSIONS = [ "Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP" ], 
    b.getResult = function(a) {
        return a && this._rawResponse ? this._rawResponse : this._response;
    }, b.cancel = function() {
        this.canceled = !0, this._clean(), this._request.abort();
    }, b.load = function() {
        if (null == this._request) return void this._handleError();
        this._request.addEventListener("loadstart", this._handleLoadStartProxy, !1), this._request.addEventListener("progress", this._handleProgressProxy, !1), 
        this._request.addEventListener("abort", this._handleAbortProxy, !1), this._request.addEventListener("error", this._handleErrorProxy, !1), 
        this._request.addEventListener("timeout", this._handleTimeoutProxy, !1), this._request.addEventListener("load", this._handleLoadProxy, !1), 
        this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, !1), 
        1 == this._xhrLevel && (this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout));
        try {
            this._item.values && this._item.method != createjs.AbstractLoader.GET ? this._item.method == createjs.AbstractLoader.POST && this._request.send(createjs.RequestUtils.formatQueryString(this._item.values)) : this._request.send();
        } catch (a) {
            this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, a));
        }
    }, b.setResponseType = function(a) {
        this._request.responseType = a;
    }, b.getAllResponseHeaders = function() {
        return this._request.getAllResponseHeaders instanceof Function ? this._request.getAllResponseHeaders() : null;
    }, b.getResponseHeader = function(a) {
        return this._request.getResponseHeader instanceof Function ? this._request.getResponseHeader(a) : null;
    }, b._handleProgress = function(a) {
        if (a && !(a.loaded > 0 && 0 == a.total)) {
            var b = new createjs.ProgressEvent(a.loaded, a.total);
            this.dispatchEvent(b);
        }
    }, b._handleLoadStart = function() {
        clearTimeout(this._loadTimeout), this.dispatchEvent("loadstart");
    }, b._handleAbort = function(a) {
        this._clean(), this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, a));
    }, b._handleError = function(a) {
        this._clean(), this.dispatchEvent(new createjs.ErrorEvent(a.message));
    }, b._handleReadyStateChange = function() {
        4 == this._request.readyState && this._handleLoad();
    }, b._handleLoad = function() {
        if (!this.loaded) {
            this.loaded = !0;
            var a = this._checkError();
            if (a) return void this._handleError(a);
            this._response = this._getResponse(), this._clean(), this.dispatchEvent(new createjs.Event("complete"));
        }
    }, b._handleTimeout = function(a) {
        this._clean(), this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, a));
    }, b._checkError = function() {
        var a = parseInt(this._request.status);
        switch (a) {
          case 404:
          case 0:
            return new Error(a);
        }
        return null;
    }, b._getResponse = function() {
        if (null != this._response) return this._response;
        if (null != this._request.response) return this._request.response;
        try {
            if (null != this._request.responseText) return this._request.responseText;
        } catch (a) {}
        try {
            if (null != this._request.responseXML) return this._request.responseXML;
        } catch (a) {}
        return null;
    }, b._createXHR = function(a) {
        var b = createjs.RequestUtils.isCrossDomain(a), c = {}, d = null;
        if (window.XMLHttpRequest) d = new XMLHttpRequest(), b && void 0 === d.withCredentials && window.XDomainRequest && (d = new XDomainRequest()); else {
            for (var e = 0, f = s.ACTIVEX_VERSIONS.length; f > e; e++) {
                s.ACTIVEX_VERSIONS[e];
                try {
                    d = new ActiveXObject(axVersions);
                    break;
                } catch (g) {}
            }
            if (null == d) return !1;
        }
        a.mimeType && d.overrideMimeType && d.overrideMimeType(a.mimeType), this._xhrLevel = "string" == typeof d.responseType ? 2 : 1;
        var h = null;
        if (h = a.method == createjs.AbstractLoader.GET ? createjs.RequestUtils.buildPath(a.src, a.values) : a.src, 
        d.open(a.method || createjs.AbstractLoader.GET, h, !0), b && d instanceof XMLHttpRequest && 1 == this._xhrLevel && (c.Origin = location.origin), 
        a.values && a.method == createjs.AbstractLoader.POST && (c["Content-Type"] = "application/x-www-form-urlencoded"), 
        b || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest"), a.headers) for (var i in a.headers) c[i] = a.headers[i];
        for (i in c) d.setRequestHeader(i, c[i]);
        return d instanceof XMLHttpRequest && void 0 !== a.withCredentials && (d.withCredentials = a.withCredentials), 
        this._request = d, !0;
    }, b._clean = function() {
        clearTimeout(this._loadTimeout), this._request.removeEventListener("loadstart", this._handleLoadStartProxy), 
        this._request.removeEventListener("progress", this._handleProgressProxy), this._request.removeEventListener("abort", this._handleAbortProxy), 
        this._request.removeEventListener("error", this._handleErrorProxy), this._request.removeEventListener("timeout", this._handleTimeoutProxy), 
        this._request.removeEventListener("load", this._handleLoadProxy), this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
    }, b.toString = function() {
        return "[PreloadJS XHRRequest]";
    }, createjs.XHRRequest = createjs.promote(a, "AbstractRequest");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b, c) {
        this.AbstractLoader_constructor(), this.init(a, b, c);
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    b.init = function(a, b, c) {
        this.useXHR = !0, this.preferXHR = !0, this._preferXHR = !0, this.setPreferXHR(a), 
        this.stopOnError = !1, this.maintainScriptOrder = !0, this.next = null, this._paused = !1, 
        this._basePath = b, this._crossOrigin = c, this._typeCallbacks = {}, this._extensionCallbacks = {}, 
        this._loadStartWasDispatched = !1, this._maxConnections = 1, this._currentlyLoadingScript = null, 
        this._currentLoads = [], this._loadQueue = [], this._loadQueueBackup = [], this._loadItemsById = {}, 
        this._loadItemsBySrc = {}, this._loadedResults = {}, this._loadedRawResults = {}, 
        this._numItems = 0, this._numItemsLoaded = 0, this._scriptOrder = [], this._loadedScripts = [], 
        this._lastProgress = 0/0, this._availableLoaders = [ createjs.ImageLoader, createjs.JavaScriptLoader, createjs.CSSLoader, createjs.JSONLoader, createjs.JSONPLoader, createjs.SoundLoader, createjs.ManifestLoader, createjs.SpriteSheetLoader, createjs.XMLLoader, createjs.SVGLoader, createjs.BinaryLoader, createjs.VideoLoader, createjs.TextLoader ], 
        this._defaultLoaderLength = this._availableLoaders.length;
    }, c.loadTimeout = 8e3, c.LOAD_TIMEOUT = 0, c.BINARY = createjs.AbstractLoader.BINARY, 
    c.CSS = createjs.AbstractLoader.CSS, c.IMAGE = createjs.AbstractLoader.IMAGE, c.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT, 
    c.JSON = createjs.AbstractLoader.JSON, c.JSONP = createjs.AbstractLoader.JSONP, 
    c.MANIFEST = createjs.AbstractLoader.MANIFEST, c.SOUND = createjs.AbstractLoader.SOUND, 
    c.VIDEO = createjs.AbstractLoader.VIDEO, c.SVG = createjs.AbstractLoader.SVG, c.TEXT = createjs.AbstractLoader.TEXT, 
    c.XML = createjs.AbstractLoader.XML, c.POST = createjs.AbstractLoader.POST, c.GET = createjs.AbstractLoader.GET, 
    b.registerLoader = function(a) {
        if (!a || !a.canLoadItem) throw new Error("loader is of an incorrect type.");
        if (-1 != this._availableLoaders.indexOf(a)) throw new Error("loader already exists.");
        this._availableLoaders.unshift(a);
    }, b.unregisterLoader = function(a) {
        var b = this._availableLoaders.indexOf(a);
        -1 != b && b < this._defaultLoaderLength - 1 && this._availableLoaders.splice(b, 1);
    }, b.setUseXHR = function(a) {
        return this.setPreferXHR(a);
    }, b.setPreferXHR = function(a) {
        return this.preferXHR = 0 != a && null != window.XMLHttpRequest, this.preferXHR;
    }, b.removeAll = function() {
        this.remove();
    }, b.remove = function(a) {
        var b = null;
        if (!a || a instanceof Array) {
            if (a) b = a; else if (arguments.length > 0) return;
        } else b = [ a ];
        var c = !1;
        if (b) {
            for (;b.length; ) {
                var d = b.pop(), e = this.getResult(d);
                for (f = this._loadQueue.length - 1; f >= 0; f--) if (g = this._loadQueue[f].getItem(), 
                g.id == d || g.src == d) {
                    this._loadQueue.splice(f, 1)[0].cancel();
                    break;
                }
                for (f = this._loadQueueBackup.length - 1; f >= 0; f--) if (g = this._loadQueueBackup[f].getItem(), 
                g.id == d || g.src == d) {
                    this._loadQueueBackup.splice(f, 1)[0].cancel();
                    break;
                }
                if (e) delete this._loadItemsById[e.id], delete this._loadItemsBySrc[e.src], this._disposeItem(e); else for (var f = this._currentLoads.length - 1; f >= 0; f--) {
                    var g = this._currentLoads[f].getItem();
                    if (g.id == d || g.src == d) {
                        this._currentLoads.splice(f, 1)[0].cancel(), c = !0;
                        break;
                    }
                }
            }
            c && this._loadNext();
        } else {
            this.close();
            for (var h in this._loadItemsById) this._disposeItem(this._loadItemsById[h]);
            this.init(this.preferXHR, this._basePath);
        }
    }, b.reset = function() {
        this.close();
        for (var a in this._loadItemsById) this._disposeItem(this._loadItemsById[a]);
        for (var b = [], c = 0, d = this._loadQueueBackup.length; d > c; c++) b.push(this._loadQueueBackup[c].getItem());
        this.loadManifest(b, !1);
    }, b.installPlugin = function(a) {
        if (null != a && null != a.getPreloadHandlers) {
            var b = a.getPreloadHandlers();
            if (b.scope = a, null != b.types) for (var c = 0, d = b.types.length; d > c; c++) this._typeCallbacks[b.types[c]] = b;
            if (null != b.extensions) for (c = 0, d = b.extensions.length; d > c; c++) this._extensionCallbacks[b.extensions[c]] = b;
        }
    }, b.setMaxConnections = function(a) {
        this._maxConnections = a, !this._paused && this._loadQueue.length > 0 && this._loadNext();
    }, b.loadFile = function(a, b, c) {
        if (null == a) {
            var d = new createjs.ErrorEvent("PRELOAD_NO_FILE");
            return void this._sendError(d);
        }
        this._addItem(a, null, c), this.setPaused(b !== !1 ? !1 : !0);
    }, b.loadManifest = function(a, b, d) {
        var e = null, f = null;
        if (a instanceof Array) {
            if (0 == a.length) {
                var g = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
                return void this._sendError(g);
            }
            e = a;
        } else if ("string" == typeof a) e = [ {
            src: a,
            type: c.MANIFEST
        } ]; else {
            if ("object" != typeof a) {
                var g = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
                return void this._sendError(g);
            }
            if (void 0 !== a.src) {
                if (null == a.type) a.type = c.MANIFEST; else if (a.type != c.MANIFEST) {
                    var g = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
                    this._sendError(g);
                }
                e = [ a ];
            } else void 0 !== a.manifest && (e = a.manifest, f = a.path);
        }
        for (var h = 0, i = e.length; i > h; h++) this._addItem(e[h], f, d);
        this.setPaused(b !== !1 ? !1 : !0);
    }, b.load = function() {
        this.setPaused(!1);
    }, b.getItem = function(a) {
        return this._loadItemsById[a] || this._loadItemsBySrc[a];
    }, b.getResult = function(a, b) {
        var c = this._loadItemsById[a] || this._loadItemsBySrc[a];
        if (null == c) return null;
        var d = c.id;
        return b && this._loadedRawResults[d] ? this._loadedRawResults[d] : this._loadedResults[d];
    }, b.getItems = function(a) {
        for (var b = [], c = 0, d = this._loadQueueBackup.length; d > c; c++) {
            var e = this._loadQueueBackup[c], f = e.getItem();
            (a !== !0 || e.loaded) && b.push({
                item: f,
                result: this.getResult(f.id),
                rawResult: this.getResult(f.id, !0)
            });
        }
        return b;
    }, b.setPaused = function(a) {
        this._paused = a, this._paused || this._loadNext();
    }, b.close = function() {
        for (;this._currentLoads.length; ) this._currentLoads.pop().cancel();
        this._scriptOrder.length = 0, this._loadedScripts.length = 0, this.loadStartWasDispatched = !1, 
        this._itemCount = 0, this._lastProgress = 0/0;
    }, b._addItem = function(a, b, c) {
        var d = this._createLoadItem(a, b, c);
        if (null != d) {
            var e = this._createLoader(d);
            null != e && (d._loader = e, this._loadQueue.push(e), this._loadQueueBackup.push(e), 
            this._numItems++, this._updateProgress(), (this.maintainScriptOrder && d.type == createjs.LoadQueue.JAVASCRIPT || d.maintainOrder === !0) && (this._scriptOrder.push(d), 
            this._loadedScripts.push(null)));
        }
    }, b._createLoadItem = function(a, b, d) {
        var e = createjs.LoadItem.create(a);
        if (null == e) return null;
        var f = createjs.RequestUtils.parseURI(e.src);
        f.extension && (e.ext = f.extension), null == e.type && (e.type = createjs.RequestUtils.getTypeByExtension(e.ext));
        var g = "", h = d || this._basePath, i = e.src;
        if (!f.absolute && !f.relative) if (b) {
            g = b;
            var j = createjs.RequestUtils.parseURI(b);
            i = b + i, null == h || j.absolute || j.relative || (g = h + g);
        } else null != h && (g = h);
        e.src = g + e.src, e.path = g, (void 0 === e.id || null === e.id || "" === e.id) && (e.id = i);
        var k = this._typeCallbacks[e.type] || this._extensionCallbacks[e.ext];
        if (k) {
            var l = k.callback.call(k.scope, e, this);
            if (l === !1) return null;
            l === !0 || null != l && (e._loader = l), f = createjs.RequestUtils.parseURI(e.src), 
            null != f.extension && (e.ext = f.extension);
        }
        return this._loadItemsById[e.id] = e, this._loadItemsBySrc[e.src] = e, null == e.loadTimeout && (e.loadTimeout = c.loadTimeout), 
        null == e.crossOrigin && (e.crossOrigin = this._crossOrigin), e;
    }, b._createLoader = function(a) {
        if (null != a._loader) return a._loader;
        for (var b = this.preferXHR, c = 0; c < this._availableLoaders.length; c++) {
            var d = this._availableLoaders[c];
            if (d && d.canLoadItem(a)) return new d(a, b);
        }
        return null;
    }, b._loadNext = function() {
        if (!this._paused) {
            this._loadStartWasDispatched || (this._sendLoadStart(), this._loadStartWasDispatched = !0), 
            this._numItems == this._numItemsLoaded ? (this.loaded = !0, this._sendComplete(), 
            this.next && this.next.load && this.next.load()) : this.loaded = !1;
            for (var a = 0; a < this._loadQueue.length && !(this._currentLoads.length >= this._maxConnections); a++) {
                var b = this._loadQueue[a];
                this._canStartLoad(b) && (this._loadQueue.splice(a, 1), a--, this._loadItem(b));
            }
        }
    }, b._loadItem = function(a) {
        a.on("fileload", this._handleFileLoad, this), a.on("progress", this._handleProgress, this), 
        a.on("complete", this._handleFileComplete, this), a.on("error", this._handleError, this), 
        a.on("fileerror", this._handleFileError, this), this._currentLoads.push(a), this._sendFileStart(a.getItem()), 
        a.load();
    }, b._handleFileLoad = function(a) {
        a.target = null, this.dispatchEvent(a);
    }, b._handleFileError = function(a) {
        var b = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, a.item);
        this._sendError(b);
    }, b._handleError = function(a) {
        var b = a.target;
        this._numItemsLoaded++, this._finishOrderedItem(b, !0), this._updateProgress();
        var c = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, b.getItem());
        this._sendError(c), this.stopOnError || (this._removeLoadItem(b), this._loadNext());
    }, b._handleFileComplete = function(a) {
        var b = a.target, c = b.getItem(), d = b.getResult();
        this._loadedResults[c.id] = d;
        var e = b.getResult(!0);
        null != e && e !== d && (this._loadedRawResults[c.id] = e), this._saveLoadedItems(b), 
        this._removeLoadItem(b), this._finishOrderedItem(b) || this._processFinishedLoad(c, b);
    }, b._saveLoadedItems = function(a) {
        var b = a.getLoadedItems();
        if (null !== b) for (var c = 0; c < b.length; c++) {
            var d = b[c].item;
            this._loadItemsBySrc[d.src] = d, this._loadItemsById[d.id] = d, this._loadedResults[d.id] = b[c].result, 
            this._loadedRawResults[d.id] = b[c].rawResult;
        }
    }, b._finishOrderedItem = function(a, b) {
        var c = a.getItem();
        if (this.maintainScriptOrder && c.type == createjs.LoadQueue.JAVASCRIPT || c.maintainOrder) {
            a instanceof createjs.JavaScriptLoader && (this._currentlyLoadingScript = !1);
            var d = createjs.indexOf(this._scriptOrder, c);
            return -1 == d ? !1 : (this._loadedScripts[d] = b === !0 ? !0 : c, this._checkScriptLoadOrder(), 
            !0);
        }
        return !1;
    }, b._checkScriptLoadOrder = function() {
        for (var a = this._loadedScripts.length, b = 0; a > b; b++) {
            var c = this._loadedScripts[b];
            if (null === c) break;
            if (c !== !0) {
                var d = this._loadedResults[c.id];
                c.type == createjs.LoadQueue.JAVASCRIPT && (document.body || document.getElementsByTagName("body")[0]).appendChild(d);
                var e = c._loader;
                this._processFinishedLoad(c, e), this._loadedScripts[b] = !0;
            }
        }
    }, b._processFinishedLoad = function(a, b) {
        this._numItemsLoaded++, this._updateProgress(), this._sendFileComplete(a, b), this._loadNext();
    }, b._canStartLoad = function(a) {
        if (!this.maintainScriptOrder || a.preferXHR) return !0;
        var b = a.getItem();
        if (b.type != createjs.LoadQueue.JAVASCRIPT) return !0;
        if (this._currentlyLoadingScript) return !1;
        for (var c = this._scriptOrder.indexOf(b), d = 0; c > d; ) {
            var e = this._loadedScripts[d];
            if (null == e) return !1;
            d++;
        }
        return this._currentlyLoadingScript = !0, !0;
    }, b._removeLoadItem = function(a) {
        var b = a.getItem();
        delete b._loader;
        for (var c = this._currentLoads.length, d = 0; c > d; d++) if (this._currentLoads[d] == a) {
            this._currentLoads.splice(d, 1);
            break;
        }
    }, b._handleProgress = function(a) {
        var b = a.target;
        this._sendFileProgress(b.getItem(), b.progress), this._updateProgress();
    }, b._updateProgress = function() {
        var a = this._numItemsLoaded / this._numItems, b = this._numItems - this._numItemsLoaded;
        if (b > 0) {
            for (var c = 0, d = 0, e = this._currentLoads.length; e > d; d++) c += this._currentLoads[d].progress;
            a += c / b * (b / this._numItems);
        }
        this._lastProgress != a && (this._sendProgress(a), this._lastProgress = a);
    }, b._disposeItem = function(a) {
        delete this._loadedResults[a.id], delete this._loadedRawResults[a.id], delete this._loadItemsById[a.id], 
        delete this._loadItemsBySrc[a.src];
    }, b._sendFileProgress = function(a, b) {
        if (this._isCanceled()) return void this._cleanUp();
        if (this.hasEventListener("fileprogress")) {
            var c = new createjs.Event("fileprogress");
            c.progress = b, c.loaded = b, c.total = 1, c.item = a, this.dispatchEvent(c);
        }
    }, b._sendFileComplete = function(a, b) {
        if (!this._isCanceled()) {
            var c = new createjs.Event("fileload");
            c.loader = b, c.item = a, c.result = this._loadedResults[a.id], c.rawResult = this._loadedRawResults[a.id], 
            a.completeHandler && a.completeHandler(c), this.hasEventListener("fileload") && this.dispatchEvent(c);
        }
    }, b._sendFileStart = function(a) {
        var b = new createjs.Event("filestart");
        b.item = a, this.hasEventListener("filestart") && this.dispatchEvent(b);
    }, b.toString = function() {
        return "[PreloadJS LoadQueue]";
    }, createjs.LoadQueue = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.TEXT);
    }
    var b = (createjs.extend(a, createjs.AbstractLoader), a);
    b.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.TEXT;
    }, createjs.TextLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.BINARY), this.on("initialize", this._updateXHR, this);
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.BINARY;
    }, b._updateXHR = function(a) {
        a.loader.setResponseType("arraybuffer");
    }, createjs.BinaryLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.CSS), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "href", this._tag = document.createElement(b ? "style" : "link"), 
        this._tag.rel = "stylesheet", this._tag.type = "text/css";
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.CSS;
    }, b._formatResult = function(a) {
        if (this._preferXHR) {
            var b = a.getTag(), c = document.getElementsByTagName("head")[0];
            if (c.appendChild(b), b.styleSheet) b.styleSheet.cssText = a.getResult(!0); else {
                var d = document.createTextNode(a.getResult(!0));
                b.appendChild(d);
            }
        } else b = this._tag;
        return b;
    }, createjs.CSSLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.IMAGE), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "src", createjs.RequestUtils.isImageTag(a) ? this._tag = a : createjs.RequestUtils.isImageTag(a.src) ? this._tag = a.src : createjs.RequestUtils.isImageTag(a.tag) && (this._tag = a.tag), 
        null != this._tag ? this._preferXHR = !1 : this._tag = document.createElement("img"), 
        this.on("initialize", this._updateXHR, this);
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.IMAGE;
    }, b.load = function() {
        if ("" != this._tag.src && this._tag.complete) return void this._sendComplete();
        var a = this._item.crossOrigin;
        1 == a && (a = "Anonymous"), null == a || createjs.RequestUtils.isLocal(this._item.src) || (this._tag.crossOrigin = a), 
        this.AbstractLoader_load();
    }, b._updateXHR = function(a) {
        a.loader.mimeType = "text/plain; charset=x-user-defined-binary", a.loader.setResponseType && a.loader.setResponseType("blob");
    }, b._formatResult = function(a) {
        var b = this;
        return function(c) {
            var d = b._tag, e = window.URL || window.webkitURL;
            if (b._preferXHR) if (e) {
                var f = e.createObjectURL(a.getResult(!0));
                d.src = f, d.onload = function() {
                    e.revokeObjectURL(b.src);
                };
            } else d.src = a.getItem().src;
            d.complete ? c(d) : d.onload = function() {
                c(this);
            };
        };
    }, createjs.ImageLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.JAVASCRIPT), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "src", this.setTag(document.createElement("script"));
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.JAVASCRIPT;
    }, b._formatResult = function(a) {
        var b = a.getTag();
        return this._preferXHR && (b.text = a.getResult(!0)), b;
    }, createjs.JavaScriptLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.JSON), this.resultFormatter = this._formatResult;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.JSON && !a._loadAsJSONP;
    }, b._formatResult = function(a) {
        var b = null;
        try {
            b = createjs.DataUtils.parseJSON(a.getResult(!0));
        } catch (c) {
            var d = new createjs.ErrorEvent("JSON_FORMAT", null, c);
            return this._sendError(d), c;
        }
        return b;
    }, createjs.JSONLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !1, createjs.AbstractLoader.JSONP), this.setTag(document.createElement("script")), 
        this.getTag().type = "text/javascript";
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.JSONP || a._loadAsJSONP;
    }, b.cancel = function() {
        this.AbstractLoader_cancel(), this._dispose();
    }, b.load = function() {
        if (null == this._item.callback) throw new Error("callback is required for loading JSONP requests.");
        if (null != window[this._item.callback]) throw new Error("JSONP callback '" + this._item.callback + "' already exists on window. You need to specify a different callback or re-name the current one.");
        window[this._item.callback] = createjs.proxy(this._handleLoad, this), window.document.body.appendChild(this._tag), 
        this._tag.src = this._item.src;
    }, b._handleLoad = function(a) {
        this._result = this._rawResult = a, this._sendComplete(), this._dispose();
    }, b._dispose = function() {
        window.document.body.removeChild(this._tag), delete window[this._item.callback];
    }, createjs.JSONPLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, null, createjs.AbstractLoader.MANIFEST), this._manifestQueue = null;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.MANIFEST_PROGRESS = .25, c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.MANIFEST;
    }, b.load = function() {
        this.AbstractLoader_load();
    }, b._createRequest = function() {
        var a = this._item.callback;
        this._request = null != a ? new createjs.JSONPLoader(this._item) : new createjs.JSONLoader(this._item);
    }, b.handleEvent = function(a) {
        switch (a.type) {
          case "complete":
            return this._rawResult = a.target.getResult(!0), this._result = a.target.getResult(), 
            this._sendProgress(c.MANIFEST_PROGRESS), void this._loadManifest(this._result);

          case "progress":
            return a.loaded *= c.MANIFEST_PROGRESS, this.progress = a.loaded / a.total, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0), 
            void this._sendProgress(a);
        }
        this.AbstractLoader_handleEvent(a);
    }, b.destroy = function() {
        this.AbstractLoader_destroy(), this._manifestQueue.close();
    }, b._loadManifest = function(a) {
        if (a && a.manifest) {
            var b = this._manifestQueue = new createjs.LoadQueue();
            b.on("fileload", this._handleManifestFileLoad, this), b.on("progress", this._handleManifestProgress, this), 
            b.on("complete", this._handleManifestComplete, this, !0), b.on("error", this._handleManifestError, this, !0), 
            b.loadManifest(a);
        } else this._sendComplete();
    }, b._handleManifestFileLoad = function(a) {
        a.target = null, this.dispatchEvent(a);
    }, b._handleManifestComplete = function() {
        this._loadedItems = this._manifestQueue.getItems(!0), this._sendComplete();
    }, b._handleManifestProgress = function(a) {
        this.progress = a.progress * (1 - c.MANIFEST_PROGRESS) + c.MANIFEST_PROGRESS, this._sendProgress(this.progress);
    }, b._handleManifestError = function(a) {
        var b = new createjs.Event("fileerror");
        b.item = a.data, this.dispatchEvent(b);
    }, createjs.ManifestLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractMediaLoader_constructor(a, b, createjs.AbstractLoader.SOUND), createjs.RequestUtils.isAudioTag(a) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.src) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.tag) && (this._tag = createjs.RequestUtils.isAudioTag(a) ? a : a.src), 
        null != this._tag && (this._preferXHR = !1);
    }
    var b = createjs.extend(a, createjs.AbstractMediaLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.SOUND;
    }, b._createTag = function(a) {
        var b = document.createElement("audio");
        return b.autoplay = !1, b.preload = "none", b.src = a, b;
    }, createjs.SoundLoader = createjs.promote(a, "AbstractMediaLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractMediaLoader_constructor(a, b, createjs.AbstractLoader.VIDEO), createjs.RequestUtils.isVideoTag(a) || createjs.RequestUtils.isVideoTag(a.src) ? (this.setTag(createjs.RequestUtils.isVideoTag(a) ? a : a.src), 
        this._preferXHR = !1) : this.setTag(this._createTag());
    }
    var b = createjs.extend(a, createjs.AbstractMediaLoader), c = a;
    b._createTag = function() {
        return document.createElement("video");
    }, c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.VIDEO;
    }, createjs.VideoLoader = createjs.promote(a, "AbstractMediaLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, null, createjs.AbstractLoader.SPRITESHEET), this._manifestQueue = null;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.SPRITESHEET_PROGRESS = .25, c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.SPRITESHEET;
    }, b.destroy = function() {
        this.AbstractLoader_destroy, this._manifestQueue.close();
    }, b._createRequest = function() {
        var a = this._item.callback;
        this._request = null != a && a instanceof Function ? new createjs.JSONPLoader(this._item) : new createjs.JSONLoader(this._item);
    }, b.handleEvent = function(a) {
        switch (a.type) {
          case "complete":
            return this._rawResult = a.target.getResult(!0), this._result = a.target.getResult(), 
            this._sendProgress(c.SPRITESHEET_PROGRESS), void this._loadManifest(this._result);

          case "progress":
            return a.loaded *= c.SPRITESHEET_PROGRESS, this.progress = a.loaded / a.total, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0), 
            void this._sendProgress(a);
        }
        this.AbstractLoader_handleEvent(a);
    }, b._loadManifest = function(a) {
        if (a && a.images) {
            var b = this._manifestQueue = new createjs.LoadQueue();
            b.on("complete", this._handleManifestComplete, this, !0), b.on("fileload", this._handleManifestFileLoad, this), 
            b.on("progress", this._handleManifestProgress, this), b.on("error", this._handleManifestError, this, !0), 
            b.loadManifest(a.images);
        }
    }, b._handleManifestFileLoad = function(a) {
        var b = a.result;
        if (null != b) {
            var c = this.getResult().images, d = c.indexOf(a.item.src);
            c[d] = b;
        }
    }, b._handleManifestComplete = function() {
        this._result = new createjs.SpriteSheet(this._result), this._loadedItems = this._manifestQueue.getItems(!0), 
        this._sendComplete();
    }, b._handleManifestProgress = function(a) {
        this.progress = a.progress * (1 - c.SPRITESHEET_PROGRESS) + c.SPRITESHEET_PROGRESS, 
        this._sendProgress(this.progress);
    }, b._handleManifestError = function(a) {
        var b = new createjs.Event("fileerror");
        b.item = a.data, this.dispatchEvent(b);
    }, createjs.SpriteSheetLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a, b) {
        this.AbstractLoader_constructor(a, b, createjs.AbstractLoader.SVG), this.resultFormatter = this._formatResult, 
        this._tagSrcAttribute = "data", b ? this.setTag(document.createElement("svg")) : (this.setTag(document.createElement("object")), 
        this.getTag().type = "image/svg+xml"), this.getTag().style.visibility = "hidden";
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.SVG;
    }, b._formatResult = function(a) {
        var b = createjs.DataUtils.parseXML(a.getResult(!0), "text/xml"), c = a.getTag();
        return !this._preferXHR && document.body.contains(c) && document.body.removeChild(c), 
        null != b.documentElement ? (c.appendChild(b.documentElement), c.style.visibility = "visible", 
        c) : b;
    }, createjs.SVGLoader = createjs.promote(a, "AbstractLoader");
}(), this.createjs = this.createjs || {}, function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.XML), this.resultFormatter = this._formatResult;
    }
    var b = createjs.extend(a, createjs.AbstractLoader), c = a;
    c.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.XML;
    }, b._formatResult = function(a) {
        return createjs.DataUtils.parseXML(a.getResult(!0), "text/xml");
    }, createjs.XMLLoader = createjs.promote(a, "AbstractLoader");
}(), function(a) {
    function b(a, b, c, d, e) {
        this._listener = b, this._isOnce = c, this.context = d, this._signal = a, this._priority = e || 0;
    }
    function c(a, b) {
        if ("function" != typeof a) throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
    }
    function d() {
        this._bindings = [], this._prevParams = null;
        var a = this;
        this.dispatch = function() {
            d.prototype.dispatch.apply(a, arguments);
        };
    }
    b.prototype = {
        active: !0,
        params: null,
        execute: function(a) {
            var b, c;
            return this.active && this._listener && (c = this.params ? this.params.concat(a) : a, 
            b = this._listener.apply(this.context, c), this._isOnce && this.detach()), b;
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function() {
            return !!this._signal && !!this._listener;
        },
        isOnce: function() {
            return this._isOnce;
        },
        getListener: function() {
            return this._listener;
        },
        getSignal: function() {
            return this._signal;
        },
        _destroy: function() {
            delete this._signal, delete this._listener, delete this.context;
        },
        toString: function() {
            return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
    }, d.prototype = {
        VERSION: "1.0.0",
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _registerListener: function(a, c, d, e) {
            var f, g = this._indexOfListener(a, d);
            if (-1 !== g) {
                if (f = this._bindings[g], f.isOnce() !== c) throw new Error("You cannot add" + (c ? "" : "Once") + "() then add" + (c ? "Once" : "") + "() the same listener without removing the relationship first.");
            } else f = new b(this, a, c, d, e), this._addBinding(f);
            return this.memorize && this._prevParams && f.execute(this._prevParams), f;
        },
        _addBinding: function(a) {
            var b = this._bindings.length;
            do --b; while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
            this._bindings.splice(b + 1, 0, a);
        },
        _indexOfListener: function(a, b) {
            for (var c, d = this._bindings.length; d--; ) if (c = this._bindings[d], c._listener === a && c.context === b) return d;
            return -1;
        },
        has: function(a, b) {
            return -1 !== this._indexOfListener(a, b);
        },
        add: function(a, b, d) {
            return c(a, "add"), this._registerListener(a, !1, b, d);
        },
        addOnce: function(a, b, d) {
            return c(a, "addOnce"), this._registerListener(a, !0, b, d);
        },
        remove: function(a, b) {
            c(a, "remove");
            var d = this._indexOfListener(a, b);
            return -1 !== d && (this._bindings[d]._destroy(), this._bindings.splice(d, 1)), 
            a;
        },
        removeAll: function() {
            for (var a = this._bindings.length; a--; ) this._bindings[a]._destroy();
            this._bindings.length = 0;
        },
        getNumListeners: function() {
            return this._bindings.length;
        },
        halt: function() {
            this._shouldPropagate = !1;
        },
        dispatch: function() {
            if (this.active) {
                var a, b = Array.prototype.slice.call(arguments), c = this._bindings.length;
                if (this.memorize && (this._prevParams = b), c) {
                    a = this._bindings.slice(), this._shouldPropagate = !0;
                    do c--; while (a[c] && this._shouldPropagate && a[c].execute(b) !== !1);
                }
            }
        },
        forget: function() {
            this._prevParams = null;
        },
        dispose: function() {
            this.removeAll(), delete this._bindings, delete this._prevParams;
        },
        toString: function() {
            return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
    };
    var e = d;
    e.Signal = d, "function" == typeof define && define.amd ? define(function() {
        return e;
    }) : "undefined" != typeof module && module.exports ? module.exports = e : a.signals = e;
}(this);

var Stats = function() {
    var a = Date.now(), b = a, c = 0, d = 1/0, e = 0, f = 0, g = 1/0, h = 0, i = 0, j = 0, k = document.createElement("div");
    k.id = "stats", k.addEventListener("mousedown", function(a) {
        a.preventDefault(), s(++j % 2);
    }, !1), k.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var l = document.createElement("div");
    l.id = "fps", l.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002", 
    k.appendChild(l);
    var m = document.createElement("div");
    m.id = "fpsText", m.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    m.innerHTML = "FPS", l.appendChild(m);
    var n = document.createElement("div");
    for (n.id = "fpsGraph", n.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff", 
    l.appendChild(n); 74 > n.children.length; ) {
        var o = document.createElement("span");
        o.style.cssText = "width:1px;height:30px;float:left;background-color:#113", n.appendChild(o);
    }
    var p = document.createElement("div");
    p.id = "ms", p.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none", 
    k.appendChild(p);
    var q = document.createElement("div");
    q.id = "msText", q.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    q.innerHTML = "MS", p.appendChild(q);
    var r = document.createElement("div");
    for (r.id = "msGraph", r.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0", 
    p.appendChild(r); 74 > r.children.length; ) o = document.createElement("span"), 
    o.style.cssText = "width:1px;height:30px;float:left;background-color:#131", r.appendChild(o);
    var s = function(a) {
        switch (j = a) {
          case 0:
            l.style.display = "block", p.style.display = "none";
            break;

          case 1:
            l.style.display = "none", p.style.display = "block";
        }
    };
    return {
        REVISION: 12,
        domElement: k,
        setMode: s,
        begin: function() {
            a = Date.now();
        },
        end: function() {
            var j = Date.now();
            c = j - a, d = Math.min(d, c), e = Math.max(e, c), q.textContent = c + " MS (" + d + "-" + e + ")";
            var k = Math.min(30, 30 - 30 * (c / 200));
            return r.appendChild(r.firstChild).style.height = k + "px", i++, j > b + 1e3 && (f = Math.round(1e3 * i / (j - b)), 
            g = Math.min(g, f), h = Math.max(h, f), m.textContent = f + " FPS (" + g + "-" + h + ")", 
            k = Math.min(30, 30 - 30 * (f / 100)), n.appendChild(n.firstChild).style.height = k + "px", 
            b = j, i = 0), j;
        },
        update: function() {
            a = this.end();
        }
    };
};

"object" == typeof module && (module.exports = Stats);

var THREE = {
    REVISION: "70"
};

"object" == typeof module && (module.exports = THREE), void 0 === Math.sign && (Math.sign = function(a) {
    return 0 > a ? -1 : a > 0 ? 1 : 0;
}), THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
}, THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, 
THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, 
THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, 
THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, 
THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, 
THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, 
THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, 
THREE.ReverseSubtractEquation = 102, THREE.MinEquation = 103, THREE.MaxEquation = 104, 
THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, 
THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, 
THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, 
THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, 
THREE.AddOperation = 2, THREE.UVMapping = 300, THREE.CubeReflectionMapping = 301, 
THREE.CubeRefractionMapping = 302, THREE.EquirectangularReflectionMapping = 303, 
THREE.EquirectangularRefractionMapping = 304, THREE.SphericalReflectionMapping = 305, 
THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, 
THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, 
THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, 
THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, 
THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.UnsignedShort4444Type = 1016, 
THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, 
THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, 
THREE.RGBEFormat = THREE.RGBAFormat, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, 
THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.RGB_PVRTC_4BPPV1_Format = 2100, 
THREE.RGB_PVRTC_2BPPV1_Format = 2101, THREE.RGBA_PVRTC_4BPPV1_Format = 2102, THREE.RGBA_PVRTC_2BPPV1_Format = 2103, 
THREE.Projector = function() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), 
    this.projectVector = function(a, b) {
        console.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b);
    }, this.unprojectVector = function(a, b) {
        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), 
        a.unproject(b);
    }, this.pickingRay = function() {
        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
}, THREE.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), 
    this.domElement = document.createElement("canvas"), this.clear = function() {}, 
    this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {};
}, THREE.Color = function(a) {
    return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a);
}, THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
        return a instanceof THREE.Color ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), 
        this;
    },
    setHex: function(a) {
        return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, 
        this.b = (255 & a) / 255, this;
    },
    setRGB: function(a, b, c) {
        return this.r = a, this.g = b, this.b = c, this;
    },
    setHSL: function(a, b, c) {
        if (0 === b) this.r = this.g = this.b = c; else {
            var d = function(a, b, c) {
                return 0 > c && (c += 1), c > 1 && (c -= 1), 1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + 6 * (b - a) * (2 / 3 - c) : a;
            };
            b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = d(c, b, a + 1 / 3), 
            this.g = d(c, b, a), this.b = d(c, b, a - 1 / 3);
        }
        return this;
    },
    setStyle: function(a) {
        return /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a) ? (a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), 
        this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, 
        this.b = Math.min(255, parseInt(a[3], 10)) / 255, this) : /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a) ? (a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), 
        this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, 
        this.b = Math.min(100, parseInt(a[3], 10)) / 100, this) : /^\#([0-9a-f]{6})$/i.test(a) ? (a = /^\#([0-9a-f]{6})$/i.exec(a), 
        this.setHex(parseInt(a[1], 16)), this) : /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a) ? (a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), 
        this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this) : /^(\w+)$/i.test(a) ? (this.setHex(THREE.ColorKeywords[a]), 
        this) : void 0;
    },
    copy: function(a) {
        return this.r = a.r, this.g = a.g, this.b = a.b, this;
    },
    copyGammaToLinear: function(a) {
        return this.r = a.r * a.r, this.g = a.g * a.g, this.b = a.b * a.b, this;
    },
    copyLinearToGamma: function(a) {
        return this.r = Math.sqrt(a.r), this.g = Math.sqrt(a.g), this.b = Math.sqrt(a.b), 
        this;
    },
    convertGammaToLinear: function() {
        var a = this.r, b = this.g, c = this.b;
        return this.r = a * a, this.g = b * b, this.b = c * c, this;
    },
    convertLinearToGamma: function() {
        return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), 
        this;
    },
    getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(a) {
        a = a || {
            h: 0,
            s: 0,
            l: 0
        };
        var b, c = this.r, d = this.g, e = this.b, f = Math.max(c, d, e), g = Math.min(c, d, e), h = (g + f) / 2;
        if (g === f) g = b = 0; else {
            var i = f - g, g = .5 >= h ? i / (f + g) : i / (2 - f - g);
            switch (f) {
              case c:
                b = (d - e) / i + (e > d ? 6 : 0);
                break;

              case d:
                b = (e - c) / i + 2;
                break;

              case e:
                b = (c - d) / i + 4;
            }
            b /= 6;
        }
        return a.h = b, a.s = g, a.l = h, a;
    },
    getStyle: function() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function(a, b, c) {
        var d = this.getHSL();
        return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this;
    },
    add: function(a) {
        return this.r += a.r, this.g += a.g, this.b += a.b, this;
    },
    addColors: function(a, b) {
        return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this;
    },
    addScalar: function(a) {
        return this.r += a, this.g += a, this.b += a, this;
    },
    multiply: function(a) {
        return this.r *= a.r, this.g *= a.g, this.b *= a.b, this;
    },
    multiplyScalar: function(a) {
        return this.r *= a, this.g *= a, this.b *= a, this;
    },
    lerp: function(a, b) {
        return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, 
        this;
    },
    equals: function(a) {
        return a.r === this.r && a.g === this.g && a.b === this.b;
    },
    fromArray: function(a) {
        return this.r = a[0], this.g = a[1], this.b = a[2], this;
    },
    toArray: function() {
        return [ this.r, this.g, this.b ];
    },
    clone: function() {
        return new THREE.Color().setRGB(this.r, this.g, this.b);
    }
}, THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, THREE.Quaternion = function(a, b, c, d) {
    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1;
}, THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    _x: 0,
    _y: 0,
    _z: 0,
    _w: 0,
    get x() {
        return this._x;
    },
    set x(a) {
        this._x = a, this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(a) {
        this._y = a, this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(a) {
        this._z = a, this.onChangeCallback();
    },
    get w() {
        return this._w;
    },
    set w(a) {
        this._w = a, this.onChangeCallback();
    },
    set: function(a, b, c, d) {
        return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), 
        this;
    },
    copy: function(a) {
        return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), 
        this;
    },
    setFromEuler: function(a, b) {
        if (!1 == a instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2);
        return "XYZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, 
        this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === a.order ? (this._x = f * d * e + c * g * h, 
        this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === a.order ? (this._x = f * d * e - c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === a.order ? (this._x = f * d * e - c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === a.order ? (this._x = f * d * e + c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === a.order && (this._x = f * d * e - c * g * h, 
        this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h), 
        !1 !== b && this.onChangeCallback(), this;
    },
    setFromAxisAngle: function(a, b) {
        var c = b / 2, d = Math.sin(c);
        return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), 
        this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(a) {
        var b = a.elements, c = b[0];
        a = b[4];
        var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], i = b[6], b = b[10], j = c + f + b;
        return j > 0 ? (c = .5 / Math.sqrt(j + 1), this._w = .25 / c, this._x = (i - g) * c, 
        this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), 
        this._w = (i - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), 
        this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), 
        this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + i) / c, this._z = .25 * c), 
        this.onChangeCallback(), this;
    },
    setFromUnitVectors: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector3()), b = c.dot(d) + 1, 1e-6 > b ? (b = 0, 
            Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d), 
            this._x = a.x, this._y = a.y, this._z = a.z, this._w = b, this.normalize(), this;
        };
    }(),
    inverse: function() {
        return this.conjugate().normalize(), this;
    },
    conjugate: function() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
    },
    dot: function(a) {
        return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
        var a = this.length();
        return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, 
        this._y *= a, this._z *= a, this._w *= a), this.onChangeCallback(), this;
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), 
        this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
    },
    multiplyQuaternions: function(a, b) {
        var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, i = b._z, j = b._w;
        return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, 
        this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, 
        this.onChangeCallback(), this;
    },
    multiplyVector3: function(a) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), 
        a.applyQuaternion(this);
    },
    slerp: function(a, b) {
        if (0 === b) return this;
        if (1 === b) return this.copy(a);
        var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
        if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, 
        g = -g) : this.copy(a), g >= 1) return this._w = f, this._x = c, this._y = d, this._z = e, 
        this;
        var h = Math.acos(g), i = Math.sqrt(1 - g * g);
        return .001 > Math.abs(i) ? (this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), 
        this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this) : (g = Math.sin((1 - b) * h) / i, 
        h = Math.sin(b * h) / i, this._w = f * g + this._w * h, this._x = c * g + this._x * h, 
        this._y = d * g + this._y * h, this._z = e * g + this._z * h, this.onChangeCallback(), 
        this);
    },
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], 
        this._w = a[b + 3], this.onChangeCallback(), this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, 
        a[b + 2] = this._z, a[b + 3] = this._w, a;
    },
    onChange: function(a) {
        return this.onChangeCallback = a, this;
    },
    onChangeCallback: function() {},
    clone: function() {
        return new THREE.Quaternion(this._x, this._y, this._z, this._w);
    }
}, THREE.Quaternion.slerp = function(a, b, c, d) {
    return c.copy(a).slerp(b, d);
}, THREE.Vector2 = function(a, b) {
    this.x = a || 0, this.y = b || 0;
}, THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    set: function(a, b) {
        return this.x = a, this.y = b, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this;
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this);
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this;
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this);
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this;
    },
    multiply: function(a) {
        return this.x *= a.x, this.y *= a.y, this;
    },
    multiplyScalar: function(a) {
        return this.x *= a, this.y *= a, this;
    },
    divide: function(a) {
        return this.x /= a.x, this.y /= a.y, this;
    },
    divideScalar: function(a) {
        return 0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0, this;
    },
    min: function(a) {
        return this.x > a.x && (this.x = a.x), this.y > a.y && (this.y = a.y), this;
    },
    max: function(a) {
        return this.x < a.x && (this.x = a.x), this.y < a.y && (this.y = a.y), this;
    },
    clamp: function(a, b) {
        return this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x), this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y), 
        this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector2(), b = new THREE.Vector2()), a.set(c, c), 
            b.set(d, d), this.clamp(a, b);
        };
    }(),
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x;
        return a = this.y - a.y, b * b + a * a;
    },
    setLength: function(a) {
        var b = this.length();
        return 0 !== b && a !== b && this.multiplyScalar(a / b), this;
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this;
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this;
    },
    clone: function() {
        return new THREE.Vector2(this.x, this.y);
    }
}, THREE.Vector3 = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0;
}, THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function(a, b, c) {
        return this.x = a, this.y = b, this.z = c, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setZ: function(a) {
        return this.z = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          case 2:
            this.z = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this.z = a.z, this;
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this.z += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this);
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), 
        this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this);
    },
    multiplyScalar: function(a) {
        return this.x *= a, this.y *= a, this.z *= a, this;
    },
    multiplyVectors: function(a, b) {
        return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
    },
    applyEuler: function() {
        var a;
        return function(b) {
            return !1 == b instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), 
            void 0 === a && (a = new THREE.Quaternion()), this.applyQuaternion(a.setFromEuler(b)), 
            this;
        };
    }(),
    applyAxisAngle: function() {
        var a;
        return function(b, c) {
            return void 0 === a && (a = new THREE.Quaternion()), this.applyQuaternion(a.setFromAxisAngle(b, c)), 
            this;
        };
    }(),
    applyMatrix3: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[3] * c + a[6] * d, this.y = a[1] * b + a[4] * c + a[7] * d, 
        this.z = a[2] * b + a[5] * c + a[8] * d, this;
    },
    applyMatrix4: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12], this.y = a[1] * b + a[5] * c + a[9] * d + a[13], 
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14], this;
    },
    applyProjection: function(a) {
        var b = this.x, c = this.y, d = this.z;
        a = a.elements;
        var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
        return this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e, this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e, 
        this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e, this;
    },
    applyQuaternion: function(a) {
        var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
        a = a.w;
        var h = a * b + f * d - g * c, i = a * c + g * b - e * d, j = a * d + e * c - f * b, b = -e * b - f * c - g * d;
        return this.x = h * a + b * -e + i * -g - j * -f, this.y = i * a + b * -f + j * -e - h * -g, 
        this.z = j * a + b * -g + h * -f - i * -e, this;
    },
    project: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), 
            this.applyProjection(a);
        };
    }(),
    unproject: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), 
            this.applyProjection(a);
        };
    }(),
    transformDirection: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d, this.y = a[1] * b + a[5] * c + a[9] * d, 
        this.z = a[2] * b + a[6] * c + a[10] * d, this.normalize(), this;
    },
    divide: function(a) {
        return this.x /= a.x, this.y /= a.y, this.z /= a.z, this;
    },
    divideScalar: function(a) {
        return 0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0, 
        this;
    },
    min: function(a) {
        return this.x > a.x && (this.x = a.x), this.y > a.y && (this.y = a.y), this.z > a.z && (this.z = a.z), 
        this;
    },
    max: function(a) {
        return this.x < a.x && (this.x = a.x), this.y < a.y && (this.y = a.y), this.z < a.z && (this.z = a.z), 
        this;
    },
    clamp: function(a, b) {
        return this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x), this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y), 
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z), this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3()), a.set(c, c, c), 
            b.set(d, d, d), this.clamp(a, b);
        };
    }(),
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
        this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
        this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
        this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(a) {
        var b = this.length();
        return 0 !== b && a !== b && this.multiplyScalar(a / b), this;
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
        this;
    },
    cross: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), 
        this.crossVectors(a, b);
        var c = this.x, d = this.y, e = this.z;
        return this.x = d * a.z - e * a.y, this.y = e * a.x - c * a.z, this.z = c * a.y - d * a.x, 
        this;
    },
    crossVectors: function(a, b) {
        var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
        return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this;
    },
    projectOnVector: function() {
        var a, b;
        return function(c) {
            return void 0 === a && (a = new THREE.Vector3()), a.copy(c).normalize(), b = this.dot(a), 
            this.copy(a).multiplyScalar(b);
        };
    }(),
    projectOnPlane: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Vector3()), a.copy(this).projectOnVector(b), 
            this.sub(a);
        };
    }(),
    reflect: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Vector3()), this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
        };
    }(),
    angleTo: function(a) {
        return a = this.dot(a) / (this.length() * a.length()), Math.acos(THREE.Math.clamp(a, -1, 1));
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x, c = this.y - a.y;
        return a = this.z - a.z, b * b + c * c + a * a;
    },
    setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(a) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), 
        this.setFromMatrixPosition(a);
    },
    getScaleFromMatrix: function(a) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), 
        this.setFromMatrixScale(a);
    },
    getColumnFromMatrix: function(a, b) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), 
        this.setFromMatrixColumn(a, b);
    },
    setFromMatrixPosition: function(a) {
        return this.x = a.elements[12], this.y = a.elements[13], this.z = a.elements[14], 
        this;
    },
    setFromMatrixScale: function(a) {
        var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(), c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
        return a = this.set(a.elements[8], a.elements[9], a.elements[10]).length(), this.x = b, 
        this.y = c, this.z = a, this;
    },
    setFromMatrixColumn: function(a, b) {
        var c = 4 * a, d = b.elements;
        return this.x = d[c], this.y = d[c + 1], this.z = d[c + 2], this;
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
        this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a[b + 2] = this.z, a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this.z = a.array[b + 2], this;
    },
    clone: function() {
        return new THREE.Vector3(this.x, this.y, this.z);
    }
}, THREE.Vector4 = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1;
}, THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function(a, b, c, d) {
        return this.x = a, this.y = b, this.z = c, this.w = d, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setZ: function(a) {
        return this.z = a, this;
    },
    setW: function(a) {
        return this.w = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          case 2:
            this.z = b;
            break;

          case 3:
            this.w = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          case 3:
            return this.w;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, 
        this;
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, 
        this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this.z += a, this.w += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, 
        this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, 
        this);
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, 
        this;
    },
    multiplyScalar: function(a) {
        return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this;
    },
    applyMatrix4: function(a) {
        var b = this.x, c = this.y, d = this.z, e = this.w;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e, this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e, 
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e, this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e, 
        this;
    },
    divideScalar: function(a) {
        return 0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, 
        this.w = 1), this;
    },
    setAxisAngleFromQuaternion: function(a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, 
        this.z = a.z / b), this;
    },
    setAxisAngleFromRotationMatrix: function(a) {
        var b, c, d;
        a = a.elements;
        var e = a[0];
        d = a[4];
        var f = a[8], g = a[1], h = a[5], i = a[9];
        c = a[2], b = a[6];
        var j = a[10];
        return .01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(i - b) ? .1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(i + b) && .1 > Math.abs(e + h + j - 3) ? (this.set(1, 0, 0, 0), 
        this) : (a = Math.PI, e = (e + 1) / 2, h = (h + 1) / 2, j = (j + 1) / 2, d = (d + g) / 4, 
        f = (f + c) / 4, i = (i + b) / 4, e > h && e > j ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), 
        c = d / b, d = f / b) : h > j ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), 
        b = d / c, d = i / c) : .01 > j ? (c = b = .707106781, d = 0) : (d = Math.sqrt(j), 
        b = f / d, c = i / d), this.set(b, c, d, a), this) : (a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (g - d) * (g - d)), 
        .001 > Math.abs(a) && (a = 1), this.x = (b - i) / a, this.y = (f - c) / a, this.z = (g - d) / a, 
        this.w = Math.acos((e + h + j - 1) / 2), this);
    },
    min: function(a) {
        return this.x > a.x && (this.x = a.x), this.y > a.y && (this.y = a.y), this.z > a.z && (this.z = a.z), 
        this.w > a.w && (this.w = a.w), this;
    },
    max: function(a) {
        return this.x < a.x && (this.x = a.x), this.y < a.y && (this.y = a.y), this.z < a.z && (this.z = a.z), 
        this.w < a.w && (this.w = a.w), this;
    },
    clamp: function(a, b) {
        return this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x), this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y), 
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z), this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w), 
        this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector4(), b = new THREE.Vector4()), a.set(c, c, c, c), 
            b.set(d, d, d, d), this.clamp(a, b);
        };
    }(),
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
        this.w = Math.floor(this.w), this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
        this.w = Math.ceil(this.w), this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
        this.w = Math.round(this.w), this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), 
        this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(a) {
        var b = this.length();
        return 0 !== b && a !== b && this.multiplyScalar(a / b), this;
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
        this.w += (a.w - this.w) * b, this;
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
        this.w = a[b + 3], this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a[b + 2] = this.z, a[b + 3] = this.w, a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this.z = a.array[b + 2], this.w = a.array[b + 3], this;
    },
    clone: function() {
        return new THREE.Vector4(this.x, this.y, this.z, this.w);
    }
}, THREE.Euler = function(a, b, c, d) {
    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || THREE.Euler.DefaultOrder;
}, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", 
THREE.Euler.prototype = {
    constructor: THREE.Euler,
    _x: 0,
    _y: 0,
    _z: 0,
    _order: THREE.Euler.DefaultOrder,
    get x() {
        return this._x;
    },
    set x(a) {
        this._x = a, this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(a) {
        this._y = a, this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(a) {
        this._z = a, this.onChangeCallback();
    },
    get order() {
        return this._order;
    },
    set order(a) {
        this._order = a, this.onChangeCallback();
    },
    set: function(a, b, c, d) {
        return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), 
        this;
    },
    copy: function(a) {
        return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), 
        this;
    },
    setFromRotationMatrix: function(a, b, c) {
        var d = THREE.Math.clamp, e = a.elements;
        a = e[0];
        var f = e[4], g = e[8], h = e[1], i = e[5], j = e[9], k = e[2], l = e[6], e = e[10];
        return b = b || this._order, "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-j, e), 
        this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(j, -1, 1)), 
        .99999 > Math.abs(j) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, a), 
        this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(-k, e), 
        this._z = Math.atan2(-f, i)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), 
        .99999 > Math.abs(k) ? (this._x = Math.atan2(l, e), this._z = Math.atan2(h, a)) : (this._x = 0, 
        this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), 
        .99999 > Math.abs(h) ? (this._x = Math.atan2(-j, i), this._y = Math.atan2(-k, a)) : (this._x = 0, 
        this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), 
        .99999 > Math.abs(f) ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-j, e), 
        this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), 
        this._order = b, !1 !== c && this.onChangeCallback(), this;
    },
    setFromQuaternion: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationFromQuaternion(b), 
            this.setFromRotationMatrix(a, c, d), this;
        };
    }(),
    setFromVector3: function(a, b) {
        return this.set(a.x, a.y, a.z, b || this._order);
    },
    reorder: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            a.setFromEuler(this), this.setFromQuaternion(a, b);
        };
    }(),
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
    },
    fromArray: function(a) {
        return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), 
        this.onChangeCallback(), this;
    },
    toArray: function() {
        return [ this._x, this._y, this._z, this._order ];
    },
    toVector3: function(a) {
        return a ? a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z);
    },
    onChange: function(a) {
        return this.onChangeCallback = a, this;
    },
    onChangeCallback: function() {},
    clone: function() {
        return new THREE.Euler(this._x, this._y, this._z, this._order);
    }
}, THREE.Line3 = function(a, b) {
    this.start = void 0 !== a ? a : new THREE.Vector3(), this.end = void 0 !== b ? b : new THREE.Vector3();
}, THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function(a, b) {
        return this.start.copy(a), this.end.copy(b), this;
    },
    copy: function(a) {
        return this.start.copy(a.start), this.end.copy(a.end), this;
    },
    center: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(.5);
    },
    delta: function(a) {
        return (a || new THREE.Vector3()).subVectors(this.end, this.start);
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end);
    },
    distance: function() {
        return this.start.distanceTo(this.end);
    },
    at: function(a, b) {
        var c = b || new THREE.Vector3();
        return this.delta(c).multiplyScalar(a).add(this.start);
    },
    closestPointToPointParameter: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c, d) {
            a.subVectors(c, this.start), b.subVectors(this.end, this.start);
            var e = b.dot(b), e = b.dot(a) / e;
            return d && (e = THREE.Math.clamp(e, 0, 1)), e;
        };
    }(),
    closestPointToPoint: function(a, b, c) {
        return a = this.closestPointToPointParameter(a, b), c = c || new THREE.Vector3(), 
        this.delta(c).multiplyScalar(a).add(this.start);
    },
    applyMatrix4: function(a) {
        return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this;
    },
    equals: function(a) {
        return a.start.equals(this.start) && a.end.equals(this.end);
    },
    clone: function() {
        return new THREE.Line3().copy(this);
    }
}, THREE.Box2 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector2(1/0, 1/0), this.max = void 0 !== b ? b : new THREE.Vector2(-1/0, -1/0);
}, THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function(a, b) {
        return this.min.copy(a), this.max.copy(b), this;
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; c > b; b++) this.expandByPoint(a[b]);
        return this;
    },
    setFromCenterAndSize: function() {
        var a = new THREE.Vector2();
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;
        };
    }(),
    copy: function(a) {
        return this.min.copy(a.min), this.max.copy(a.max), this;
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = 1/0, this.max.x = this.max.y = -1/0, this;
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    center: function(a) {
        return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(a) {
        return (a || new THREE.Vector2()).subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
        return this.min.min(a), this.max.max(a), this;
    },
    expandByVector: function(a) {
        return this.min.sub(a), this.max.add(a), this;
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a), this.max.addScalar(a), this;
    },
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1;
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector2()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
    },
    isIntersectionBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector2();
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
        };
    }(),
    intersect: function(a) {
        return this.min.max(a.min), this.max.min(a.max), this;
    },
    union: function(a) {
        return this.min.min(a.min), this.max.max(a.max), this;
    },
    translate: function(a) {
        return this.min.add(a), this.max.add(a), this;
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max);
    },
    clone: function() {
        return new THREE.Box2().copy(this);
    }
}, THREE.Box3 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector3(1/0, 1/0, 1/0), this.max = void 0 !== b ? b : new THREE.Vector3(-1/0, -1/0, -1/0);
}, THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function(a, b) {
        return this.min.copy(a), this.max.copy(b), this;
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; c > b; b++) this.expandByPoint(a[b]);
        return this;
    },
    setFromCenterAndSize: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;
        };
    }(),
    setFromObject: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = this;
            return b.updateMatrixWorld(!0), this.makeEmpty(), b.traverse(function(b) {
                var d = b.geometry;
                if (void 0 !== d) if (d instanceof THREE.Geometry) for (var e = d.vertices, d = 0, f = e.length; f > d; d++) a.copy(e[d]), 
                a.applyMatrix4(b.matrixWorld), c.expandByPoint(a); else if (d instanceof THREE.BufferGeometry && void 0 !== d.attributes.position) for (e = d.attributes.position.array, 
                d = 0, f = e.length; f > d; d += 3) a.set(e[d], e[d + 1], e[d + 2]), a.applyMatrix4(b.matrixWorld), 
                c.expandByPoint(a);
            }), this;
        };
    }(),
    copy: function(a) {
        return this.min.copy(a.min), this.max.copy(a.max), this;
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = this.min.z = 1/0, this.max.x = this.max.y = this.max.z = -1/0, 
        this;
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    center: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(a) {
        return (a || new THREE.Vector3()).subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
        return this.min.min(a), this.max.max(a), this;
    },
    expandByVector: function(a) {
        return this.min.sub(a), this.max.add(a), this;
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a), this.max.addScalar(a), this;
    },
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1;
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector3()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
    },
    isIntersectionBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
        };
    }(),
    getBoundingSphere: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return b = b || new THREE.Sphere(), b.center = this.center(), b.radius = .5 * this.size(a).length(), 
            b;
        };
    }(),
    intersect: function(a) {
        return this.min.max(a.min), this.max.min(a.max), this;
    },
    union: function(a) {
        return this.min.min(a.min), this.max.max(a.max), this;
    },
    applyMatrix4: function() {
        var a = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
        return function(b) {
            return a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), 
            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), 
            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), 
            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), 
            this.makeEmpty(), this.setFromPoints(a), this;
        };
    }(),
    translate: function(a) {
        return this.min.add(a), this.max.add(a), this;
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max);
    },
    clone: function() {
        return new THREE.Box3().copy(this);
    }
}, THREE.Matrix3 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}, THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function(a, b, c, d, e, f, g, h, i) {
        var j = this.elements;
        return j[0] = a, j[3] = b, j[6] = c, j[1] = d, j[4] = e, j[7] = f, j[2] = g, j[5] = h, 
        j[8] = i, this;
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    copy: function(a) {
        return a = a.elements, this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]), 
        this;
    },
    multiplyVector3: function(a) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), 
        a.applyMatrix3(this);
    },
    multiplyVector3Array: function(a) {
        return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
        this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
        var a = new THREE.Vector3();
        return function(b, c, d) {
            void 0 === c && (c = 0), void 0 === d && (d = b.length);
            for (var e = 0; d > e; e += 3, c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], 
            a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b;
        };
    }(),
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, 
        b[5] *= a, b[8] *= a, this;
    },
    determinant: function() {
        var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], a = a[8];
        return b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h;
    },
    getInverse: function(a, b) {
        var c = a.elements, d = this.elements;
        if (d[0] = c[10] * c[5] - c[6] * c[9], d[1] = -c[10] * c[1] + c[2] * c[9], d[2] = c[6] * c[1] - c[2] * c[5], 
        d[3] = -c[10] * c[4] + c[6] * c[8], d[4] = c[10] * c[0] - c[2] * c[8], d[5] = -c[6] * c[0] + c[2] * c[4], 
        d[6] = c[9] * c[4] - c[5] * c[8], d[7] = -c[9] * c[0] + c[1] * c[8], d[8] = c[5] * c[0] - c[1] * c[4], 
        c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6], 0 === c) {
            if (b) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), 
            this.identity(), this;
        }
        return this.multiplyScalar(1 / c), this;
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], 
        b[5] = b[7], b[7] = a, this;
    },
    flattenToArrayOffset: function(a, b) {
        var c = this.elements;
        return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
        a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a;
    },
    getNormalMatrix: function(a) {
        return this.getInverse(a).transpose(), this;
    },
    transposeIntoArray: function(a) {
        var b = this.elements;
        return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], 
        a[6] = b[2], a[7] = b[5], a[8] = b[8], this;
    },
    fromArray: function(a) {
        return this.elements.set(a), this;
    },
    toArray: function() {
        var a = this.elements;
        return [ a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8] ];
    },
    clone: function() {
        return new THREE.Matrix3().fromArray(this.elements);
    }
}, THREE.Matrix4 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}, THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        var q = this.elements;
        return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, 
        q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, 
        this;
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    copy: function(a) {
        return this.elements.set(a.elements), this;
    },
    extractPosition: function(a) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), 
        this.copyPosition(a);
    },
    copyPosition: function(a) {
        var b = this.elements;
        return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this;
    },
    extractBasis: function(a, b, c) {
        var d = this.elements;
        return a.set(d[0], d[1], d[2]), b.set(d[4], d[5], d[6]), c.set(d[8], d[9], d[10]), 
        this;
    },
    makeBasis: function(a, b, c) {
        return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), 
        this;
    },
    extractRotation: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = this.elements;
            b = b.elements;
            var d = 1 / a.set(b[0], b[1], b[2]).length(), e = 1 / a.set(b[4], b[5], b[6]).length(), f = 1 / a.set(b[8], b[9], b[10]).length();
            return c[0] = b[0] * d, c[1] = b[1] * d, c[2] = b[2] * d, c[4] = b[4] * e, c[5] = b[5] * e, 
            c[6] = b[6] * e, c[8] = b[8] * f, c[9] = b[9] * f, c[10] = b[10] * f, this;
        };
    }(),
    makeRotationFromEuler: function(a) {
        !1 == a instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
        if ("XYZ" === a.order) {
            a = f * h;
            var i = f * e, j = c * h, k = c * e;
            b[0] = g * h, b[4] = -g * e, b[8] = d, b[1] = i + j * d, b[5] = a - k * d, b[9] = -c * g, 
            b[2] = k - a * d, b[6] = j + i * d, b[10] = f * g;
        } else "YXZ" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a + k * c, 
        b[4] = j * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = i * c - j, 
        b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, i = g * e, j = d * h, 
        k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = j + i * c, b[1] = i + j * c, 
        b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, 
        i = f * e, j = c * h, k = c * e, b[0] = g * h, b[4] = j * d - i, b[8] = a * d + k, 
        b[1] = g * e, b[5] = k * d + a, b[9] = i * d - j, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, 
        i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = j * e + i, 
        b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = i * e + j, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, 
        i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, 
        b[5] = f * h, b[9] = i * e - j, b[2] = j * e - i, b[6] = c * h, b[10] = k * e + a);
        return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, 
        this;
    },
    setRotationFromQuaternion: function(a) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), 
        this.makeRotationFromQuaternion(a);
    },
    makeRotationFromQuaternion: function(a) {
        var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, i = e + e;
        a = c * g;
        var j = c * h, c = c * i, k = d * h, d = d * i, e = e * i, g = f * g, h = f * h, f = f * i;
        return b[0] = 1 - (k + e), b[4] = j - f, b[8] = c + h, b[1] = j + f, b[5] = 1 - (a + e), 
        b[9] = d - g, b[2] = c - h, b[6] = d + g, b[10] = 1 - (a + k), b[3] = 0, b[7] = 0, 
        b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;
    },
    lookAt: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
        return function(d, e, f) {
            var g = this.elements;
            return c.subVectors(d, e).normalize(), 0 === c.length() && (c.z = 1), a.crossVectors(f, c).normalize(), 
            0 === a.length() && (c.x += 1e-4, a.crossVectors(f, c).normalize()), b.crossVectors(c, a), 
            g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, 
            g[6] = b.z, g[10] = c.z, this;
        };
    }(),
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), 
        this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
    },
    multiplyMatrices: function(a, b) {
        var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], i = c[12], j = c[1], k = c[5], l = c[9], m = c[13], n = c[2], o = c[6], p = c[10], q = c[14], r = c[3], s = c[7], t = c[11], c = c[15], u = d[0], v = d[4], w = d[8], x = d[12], y = d[1], z = d[5], A = d[9], B = d[13], C = d[2], D = d[6], E = d[10], F = d[14], G = d[3], H = d[7], I = d[11], d = d[15];
        return e[0] = f * u + g * y + h * C + i * G, e[4] = f * v + g * z + h * D + i * H, 
        e[8] = f * w + g * A + h * E + i * I, e[12] = f * x + g * B + h * F + i * d, e[1] = j * u + k * y + l * C + m * G, 
        e[5] = j * v + k * z + l * D + m * H, e[9] = j * w + k * A + l * E + m * I, e[13] = j * x + k * B + l * F + m * d, 
        e[2] = n * u + o * y + p * C + q * G, e[6] = n * v + o * z + p * D + q * H, e[10] = n * w + o * A + p * E + q * I, 
        e[14] = n * x + o * B + p * F + q * d, e[3] = r * u + s * y + t * C + c * G, e[7] = r * v + s * z + t * D + c * H, 
        e[11] = r * w + s * A + t * E + c * I, e[15] = r * x + s * B + t * F + c * d, this;
    },
    multiplyToArray: function(a, b, c) {
        var d = this.elements;
        return this.multiplyMatrices(a, b), c[0] = d[0], c[1] = d[1], c[2] = d[2], c[3] = d[3], 
        c[4] = d[4], c[5] = d[5], c[6] = d[6], c[7] = d[7], c[8] = d[8], c[9] = d[9], c[10] = d[10], 
        c[11] = d[11], c[12] = d[12], c[13] = d[13], c[14] = d[14], c[15] = d[15], this;
    },
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, 
        b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, 
        b[11] *= a, b[15] *= a, this;
    },
    multiplyVector3: function(a) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), 
        a.applyProjection(this);
    },
    multiplyVector4: function(a) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
        a.applyMatrix4(this);
    },
    multiplyVector3Array: function(a) {
        return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
        this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
        var a = new THREE.Vector3();
        return function(b, c, d) {
            void 0 === c && (c = 0), void 0 === d && (d = b.length);
            for (var e = 0; d > e; e += 3, c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], 
            a.applyMatrix4(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b;
        };
    }(),
    rotateAxis: function(a) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), 
        a.transformDirection(this);
    },
    crossVector: function(a) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
        a.applyMatrix4(this);
    },
    determinant: function() {
        var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], i = a[13], j = a[2], k = a[6], l = a[10], m = a[14];
        return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j);
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], 
        b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], 
        b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this;
    },
    flattenToArrayOffset: function(a, b) {
        var c = this.elements;
        return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
        a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], 
        a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], 
        a[b + 15] = c[15], a;
    },
    getPosition: function() {
        var a = new THREE.Vector3();
        return function() {
            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
            var b = this.elements;
            return a.set(b[12], b[13], b[14]);
        };
    }(),
    setPosition: function(a) {
        var b = this.elements;
        return b[12] = a.x, b[13] = a.y, b[14] = a.z, this;
    },
    getInverse: function(a, b) {
        var c = this.elements, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[12], i = d[1], j = d[5], k = d[9], l = d[13], m = d[2], n = d[6], o = d[10], p = d[14], q = d[3], r = d[7], s = d[11], d = d[15];
        if (c[0] = k * p * r - l * o * r + l * n * s - j * p * s - k * n * d + j * o * d, 
        c[4] = h * o * r - g * p * r - h * n * s + f * p * s + g * n * d - f * o * d, c[8] = g * l * r - h * k * r + h * j * s - f * l * s - g * j * d + f * k * d, 
        c[12] = h * k * n - g * l * n - h * j * o + f * l * o + g * j * p - f * k * p, c[1] = l * o * q - k * p * q - l * m * s + i * p * s + k * m * d - i * o * d, 
        c[5] = g * p * q - h * o * q + h * m * s - e * p * s - g * m * d + e * o * d, c[9] = h * k * q - g * l * q - h * i * s + e * l * s + g * i * d - e * k * d, 
        c[13] = g * l * m - h * k * m + h * i * o - e * l * o - g * i * p + e * k * p, c[2] = j * p * q - l * n * q + l * m * r - i * p * r - j * m * d + i * n * d, 
        c[6] = h * n * q - f * p * q - h * m * r + e * p * r + f * m * d - e * n * d, c[10] = f * l * q - h * j * q + h * i * r - e * l * r - f * i * d + e * j * d, 
        c[14] = h * j * m - f * l * m - h * i * n + e * l * n + f * i * p - e * j * p, c[3] = k * n * q - j * o * q - k * m * r + i * o * r + j * m * s - i * n * s, 
        c[7] = f * o * q - g * n * q + g * m * r - e * o * r - f * m * s + e * n * s, c[11] = g * j * q - f * k * q - g * i * r + e * k * r + f * i * s - e * j * s, 
        c[15] = f * k * m - g * j * m + g * i * n - e * k * n - f * i * o + e * j * o, c = e * c[0] + i * c[4] + m * c[8] + q * c[12], 
        0 == c) {
            if (b) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0"), 
            this.identity(), this;
        }
        return this.multiplyScalar(1 / c), this;
    },
    translate: function() {
        console.warn("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
        console.warn("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
        console.warn("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
        console.warn("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
        console.warn("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    scale: function(a) {
        var b = this.elements, c = a.x, d = a.y;
        return a = a.z, b[0] *= c, b[4] *= d, b[8] *= a, b[1] *= c, b[5] *= d, b[9] *= a, 
        b[2] *= c, b[6] *= d, b[10] *= a, b[3] *= c, b[7] *= d, b[11] *= a, this;
    },
    getMaxScaleOnAxis: function() {
        var a = this.elements;
        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));
    },
    makeTranslation: function(a, b, c) {
        return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this;
    },
    makeRotationX: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationY: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationZ: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationAxis: function(a, b) {
        var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, i = e * f, j = e * g;
        return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), 
        this;
    },
    makeScale: function(a, b, c) {
        return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this;
    },
    compose: function(a, b, c) {
        return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this;
    },
    decompose: function() {
        var a = new THREE.Vector3(), b = new THREE.Matrix4();
        return function(c, d, e) {
            var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), i = a.set(f[8], f[9], f[10]).length();
            0 > this.determinant() && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.elements.set(this.elements), 
            c = 1 / g;
            var f = 1 / h, j = 1 / i;
            return b.elements[0] *= c, b.elements[1] *= c, b.elements[2] *= c, b.elements[4] *= f, 
            b.elements[5] *= f, b.elements[6] *= f, b.elements[8] *= j, b.elements[9] *= j, 
            b.elements[10] *= j, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this;
        };
    }(),
    makeFrustum: function(a, b, c, d, e, f) {
        var g = this.elements;
        return g[0] = 2 * e / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, 
        g[5] = 2 * e / (d - c), g[9] = (d + c) / (d - c), g[13] = 0, g[2] = 0, g[6] = 0, 
        g[10] = -(f + e) / (f - e), g[14] = -2 * f * e / (f - e), g[3] = 0, g[7] = 0, g[11] = -1, 
        g[15] = 0, this;
    },
    makePerspective: function(a, b, c, d) {
        a = c * Math.tan(THREE.Math.degToRad(.5 * a));
        var e = -a;
        return this.makeFrustum(e * b, a * b, e, a, c, d);
    },
    makeOrthographic: function(a, b, c, d, e, f) {
        var g = this.elements, h = b - a, i = c - d, j = f - e;
        return g[0] = 2 / h, g[4] = 0, g[8] = 0, g[12] = -((b + a) / h), g[1] = 0, g[5] = 2 / i, 
        g[9] = 0, g[13] = -((c + d) / i), g[2] = 0, g[6] = 0, g[10] = -2 / j, g[14] = -((f + e) / j), 
        g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this;
    },
    fromArray: function(a) {
        return this.elements.set(a), this;
    },
    toArray: function() {
        var a = this.elements;
        return [ a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15] ];
    },
    clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
    }
}, THREE.Ray = function(a, b) {
    this.origin = void 0 !== a ? a : new THREE.Vector3(), this.direction = void 0 !== b ? b : new THREE.Vector3();
}, THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function(a, b) {
        return this.origin.copy(a), this.direction.copy(b), this;
    },
    copy: function(a) {
        return this.origin.copy(a.origin), this.direction.copy(a.direction), this;
    },
    at: function(a, b) {
        return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);
    },
    recast: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return this.origin.copy(this.at(b, a)), this;
        };
    }(),
    closestPointToPoint: function(a, b) {
        var c = b || new THREE.Vector3();
        c.subVectors(a, this.origin);
        var d = c.dot(this.direction);
        return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            return 0 > c ? this.origin.distanceTo(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), 
            a.distanceTo(b));
        };
    }(),
    distanceSqToSegment: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
        return function(d, e, f, g) {
            a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
            var h, i = .5 * d.distanceTo(e), j = -this.direction.dot(b), k = c.dot(this.direction), l = -c.dot(b), m = c.lengthSq(), n = Math.abs(1 - j * j);
            return n > 0 ? (d = j * l - k, e = j * k - l, h = i * n, d >= 0 ? e >= -h ? h >= e ? (i = 1 / n, 
            d *= i, e *= i, j = d * (d + j * e + 2 * k) + e * (j * d + e + 2 * l) + m) : (e = i, 
            d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : (e = -i, d = Math.max(0, -(j * e + k)), 
            j = -d * d + e * (e + 2 * l) + m) : -h >= e ? (d = Math.max(0, -(-j * i + k)), e = d > 0 ? -i : Math.min(Math.max(-i, -l), i), 
            j = -d * d + e * (e + 2 * l) + m) : h >= e ? (d = 0, e = Math.min(Math.max(-i, -l), i), 
            j = e * (e + 2 * l) + m) : (d = Math.max(0, -(j * i + k)), e = d > 0 ? i : Math.min(Math.max(-i, -l), i), 
            j = -d * d + e * (e + 2 * l) + m)) : (e = j > 0 ? -i : i, d = Math.max(0, -(j * e + k)), 
            j = -d * d + e * (e + 2 * l) + m), f && f.copy(this.direction).multiplyScalar(d).add(this.origin), 
            g && g.copy(b).multiplyScalar(e).add(a), j;
        };
    }(),
    isIntersectionSphere: function(a) {
        return this.distanceToPoint(a.center) <= a.radius;
    },
    intersectSphere: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            a.subVectors(b.center, this.origin);
            var d = a.dot(this.direction), e = a.dot(a) - d * d, f = b.radius * b.radius;
            return e > f ? null : (f = Math.sqrt(f - e), e = d - f, d += f, 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c));
        };
    }(),
    isIntersectionPlane: function(a) {
        var b = a.distanceToPoint(this.origin);
        return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
    },
    distanceToPlane: function(a) {
        var b = a.normal.dot(this.direction);
        return 0 == b ? 0 == a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b, 
        a >= 0 ? a : null);
    },
    intersectPlane: function(a, b) {
        var c = this.distanceToPlane(a);
        return null === c ? null : this.at(c, b);
    },
    isIntersectionBox: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return null !== this.intersectBox(b, a);
        };
    }(),
    intersectBox: function(a, b) {
        var c, d, e, f, g;
        d = 1 / this.direction.x, f = 1 / this.direction.y, g = 1 / this.direction.z;
        var h = this.origin;
        return d >= 0 ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, 
        d *= a.min.x - h.x), f >= 0 ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, 
        f *= a.min.y - h.y), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (d > f || d !== d) && (d = f), 
        g >= 0 ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, 
        g *= a.min.z - h.z), c > g || e > d ? null : ((e > c || c !== c) && (c = e), (d > g || d !== d) && (d = g), 
        0 > d ? null : this.at(c >= 0 ? c : d, b)));
    },
    intersectTriangle: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Vector3();
        return function(e, f, g, h, i) {
            if (b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c), f = this.direction.dot(d), 
            f > 0) {
                if (h) return null;
                h = 1;
            } else {
                if (!(0 > f)) return null;
                h = -1, f = -f;
            }
            return a.subVectors(this.origin, e), e = h * this.direction.dot(c.crossVectors(a, c)), 
            0 > e ? null : (g = h * this.direction.dot(b.cross(a)), 0 > g || e + g > f ? null : (e = -h * a.dot(d), 
            0 > e ? null : this.at(e / f, i)));
        };
    }(),
    applyMatrix4: function(a) {
        return this.direction.add(this.origin).applyMatrix4(a), this.origin.applyMatrix4(a), 
        this.direction.sub(this.origin), this.direction.normalize(), this;
    },
    equals: function(a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction);
    },
    clone: function() {
        return new THREE.Ray().copy(this);
    }
}, THREE.Sphere = function(a, b) {
    this.center = void 0 !== a ? a : new THREE.Vector3(), this.radius = void 0 !== b ? b : 0;
}, THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function(a, b) {
        return this.center.copy(a), this.radius = b, this;
    },
    setFromPoints: function() {
        var a = new THREE.Box3();
        return function(b, c) {
            var d = this.center;
            void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
            for (var e = 0, f = 0, g = b.length; g > f; f++) e = Math.max(e, d.distanceToSquared(b[f]));
            return this.radius = Math.sqrt(e), this;
        };
    }(),
    copy: function(a) {
        return this.center.copy(a.center), this.radius = a.radius, this;
    },
    empty: function() {
        return 0 >= this.radius;
    },
    containsPoint: function(a) {
        return a.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(a) {
        return a.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b;
    },
    clampPoint: function(a, b) {
        var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3();
        return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), 
        d.multiplyScalar(this.radius).add(this.center)), d;
    },
    getBoundingBox: function(a) {
        return a = a || new THREE.Box3(), a.set(this.center, this.center), a.expandByScalar(this.radius), 
        a;
    },
    applyMatrix4: function(a) {
        return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this;
    },
    translate: function(a) {
        return this.center.add(a), this;
    },
    equals: function(a) {
        return a.center.equals(this.center) && a.radius === this.radius;
    },
    clone: function() {
        return new THREE.Sphere().copy(this);
    }
}, THREE.Frustum = function(a, b, c, d, e, f) {
    this.planes = [ void 0 !== a ? a : new THREE.Plane(), void 0 !== b ? b : new THREE.Plane(), void 0 !== c ? c : new THREE.Plane(), void 0 !== d ? d : new THREE.Plane(), void 0 !== e ? e : new THREE.Plane(), void 0 !== f ? f : new THREE.Plane() ];
}, THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function(a, b, c, d, e, f) {
        var g = this.planes;
        return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), 
        this;
    },
    copy: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
        return this;
    },
    setFromMatrix: function(a) {
        var b = this.planes, c = a.elements;
        a = c[0];
        var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], i = c[6], j = c[7], k = c[8], l = c[9], m = c[10], n = c[11], o = c[12], p = c[13], q = c[14], c = c[15];
        return b[0].setComponents(f - a, j - g, n - k, c - o).normalize(), b[1].setComponents(f + a, j + g, n + k, c + o).normalize(), 
        b[2].setComponents(f + d, j + h, n + l, c + p).normalize(), b[3].setComponents(f - d, j - h, n - l, c - p).normalize(), 
        b[4].setComponents(f - e, j - i, n - m, c - q).normalize(), b[5].setComponents(f + e, j + i, n + m, c + q).normalize(), 
        this;
    },
    intersectsObject: function() {
        var a = new THREE.Sphere();
        return function(b) {
            var c = b.geometry;
            return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere), 
            a.applyMatrix4(b.matrixWorld), this.intersectsSphere(a);
        };
    }(),
    intersectsSphere: function(a) {
        var b = this.planes, c = a.center;
        a = -a.radius;
        for (var d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return !1;
        return !0;
    },
    intersectsBox: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c) {
            for (var d = this.planes, e = 0; 6 > e; e++) {
                var f = d[e];
                a.x = 0 < f.normal.x ? c.min.x : c.max.x, b.x = 0 < f.normal.x ? c.max.x : c.min.x, 
                a.y = 0 < f.normal.y ? c.min.y : c.max.y, b.y = 0 < f.normal.y ? c.max.y : c.min.y, 
                a.z = 0 < f.normal.z ? c.min.z : c.max.z, b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
                if (0 > g && 0 > f) return !1;
            }
            return !0;
        };
    }(),
    containsPoint: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++) if (0 > b[c].distanceToPoint(a)) return !1;
        return !0;
    },
    clone: function() {
        return new THREE.Frustum().copy(this);
    }
}, THREE.Plane = function(a, b) {
    this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== b ? b : 0;
}, THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function(a, b) {
        return this.normal.copy(a), this.constant = b, this;
    },
    setComponents: function(a, b, c, d) {
        return this.normal.set(a, b, c), this.constant = d, this;
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
        return this.normal.copy(a), this.constant = -b.dot(this.normal), this;
    },
    setFromCoplanarPoints: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c, d, e) {
            return d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(), this.setFromNormalAndCoplanarPoint(d, c), 
            this;
        };
    }(),
    copy: function(a) {
        return this.normal.copy(a.normal), this.constant = a.constant, this;
    },
    normalize: function() {
        var a = 1 / this.normal.length();
        return this.normal.multiplyScalar(a), this.constant *= a, this;
    },
    negate: function() {
        return this.constant *= -1, this.normal.negate(), this;
    },
    distanceToPoint: function(a) {
        return this.normal.dot(a) + this.constant;
    },
    distanceToSphere: function(a) {
        return this.distanceToPoint(a.center) - a.radius;
    },
    projectPoint: function(a, b) {
        return this.orthoPoint(a, b).sub(a).negate();
    },
    orthoPoint: function(a, b) {
        var c = this.distanceToPoint(a);
        return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);
    },
    isIntersectionLine: function(a) {
        var b = this.distanceToPoint(a.start);
        return a = this.distanceToPoint(a.end), 0 > b && a > 0 || 0 > a && b > 0;
    },
    intersectLine: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            var d = c || new THREE.Vector3(), e = b.delta(a), f = this.normal.dot(e);
            return 0 != f ? (f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || f > 1 ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)) : 0 == this.distanceToPoint(b.start) ? d.copy(b.start) : void 0;
        };
    }(),
    coplanarPoint: function(a) {
        return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Matrix3();
        return function(d, e) {
            var f = e || c.getNormalMatrix(d), f = a.copy(this.normal).applyMatrix3(f), g = this.coplanarPoint(b);
            return g.applyMatrix4(d), this.setFromNormalAndCoplanarPoint(f, g), this;
        };
    }(),
    translate: function(a) {
        return this.constant -= a.dot(this.normal), this;
    },
    equals: function(a) {
        return a.normal.equals(this.normal) && a.constant == this.constant;
    },
    clone: function() {
        return new THREE.Plane().copy(this);
    }
}, THREE.Math = {
    generateUUID: function() {
        var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), c = Array(36), d = 0;
        return function() {
            for (var e = 0; 36 > e; e++) 8 == e || 13 == e || 18 == e || 23 == e ? c[e] = "-" : 14 == e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), 
            a = 15 & d, d >>= 4, c[e] = b[19 == e ? 3 & a | 8 : a]);
            return c.join("");
        };
    }(),
    clamp: function(a, b, c) {
        return b > a ? b : a > c ? c : a;
    },
    clampBottom: function(a, b) {
        return b > a ? b : a;
    },
    mapLinear: function(a, b, c, d, e) {
        return d + (a - b) * (e - d) / (c - b);
    },
    smoothstep: function(a, b, c) {
        return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a));
    },
    smootherstep: function(a, b, c) {
        return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10));
    },
    random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
    },
    randInt: function(a, b) {
        return Math.floor(this.randFloat(a, b));
    },
    randFloat: function(a, b) {
        return a + Math.random() * (b - a);
    },
    randFloatSpread: function(a) {
        return a * (.5 - Math.random());
    },
    degToRad: function() {
        var a = Math.PI / 180;
        return function(b) {
            return b * a;
        };
    }(),
    radToDeg: function() {
        var a = 180 / Math.PI;
        return function(b) {
            return b * a;
        };
    }(),
    isPowerOfTwo: function(a) {
        return 0 === (a & a - 1) && 0 !== a;
    }
}, THREE.Spline = function(a) {
    function b(a, b, c, d, e, f, g) {
        return a = .5 * (c - a), d = .5 * (d - b), (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
    }
    this.points = a;
    var c, d, e, f, g, h, i, j, k, l = [], m = {
        x: 0,
        y: 0,
        z: 0
    };
    this.initFromArray = function(a) {
        this.points = [];
        for (var b = 0; b < a.length; b++) this.points[b] = {
            x: a[b][0],
            y: a[b][1],
            z: a[b][2]
        };
    }, this.getPoint = function(a) {
        return c = (this.points.length - 1) * a, d = Math.floor(c), e = c - d, l[0] = 0 === d ? d : d - 1, 
        l[1] = d, l[2] = d > this.points.length - 2 ? this.points.length - 1 : d + 1, l[3] = d > this.points.length - 3 ? this.points.length - 1 : d + 2, 
        h = this.points[l[0]], i = this.points[l[1]], j = this.points[l[2]], k = this.points[l[3]], 
        f = e * e, g = e * f, m.x = b(h.x, i.x, j.x, k.x, e, f, g), m.y = b(h.y, i.y, j.y, k.y, e, f, g), 
        m.z = b(h.z, i.z, j.z, k.z, e, f, g), m;
    }, this.getControlPointsArray = function() {
        var a, b, c = this.points.length, d = [];
        for (a = 0; c > a; a++) b = this.points[a], d[a] = [ b.x, b.y, b.z ];
        return d;
    }, this.getLength = function(a) {
        var b, c, d, e = b = b = 0, f = new THREE.Vector3(), g = new THREE.Vector3(), h = [], i = 0;
        for (h[0] = 0, a || (a = 100), c = this.points.length * a, f.copy(this.points[0]), 
        a = 1; c > a; a++) b = a / c, d = this.getPoint(b), g.copy(d), i += g.distanceTo(f), 
        f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = i, 
        e = b);
        return h[h.length] = i, {
            chunks: h,
            total: i
        };
    }, this.reparametrizeByArcLength = function(a) {
        var b, c, d, e, f, g, h = [], i = new THREE.Vector3(), j = this.getLength();
        for (h.push(i.copy(this.points[0]).clone()), b = 1; b < this.points.length; b++) {
            for (c = j.chunks[b] - j.chunks[b - 1], g = Math.ceil(a * c / j.total), e = (b - 1) / (this.points.length - 1), 
            f = b / (this.points.length - 1), c = 1; g - 1 > c; c++) d = e + 1 / g * c * (f - e), 
            d = this.getPoint(d), h.push(i.copy(d).clone());
            h.push(i.copy(this.points[b]).clone());
        }
        this.points = h;
    };
}, THREE.Triangle = function(a, b, c) {
    this.a = void 0 !== a ? a : new THREE.Vector3(), this.b = void 0 !== b ? b : new THREE.Vector3(), 
    this.c = void 0 !== c ? c : new THREE.Vector3();
}, THREE.Triangle.normal = function() {
    var a = new THREE.Vector3();
    return function(b, c, d, e) {
        return e = e || new THREE.Vector3(), e.subVectors(d, c), a.subVectors(b, c), e.cross(a), 
        b = e.lengthSq(), b > 0 ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
    };
}(), THREE.Triangle.barycoordFromPoint = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function(d, e, f, g, h) {
        a.subVectors(g, e), b.subVectors(f, e), c.subVectors(d, e), d = a.dot(a), e = a.dot(b), 
        f = a.dot(c);
        var i = b.dot(b);
        g = b.dot(c);
        var j = d * i - e * e;
        return h = h || new THREE.Vector3(), 0 == j ? h.set(-2, -1, -1) : (j = 1 / j, i = (i * f - e * g) * j, 
        d = (d * g - e * f) * j, h.set(1 - i - d, d, i));
    };
}(), THREE.Triangle.containsPoint = function() {
    var a = new THREE.Vector3();
    return function(b, c, d, e) {
        return b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a), 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;
    };
}(), THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function(a, b, c) {
        return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
    },
    setFromPointsAndIndices: function(a, b, c, d) {
        return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this;
    },
    copy: function(a) {
        return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this;
    },
    area: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function() {
            return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length();
        };
    }(),
    midpoint: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    normal: function(a) {
        return THREE.Triangle.normal(this.a, this.b, this.c, a);
    },
    plane: function(a) {
        return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
    },
    barycoordFromPoint: function(a, b) {
        return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);
    },
    containsPoint: function(a) {
        return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
    },
    equals: function(a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
    },
    clone: function() {
        return new THREE.Triangle().copy(this);
    }
}, THREE.Clock = function(a) {
    this.autoStart = void 0 !== a ? a : !0, this.elapsedTime = this.oldTime = this.startTime = 0, 
    this.running = !1;
}, THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function() {
        this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), 
        this.running = !0;
    },
    stop: function() {
        this.getElapsedTime(), this.running = !1;
    },
    getElapsedTime: function() {
        return this.getDelta(), this.elapsedTime;
    },
    getDelta: function() {
        var a = 0;
        if (this.autoStart && !this.running && this.start(), this.running) {
            var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), a = .001 * (b - this.oldTime);
            this.oldTime = b, this.elapsedTime += a;
        }
        return a;
    }
}, THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function(a) {
        a.addEventListener = THREE.EventDispatcher.prototype.addEventListener, a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, 
        a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
    },
    addEventListener: function(a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b);
    },
    hasEventListener: function(a, b) {
        if (void 0 === this._listeners) return !1;
        var c = this._listeners;
        return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c) {
                var d = c.indexOf(b);
                -1 !== d && c.splice(d, 1);
            }
        }
    },
    dispatchEvent: function(a) {
        if (void 0 !== this._listeners) {
            var b = this._listeners[a.type];
            if (void 0 !== b) {
                a.target = this;
                for (var c = [], d = b.length, e = 0; d > e; e++) c[e] = b[e];
                for (e = 0; d > e; e++) c[e].call(this, a);
            }
        }
    }
}, function(a) {
    a.Raycaster = function(b, c, d, e) {
        this.ray = new a.Ray(b, c), this.near = d || 0, this.far = e || 1/0, this.params = {
            Sprite: {},
            Mesh: {},
            PointCloud: {
                threshold: 1
            },
            LOD: {},
            Line: {}
        };
    };
    var b = function(a, b) {
        return a.distance - b.distance;
    }, c = function(a, b, d, e) {
        if (a.raycast(b, d), !0 === e) {
            a = a.children, e = 0;
            for (var f = a.length; f > e; e++) c(a[e], b, d, !0);
        }
    };
    a.Raycaster.prototype = {
        constructor: a.Raycaster,
        precision: 1e-4,
        linePrecision: 1,
        set: function(a, b) {
            this.ray.set(a, b);
        },
        setFromCamera: function(b, c) {
            c instanceof a.PerspectiveCamera ? (this.ray.origin.copy(c.position), this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(c.position).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), 
            this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function(a, d) {
            var e = [];
            return c(a, this, e, d), e.sort(b), e;
        },
        intersectObjects: function(a, d) {
            var e = [];
            if (!1 == a instanceof Array) return console.log("THREE.Raycaster.intersectObjects: objects is not an Array."), 
            e;
            for (var f = 0, g = a.length; g > f; f++) c(a[f], this, e, d);
            return e.sort(b), e;
        }
    };
}(THREE), THREE.Object3D = function() {
    Object.defineProperty(this, "id", {
        value: THREE.Object3DIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Object3D", 
    this.parent = void 0, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
    var a = new THREE.Vector3(), b = new THREE.Euler(), c = new THREE.Quaternion(), d = new THREE.Vector3(1, 1, 1);
    b.onChange(function() {
        c.setFromEuler(b, !1);
    }), c.onChange(function() {
        b.setFromQuaternion(c, void 0, !1);
    }), Object.defineProperties(this, {
        position: {
            enumerable: !0,
            value: a
        },
        rotation: {
            enumerable: !0,
            value: b
        },
        quaternion: {
            enumerable: !0,
            value: c
        },
        scale: {
            enumerable: !0,
            value: d
        }
    }), this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4(), this.matrixWorld = new THREE.Matrix4(), 
    this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, 
    this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.userData = {};
}, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get eulerOrder() {
        return console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), 
        this.rotation.order;
    },
    set eulerOrder(a) {
        console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), 
        this.rotation.order = a;
    },
    get useQuaternion() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set useQuaternion(a) {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    applyMatrix: function(a) {
        this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    setRotationFromAxisAngle: function(a, b) {
        this.quaternion.setFromAxisAngle(a, b);
    },
    setRotationFromEuler: function(a) {
        this.quaternion.setFromEuler(a, !0);
    },
    setRotationFromMatrix: function(a) {
        this.quaternion.setFromRotationMatrix(a);
    },
    setRotationFromQuaternion: function(a) {
        this.quaternion.copy(a);
    },
    rotateOnAxis: function() {
        var a = new THREE.Quaternion();
        return function(b, c) {
            return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this;
        };
    }(),
    rotateX: function() {
        var a = new THREE.Vector3(1, 0, 0);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    rotateY: function() {
        var a = new THREE.Vector3(0, 1, 0);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    rotateZ: function() {
        var a = new THREE.Vector3(0, 0, 1);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    translateOnAxis: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), 
            this;
        };
    }(),
    translate: function(a, b) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), 
        this.translateOnAxis(b, a);
    },
    translateX: function() {
        var a = new THREE.Vector3(1, 0, 0);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    translateY: function() {
        var a = new THREE.Vector3(0, 1, 0);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    translateZ: function() {
        var a = new THREE.Vector3(0, 0, 1);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    localToWorld: function(a) {
        return a.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
        var a = new THREE.Matrix4();
        return function(b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld));
        };
    }(),
    lookAt: function() {
        var a = new THREE.Matrix4();
        return function(b) {
            a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a);
        };
    }(),
    add: function(a) {
        if (1 < arguments.length) {
            for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
            return this;
        }
        return a === this ? (console.error("THREE.Object3D.add:", a, "can't be added as a child of itself."), 
        this) : (a instanceof THREE.Object3D ? (void 0 !== a.parent && a.parent.remove(a), 
        a.parent = this, a.dispatchEvent({
            type: "added"
        }), this.children.push(a)) : console.error("THREE.Object3D.add:", a, "is not an instance of THREE.Object3D."), 
        this);
    },
    remove: function(a) {
        if (1 < arguments.length) for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
        b = this.children.indexOf(a), -1 !== b && (a.parent = void 0, a.dispatchEvent({
            type: "removed"
        }), this.children.splice(b, 1));
    },
    getChildByName: function(a, b) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), 
        this.getObjectByName(a, b);
    },
    getObjectById: function(a, b) {
        return this.getObjectByProperty("id", a, b);
    },
    getObjectByName: function(a, b) {
        return this.getObjectByProperty("name", a, b);
    },
    getObjectByProperty: function(a, b, c) {
        if (this[a] === b) return this;
        for (var d = 0, e = this.children.length; e > d; d++) {
            var f = this.children[d].getObjectByProperty(a, b, c);
            if (void 0 !== f) return f;
        }
    },
    getWorldPosition: function(a) {
        return a = a || new THREE.Vector3(), this.updateMatrixWorld(!0), a.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c) {
            return c = c || new THREE.Quaternion(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, c, b), 
            c;
        };
    }(),
    getWorldRotation: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            return b = b || new THREE.Euler(), this.getWorldQuaternion(a), b.setFromQuaternion(a, this.rotation.order, !1);
        };
    }(),
    getWorldScale: function() {
        var a = new THREE.Vector3(), b = new THREE.Quaternion();
        return function(c) {
            return c = c || new THREE.Vector3(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, c), 
            c;
        };
    }(),
    getWorldDirection: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            return b = b || new THREE.Vector3(), this.getWorldQuaternion(a), b.set(0, 0, 1).applyQuaternion(a);
        };
    }(),
    raycast: function() {},
    traverse: function(a) {
        a(this);
        for (var b = 0, c = this.children.length; c > b; b++) this.children[b].traverse(a);
    },
    traverseVisible: function(a) {
        if (!1 !== this.visible) {
            a(this);
            for (var b = 0, c = this.children.length; c > b; b++) this.children[b].traverseVisible(a);
        }
    },
    traverseAncestors: function(a) {
        this.parent && (a(this.parent), this.parent.traverseAncestors(a));
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(a) {
        !0 === this.matrixAutoUpdate && this.updateMatrix(), (!0 === this.matrixWorldNeedsUpdate || !0 === a) && (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
        this.matrixWorldNeedsUpdate = !1, a = !0);
        for (var b = 0, c = this.children.length; c > b; b++) this.children[b].updateMatrixWorld(a);
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.3,
                type: "Object",
                generator: "ObjectExporter"
            }
        }, b = {}, c = function(c) {
            if (void 0 === a.geometries && (a.geometries = []), void 0 === b[c.uuid]) {
                var d = c.toJSON();
                delete d.metadata, b[c.uuid] = d, a.geometries.push(d);
            }
            return c.uuid;
        }, d = {}, e = function(b) {
            if (void 0 === a.materials && (a.materials = []), void 0 === d[b.uuid]) {
                var c = b.toJSON();
                delete c.metadata, d[b.uuid] = c, a.materials.push(c);
            }
            return b.uuid;
        }, f = function(a) {
            var b = {};
            if (b.uuid = a.uuid, b.type = a.type, "" !== a.name && (b.name = a.name), "{}" !== JSON.stringify(a.userData) && (b.userData = a.userData), 
            !0 !== a.visible && (b.visible = a.visible), a instanceof THREE.PerspectiveCamera ? (b.fov = a.fov, 
            b.aspect = a.aspect, b.near = a.near, b.far = a.far) : a instanceof THREE.OrthographicCamera ? (b.left = a.left, 
            b.right = a.right, b.top = a.top, b.bottom = a.bottom, b.near = a.near, b.far = a.far) : a instanceof THREE.AmbientLight ? b.color = a.color.getHex() : a instanceof THREE.DirectionalLight ? (b.color = a.color.getHex(), 
            b.intensity = a.intensity) : a instanceof THREE.PointLight ? (b.color = a.color.getHex(), 
            b.intensity = a.intensity, b.distance = a.distance) : a instanceof THREE.SpotLight ? (b.color = a.color.getHex(), 
            b.intensity = a.intensity, b.distance = a.distance, b.angle = a.angle, b.exponent = a.exponent) : a instanceof THREE.HemisphereLight ? (b.color = a.color.getHex(), 
            b.groundColor = a.groundColor.getHex()) : a instanceof THREE.Mesh ? (b.geometry = c(a.geometry), 
            b.material = e(a.material)) : a instanceof THREE.Line ? (b.geometry = c(a.geometry), 
            b.material = e(a.material)) : a instanceof THREE.Sprite && (b.material = e(a.material)), 
            b.matrix = a.matrix.toArray(), 0 < a.children.length) {
                b.children = [];
                for (var d = 0; d < a.children.length; d++) b.children.push(f(a.children[d]));
            }
            return b;
        };
        return a.object = f(this), a;
    },
    clone: function(a, b) {
        if (void 0 === a && (a = new THREE.Object3D()), void 0 === b && (b = !0), a.name = this.name, 
        a.up.copy(this.up), a.position.copy(this.position), a.quaternion.copy(this.quaternion), 
        a.scale.copy(this.scale), a.rotationAutoUpdate = this.rotationAutoUpdate, a.matrix.copy(this.matrix), 
        a.matrixWorld.copy(this.matrixWorld), a.matrixAutoUpdate = this.matrixAutoUpdate, 
        a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, a.visible = this.visible, 
        a.castShadow = this.castShadow, a.receiveShadow = this.receiveShadow, a.frustumCulled = this.frustumCulled, 
        a.userData = JSON.parse(JSON.stringify(this.userData)), !0 === b) for (var c = 0; c < this.children.length; c++) a.add(this.children[c].clone());
        return a;
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, 
THREE.Face3 = function(a, b, c, d, e, f) {
    this.a = a, this.b = b, this.c = c, this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3(), 
    this.vertexNormals = d instanceof Array ? d : [], this.color = e instanceof THREE.Color ? e : new THREE.Color(), 
    this.vertexColors = e instanceof Array ? e : [], this.vertexTangents = [], this.materialIndex = void 0 !== f ? f : 0;
}, THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function() {
        var a = new THREE.Face3(this.a, this.b, this.c);
        a.normal.copy(this.normal), a.color.copy(this.color), a.materialIndex = this.materialIndex;
        for (var b = 0, c = this.vertexNormals.length; c > b; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();
        for (b = 0, c = this.vertexColors.length; c > b; b++) a.vertexColors[b] = this.vertexColors[b].clone();
        for (b = 0, c = this.vertexTangents.length; c > b; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();
        return a;
    }
}, THREE.Face4 = function(a, b, c, d, e, f, g) {
    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), 
    new THREE.Face3(a, b, c, e, f, g);
}, THREE.BufferAttribute = function(a, b) {
    this.array = a, this.itemSize = b, this.needsUpdate = !1;
}, THREE.BufferAttribute.prototype = {
    constructor: THREE.BufferAttribute,
    get length() {
        return this.array.length;
    },
    copyAt: function(a, b, c) {
        a *= this.itemSize, c *= b.itemSize;
        for (var d = 0, e = this.itemSize; e > d; d++) this.array[a + d] = b.array[c + d];
    },
    set: function(a) {
        return this.array.set(a), this;
    },
    setX: function(a, b) {
        return this.array[a * this.itemSize] = b, this;
    },
    setY: function(a, b) {
        return this.array[a * this.itemSize + 1] = b, this;
    },
    setZ: function(a, b) {
        return this.array[a * this.itemSize + 2] = b, this;
    },
    setXY: function(a, b, c) {
        return a *= this.itemSize, this.array[a] = b, this.array[a + 1] = c, this;
    },
    setXYZ: function(a, b, c, d) {
        return a *= this.itemSize, this.array[a] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
        this;
    },
    setXYZW: function(a, b, c, d, e) {
        return a *= this.itemSize, this.array[a] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
        this.array[a + 3] = e, this;
    },
    clone: function() {
        return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize);
    }
}, THREE.Int8Attribute = function(a, b) {
    return console.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint8Attribute = function(a, b) {
    return console.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint8ClampedAttribute = function(a, b) {
    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Int16Attribute = function(a, b) {
    return console.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint16Attribute = function(a, b) {
    return console.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Int32Attribute = function(a, b) {
    return console.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Uint32Attribute = function(a, b) {
    return console.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Float32Attribute = function(a, b) {
    return console.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.Float64Attribute = function(a, b) {
    return console.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), 
    new THREE.BufferAttribute(a, b);
}, THREE.BufferGeometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", 
    this.attributes = {}, this.attributesKeys = [], this.offsets = this.drawcalls = [], 
    this.boundingSphere = this.boundingBox = null;
}, THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    addAttribute: function(a, b, c) {
        !1 == b instanceof THREE.BufferAttribute ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), 
        this.attributes[a] = {
            array: b,
            itemSize: c
        }) : (this.attributes[a] = b, this.attributesKeys = Object.keys(this.attributes));
    },
    getAttribute: function(a) {
        return this.attributes[a];
    },
    addDrawCall: function(a, b, c) {
        this.drawcalls.push({
            start: a,
            count: b,
            index: void 0 !== c ? c : 0
        });
    },
    applyMatrix: function(a) {
        var b = this.attributes.position;
        void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0), b = this.attributes.normal, 
        void 0 !== b && (new THREE.Matrix3().getNormalMatrix(a).applyToVector3Array(b.array), 
        b.needsUpdate = !0);
    },
    center: function() {},
    fromGeometry: function(a, b) {
        b = b || {
            vertexColors: THREE.NoColors
        };
        var c = a.vertices, d = a.faces, e = a.faceVertexUvs, f = b.vertexColors, g = 0 < e[0].length, h = 3 == d[0].vertexNormals.length, i = new Float32Array(9 * d.length);
        this.addAttribute("position", new THREE.BufferAttribute(i, 3));
        var j = new Float32Array(9 * d.length);
        if (this.addAttribute("normal", new THREE.BufferAttribute(j, 3)), f !== THREE.NoColors) {
            var k = new Float32Array(9 * d.length);
            this.addAttribute("color", new THREE.BufferAttribute(k, 3));
        }
        if (!0 === g) {
            var l = new Float32Array(6 * d.length);
            this.addAttribute("uv", new THREE.BufferAttribute(l, 2));
        }
        for (var m = 0, n = 0, o = 0; m < d.length; m++, n += 6, o += 9) {
            var p = d[m], q = c[p.a], r = c[p.b], s = c[p.c];
            i[o] = q.x, i[o + 1] = q.y, i[o + 2] = q.z, i[o + 3] = r.x, i[o + 4] = r.y, i[o + 5] = r.z, 
            i[o + 6] = s.x, i[o + 7] = s.y, i[o + 8] = s.z, !0 === h ? (q = p.vertexNormals[0], 
            r = p.vertexNormals[1], s = p.vertexNormals[2], j[o] = q.x, j[o + 1] = q.y, j[o + 2] = q.z, 
            j[o + 3] = r.x, j[o + 4] = r.y, j[o + 5] = r.z, j[o + 6] = s.x, j[o + 7] = s.y, 
            j[o + 8] = s.z) : (q = p.normal, j[o] = q.x, j[o + 1] = q.y, j[o + 2] = q.z, j[o + 3] = q.x, 
            j[o + 4] = q.y, j[o + 5] = q.z, j[o + 6] = q.x, j[o + 7] = q.y, j[o + 8] = q.z), 
            f === THREE.FaceColors ? (p = p.color, k[o] = p.r, k[o + 1] = p.g, k[o + 2] = p.b, 
            k[o + 3] = p.r, k[o + 4] = p.g, k[o + 5] = p.b, k[o + 6] = p.r, k[o + 7] = p.g, 
            k[o + 8] = p.b) : f === THREE.VertexColors && (q = p.vertexColors[0], r = p.vertexColors[1], 
            p = p.vertexColors[2], k[o] = q.r, k[o + 1] = q.g, k[o + 2] = q.b, k[o + 3] = r.r, 
            k[o + 4] = r.g, k[o + 5] = r.b, k[o + 6] = p.r, k[o + 7] = p.g, k[o + 8] = p.b), 
            !0 === g && (p = e[0][m][0], q = e[0][m][1], r = e[0][m][2], l[n] = p.x, l[n + 1] = p.y, 
            l[n + 2] = q.x, l[n + 3] = q.y, l[n + 4] = r.x, l[n + 5] = r.y);
        }
        return this.computeBoundingSphere(), this;
    },
    computeBoundingBox: function() {
        var a = new THREE.Vector3();
        return function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3());
            var b = this.attributes.position.array;
            if (b) {
                var c = this.boundingBox;
                c.makeEmpty();
                for (var d = 0, e = b.length; e > d; d += 3) a.set(b[d], b[d + 1], b[d + 2]), c.expandByPoint(a);
            }
            (void 0 === b || 0 === b.length) && (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), 
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.');
        };
    }(),
    computeBoundingSphere: function() {
        var a = new THREE.Box3(), b = new THREE.Vector3();
        return function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
            var c = this.attributes.position.array;
            if (c) {
                a.makeEmpty();
                for (var d = this.boundingSphere.center, e = 0, f = c.length; f > e; e += 3) b.set(c[e], c[e + 1], c[e + 2]), 
                a.expandByPoint(b);
                a.center(d);
                for (var g = 0, e = 0, f = c.length; f > e; e += 3) b.set(c[e], c[e + 1], c[e + 2]), 
                g = Math.max(g, d.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(g), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');
            }
        };
    }(),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        var a = this.attributes;
        if (a.position) {
            var b = a.position.array;
            if (void 0 === a.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(b.length), 3)); else for (var c = a.normal.array, d = 0, e = c.length; e > d; d++) c[d] = 0;
            var f, g, h, c = a.normal.array, i = new THREE.Vector3(), j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3(), m = new THREE.Vector3();
            if (a.index) for (var n = a.index.array, o = 0 < this.offsets.length ? this.offsets : [ {
                start: 0,
                count: n.length,
                index: 0
            } ], p = 0, q = o.length; q > p; ++p) {
                e = o[p].start, f = o[p].count;
                for (var r = o[p].index, d = e, e = e + f; e > d; d += 3) f = 3 * (r + n[d]), g = 3 * (r + n[d + 1]), 
                h = 3 * (r + n[d + 2]), i.fromArray(b, f), j.fromArray(b, g), k.fromArray(b, h), 
                l.subVectors(k, j), m.subVectors(i, j), l.cross(m), c[f] += l.x, c[f + 1] += l.y, 
                c[f + 2] += l.z, c[g] += l.x, c[g + 1] += l.y, c[g + 2] += l.z, c[h] += l.x, c[h + 1] += l.y, 
                c[h + 2] += l.z;
            } else for (d = 0, e = b.length; e > d; d += 9) i.fromArray(b, d), j.fromArray(b, d + 3), 
            k.fromArray(b, d + 6), l.subVectors(k, j), m.subVectors(i, j), l.cross(m), c[d] = l.x, 
            c[d + 1] = l.y, c[d + 2] = l.z, c[d + 3] = l.x, c[d + 4] = l.y, c[d + 5] = l.z, 
            c[d + 6] = l.x, c[d + 7] = l.y, c[d + 8] = l.z;
            this.normalizeNormals(), a.normal.needsUpdate = !0;
        }
    },
    computeTangents: function() {
        function a(a, b, c) {
            B.fromArray(d, 3 * a), C.fromArray(d, 3 * b), D.fromArray(d, 3 * c), E.fromArray(f, 2 * a), 
            F.fromArray(f, 2 * b), G.fromArray(f, 2 * c), l = C.x - B.x, m = D.x - B.x, n = C.y - B.y, 
            o = D.y - B.y, p = C.z - B.z, q = D.z - B.z, r = F.x - E.x, s = G.x - E.x, t = F.y - E.y, 
            u = G.y - E.y, v = 1 / (r * u - s * t), H.set((u * l - t * m) * v, (u * n - t * o) * v, (u * p - t * q) * v), 
            I.set((r * m - s * l) * v, (r * o - s * n) * v, (r * q - s * p) * v), i[a].add(H), 
            i[b].add(H), i[c].add(H), j[a].add(I), j[b].add(I), j[c].add(I);
        }
        function b(a) {
            Q.fromArray(e, 3 * a), R.copy(Q), M = i[a], O.copy(M), O.sub(Q.multiplyScalar(Q.dot(M))).normalize(), 
            P.crossVectors(R, M), N = P.dot(j[a]), L = 0 > N ? -1 : 1, h[4 * a] = O.x, h[4 * a + 1] = O.y, 
            h[4 * a + 2] = O.z, h[4 * a + 3] = L;
        }
        if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()"); else {
            var c = this.attributes.index.array, d = this.attributes.position.array, e = this.attributes.normal.array, f = this.attributes.uv.array, g = d.length / 3;
            void 0 === this.attributes.tangent && this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * g), 4));
            for (var h = this.attributes.tangent.array, i = [], j = [], k = 0; g > k; k++) i[k] = new THREE.Vector3(), 
            j[k] = new THREE.Vector3();
            var l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B = new THREE.Vector3(), C = new THREE.Vector3(), D = new THREE.Vector3(), E = new THREE.Vector2(), F = new THREE.Vector2(), G = new THREE.Vector2(), H = new THREE.Vector3(), I = new THREE.Vector3();
            0 === this.drawcalls.length && this.addDrawCall(0, c.length, 0);
            var J = this.drawcalls, k = 0;
            for (x = J.length; x > k; ++k) {
                w = J[k].start, y = J[k].count;
                var K = J[k].index, g = w;
                for (w += y; w > g; g += 3) y = K + c[g], z = K + c[g + 1], A = K + c[g + 2], a(y, z, A);
            }
            var L, M, N, O = new THREE.Vector3(), P = new THREE.Vector3(), Q = new THREE.Vector3(), R = new THREE.Vector3(), k = 0;
            for (x = J.length; x > k; ++k) for (w = J[k].start, y = J[k].count, K = J[k].index, 
            g = w, w += y; w > g; g += 3) y = K + c[g], z = K + c[g + 1], A = K + c[g + 2], 
            b(y), b(z), b(A);
        }
    },
    computeOffsets: function(a) {
        var b = a;
        void 0 === a && (b = 65535), Date.now(), a = this.attributes.index.array;
        for (var c = this.attributes.position.array, d = a.length / 3, e = new Uint16Array(a.length), f = 0, g = 0, h = [ {
            start: 0,
            count: 0,
            index: 0
        } ], i = h[0], j = 0, k = 0, l = new Int32Array(6), m = new Int32Array(c.length), n = new Int32Array(c.length), o = 0; o < c.length; o++) m[o] = -1, 
        n[o] = -1;
        for (c = 0; d > c; c++) {
            for (var p = k = 0; 3 > p; p++) o = a[3 * c + p], -1 == m[o] ? (l[2 * p] = o, l[2 * p + 1] = -1, 
            k++) : m[o] < i.index ? (l[2 * p] = o, l[2 * p + 1] = -1, j++) : (l[2 * p] = o, 
            l[2 * p + 1] = m[o]);
            if (g + k > i.index + b) for (i = {
                start: f,
                count: 0,
                index: g
            }, h.push(i), k = 0; 6 > k; k += 2) p = l[k + 1], p > -1 && p < i.index && (l[k + 1] = -1);
            for (k = 0; 6 > k; k += 2) o = l[k], p = l[k + 1], -1 === p && (p = g++), m[o] = p, 
            n[p] = o, e[f++] = p - i.index, i.count++;
        }
        return this.reorderBuffers(e, n, g), this.offsets = h;
    },
    merge: function(a, b) {
        if (!1 != a instanceof THREE.BufferGeometry) {
            void 0 === b && (b = 0);
            var c, d = this.attributes;
            for (c in d) if (void 0 !== a.attributes[c]) for (var e = d[c].array, f = a.attributes[c], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, 
            f++) e[f] = g[h];
            return this;
        }
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
    },
    normalizeNormals: function() {
        for (var a, b, c, d = this.attributes.normal.array, e = 0, f = d.length; f > e; e += 3) a = d[e], 
        b = d[e + 1], c = d[e + 2], a = 1 / Math.sqrt(a * a + b * b + c * c), d[e] *= a, 
        d[e + 1] *= a, d[e + 2] *= a;
    },
    reorderBuffers: function(a, b, c) {
        var d, e = {};
        for (d in this.attributes) "index" != d && (e[d] = new this.attributes[d].array.constructor(this.attributes[d].itemSize * c));
        for (var f = 0; c > f; f++) {
            var g = b[f];
            for (d in this.attributes) if ("index" != d) for (var h = this.attributes[d].array, i = this.attributes[d].itemSize, j = e[d], k = 0; i > k; k++) j[f * i + k] = h[g * i + k];
        }
        this.attributes.index.array = a;
        for (d in this.attributes) "index" != d && (this.attributes[d].array = e[d], this.attributes[d].numItems = this.attributes[d].itemSize * c);
    },
    toJSON: function() {
        var a, b = {
            metadata: {
                version: 4,
                type: "BufferGeometry",
                generator: "BufferGeometryExporter"
            },
            uuid: this.uuid,
            type: this.type,
            data: {
                attributes: {}
            }
        }, c = this.attributes, d = this.offsets, e = this.boundingSphere;
        for (a in c) {
            for (var f = c[a], g = [], h = f.array, i = 0, j = h.length; j > i; i++) g[i] = h[i];
            b.data.attributes[a] = {
                itemSize: f.itemSize,
                type: f.array.constructor.name,
                array: g
            };
        }
        return 0 < d.length && (b.data.offsets = JSON.parse(JSON.stringify(d))), null !== e && (b.data.boundingSphere = {
            center: e.center.toArray(),
            radius: e.radius
        }), b;
    },
    clone: function() {
        var a, b = new THREE.BufferGeometry();
        for (a in this.attributes) b.addAttribute(a, this.attributes[a].clone());
        a = 0;
        for (var c = this.offsets.length; c > a; a++) {
            var d = this.offsets[a];
            b.offsets.push({
                start: d.start,
                index: d.index,
                count: d.count
            });
        }
        return b;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Geometry", 
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], 
    this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], 
    this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, 
    this.hasTangents = !1, this.dynamic = !0, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;
}, THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function(a) {
        for (var b = new THREE.Matrix3().getNormalMatrix(a), c = 0, d = this.vertices.length; d > c; c++) this.vertices[c].applyMatrix4(a);
        for (c = 0, d = this.faces.length; d > c; c++) {
            a = this.faces[c], a.normal.applyMatrix3(b).normalize();
            for (var e = 0, f = a.vertexNormals.length; f > e; e++) a.vertexNormals[e].applyMatrix3(b).normalize();
        }
        this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere();
    },
    fromBufferGeometry: function(a) {
        for (var b = this, c = a.attributes, d = c.position.array, e = void 0 !== c.index ? c.index.array : void 0, f = void 0 !== c.normal ? c.normal.array : void 0, g = void 0 !== c.color ? c.color.array : void 0, h = void 0 !== c.uv ? c.uv.array : void 0, i = [], j = [], k = c = 0; c < d.length; c += 3, 
        k += 2) b.vertices.push(new THREE.Vector3(d[c], d[c + 1], d[c + 2])), void 0 !== f && i.push(new THREE.Vector3(f[c], f[c + 1], f[c + 2])), 
        void 0 !== g && b.colors.push(new THREE.Color(g[c], g[c + 1], g[c + 2])), void 0 !== h && j.push(new THREE.Vector2(h[k], h[k + 1]));
        if (k = function(a, c, d) {
            var e = void 0 !== f ? [ i[a].clone(), i[c].clone(), i[d].clone() ] : [], k = void 0 !== g ? [ b.colors[a].clone(), b.colors[c].clone(), b.colors[d].clone() ] : [];
            b.faces.push(new THREE.Face3(a, c, d, e, k)), void 0 !== h && b.faceVertexUvs[0].push([ j[a].clone(), j[c].clone(), j[d].clone() ]);
        }, void 0 !== e) for (c = 0; c < e.length; c += 3) k(e[c], e[c + 1], e[c + 2]); else for (c = 0; c < d.length / 3; c += 3) k(c, c + 1, c + 2);
        return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), 
        null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this;
    },
    center: function() {
        this.computeBoundingBox();
        var a = new THREE.Vector3();
        return a.addVectors(this.boundingBox.min, this.boundingBox.max), a.multiplyScalar(-.5), 
        this.applyMatrix(new THREE.Matrix4().makeTranslation(a.x, a.y, a.z)), this.computeBoundingBox(), 
        a;
    },
    computeFaceNormals: function() {
        for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; d > c; c++) {
            var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
            a.subVectors(this.vertices[e.c], g), b.subVectors(f, g), a.cross(b), a.normalize(), 
            e.normal.copy(a);
        }
    },
    computeVertexNormals: function(a) {
        var b, c, d;
        for (d = Array(this.vertices.length), b = 0, c = this.vertices.length; c > b; b++) d[b] = new THREE.Vector3();
        if (a) {
            var e, f, g, h = new THREE.Vector3(), i = new THREE.Vector3();
            for (new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), a = 0, b = this.faces.length; b > a; a++) c = this.faces[a], 
            e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), 
            i.subVectors(e, f), h.cross(i), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);
        } else for (a = 0, b = this.faces.length; b > a; a++) c = this.faces[a], d[c.a].add(c.normal), 
        d[c.b].add(c.normal), d[c.c].add(c.normal);
        for (b = 0, c = this.vertices.length; c > b; b++) d[b].normalize();
        for (a = 0, b = this.faces.length; b > a; a++) c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), 
        c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone();
    },
    computeMorphNormals: function() {
        var a, b, c, d, e;
        for (c = 0, d = this.faces.length; d > c; c++) for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), 
        e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; b > a; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
        var f = new THREE.Geometry();
        for (f.faces = this.faces, a = 0, b = this.morphTargets.length; b > a; a++) {
            if (!this.morphNormals[a]) {
                this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [], 
                e = this.morphNormals[a].faceNormals;
                var g, h, i = this.morphNormals[a].vertexNormals;
                for (c = 0, d = this.faces.length; d > c; c++) g = new THREE.Vector3(), h = {
                    a: new THREE.Vector3(),
                    b: new THREE.Vector3(),
                    c: new THREE.Vector3()
                }, e.push(g), i.push(h);
            }
            for (i = this.morphNormals[a], f.vertices = this.morphTargets[a].vertices, f.computeFaceNormals(), 
            f.computeVertexNormals(), c = 0, d = this.faces.length; d > c; c++) e = this.faces[c], 
            g = i.faceNormals[c], h = i.vertexNormals[c], g.copy(e.normal), h.a.copy(e.vertexNormals[0]), 
            h.b.copy(e.vertexNormals[1]), h.c.copy(e.vertexNormals[2]);
        }
        for (c = 0, d = this.faces.length; d > c; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, 
        e.vertexNormals = e.__originalVertexNormals;
    },
    computeTangents: function() {
        var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r = [], s = [];
        c = new THREE.Vector3();
        var t = new THREE.Vector3(), u = new THREE.Vector3(), v = new THREE.Vector3(), w = new THREE.Vector3();
        for (a = 0, b = this.vertices.length; b > a; a++) r[a] = new THREE.Vector3(), s[a] = new THREE.Vector3();
        for (a = 0, b = this.faces.length; b > a; a++) e = this.faces[a], f = this.faceVertexUvs[0][a], 
        d = e.a, q = e.b, e = e.c, g = this.vertices[d], h = this.vertices[q], i = this.vertices[e], 
        j = f[0], k = f[1], l = f[2], f = h.x - g.x, m = i.x - g.x, n = h.y - g.y, o = i.y - g.y, 
        h = h.z - g.z, g = i.z - g.z, i = k.x - j.x, p = l.x - j.x, k = k.y - j.y, j = l.y - j.y, 
        l = 1 / (i * j - p * k), c.set((j * f - k * m) * l, (j * n - k * o) * l, (j * h - k * g) * l), 
        t.set((i * m - p * f) * l, (i * o - p * n) * l, (i * g - p * h) * l), r[d].add(c), 
        r[q].add(c), r[e].add(c), s[d].add(t), s[q].add(t), s[e].add(t);
        for (t = [ "a", "b", "c", "d" ], a = 0, b = this.faces.length; b > a; a++) for (e = this.faces[a], 
        c = 0; c < Math.min(e.vertexNormals.length, 3); c++) w.copy(e.vertexNormals[c]), 
        d = e[t[c]], q = r[d], u.copy(q), u.sub(w.multiplyScalar(w.dot(q))).normalize(), 
        v.crossVectors(e.vertexNormals[c], q), d = v.dot(s[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(u.x, u.y, u.z, d);
        this.hasTangents = !0;
    },
    computeLineDistances: function() {
        for (var a = 0, b = this.vertices, c = 0, d = b.length; d > c; c++) c > 0 && (a += b[c].distanceTo(b[c - 1])), 
        this.lineDistances[c] = a;
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere()), this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(a, b, c) {
        if (!1 == a instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a); else {
            var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, i = a.faces, j = this.faceVertexUvs[0];
            a = a.faceVertexUvs[0], void 0 === c && (c = 0), void 0 !== b && (d = new THREE.Matrix3().getNormalMatrix(b));
            for (var k = 0, l = g.length; l > k; k++) {
                var m = g[k].clone();
                void 0 !== b && m.applyMatrix4(b), f.push(m);
            }
            for (k = 0, l = i.length; l > k; k++) {
                var n, g = i[k], o = g.vertexNormals, p = g.vertexColors, m = new THREE.Face3(g.a + e, g.b + e, g.c + e);
                for (m.normal.copy(g.normal), void 0 !== d && m.normal.applyMatrix3(d).normalize(), 
                b = 0, f = o.length; f > b; b++) n = o[b].clone(), void 0 !== d && n.applyMatrix3(d).normalize(), 
                m.vertexNormals.push(n);
                for (m.color.copy(g.color), b = 0, f = p.length; f > b; b++) n = p[b], m.vertexColors.push(n.clone());
                m.materialIndex = g.materialIndex + c, h.push(m);
            }
            for (k = 0, l = a.length; l > k; k++) if (c = a[k], d = [], void 0 !== c) {
                for (b = 0, f = c.length; f > b; b++) d.push(c[b].clone());
                j.push(d);
            }
        }
    },
    mergeMesh: function(a) {
        !1 == a instanceof THREE.Mesh ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), 
        this.merge(a.geometry, a.matrix));
    },
    mergeVertices: function() {
        var a, b, c, d = {}, e = [], f = [], g = Math.pow(10, 4);
        for (b = 0, c = this.vertices.length; c > b; b++) a = this.vertices[b], a = Math.round(a.x * g) + "_" + Math.round(a.y * g) + "_" + Math.round(a.z * g), 
        void 0 === d[a] ? (d[a] = b, e.push(this.vertices[b]), f[b] = e.length - 1) : f[b] = f[d[a]];
        for (d = [], b = 0, c = this.faces.length; c > b; b++) for (g = this.faces[b], g.a = f[g.a], 
        g.b = f[g.b], g.c = f[g.c], g = [ g.a, g.b, g.c ], a = 0; 3 > a; a++) if (g[a] == g[(a + 1) % 3]) {
            d.push(b);
            break;
        }
        for (b = d.length - 1; b >= 0; b--) for (g = d[b], this.faces.splice(g, 1), f = 0, 
        c = this.faceVertexUvs.length; c > f; f++) this.faceVertexUvs[f].splice(g, 1);
        return b = this.vertices.length - e.length, this.vertices = e, b;
    },
    toJSON: function() {
        function a(a, b, c) {
            return c ? a | 1 << b : a & ~(1 << b);
        }
        function b(a) {
            var b = a.x.toString() + a.y.toString() + a.z.toString();
            return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3, i.push(a.x, a.y, a.z), j[b]);
        }
        function c(a) {
            var b = a.r.toString() + a.g.toString() + a.b.toString();
            return void 0 !== l[b] ? l[b] : (l[b] = k.length, k.push(a.getHex()), l[b]);
        }
        function d(a) {
            var b = a.x.toString() + a.y.toString();
            return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2, m.push(a.x, a.y), n[b]);
        }
        var e = {
            metadata: {
                version: 4,
                type: "BufferGeometry",
                generator: "BufferGeometryExporter"
            },
            uuid: this.uuid,
            type: this.type
        };
        if ("" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
            var f, g = this.parameters;
            for (f in g) void 0 !== g[f] && (e[f] = g[f]);
            return e;
        }
        for (g = [], f = 0; f < this.vertices.length; f++) {
            var h = this.vertices[f];
            g.push(h.x, h.y, h.z);
        }
        var h = [], i = [], j = {}, k = [], l = {}, m = [], n = {};
        for (f = 0; f < this.faces.length; f++) {
            var o = this.faces[f], p = void 0 !== this.faceVertexUvs[0][f], q = 0 < o.normal.length(), r = 0 < o.vertexNormals.length, s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b, t = 0 < o.vertexColors.length, u = 0, u = a(u, 0, 0), u = a(u, 1, !1), u = a(u, 2, !1), u = a(u, 3, p), u = a(u, 4, q), u = a(u, 5, r), u = a(u, 6, s), u = a(u, 7, t);
            h.push(u), h.push(o.a, o.b, o.c), p && (p = this.faceVertexUvs[0][f], h.push(d(p[0]), d(p[1]), d(p[2]))), 
            q && h.push(b(o.normal)), r && (q = o.vertexNormals, h.push(b(q[0]), b(q[1]), b(q[2]))), 
            s && h.push(c(o.color)), t && (o = o.vertexColors, h.push(c(o[0]), c(o[1]), c(o[2])));
        }
        return e.data = {}, e.data.vertices = g, e.data.normals = i, 0 < k.length && (e.data.colors = k), 
        0 < m.length && (e.data.uvs = [ m ]), e.data.faces = h, e;
    },
    clone: function() {
        for (var a = new THREE.Geometry(), b = this.vertices, c = 0, d = b.length; d > c; c++) a.vertices.push(b[c].clone());
        for (b = this.faces, c = 0, d = b.length; d > c; c++) a.faces.push(b[c].clone());
        for (c = 0, d = this.faceVertexUvs.length; d > c; c++) {
            b = this.faceVertexUvs[c], void 0 === a.faceVertexUvs[c] && (a.faceVertexUvs[c] = []);
            for (var e = 0, f = b.length; f > e; e++) {
                for (var g = b[e], h = [], i = 0, j = g.length; j > i; i++) h.push(g[i].clone());
                a.faceVertexUvs[c].push(h);
            }
        }
        return a;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, 
THREE.Camera = function() {
    THREE.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new THREE.Matrix4(), 
    this.projectionMatrix = new THREE.Matrix4();
}, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.constructor = THREE.Camera, 
THREE.Camera.prototype.getWorldDirection = function() {
    var a = new THREE.Quaternion();
    return function(b) {
        return b = b || new THREE.Vector3(), this.getWorldQuaternion(a), b.set(0, 0, -1).applyQuaternion(a);
    };
}(), THREE.Camera.prototype.lookAt = function() {
    var a = new THREE.Matrix4();
    return function(b) {
        a.lookAt(this.position, b, this.up), this.quaternion.setFromRotationMatrix(a);
    };
}(), THREE.Camera.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Camera()), THREE.Object3D.prototype.clone.call(this, a), 
    a.matrixWorldInverse.copy(this.matrixWorldInverse), a.projectionMatrix.copy(this.projectionMatrix), 
    a;
}, THREE.CubeCamera = function(a, b, c) {
    THREE.Object3D.call(this), this.type = "CubeCamera";
    var d = new THREE.PerspectiveCamera(90, 1, a, b);
    d.up.set(0, -1, 0), d.lookAt(new THREE.Vector3(1, 0, 0)), this.add(d);
    var e = new THREE.PerspectiveCamera(90, 1, a, b);
    e.up.set(0, -1, 0), e.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(e);
    var f = new THREE.PerspectiveCamera(90, 1, a, b);
    f.up.set(0, 0, 1), f.lookAt(new THREE.Vector3(0, 1, 0)), this.add(f);
    var g = new THREE.PerspectiveCamera(90, 1, a, b);
    g.up.set(0, 0, -1), g.lookAt(new THREE.Vector3(0, -1, 0)), this.add(g);
    var h = new THREE.PerspectiveCamera(90, 1, a, b);
    h.up.set(0, -1, 0), h.lookAt(new THREE.Vector3(0, 0, 1)), this.add(h);
    var i = new THREE.PerspectiveCamera(90, 1, a, b);
    i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(0, 0, -1)), this.add(i), this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    }), this.updateCubeMap = function(a, b) {
        var c = this.renderTarget, j = c.generateMipmaps;
        c.generateMipmaps = !1, c.activeCubeFace = 0, a.render(b, d, c), c.activeCubeFace = 1, 
        a.render(b, e, c), c.activeCubeFace = 2, a.render(b, f, c), c.activeCubeFace = 3, 
        a.render(b, g, c), c.activeCubeFace = 4, a.render(b, h, c), c.generateMipmaps = j, 
        c.activeCubeFace = 5, a.render(b, i, c);
    };
}, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CubeCamera.prototype.constructor = THREE.CubeCamera, 
THREE.OrthographicCamera = function(a, b, c, d, e, f) {
    THREE.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = a, 
    this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, 
    this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix();
}, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera, 
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
    var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2;
    this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far);
}, THREE.OrthographicCamera.prototype.clone = function() {
    var a = new THREE.OrthographicCamera();
    return THREE.Camera.prototype.clone.call(this, a), a.zoom = this.zoom, a.left = this.left, 
    a.right = this.right, a.top = this.top, a.bottom = this.bottom, a.near = this.near, 
    a.far = this.far, a.projectionMatrix.copy(this.projectionMatrix), a;
}, THREE.PerspectiveCamera = function(a, b, c, d) {
    THREE.Camera.call(this), this.type = "PerspectiveCamera", this.zoom = 1, this.fov = void 0 !== a ? a : 50, 
    this.aspect = void 0 !== b ? b : 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, 
    this.updateProjectionMatrix();
}, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera, 
THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
    void 0 === b && (b = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a))), 
    this.updateProjectionMatrix();
}, THREE.PerspectiveCamera.prototype.setViewOffset = function(a, b, c, d, e, f) {
    this.fullWidth = a, this.fullHeight = b, this.x = c, this.y = d, this.width = e, 
    this.height = f, this.updateProjectionMatrix();
}, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    var a = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
    if (this.fullWidth) {
        var b = this.fullWidth / this.fullHeight, a = Math.tan(THREE.Math.degToRad(.5 * a)) * this.near, c = -a, d = b * c, b = Math.abs(b * a - d), c = Math.abs(a - c);
        this.projectionMatrix.makeFrustum(d + this.x * b / this.fullWidth, d + (this.x + this.width) * b / this.fullWidth, a - (this.y + this.height) * c / this.fullHeight, a - this.y * c / this.fullHeight, this.near, this.far);
    } else this.projectionMatrix.makePerspective(a, this.aspect, this.near, this.far);
}, THREE.PerspectiveCamera.prototype.clone = function() {
    var a = new THREE.PerspectiveCamera();
    return THREE.Camera.prototype.clone.call(this, a), a.zoom = this.zoom, a.fov = this.fov, 
    a.aspect = this.aspect, a.near = this.near, a.far = this.far, a.projectionMatrix.copy(this.projectionMatrix), 
    a;
}, THREE.Light = function(a) {
    THREE.Object3D.call(this), this.type = "Light", this.color = new THREE.Color(a);
}, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.constructor = THREE.Light, 
THREE.Light.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Light()), THREE.Object3D.prototype.clone.call(this, a), 
    a.color.copy(this.color), a;
}, THREE.AmbientLight = function(a) {
    THREE.Light.call(this, a), this.type = "AmbientLight";
}, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.constructor = THREE.AmbientLight, 
THREE.AmbientLight.prototype.clone = function() {
    var a = new THREE.AmbientLight();
    return THREE.Light.prototype.clone.call(this, a), a;
}, THREE.AreaLight = function(a, b) {
    THREE.Light.call(this, a), this.type = "AreaLight", this.normal = new THREE.Vector3(0, -1, 0), 
    this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== b ? b : 1, 
    this.height = this.width = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, 
    this.quadraticAttenuation = .1;
}, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.AreaLight.prototype.constructor = THREE.AreaLight, 
THREE.DirectionalLight = function(a, b) {
    THREE.Light.call(this, a), this.type = "DirectionalLight", this.position.set(0, 1, 0), 
    this.target = new THREE.Object3D(), this.intensity = void 0 !== b ? b : 1, this.onlyShadow = this.castShadow = !1, 
    this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, 
    this.shadowCameraTop = this.shadowCameraRight = 500, this.shadowCameraBottom = -500, 
    this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, 
    this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), 
    this.shadowCascadeCount = 2, this.shadowCascadeBias = [ 0, 0, 0 ], this.shadowCascadeWidth = [ 512, 512, 512 ], 
    this.shadowCascadeHeight = [ 512, 512, 512 ], this.shadowCascadeNearZ = [ -1, .99, .998 ], 
    this.shadowCascadeFarZ = [ .99, .998, 1 ], this.shadowCascadeArray = [], this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
}, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight, 
THREE.DirectionalLight.prototype.clone = function() {
    var a = new THREE.DirectionalLight();
    return THREE.Light.prototype.clone.call(this, a), a.target = this.target.clone(), 
    a.intensity = this.intensity, a.castShadow = this.castShadow, a.onlyShadow = this.onlyShadow, 
    a.shadowCameraNear = this.shadowCameraNear, a.shadowCameraFar = this.shadowCameraFar, 
    a.shadowCameraLeft = this.shadowCameraLeft, a.shadowCameraRight = this.shadowCameraRight, 
    a.shadowCameraTop = this.shadowCameraTop, a.shadowCameraBottom = this.shadowCameraBottom, 
    a.shadowCameraVisible = this.shadowCameraVisible, a.shadowBias = this.shadowBias, 
    a.shadowDarkness = this.shadowDarkness, a.shadowMapWidth = this.shadowMapWidth, 
    a.shadowMapHeight = this.shadowMapHeight, a.shadowCascade = this.shadowCascade, 
    a.shadowCascadeOffset.copy(this.shadowCascadeOffset), a.shadowCascadeCount = this.shadowCascadeCount, 
    a.shadowCascadeBias = this.shadowCascadeBias.slice(0), a.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), 
    a.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), a.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), 
    a.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), a;
}, THREE.HemisphereLight = function(a, b, c) {
    THREE.Light.call(this, a), this.type = "HemisphereLight", this.position.set(0, 100, 0), 
    this.groundColor = new THREE.Color(b), this.intensity = void 0 !== c ? c : 1;
}, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight, 
THREE.HemisphereLight.prototype.clone = function() {
    var a = new THREE.HemisphereLight();
    return THREE.Light.prototype.clone.call(this, a), a.groundColor.copy(this.groundColor), 
    a.intensity = this.intensity, a;
}, THREE.PointLight = function(a, b, c) {
    THREE.Light.call(this, a), this.type = "PointLight", this.intensity = void 0 !== b ? b : 1, 
    this.distance = void 0 !== c ? c : 0;
}, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.constructor = THREE.PointLight, 
THREE.PointLight.prototype.clone = function() {
    var a = new THREE.PointLight();
    return THREE.Light.prototype.clone.call(this, a), a.intensity = this.intensity, 
    a.distance = this.distance, a;
}, THREE.SpotLight = function(a, b, c, d, e) {
    THREE.Light.call(this, a), this.type = "SpotLight", this.position.set(0, 1, 0), 
    this.target = new THREE.Object3D(), this.intensity = void 0 !== b ? b : 1, this.distance = void 0 !== c ? c : 0, 
    this.angle = void 0 !== d ? d : Math.PI / 3, this.exponent = void 0 !== e ? e : 10, 
    this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, 
    this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, 
    this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
}, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.constructor = THREE.SpotLight, 
THREE.SpotLight.prototype.clone = function() {
    var a = new THREE.SpotLight();
    return THREE.Light.prototype.clone.call(this, a), a.target = this.target.clone(), 
    a.intensity = this.intensity, a.distance = this.distance, a.angle = this.angle, 
    a.exponent = this.exponent, a.castShadow = this.castShadow, a.onlyShadow = this.onlyShadow, 
    a.shadowCameraNear = this.shadowCameraNear, a.shadowCameraFar = this.shadowCameraFar, 
    a.shadowCameraFov = this.shadowCameraFov, a.shadowCameraVisible = this.shadowCameraVisible, 
    a.shadowBias = this.shadowBias, a.shadowDarkness = this.shadowDarkness, a.shadowMapWidth = this.shadowMapWidth, 
    a.shadowMapHeight = this.shadowMapHeight, a;
}, THREE.Cache = function() {
    this.files = {};
}, THREE.Cache.prototype = {
    constructor: THREE.Cache,
    add: function(a, b) {
        this.files[a] = b;
    },
    get: function(a) {
        return this.files[a];
    },
    remove: function(a) {
        delete this.files[a];
    },
    clear: function() {
        this.files = {};
    }
}, THREE.Loader = function(a) {
    this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null, 
    this.imageLoader = new THREE.ImageLoader(), this.onLoadStart = function() {}, this.onLoadProgress = function() {}, 
    this.onLoadComplete = function() {};
}, THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: void 0,
    addStatusElement: function() {
        var a = document.createElement("div");
        return a.style.position = "absolute", a.style.right = "0px", a.style.top = "0px", 
        a.style.fontSize = "0.8em", a.style.textAlign = "left", a.style.background = "rgba(0,0,0,0.25)", 
        a.style.color = "#fff", a.style.width = "120px", a.style.padding = "0.5em 0.5em 0.5em 0.5em", 
        a.style.zIndex = 1e3, a.innerHTML = "Loading ...", a;
    },
    updateProgress: function(a) {
        var b = "Loaded ", b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + "%") : b + ((a.loaded / 1024).toFixed(2) + " KB");
        this.statusDomElement.innerHTML = b;
    },
    extractUrlBase: function(a) {
        return a = a.split("/"), 1 === a.length ? "./" : (a.pop(), a.join("/") + "/");
    },
    initMaterials: function(a, b) {
        for (var c = [], d = 0; d < a.length; ++d) c[d] = this.createMaterial(a[d], b);
        return c;
    },
    needsTangents: function(a) {
        for (var b = 0, c = a.length; c > b; b++) if (a[b] instanceof THREE.ShaderMaterial) return !0;
        return !1;
    },
    createMaterial: function(a, b) {
        function c(a) {
            return a = Math.log(a) / Math.LN2, Math.pow(2, Math.round(a));
        }
        function d(a, d, e, g, h, i, j) {
            var k, l = b + e, m = THREE.Loader.Handlers.get(l);
            null !== m ? k = m.load(l) : (k = new THREE.Texture(), m = f.imageLoader, m.crossOrigin = f.crossOrigin, 
            m.load(l, function(a) {
                if (!1 === THREE.Math.isPowerOfTwo(a.width) || !1 === THREE.Math.isPowerOfTwo(a.height)) {
                    var b = c(a.width), d = c(a.height), e = document.createElement("canvas");
                    e.width = b, e.height = d, e.getContext("2d").drawImage(a, 0, 0, b, d), k.image = e;
                } else k.image = a;
                k.needsUpdate = !0;
            })), k.sourceFile = e, g && (k.repeat.set(g[0], g[1]), 1 !== g[0] && (k.wrapS = THREE.RepeatWrapping), 
            1 !== g[1] && (k.wrapT = THREE.RepeatWrapping)), h && k.offset.set(h[0], h[1]), 
            i && (e = {
                repeat: THREE.RepeatWrapping,
                mirror: THREE.MirroredRepeatWrapping
            }, void 0 !== e[i[0]] && (k.wrapS = e[i[0]]), void 0 !== e[i[1]] && (k.wrapT = e[i[1]])), 
            j && (k.anisotropy = j), a[d] = k;
        }
        function e(a) {
            return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
        }
        var f = this, g = "MeshLambertMaterial", h = {
            color: 15658734,
            opacity: 1,
            map: null,
            lightMap: null,
            normalMap: null,
            bumpMap: null,
            wireframe: !1
        };
        if (a.shading) {
            var i = a.shading.toLowerCase();
            "phong" === i ? g = "MeshPhongMaterial" : "basic" === i && (g = "MeshBasicMaterial");
        }
        return void 0 !== a.blending && void 0 !== THREE[a.blending] && (h.blending = THREE[a.blending]), 
        (void 0 !== a.transparent || 1 > a.opacity) && (h.transparent = a.transparent), 
        void 0 !== a.depthTest && (h.depthTest = a.depthTest), void 0 !== a.depthWrite && (h.depthWrite = a.depthWrite), 
        void 0 !== a.visible && (h.visible = a.visible), void 0 !== a.flipSided && (h.side = THREE.BackSide), 
        void 0 !== a.doubleSided && (h.side = THREE.DoubleSide), void 0 !== a.wireframe && (h.wireframe = a.wireframe), 
        void 0 !== a.vertexColors && ("face" === a.vertexColors ? h.vertexColors = THREE.FaceColors : a.vertexColors && (h.vertexColors = THREE.VertexColors)), 
        a.colorDiffuse ? h.color = e(a.colorDiffuse) : a.DbgColor && (h.color = a.DbgColor), 
        a.colorSpecular && (h.specular = e(a.colorSpecular)), a.colorAmbient && (h.ambient = e(a.colorAmbient)), 
        a.colorEmissive && (h.emissive = e(a.colorEmissive)), a.transparency && (h.opacity = a.transparency), 
        a.specularCoef && (h.shininess = a.specularCoef), a.mapDiffuse && b && d(h, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy), 
        a.mapLight && b && d(h, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy), 
        a.mapBump && b && d(h, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy), 
        a.mapNormal && b && d(h, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy), 
        a.mapSpecular && b && d(h, "specularMap", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy), 
        a.mapAlpha && b && d(h, "alphaMap", a.mapAlpha, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy), 
        a.mapBumpScale && (h.bumpScale = a.mapBumpScale), a.mapNormalFactor && (h.normalScale = new THREE.Vector2(a.mapNormalFactor, a.mapNormalFactor)), 
        g = new THREE[g](h), void 0 !== a.DbgName && (g.name = a.DbgName), g;
    }
}, THREE.Loader.Handlers = {
    handlers: [],
    add: function(a, b) {
        this.handlers.push(a, b);
    },
    get: function(a) {
        for (var b = 0, c = this.handlers.length; c > b; b += 2) {
            var d = this.handlers[b + 1];
            if (this.handlers[b].test(a)) return d;
        }
        return null;
    }
}, THREE.XHRLoader = function(a) {
    this.cache = new THREE.Cache(), this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function(a, b, c, d) {
        var e = this, f = e.cache.get(a);
        void 0 !== f ? b && b(f) : (f = new XMLHttpRequest(), f.open("GET", a, !0), f.addEventListener("load", function() {
            e.cache.add(a, this.response), b && b(this.response), e.manager.itemEnd(a);
        }, !1), void 0 !== c && f.addEventListener("progress", function(a) {
            c(a);
        }, !1), void 0 !== d && f.addEventListener("error", function(a) {
            d(a);
        }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (f.responseType = this.responseType), 
        f.send(null), e.manager.itemStart(a));
    },
    setResponseType: function(a) {
        this.responseType = a;
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    }
}, THREE.ImageLoader = function(a) {
    this.cache = new THREE.Cache(), this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function(a, b, c, d) {
        var e = this, f = e.cache.get(a);
        return void 0 === f ? (f = document.createElement("img"), void 0 !== b && f.addEventListener("load", function() {
            e.cache.add(a, this), b(this), e.manager.itemEnd(a);
        }, !1), void 0 !== c && f.addEventListener("progress", function(a) {
            c(a);
        }, !1), void 0 !== d && f.addEventListener("error", function(a) {
            d(a);
        }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), f.src = a, 
        e.manager.itemStart(a), f) : void b(f);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    }
}, THREE.JSONLoader = function(a) {
    THREE.Loader.call(this, a), this.withCredentials = !1;
}, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.constructor = THREE.JSONLoader, 
THREE.JSONLoader.prototype.load = function(a, b, c) {
    c = c && "string" == typeof c ? c : this.extractUrlBase(a), this.onLoadStart(), 
    this.loadAjaxJSON(this, a, b, c);
}, THREE.JSONLoader.prototype.loadAjaxJSON = function(a, b, c, d, e) {
    var f = new XMLHttpRequest(), g = 0;
    f.onreadystatechange = function() {
        if (f.readyState === f.DONE) if (200 === f.status || 0 === f.status) {
            if (f.responseText) {
                var h = JSON.parse(f.responseText);
                if (void 0 !== h.metadata && "scene" === h.metadata.type) return void console.error('THREE.JSONLoader: "' + b + '" seems to be a Scene. Use THREE.SceneLoader instead.');
                h = a.parse(h, d), c(h.geometry, h.materials);
            } else console.error('THREE.JSONLoader: "' + b + '" seems to be unreachable or the file is empty.');
            a.onLoadComplete();
        } else console.error("THREE.JSONLoader: Couldn't load \"" + b + '" (' + f.status + ")"); else f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader("Content-Length")), 
        e({
            total: g,
            loaded: f.responseText.length
        })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader("Content-Length"));
    }, f.open("GET", b, !0), f.withCredentials = this.withCredentials, f.send(null);
}, THREE.JSONLoader.prototype.parse = function(a, b) {
    var c = new THREE.Geometry(), d = void 0 !== a.scale ? 1 / a.scale : 1;
    return function(b) {
        var d, e, f, g, h, i, j, k, l, m, n, o, p, q = a.faces;
        i = a.vertices;
        var r = a.normals, s = a.colors, t = 0;
        if (void 0 !== a.uvs) {
            for (d = 0; d < a.uvs.length; d++) a.uvs[d].length && t++;
            for (d = 0; t > d; d++) c.faceVertexUvs[d] = [];
        }
        for (g = 0, h = i.length; h > g; ) d = new THREE.Vector3(), d.x = i[g++] * b, d.y = i[g++] * b, 
        d.z = i[g++] * b, c.vertices.push(d);
        for (g = 0, h = q.length; h > g; ) if (b = q[g++], l = 1 & b, f = 2 & b, d = 8 & b, 
        j = 16 & b, m = 32 & b, i = 64 & b, b &= 128, l) {
            if (l = new THREE.Face3(), l.a = q[g], l.b = q[g + 1], l.c = q[g + 3], n = new THREE.Face3(), 
            n.a = q[g + 1], n.b = q[g + 2], n.c = q[g + 3], g += 4, f && (f = q[g++], l.materialIndex = f, 
            n.materialIndex = f), f = c.faces.length, d) for (d = 0; t > d; d++) for (o = a.uvs[d], 
            c.faceVertexUvs[d][f] = [], c.faceVertexUvs[d][f + 1] = [], e = 0; 4 > e; e++) k = q[g++], 
            p = o[2 * k], k = o[2 * k + 1], p = new THREE.Vector2(p, k), 2 !== e && c.faceVertexUvs[d][f].push(p), 
            0 !== e && c.faceVertexUvs[d][f + 1].push(p);
            if (j && (j = 3 * q[g++], l.normal.set(r[j++], r[j++], r[j]), n.normal.copy(l.normal)), 
            m) for (d = 0; 4 > d; d++) j = 3 * q[g++], m = new THREE.Vector3(r[j++], r[j++], r[j]), 
            2 !== d && l.vertexNormals.push(m), 0 !== d && n.vertexNormals.push(m);
            if (i && (i = q[g++], i = s[i], l.color.setHex(i), n.color.setHex(i)), b) for (d = 0; 4 > d; d++) i = q[g++], 
            i = s[i], 2 !== d && l.vertexColors.push(new THREE.Color(i)), 0 !== d && n.vertexColors.push(new THREE.Color(i));
            c.faces.push(l), c.faces.push(n);
        } else {
            if (l = new THREE.Face3(), l.a = q[g++], l.b = q[g++], l.c = q[g++], f && (f = q[g++], 
            l.materialIndex = f), f = c.faces.length, d) for (d = 0; t > d; d++) for (o = a.uvs[d], 
            c.faceVertexUvs[d][f] = [], e = 0; 3 > e; e++) k = q[g++], p = o[2 * k], k = o[2 * k + 1], 
            p = new THREE.Vector2(p, k), c.faceVertexUvs[d][f].push(p);
            if (j && (j = 3 * q[g++], l.normal.set(r[j++], r[j++], r[j])), m) for (d = 0; 3 > d; d++) j = 3 * q[g++], 
            m = new THREE.Vector3(r[j++], r[j++], r[j]), l.vertexNormals.push(m);
            if (i && (i = q[g++], l.color.setHex(s[i])), b) for (d = 0; 3 > d; d++) i = q[g++], 
            l.vertexColors.push(new THREE.Color(s[i]));
            c.faces.push(l);
        }
    }(d), function() {
        var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
        if (a.skinWeights) for (var d = 0, e = a.skinWeights.length; e > d; d += b) c.skinWeights.push(new THREE.Vector4(a.skinWeights[d], b > 1 ? a.skinWeights[d + 1] : 0, b > 2 ? a.skinWeights[d + 2] : 0, b > 3 ? a.skinWeights[d + 3] : 0));
        if (a.skinIndices) for (d = 0, e = a.skinIndices.length; e > d; d += b) c.skinIndices.push(new THREE.Vector4(a.skinIndices[d], b > 1 ? a.skinIndices[d + 1] : 0, b > 2 ? a.skinIndices[d + 2] : 0, b > 3 ? a.skinIndices[d + 3] : 0));
        c.bones = a.bones, c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match."), 
        c.animation = a.animation, c.animations = a.animations;
    }(), function(b) {
        if (void 0 !== a.morphTargets) {
            var d, e, f, g, h, i;
            for (d = 0, e = a.morphTargets.length; e > d; d++) for (c.morphTargets[d] = {}, 
            c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], 
            h = c.morphTargets[d].vertices, i = a.morphTargets[d].vertices, f = 0, g = i.length; g > f; f += 3) {
                var j = new THREE.Vector3();
                j.x = i[f] * b, j.y = i[f + 1] * b, j.z = i[f + 2] * b, h.push(j);
            }
        }
        if (void 0 !== a.morphColors) for (d = 0, e = a.morphColors.length; e > d; d++) for (c.morphColors[d] = {}, 
        c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], g = c.morphColors[d].colors, 
        h = a.morphColors[d].colors, b = 0, f = h.length; f > b; b += 3) i = new THREE.Color(16755200), 
        i.setRGB(h[b], h[b + 1], h[b + 2]), g.push(i);
    }(d), c.computeFaceNormals(), c.computeBoundingSphere(), void 0 === a.materials || 0 === a.materials.length ? {
        geometry: c
    } : (d = this.initMaterials(a.materials, b), this.needsTangents(d) && c.computeTangents(), 
    {
        geometry: c,
        materials: d
    });
}, THREE.LoadingManager = function(a, b, c) {
    var d = this, e = 0, f = 0;
    this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function() {
        f++;
    }, this.itemEnd = function(a) {
        e++, void 0 !== d.onProgress && d.onProgress(a, e, f), e === f && void 0 !== d.onLoad && d.onLoad();
    };
}, THREE.DefaultLoadingManager = new THREE.LoadingManager(), THREE.BufferGeometryLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            b(e.parse(JSON.parse(a)));
        }, c, d);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    parse: function(a) {
        var b, c = new THREE.BufferGeometry(), d = a.attributes;
        for (b in d) {
            var e = d[b], f = new self[e.type](e.array);
            c.addAttribute(b, new THREE.BufferAttribute(f, e.itemSize));
        }
        return d = a.offsets, void 0 !== d && (c.offsets = JSON.parse(JSON.stringify(d))), 
        a = a.boundingSphere, void 0 !== a && (d = new THREE.Vector3(), void 0 !== a.center && d.fromArray(a.center), 
        c.boundingSphere = new THREE.Sphere(d, a.radius)), c;
    }
}, THREE.MaterialLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            b(e.parse(JSON.parse(a)));
        }, c, d);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    parse: function(a) {
        var b = new THREE[a.type]();
        if (void 0 !== a.color && b.color.setHex(a.color), void 0 !== a.ambient && b.ambient.setHex(a.ambient), 
        void 0 !== a.emissive && b.emissive.setHex(a.emissive), void 0 !== a.specular && b.specular.setHex(a.specular), 
        void 0 !== a.shininess && (b.shininess = a.shininess), void 0 !== a.uniforms && (b.uniforms = a.uniforms), 
        void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader), void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader), 
        void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors), void 0 !== a.shading && (b.shading = a.shading), 
        void 0 !== a.blending && (b.blending = a.blending), void 0 !== a.side && (b.side = a.side), 
        void 0 !== a.opacity && (b.opacity = a.opacity), void 0 !== a.transparent && (b.transparent = a.transparent), 
        void 0 !== a.wireframe && (b.wireframe = a.wireframe), void 0 !== a.materials) for (var c = 0, d = a.materials.length; d > c; c++) b.materials.push(this.parse(a.materials[c]));
        return b;
    }
}, THREE.ObjectLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            b(e.parse(JSON.parse(a)));
        }, c, d);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    parse: function(a) {
        var b = this.parseGeometries(a.geometries), c = this.parseMaterials(a.materials);
        return this.parseObject(a.object, b, c);
    },
    parseGeometries: function(a) {
        var b = {};
        if (void 0 !== a) for (var c = new THREE.JSONLoader(), d = new THREE.BufferGeometryLoader(), e = 0, f = a.length; f > e; e++) {
            var g, h = a[e];
            switch (h.type) {
              case "PlaneGeometry":
                g = new THREE.PlaneGeometry(h.width, h.height, h.widthSegments, h.heightSegments);
                break;

              case "BoxGeometry":
              case "CubeGeometry":
                g = new THREE.BoxGeometry(h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                break;

              case "CircleGeometry":
                g = new THREE.CircleGeometry(h.radius, h.segments);
                break;

              case "CylinderGeometry":
                g = new THREE.CylinderGeometry(h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded);
                break;

              case "SphereGeometry":
                g = new THREE.SphereGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                break;

              case "IcosahedronGeometry":
                g = new THREE.IcosahedronGeometry(h.radius, h.detail);
                break;

              case "TorusGeometry":
                g = new THREE.TorusGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                break;

              case "TorusKnotGeometry":
                g = new THREE.TorusKnotGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.p, h.q, h.heightScale);
                break;

              case "BufferGeometry":
                g = d.parse(h.data);
                break;

              case "Geometry":
                g = c.parse(h.data).geometry;
            }
            g.uuid = h.uuid, void 0 !== h.name && (g.name = h.name), b[h.uuid] = g;
        }
        return b;
    },
    parseMaterials: function(a) {
        var b = {};
        if (void 0 !== a) for (var c = new THREE.MaterialLoader(), d = 0, e = a.length; e > d; d++) {
            var f = a[d], g = c.parse(f);
            g.uuid = f.uuid, void 0 !== f.name && (g.name = f.name), b[f.uuid] = g;
        }
        return b;
    },
    parseObject: function() {
        var a = new THREE.Matrix4();
        return function(b, c, d) {
            var e;
            switch (b.type) {
              case "Scene":
                e = new THREE.Scene();
                break;

              case "PerspectiveCamera":
                e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
                break;

              case "OrthographicCamera":
                e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
                break;

              case "AmbientLight":
                e = new THREE.AmbientLight(b.color);
                break;

              case "DirectionalLight":
                e = new THREE.DirectionalLight(b.color, b.intensity);
                break;

              case "PointLight":
                e = new THREE.PointLight(b.color, b.intensity, b.distance);
                break;

              case "SpotLight":
                e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent);
                break;

              case "HemisphereLight":
                e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
                break;

              case "Mesh":
                e = c[b.geometry];
                var f = d[b.material];
                void 0 === e && console.warn("THREE.ObjectLoader: Undefined geometry", b.geometry), 
                void 0 === f && console.warn("THREE.ObjectLoader: Undefined material", b.material), 
                e = new THREE.Mesh(e, f);
                break;

              case "Line":
                e = c[b.geometry], f = d[b.material], void 0 === e && console.warn("THREE.ObjectLoader: Undefined geometry", b.geometry), 
                void 0 === f && console.warn("THREE.ObjectLoader: Undefined material", b.material), 
                e = new THREE.Line(e, f);
                break;

              case "Sprite":
                f = d[b.material], void 0 === f && console.warn("THREE.ObjectLoader: Undefined material", b.material), 
                e = new THREE.Sprite(f);
                break;

              case "Group":
                e = new THREE.Group();
                break;

              default:
                e = new THREE.Object3D();
            }
            if (e.uuid = b.uuid, void 0 !== b.name && (e.name = b.name), void 0 !== b.matrix ? (a.fromArray(b.matrix), 
            a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), 
            void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale)), 
            void 0 !== b.visible && (e.visible = b.visible), void 0 !== b.userData && (e.userData = b.userData), 
            void 0 !== b.children) for (var g in b.children) e.add(this.parseObject(b.children[g], c, d));
            return e;
        };
    }()
}, THREE.TextureLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function(a, b, c, d) {
        var e = new THREE.ImageLoader(this.manager);
        e.setCrossOrigin(this.crossOrigin), e.load(a, function(a) {
            a = new THREE.Texture(a), a.needsUpdate = !0, void 0 !== b && b(a);
        }, c, d);
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    }
}, THREE.DataTextureLoader = THREE.BinaryTextureLoader = function() {
    this._parser = null;
}, THREE.BinaryTextureLoader.prototype = {
    constructor: THREE.BinaryTextureLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.DataTexture(), g = new THREE.XHRLoader();
        return g.setResponseType("arraybuffer"), g.load(a, function(a) {
            (a = e._parser(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, 
            f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping, 
            f.wrapT = void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ? a.magFilter : THREE.LinearFilter, 
            f.minFilter = void 0 !== a.minFilter ? a.minFilter : THREE.LinearMipMapLinearFilter, 
            f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), 
            void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 
            1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, a));
        }, c, d), f;
    }
}, THREE.CompressedTextureLoader = function() {
    this._parser = null;
}, THREE.CompressedTextureLoader.prototype = {
    constructor: THREE.CompressedTextureLoader,
    load: function(a, b, c) {
        var d = this, e = [], f = new THREE.CompressedTexture();
        f.image = e;
        var g = new THREE.XHRLoader();
        if (g.setResponseType("arraybuffer"), a instanceof Array) {
            var h = 0;
            c = function(c) {
                g.load(a[c], function(a) {
                    a = d._parser(a, !0), e[c] = {
                        width: a.width,
                        height: a.height,
                        format: a.format,
                        mipmaps: a.mipmaps
                    }, h += 1, 6 === h && (1 == a.mipmapCount && (f.minFilter = THREE.LinearFilter), 
                    f.format = a.format, f.needsUpdate = !0, b && b(f));
                });
            };
            for (var i = 0, j = a.length; j > i; ++i) c(i);
        } else g.load(a, function(a) {
            if (a = d._parser(a, !0), a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, g = 0; c > g; g++) {
                e[g] = {
                    mipmaps: []
                };
                for (var h = 0; h < a.mipmapCount; h++) e[g].mipmaps.push(a.mipmaps[g * a.mipmapCount + h]), 
                e[g].format = a.format, e[g].width = a.width, e[g].height = a.height;
            } else f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
            1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.format = a.format, 
            f.needsUpdate = !0, b && b(f);
        });
        return f;
    }
}, THREE.Material = function() {
    Object.defineProperty(this, "id", {
        value: THREE.MaterialIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Material", 
    this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, 
    this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, 
    this.blendEquation = THREE.AddEquation, this.depthWrite = this.depthTest = !0, this.polygonOffset = !1, 
    this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, 
    this.needsUpdate = this.visible = !0;
}, THREE.Material.prototype = {
    constructor: THREE.Material,
    setValues: function(a) {
        if (void 0 !== a) for (var b in a) {
            var c = a[b];
            if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined."); else if (b in this) {
                var d = this[b];
                d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = "overdraw" == b ? Number(c) : c;
            }
        }
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type
        };
        return "" !== this.name && (a.name = this.name), this instanceof THREE.MeshBasicMaterial ? (a.color = this.color.getHex(), 
        this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), 
        this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (a.color = this.color.getHex(), 
        a.ambient = this.ambient.getHex(), a.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), 
        this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (a.color = this.color.getHex(), 
        a.ambient = this.ambient.getHex(), a.emissive = this.emissive.getHex(), a.specular = this.specular.getHex(), 
        a.shininess = this.shininess, this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), 
        this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.shading !== THREE.FlatShading && (a.shading = this.shading), 
        this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), 
        this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.ShaderMaterial ? (a.uniforms = this.uniforms, 
        a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (a.color = this.color.getHex()), 
        1 > this.opacity && (a.opacity = this.opacity), !1 !== this.transparent && (a.transparent = this.transparent), 
        !1 !== this.wireframe && (a.wireframe = this.wireframe), a;
    },
    clone: function(a) {
        return void 0 === a && (a = new THREE.Material()), a.name = this.name, a.side = this.side, 
        a.opacity = this.opacity, a.transparent = this.transparent, a.blending = this.blending, 
        a.blendSrc = this.blendSrc, a.blendDst = this.blendDst, a.blendEquation = this.blendEquation, 
        a.depthTest = this.depthTest, a.depthWrite = this.depthWrite, a.polygonOffset = this.polygonOffset, 
        a.polygonOffsetFactor = this.polygonOffsetFactor, a.polygonOffsetUnits = this.polygonOffsetUnits, 
        a.alphaTest = this.alphaTest, a.overdraw = this.overdraw, a.visible = this.visible, 
        a;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, 
THREE.LineBasicMaterial = function(a) {
    THREE.Material.call(this), this.type = "LineBasicMaterial", this.color = new THREE.Color(16777215), 
    this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = THREE.NoColors, 
    this.fog = !0, this.setValues(a);
}, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial, THREE.LineBasicMaterial.prototype.clone = function() {
    var a = new THREE.LineBasicMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.linewidth = this.linewidth, 
    a.linecap = this.linecap, a.linejoin = this.linejoin, a.vertexColors = this.vertexColors, 
    a.fog = this.fog, a;
}, THREE.LineDashedMaterial = function(a) {
    THREE.Material.call(this), this.type = "LineDashedMaterial", this.color = new THREE.Color(16777215), 
    this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, 
    this.fog = !0, this.setValues(a);
}, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial, THREE.LineDashedMaterial.prototype.clone = function() {
    var a = new THREE.LineDashedMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.linewidth = this.linewidth, 
    a.scale = this.scale, a.dashSize = this.dashSize, a.gapSize = this.gapSize, a.vertexColors = this.vertexColors, 
    a.fog = this.fog, a;
}, THREE.MeshBasicMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshBasicMaterial", this.color = new THREE.Color(16777215), 
    this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, 
    this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
    this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, 
    this.morphTargets = this.skinning = !1, this.setValues(a);
}, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial, THREE.MeshBasicMaterial.prototype.clone = function() {
    var a = new THREE.MeshBasicMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.map = this.map, 
    a.lightMap = this.lightMap, a.specularMap = this.specularMap, a.alphaMap = this.alphaMap, 
    a.envMap = this.envMap, a.combine = this.combine, a.reflectivity = this.reflectivity, 
    a.refractionRatio = this.refractionRatio, a.fog = this.fog, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.wireframeLinecap = this.wireframeLinecap, 
    a.wireframeLinejoin = this.wireframeLinejoin, a.vertexColors = this.vertexColors, 
    a.skinning = this.skinning, a.morphTargets = this.morphTargets, a;
}, THREE.MeshLambertMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshLambertMaterial", this.color = new THREE.Color(16777215), 
    this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, 
    this.wrapRGB = new THREE.Vector3(1, 1, 1), this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, 
    this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
    this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, 
    this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a);
}, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial, THREE.MeshLambertMaterial.prototype.clone = function() {
    var a = new THREE.MeshLambertMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.ambient.copy(this.ambient), 
    a.emissive.copy(this.emissive), a.wrapAround = this.wrapAround, a.wrapRGB.copy(this.wrapRGB), 
    a.map = this.map, a.lightMap = this.lightMap, a.specularMap = this.specularMap, 
    a.alphaMap = this.alphaMap, a.envMap = this.envMap, a.combine = this.combine, a.reflectivity = this.reflectivity, 
    a.refractionRatio = this.refractionRatio, a.fog = this.fog, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.wireframeLinecap = this.wireframeLinecap, 
    a.wireframeLinejoin = this.wireframeLinejoin, a.vertexColors = this.vertexColors, 
    a.skinning = this.skinning, a.morphTargets = this.morphTargets, a.morphNormals = this.morphNormals, 
    a;
}, THREE.MeshPhongMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshPhongMaterial", this.color = new THREE.Color(16777215), 
    this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), 
    this.shininess = 30, this.wrapAround = this.metal = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), 
    this.bumpMap = this.lightMap = this.map = null, this.bumpScale = 1, this.normalMap = null, 
    this.normalScale = new THREE.Vector2(1, 1), this.envMap = this.alphaMap = this.specularMap = null, 
    this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
    this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, 
    this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a);
}, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial, THREE.MeshPhongMaterial.prototype.clone = function() {
    var a = new THREE.MeshPhongMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.ambient.copy(this.ambient), 
    a.emissive.copy(this.emissive), a.specular.copy(this.specular), a.shininess = this.shininess, 
    a.metal = this.metal, a.wrapAround = this.wrapAround, a.wrapRGB.copy(this.wrapRGB), 
    a.map = this.map, a.lightMap = this.lightMap, a.bumpMap = this.bumpMap, a.bumpScale = this.bumpScale, 
    a.normalMap = this.normalMap, a.normalScale.copy(this.normalScale), a.specularMap = this.specularMap, 
    a.alphaMap = this.alphaMap, a.envMap = this.envMap, a.combine = this.combine, a.reflectivity = this.reflectivity, 
    a.refractionRatio = this.refractionRatio, a.fog = this.fog, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.wireframeLinecap = this.wireframeLinecap, 
    a.wireframeLinejoin = this.wireframeLinejoin, a.vertexColors = this.vertexColors, 
    a.skinning = this.skinning, a.morphTargets = this.morphTargets, a.morphNormals = this.morphNormals, 
    a;
}, THREE.MeshDepthMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshDepthMaterial", this.wireframe = this.morphTargets = !1, 
    this.wireframeLinewidth = 1, this.setValues(a);
}, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial, THREE.MeshDepthMaterial.prototype.clone = function() {
    var a = new THREE.MeshDepthMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.wireframe = this.wireframe, 
    a.wireframeLinewidth = this.wireframeLinewidth, a;
}, THREE.MeshNormalMaterial = function(a) {
    THREE.Material.call(this, a), this.type = "MeshNormalMaterial", this.shading = THREE.FlatShading, 
    this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(a);
}, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial, THREE.MeshNormalMaterial.prototype.clone = function() {
    var a = new THREE.MeshNormalMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.shading = this.shading, a.wireframe = this.wireframe, 
    a.wireframeLinewidth = this.wireframeLinewidth, a;
}, THREE.MeshFaceMaterial = function(a) {
    this.uuid = THREE.Math.generateUUID(), this.type = "MeshFaceMaterial", this.materials = a instanceof Array ? a : [];
}, THREE.MeshFaceMaterial.prototype = {
    constructor: THREE.MeshFaceMaterial,
    toJSON: function() {
        for (var a = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        }, b = 0, c = this.materials.length; c > b; b++) a.materials.push(this.materials[b].toJSON());
        return a;
    },
    clone: function() {
        for (var a = new THREE.MeshFaceMaterial(), b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
        return a;
    }
}, THREE.PointCloudMaterial = function(a) {
    THREE.Material.call(this), this.type = "PointCloudMaterial", this.color = new THREE.Color(16777215), 
    this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, 
    this.fog = !0, this.setValues(a);
}, THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial, THREE.PointCloudMaterial.prototype.clone = function() {
    var a = new THREE.PointCloudMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.map = this.map, 
    a.size = this.size, a.sizeAttenuation = this.sizeAttenuation, a.vertexColors = this.vertexColors, 
    a.fog = this.fog, a;
}, THREE.ParticleBasicMaterial = function(a) {
    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), 
    new THREE.PointCloudMaterial(a);
}, THREE.ParticleSystemMaterial = function(a) {
    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), 
    new THREE.PointCloudMaterial(a);
}, THREE.ShaderMaterial = function(a) {
    THREE.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, 
    this.attributes = null, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
    this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", 
    this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, 
    this.defaultAttributeValues = {
        color: [ 1, 1, 1 ],
        uv: [ 0, 0 ],
        uv2: [ 0, 0 ]
    }, this.index0AttributeName = void 0, this.setValues(a);
}, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial, 
THREE.ShaderMaterial.prototype.clone = function() {
    var a = new THREE.ShaderMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.fragmentShader = this.fragmentShader, 
    a.vertexShader = this.vertexShader, a.uniforms = THREE.UniformsUtils.clone(this.uniforms), 
    a.attributes = this.attributes, a.defines = this.defines, a.shading = this.shading, 
    a.wireframe = this.wireframe, a.wireframeLinewidth = this.wireframeLinewidth, a.fog = this.fog, 
    a.lights = this.lights, a.vertexColors = this.vertexColors, a.skinning = this.skinning, 
    a.morphTargets = this.morphTargets, a.morphNormals = this.morphNormals, a;
}, THREE.RawShaderMaterial = function(a) {
    THREE.ShaderMaterial.call(this, a), this.type = "RawShaderMaterial";
}, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), 
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial, THREE.RawShaderMaterial.prototype.clone = function() {
    var a = new THREE.RawShaderMaterial();
    return THREE.ShaderMaterial.prototype.clone.call(this, a), a;
}, THREE.SpriteMaterial = function(a) {
    THREE.Material.call(this), this.type = "SpriteMaterial", this.color = new THREE.Color(16777215), 
    this.map = null, this.rotation = 0, this.fog = !1, this.setValues(a);
}, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial, 
THREE.SpriteMaterial.prototype.clone = function() {
    var a = new THREE.SpriteMaterial();
    return THREE.Material.prototype.clone.call(this, a), a.color.copy(this.color), a.map = this.map, 
    a.rotation = this.rotation, a.fog = this.fog, a;
}, THREE.Texture = function(a, b, c, d, e, f, g, h, i) {
    Object.defineProperty(this, "id", {
        value: THREE.TextureIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE, 
    this.mipmaps = [], this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING, 
    this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping, 
    this.magFilter = void 0 !== e ? e : THREE.LinearFilter, this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter, 
    this.anisotropy = void 0 !== i ? i : 1, this.format = void 0 !== g ? g : THREE.RGBAFormat, 
    this.type = void 0 !== h ? h : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), 
    this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, 
    this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null;
}, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping, 
THREE.Texture.prototype = {
    constructor: THREE.Texture,
    get needsUpdate() {
        return this._needsUpdate;
    },
    set needsUpdate(a) {
        !0 === a && this.update(), this._needsUpdate = a;
    },
    clone: function(a) {
        return void 0 === a && (a = new THREE.Texture()), a.image = this.image, a.mipmaps = this.mipmaps.slice(0), 
        a.mapping = this.mapping, a.wrapS = this.wrapS, a.wrapT = this.wrapT, a.magFilter = this.magFilter, 
        a.minFilter = this.minFilter, a.anisotropy = this.anisotropy, a.format = this.format, 
        a.type = this.type, a.offset.copy(this.offset), a.repeat.copy(this.repeat), a.generateMipmaps = this.generateMipmaps, 
        a.premultiplyAlpha = this.premultiplyAlpha, a.flipY = this.flipY, a.unpackAlignment = this.unpackAlignment, 
        a;
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        });
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, 
THREE.CubeTexture = function(a, b, c, d, e, f, g, h, i) {
    b = void 0 !== b ? b : THREE.CubeReflectionMapping, THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), 
    this.images = a;
}, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.prototype.constructor = THREE.CubeTexture, 
THREE.CubeTexture.clone = function(a) {
    return void 0 === a && (a = new THREE.CubeTexture()), THREE.Texture.prototype.clone.call(this, a), 
    a.images = this.images, a;
}, THREE.CompressedTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
    THREE.Texture.call(this, null, f, g, h, i, j, d, e, k), this.image = {
        width: b,
        height: c
    }, this.mipmaps = a, this.generateMipmaps = this.flipY = !1;
}, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture, 
THREE.CompressedTexture.prototype.clone = function() {
    var a = new THREE.CompressedTexture();
    return THREE.Texture.prototype.clone.call(this, a), a;
}, THREE.DataTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
    THREE.Texture.call(this, null, f, g, h, i, j, d, e, k), this.image = {
        data: a,
        width: b,
        height: c
    };
}, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.constructor = THREE.DataTexture, 
THREE.DataTexture.prototype.clone = function() {
    var a = new THREE.DataTexture();
    return THREE.Texture.prototype.clone.call(this, a), a;
}, THREE.VideoTexture = function(a, b, c, d, e, f, g, h, i) {
    THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), this.generateMipmaps = !1;
    var j = this, k = function() {
        requestAnimationFrame(k), a.readyState === a.HAVE_ENOUGH_DATA && (j.needsUpdate = !0);
    };
    k();
}, THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype), THREE.VideoTexture.prototype.constructor = THREE.VideoTexture, 
THREE.Group = function() {
    THREE.Object3D.call(this), this.type = "Group";
}, THREE.Group.prototype = Object.create(THREE.Object3D.prototype), THREE.Group.prototype.constructor = THREE.Group, 
THREE.PointCloud = function(a, b) {
    THREE.Object3D.call(this), this.type = "PointCloud", this.geometry = void 0 !== a ? a : new THREE.Geometry(), 
    this.material = void 0 !== b ? b : new THREE.PointCloudMaterial({
        color: 16777215 * Math.random()
    });
}, THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype), THREE.PointCloud.prototype.constructor = THREE.PointCloud, 
THREE.PointCloud.prototype.raycast = function() {
    var a = new THREE.Matrix4(), b = new THREE.Ray();
    return function(c, d) {
        var e = this, f = e.geometry, g = c.params.PointCloud.threshold;
        if (a.getInverse(this.matrixWorld), b.copy(c.ray).applyMatrix4(a), null === f.boundingBox || !1 !== b.isIntersectionBox(f.boundingBox)) {
            var h = g / ((this.scale.x + this.scale.y + this.scale.z) / 3), i = new THREE.Vector3(), g = function(a, f) {
                var g = b.distanceToPoint(a);
                if (h > g) {
                    var i = b.closestPointToPoint(a);
                    i.applyMatrix4(e.matrixWorld);
                    var j = c.ray.origin.distanceTo(i);
                    d.push({
                        distance: j,
                        distanceToRay: g,
                        point: i.clone(),
                        index: f,
                        face: null,
                        object: e
                    });
                }
            };
            if (f instanceof THREE.BufferGeometry) {
                var j = f.attributes, k = j.position.array;
                if (void 0 !== j.index) {
                    var j = j.index.array, l = f.offsets;
                    0 === l.length && (l = [ {
                        start: 0,
                        count: j.length,
                        index: 0
                    } ]);
                    for (var m = 0, n = l.length; n > m; ++m) for (var o = l[m].start, p = l[m].index, f = o, o = o + l[m].count; o > f; f++) {
                        var q = p + j[f];
                        i.fromArray(k, 3 * q), g(i, q);
                    }
                } else for (j = k.length / 3, f = 0; j > f; f++) i.set(k[3 * f], k[3 * f + 1], k[3 * f + 2]), 
                g(i, f);
            } else for (i = this.geometry.vertices, f = 0; f < i.length; f++) g(i[f], f);
        }
    };
}(), THREE.PointCloud.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.PointCloud(this.geometry, this.material)), 
    THREE.Object3D.prototype.clone.call(this, a), a;
}, THREE.ParticleSystem = function(a, b) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), 
    new THREE.PointCloud(a, b);
}, THREE.Line = function(a, b, c) {
    THREE.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new THREE.Geometry(), 
    this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
        color: 16777215 * Math.random()
    }), this.mode = void 0 !== c ? c : THREE.LineStrip;
}, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), 
THREE.Line.prototype.constructor = THREE.Line, THREE.Line.prototype.raycast = function() {
    var a = new THREE.Matrix4(), b = new THREE.Ray(), c = new THREE.Sphere();
    return function(d, e) {
        var f = d.linePrecision, f = f * f, g = this.geometry;
        if (null === g.boundingSphere && g.computeBoundingSphere(), c.copy(g.boundingSphere), 
        c.applyMatrix4(this.matrixWorld), !1 !== d.ray.isIntersectionSphere(c)) {
            a.getInverse(this.matrixWorld), b.copy(d.ray).applyMatrix4(a);
            var h = new THREE.Vector3(), i = new THREE.Vector3(), j = new THREE.Vector3(), k = new THREE.Vector3(), l = this.mode === THREE.LineStrip ? 1 : 2;
            if (g instanceof THREE.BufferGeometry) {
                var m = g.attributes;
                if (void 0 !== m.index) {
                    var n = m.index.array, m = m.position.array, o = g.offsets;
                    0 === o.length && (o = [ {
                        start: 0,
                        count: n.length,
                        index: 0
                    } ]);
                    for (var p = 0; p < o.length; p++) for (var q = o[p].start, r = o[p].count, s = o[p].index, g = q; q + r - 1 > g; g += l) {
                        var t = s + n[g + 1];
                        h.fromArray(m, 3 * (s + n[g])), i.fromArray(m, 3 * t), t = b.distanceSqToSegment(h, i, k, j), 
                        t > f || (t = b.origin.distanceTo(k), t < d.near || t > d.far || e.push({
                            distance: t,
                            point: j.clone().applyMatrix4(this.matrixWorld),
                            face: null,
                            faceIndex: null,
                            object: this
                        }));
                    }
                } else for (m = m.position.array, g = 0; g < m.length / 3 - 1; g += l) h.fromArray(m, 3 * g), 
                i.fromArray(m, 3 * g + 3), t = b.distanceSqToSegment(h, i, k, j), t > f || (t = b.origin.distanceTo(k), 
                t < d.near || t > d.far || e.push({
                    distance: t,
                    point: j.clone().applyMatrix4(this.matrixWorld),
                    face: null,
                    faceIndex: null,
                    object: this
                }));
            } else if (g instanceof THREE.Geometry) for (h = g.vertices, i = h.length, g = 0; i - 1 > g; g += l) t = b.distanceSqToSegment(h[g], h[g + 1], k, j), 
            t > f || (t = b.origin.distanceTo(k), t < d.near || t > d.far || e.push({
                distance: t,
                point: j.clone().applyMatrix4(this.matrixWorld),
                face: null,
                faceIndex: null,
                object: this
            }));
        }
    };
}(), THREE.Line.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.mode)), 
    THREE.Object3D.prototype.clone.call(this, a), a;
}, THREE.Mesh = function(a, b) {
    THREE.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new THREE.Geometry(), 
    this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
        color: 16777215 * Math.random()
    }), this.updateMorphTargets();
}, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.constructor = THREE.Mesh, 
THREE.Mesh.prototype.updateMorphTargets = function() {
    if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
        this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], 
        this.morphTargetDictionary = {};
        for (var a = 0, b = this.geometry.morphTargets.length; b > a; a++) this.morphTargetInfluences.push(0), 
        this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;
    }
}, THREE.Mesh.prototype.getMorphTargetIndexByName = function(a) {
    return void 0 !== this.morphTargetDictionary[a] ? this.morphTargetDictionary[a] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0."), 
    0);
}, THREE.Mesh.prototype.raycast = function() {
    var a = new THREE.Matrix4(), b = new THREE.Ray(), c = new THREE.Sphere(), d = new THREE.Vector3(), e = new THREE.Vector3(), f = new THREE.Vector3();
    return function(g, h) {
        var i = this.geometry;
        if (null === i.boundingSphere && i.computeBoundingSphere(), c.copy(i.boundingSphere), 
        c.applyMatrix4(this.matrixWorld), !1 !== g.ray.isIntersectionSphere(c) && (a.getInverse(this.matrixWorld), 
        b.copy(g.ray).applyMatrix4(a), null === i.boundingBox || !1 !== b.isIntersectionBox(i.boundingBox))) if (i instanceof THREE.BufferGeometry) {
            var j = this.material;
            if (void 0 !== j) {
                var k, l, m = i.attributes, n = g.precision;
                if (void 0 !== m.index) {
                    var o = m.index.array, p = m.position.array, q = i.offsets;
                    0 === q.length && (q = [ {
                        start: 0,
                        count: o.length,
                        index: 0
                    } ]);
                    for (var r = 0, s = q.length; s > r; ++r) for (var m = q[r].start, t = q[r].index, i = m, u = m + q[r].count; u > i; i += 3) {
                        m = t + o[i], k = t + o[i + 1], l = t + o[i + 2], d.fromArray(p, 3 * m), e.fromArray(p, 3 * k), 
                        f.fromArray(p, 3 * l);
                        var v = j.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, j.side !== THREE.DoubleSide);
                        if (null !== v) {
                            v.applyMatrix4(this.matrixWorld);
                            var w = g.ray.origin.distanceTo(v);
                            n > w || w < g.near || w > g.far || h.push({
                                distance: w,
                                point: v,
                                face: new THREE.Face3(m, k, l, THREE.Triangle.normal(d, e, f)),
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                } else for (p = m.position.array, o = i = 0, u = p.length; u > i; i += 3, o += 9) m = i, 
                k = i + 1, l = i + 2, d.fromArray(p, o), e.fromArray(p, o + 3), f.fromArray(p, o + 6), 
                v = j.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, j.side !== THREE.DoubleSide), 
                null !== v && (v.applyMatrix4(this.matrixWorld), w = g.ray.origin.distanceTo(v), 
                n > w || w < g.near || w > g.far || h.push({
                    distance: w,
                    point: v,
                    face: new THREE.Face3(m, k, l, THREE.Triangle.normal(d, e, f)),
                    faceIndex: null,
                    object: this
                }));
            }
        } else if (i instanceof THREE.Geometry) for (o = this.material instanceof THREE.MeshFaceMaterial, 
        p = !0 === o ? this.material.materials : null, n = g.precision, q = i.vertices, 
        r = 0, s = i.faces.length; s > r; r++) if (t = i.faces[r], j = !0 === o ? p[t.materialIndex] : this.material, 
        void 0 !== j) {
            if (m = q[t.a], k = q[t.b], l = q[t.c], !0 === j.morphTargets) {
                v = i.morphTargets, w = this.morphTargetInfluences, d.set(0, 0, 0), e.set(0, 0, 0), 
                f.set(0, 0, 0);
                for (var u = 0, x = v.length; x > u; u++) {
                    var y = w[u];
                    if (0 !== y) {
                        var z = v[u].vertices;
                        d.x += (z[t.a].x - m.x) * y, d.y += (z[t.a].y - m.y) * y, d.z += (z[t.a].z - m.z) * y, 
                        e.x += (z[t.b].x - k.x) * y, e.y += (z[t.b].y - k.y) * y, e.z += (z[t.b].z - k.z) * y, 
                        f.x += (z[t.c].x - l.x) * y, f.y += (z[t.c].y - l.y) * y, f.z += (z[t.c].z - l.z) * y;
                    }
                }
                d.add(m), e.add(k), f.add(l), m = d, k = e, l = f;
            }
            v = j.side === THREE.BackSide ? b.intersectTriangle(l, k, m, !0) : b.intersectTriangle(m, k, l, j.side !== THREE.DoubleSide), 
            null !== v && (v.applyMatrix4(this.matrixWorld), w = g.ray.origin.distanceTo(v), 
            n > w || w < g.near || w > g.far || h.push({
                distance: w,
                point: v,
                face: t,
                faceIndex: r,
                object: this
            }));
        }
    };
}(), THREE.Mesh.prototype.clone = function(a, b) {
    return void 0 === a && (a = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, a, b), 
    a;
}, THREE.Bone = function(a) {
    THREE.Object3D.call(this), this.skin = a;
}, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.constructor = THREE.Bone, 
THREE.Skeleton = function(a, b, c) {
    if (this.useVertexTexture = void 0 !== c ? c : !0, this.identityMatrix = new THREE.Matrix4(), 
    a = a || [], this.bones = a.slice(0), this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, 
    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), 
    this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), 
    this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, 
    this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length), 
    void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton bonInverses is the wrong length."), 
    this.boneInverses = [], b = 0, a = this.bones.length; a > b; b++) this.boneInverses.push(new THREE.Matrix4());
}, THREE.Skeleton.prototype.calculateInverses = function() {
    this.boneInverses = [];
    for (var a = 0, b = this.bones.length; b > a; a++) {
        var c = new THREE.Matrix4();
        this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c);
    }
}, THREE.Skeleton.prototype.pose = function() {
    for (var a, b = 0, c = this.bones.length; c > b; b++) (a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
    for (b = 0, c = this.bones.length; c > b; b++) (a = this.bones[b]) && (a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), 
    a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale));
}, THREE.Skeleton.prototype.update = function() {
    var a = new THREE.Matrix4();
    return function() {
        for (var b = 0, c = this.bones.length; c > b; b++) a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), 
        a.flattenToArrayOffset(this.boneMatrices, 16 * b);
        this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
    };
}(), THREE.SkinnedMesh = function(a, b, c) {
    if (THREE.Mesh.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", 
    this.bindMatrix = new THREE.Matrix4(), this.bindMatrixInverse = new THREE.Matrix4(), 
    a = [], this.geometry && void 0 !== this.geometry.bones) {
        for (var d, e, f, g, h = 0, i = this.geometry.bones.length; i > h; ++h) d = this.geometry.bones[h], 
        e = d.pos, f = d.rotq, g = d.scl, b = new THREE.Bone(this), a.push(b), b.name = d.name, 
        b.position.set(e[0], e[1], e[2]), b.quaternion.set(f[0], f[1], f[2], f[3]), void 0 !== g ? b.scale.set(g[0], g[1], g[2]) : b.scale.set(1, 1, 1);
        for (h = 0, i = this.geometry.bones.length; i > h; ++h) d = this.geometry.bones[h], 
        -1 !== d.parent ? a[d.parent].add(a[h]) : this.add(a[h]);
    }
    this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(a, void 0, c));
}, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh, 
THREE.SkinnedMesh.prototype.bind = function(a, b) {
    this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), b = this.matrixWorld), 
    this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b);
}, THREE.SkinnedMesh.prototype.pose = function() {
    this.skeleton.pose();
}, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
    if (this.geometry instanceof THREE.Geometry) for (var a = 0; a < this.geometry.skinIndices.length; a++) {
        var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
        1/0 !== c ? b.multiplyScalar(c) : b.set(1);
    }
}, THREE.SkinnedMesh.prototype.updateMatrixWorld = function() {
    THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode);
}, THREE.SkinnedMesh.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), 
    THREE.Mesh.prototype.clone.call(this, a), a;
}, THREE.MorphAnimMesh = function(a, b) {
    THREE.Mesh.call(this, a, b), this.type = "MorphAnimMesh", this.duration = 1e3, this.mirroredLoop = !1, 
    this.currentKeyframe = this.lastKeyframe = this.time = 0, this.direction = 1, this.directionBackwards = !1, 
    this.setFrameRange(0, this.geometry.morphTargets.length - 1);
}, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh, 
THREE.MorphAnimMesh.prototype.setFrameRange = function(a, b) {
    this.startKeyframe = a, this.endKeyframe = b, this.length = this.endKeyframe - this.startKeyframe + 1;
}, THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
    this.direction = 1, this.directionBackwards = !1;
}, THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
    this.direction = -1, this.directionBackwards = !0;
}, THREE.MorphAnimMesh.prototype.parseAnimations = function() {
    var a = this.geometry;
    a.animations || (a.animations = {});
    for (var b, c = a.animations, d = /([a-z]+)_?(\d+)/, e = 0, f = a.morphTargets.length; f > e; e++) {
        var g = a.morphTargets[e].name.match(d);
        if (g && 1 < g.length) {
            g = g[1], c[g] || (c[g] = {
                start: 1/0,
                end: -1/0
            });
            var h = c[g];
            e < h.start && (h.start = e), e > h.end && (h.end = e), b || (b = g);
        }
    }
    a.firstAnimation = b;
}, THREE.MorphAnimMesh.prototype.setAnimationLabel = function(a, b, c) {
    this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[a] = {
        start: b,
        end: c
    };
}, THREE.MorphAnimMesh.prototype.playAnimation = function(a, b) {
    var c = this.geometry.animations[a];
    c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1e3, 
    this.time = 0) : console.warn("animation[" + a + "] undefined");
}, THREE.MorphAnimMesh.prototype.updateAnimation = function(a) {
    var b = this.duration / this.length;
    this.time += this.direction * a, this.mirroredLoop ? (this.time > this.duration || 0 > this.time) && (this.direction *= -1, 
    this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 
    0 > this.time && (this.time = 0, this.directionBackwards = !1)) : (this.time %= this.duration, 
    0 > this.time && (this.time += this.duration)), a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1), 
    a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, 
    this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, 
    this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a), b = this.time % b / b, 
    this.directionBackwards && (b = 1 - b), this.morphTargetInfluences[this.currentKeyframe] = b, 
    this.morphTargetInfluences[this.lastKeyframe] = 1 - b;
}, THREE.MorphAnimMesh.prototype.interpolateTargets = function(a, b, c) {
    for (var d = this.morphTargetInfluences, e = 0, f = d.length; f > e; e++) d[e] = 0;
    a > -1 && (d[a] = 1 - c), b > -1 && (d[b] = c);
}, THREE.MorphAnimMesh.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material)), 
    a.duration = this.duration, a.mirroredLoop = this.mirroredLoop, a.time = this.time, 
    a.lastKeyframe = this.lastKeyframe, a.currentKeyframe = this.currentKeyframe, a.direction = this.direction, 
    a.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, a), 
    a;
}, THREE.LOD = function() {
    THREE.Object3D.call(this), this.objects = [];
}, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.constructor = THREE.LOD, 
THREE.LOD.prototype.addLevel = function(a, b) {
    void 0 === b && (b = 0), b = Math.abs(b);
    for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++) ;
    this.objects.splice(c, 0, {
        distance: b,
        object: a
    }), this.add(a);
}, THREE.LOD.prototype.getObjectForDistance = function(a) {
    for (var b = 1, c = this.objects.length; c > b && !(a < this.objects[b].distance); b++) ;
    return this.objects[b - 1].object;
}, THREE.LOD.prototype.raycast = function() {
    var a = new THREE.Vector3();
    return function(b, c) {
        a.setFromMatrixPosition(this.matrixWorld);
        var d = b.ray.origin.distanceTo(a);
        this.getObjectForDistance(d).raycast(b, c);
    };
}(), THREE.LOD.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function(c) {
        if (1 < this.objects.length) {
            a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld), 
            c = a.distanceTo(b), this.objects[0].object.visible = !0;
            for (var d = 1, e = this.objects.length; e > d && c >= this.objects[d].distance; d++) this.objects[d - 1].object.visible = !1, 
            this.objects[d].object.visible = !0;
            for (;e > d; d++) this.objects[d].object.visible = !1;
        }
    };
}(), THREE.LOD.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.LOD()), THREE.Object3D.prototype.clone.call(this, a);
    for (var b = 0, c = this.objects.length; c > b; b++) {
        var d = this.objects[b].object.clone();
        d.visible = 0 === b, a.addLevel(d, this.objects[b].distance);
    }
    return a;
}, THREE.Sprite = function() {
    var a = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]), b = new Float32Array([ -.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0 ]), c = new Float32Array([ 0, 0, 1, 0, 1, 1, 0, 1 ]), d = new THREE.BufferGeometry();
    return d.addAttribute("index", new THREE.BufferAttribute(a, 1)), d.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    d.addAttribute("uv", new THREE.BufferAttribute(c, 2)), function(a) {
        THREE.Object3D.call(this), this.type = "Sprite", this.geometry = d, this.material = void 0 !== a ? a : new THREE.SpriteMaterial();
    };
}(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.constructor = THREE.Sprite, 
THREE.Sprite.prototype.raycast = function() {
    var a = new THREE.Vector3();
    return function(b, c) {
        a.setFromMatrixPosition(this.matrixWorld);
        var d = b.ray.distanceToPoint(a);
        d > this.scale.x || c.push({
            distance: d,
            point: this.position,
            face: null,
            object: this
        });
    };
}(), THREE.Sprite.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, a), 
    a;
}, THREE.Particle = THREE.Sprite, THREE.LensFlare = function(a, b, c, d, e) {
    THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3(), 
    this.customUpdateCallback = void 0, void 0 !== a && this.add(a, b, c, d, e);
}, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.constructor = THREE.LensFlare, 
THREE.LensFlare.prototype.add = function(a, b, c, d, e, f) {
    void 0 === b && (b = -1), void 0 === c && (c = 0), void 0 === f && (f = 1), void 0 === e && (e = new THREE.Color(16777215)), 
    void 0 === d && (d = THREE.NormalBlending), c = Math.min(c, Math.max(0, c)), this.lensFlares.push({
        texture: a,
        size: b,
        distance: c,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 1,
        opacity: f,
        color: e,
        blending: d
    });
}, THREE.LensFlare.prototype.updateLensFlares = function() {
    var a, b, c = this.lensFlares.length, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
    for (a = 0; c > a; a++) b = this.lensFlares[a], b.x = this.positionScreen.x + d * b.distance, 
    b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, 
    b.rotation += .25 * (b.wantedRotation - b.rotation);
}, THREE.Scene = function() {
    THREE.Object3D.call(this), this.type = "Scene", this.overrideMaterial = this.fog = null, 
    this.autoUpdate = !0;
}, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.constructor = THREE.Scene, 
THREE.Scene.prototype.clone = function(a) {
    return void 0 === a && (a = new THREE.Scene()), THREE.Object3D.prototype.clone.call(this, a), 
    null !== this.fog && (a.fog = this.fog.clone()), null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone()), 
    a.autoUpdate = this.autoUpdate, a.matrixAutoUpdate = this.matrixAutoUpdate, a;
}, THREE.Fog = function(a, b, c) {
    this.name = "", this.color = new THREE.Color(a), this.near = void 0 !== b ? b : 1, 
    this.far = void 0 !== c ? c : 1e3;
}, THREE.Fog.prototype.clone = function() {
    return new THREE.Fog(this.color.getHex(), this.near, this.far);
}, THREE.FogExp2 = function(a, b) {
    this.name = "", this.color = new THREE.Color(a), this.density = void 0 !== b ? b : 25e-5;
}, THREE.FogExp2.prototype.clone = function() {
    return new THREE.FogExp2(this.color.getHex(), this.density);
}, THREE.ShaderChunk = {}, THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n", 
THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif", 
THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", 
THREE.ShaderChunk.default_vertex = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n", 
THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", 
THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif", 
THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif", 
THREE.ShaderChunk.lights_phong_fragment = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif", 
THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif", 
THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif", 
THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", 
THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n", 
THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n", 
THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif", 
THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif", 
THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif", 
THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif", 
THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif", 
THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif", 
THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n", 
THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif", 
THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n", 
THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n", 
THREE.ShaderChunk.linear_to_gamma_fragment = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif", 
THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", 
THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n", 
THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n", 
THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = clamp( flipNormal * reflectVec.y * 0.5 + 0.5, 0.0, 1.0);\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * 0.15915494309189533576888376337251 + 0.5; // reciprocal( 2 PI ) + 0.5\n		vec4 envColor = texture2D( envMap, sampleUV );\n		\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		envColor.xyz *= envColor.xyz;\n\n	#endif\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		gl_FragColor.xyz += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif", 
THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif", 
THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif", 
THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif", 
THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif", 
THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif", 
THREE.ShaderChunk.defaultnormal_vertex = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n", 
THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", 
THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", 
THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", 
THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif", 
THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", 
THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif", 
THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif", 
THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n", 
THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif", 
THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif", 
THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", 
THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n", 
THREE.UniformsUtils = {
    merge: function(a) {
        for (var b = {}, c = 0; c < a.length; c++) {
            var d, e = this.clone(a[c]);
            for (d in e) b[d] = e[d];
        }
        return b;
    },
    clone: function(a) {
        var b, c = {};
        for (b in a) {
            c[b] = {};
            for (var d in a[b]) {
                var e = a[b][d];
                c[b][d] = e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? e.clone() : e instanceof Array ? e.slice() : e;
            }
        }
        return c;
    }
}, THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        lightMap: {
            type: "t",
            value: null
        },
        specularMap: {
            type: "t",
            value: null
        },
        alphaMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "f",
            value: -1
        },
        reflectivity: {
            type: "f",
            value: 1
        },
        refractionRatio: {
            type: "f",
            value: .98
        },
        morphTargetInfluences: {
            type: "f",
            value: 0
        }
    },
    bump: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1, 1)
        }
    },
    fog: {
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "fv",
            value: []
        },
        directionalLightDirection: {
            type: "fv",
            value: []
        },
        directionalLightColor: {
            type: "fv",
            value: []
        },
        hemisphereLightDirection: {
            type: "fv",
            value: []
        },
        hemisphereLightSkyColor: {
            type: "fv",
            value: []
        },
        hemisphereLightGroundColor: {
            type: "fv",
            value: []
        },
        pointLightColor: {
            type: "fv",
            value: []
        },
        pointLightPosition: {
            type: "fv",
            value: []
        },
        pointLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightColor: {
            type: "fv",
            value: []
        },
        spotLightPosition: {
            type: "fv",
            value: []
        },
        spotLightDirection: {
            type: "fv",
            value: []
        },
        spotLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightAngleCos: {
            type: "fv1",
            value: []
        },
        spotLightExponent: {
            type: "fv1",
            value: []
        }
    },
    particle: {
        psColor: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        size: {
            type: "f",
            value: 1
        },
        scale: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    shadowmap: {
        shadowMap: {
            type: "tv",
            value: []
        },
        shadowMapSize: {
            type: "v2v",
            value: []
        },
        shadowBias: {
            type: "fv1",
            value: []
        },
        shadowDarkness: {
            type: "fv1",
            value: []
        },
        shadowMatrix: {
            type: "m4v",
            value: []
        }
    }
}, THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap ]),
        vertexShader: [ THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}" ].join("\n")
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        } ]),
        vertexShader: [ "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	#ifdef DOUBLE_SIDED\n		if ( gl_FrontFacing )\n			gl_FragColor.xyz *= vLightFront;\n		else\n			gl_FragColor.xyz *= vLightBack;\n	#else\n		gl_FragColor.xyz *= vLightFront;\n	#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}" ].join("\n")
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        } ]),
        vertexShader: [ "#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "#define PHONG\nuniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}" ].join("\n")
    },
    particle_basic: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap ]),
        vertexShader: [ "uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n	#else\n		gl_PointSize = size;\n	#endif\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}" ].join("\n")
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.fog, {
            scale: {
                type: "f",
                value: 1
            },
            dashSize: {
                type: "f",
                value: 1
            },
            totalSize: {
                type: "f",
                value: 2
            }
        } ]),
        vertexShader: [ "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}" ].join("\n")
    },
    depth: {
        uniforms: {
            mNear: {
                type: "f",
                value: 1
            },
            mFar: {
                type: "f",
                value: 2e3
            },
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: [ THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	float color = 1.0 - smoothstep( mNear, mFar, depth );\n	gl_FragColor = vec4( vec3( color ), opacity );\n}" ].join("\n")
    },
    normal: {
        uniforms: {
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: [ "varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}" ].join("\n")
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: [ "varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n	vWorldPosition = worldPosition.xyz;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}" ].join("\n")
    },
    equirect: {
        uniforms: {
            tEquirect: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: [ "varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n	vWorldPosition = worldPosition.xyz;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\nvec3 direction = normalize( vWorldPosition );\nvec2 sampleUV;\nsampleUV.y = clamp( tFlip * direction.y * -0.5 + 0.5, 0.0, 1.0);\nsampleUV.x = atan( direction.z, direction.x ) * 0.15915494309189533576888376337251 + 0.5;\ngl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment, "}" ].join("\n")
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: [ THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
        fragmentShader: [ THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nvoid main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n	#else\n		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n	#endif\n}" ].join("\n")
    }
}, THREE.WebGLRenderer = function(a) {
    function b(a) {
        var b = a.geometry;
        a = a.material;
        var c = b.vertices.length;
        if (a.attributes) {
            void 0 === b.__webglCustomAttributesList && (b.__webglCustomAttributesList = []);
            for (var d in a.attributes) {
                var e = a.attributes[d];
                if (!e.__webglInitialized || e.createUniqueBuffers) {
                    e.__webglInitialized = !0;
                    var f = 1;
                    "v2" === e.type ? f = 2 : "v3" === e.type ? f = 3 : "v4" === e.type ? f = 4 : "c" === e.type && (f = 3), 
                    e.size = f, e.array = new Float32Array(c * f), e.buffer = Eb.createBuffer(), e.buffer.belongsToAttribute = d, 
                    e.needsUpdate = !0;
                }
                b.__webglCustomAttributesList.push(e);
            }
        }
    }
    function c(a, b) {
        var c = b.geometry, e = a.faces3, f = 3 * e.length, g = 1 * e.length, h = 3 * e.length, e = d(b, a);
        a.__vertexArray = new Float32Array(3 * f), a.__normalArray = new Float32Array(3 * f), 
        a.__colorArray = new Float32Array(3 * f), a.__uvArray = new Float32Array(2 * f), 
        1 < c.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * f)), c.hasTangents && (a.__tangentArray = new Float32Array(4 * f)), 
        b.geometry.skinWeights.length && b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * f), 
        a.__skinWeightArray = new Float32Array(4 * f)), c = null !== Lb.get("OES_element_index_uint") && g > 21845 ? Uint32Array : Uint16Array, 
        a.__typeArray = c, a.__faceArray = new c(3 * g), a.__lineArray = new c(2 * h);
        var i = a.numMorphTargets;
        if (i) for (a.__morphTargetsArrays = [], c = 0; i > c; c++) a.__morphTargetsArrays.push(new Float32Array(3 * f));
        if (i = a.numMorphNormals) for (a.__morphNormalsArrays = [], c = 0; i > c; c++) a.__morphNormalsArrays.push(new Float32Array(3 * f));
        if (a.__webglFaceCount = 3 * g, a.__webglLineCount = 2 * h, e.attributes) {
            void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
            for (var j in e.attributes) {
                var k, g = e.attributes[j], h = {};
                for (k in g) h[k] = g[k];
                (!h.__webglInitialized || h.createUniqueBuffers) && (h.__webglInitialized = !0, 
                c = 1, "v2" === h.type ? c = 2 : "v3" === h.type ? c = 3 : "v4" === h.type ? c = 4 : "c" === h.type && (c = 3), 
                h.size = c, h.array = new Float32Array(f * c), h.buffer = Eb.createBuffer(), h.buffer.belongsToAttribute = j, 
                g.needsUpdate = !0, h.__original = g), a.__webglCustomAttributesList.push(h);
            }
        }
        a.__inittedArrays = !0;
    }
    function d(a, b) {
        return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material;
    }
    function e(a, b, c, d) {
        c = c.attributes;
        var e = b.attributes;
        b = b.attributesKeys;
        for (var f = 0, i = b.length; i > f; f++) {
            var j = b[f], k = e[j];
            if (k >= 0) {
                var l = c[j];
                void 0 !== l ? (j = l.itemSize, Eb.bindBuffer(Eb.ARRAY_BUFFER, l.buffer), g(k), 
                Eb.vertexAttribPointer(k, j, Eb.FLOAT, !1, 0, d * j * 4)) : void 0 !== a.defaultAttributeValues && (2 === a.defaultAttributeValues[j].length ? Eb.vertexAttrib2fv(k, a.defaultAttributeValues[j]) : 3 === a.defaultAttributeValues[j].length && Eb.vertexAttrib3fv(k, a.defaultAttributeValues[j]));
            }
        }
        h();
    }
    function f() {
        for (var a = 0, b = Ab.length; b > a; a++) Ab[a] = 0;
    }
    function g(a) {
        Ab[a] = 1, 0 === Bb[a] && (Eb.enableVertexAttribArray(a), Bb[a] = 1);
    }
    function h() {
        for (var a = 0, b = Bb.length; b > a; a++) Bb[a] !== Ab[a] && (Eb.disableVertexAttribArray(a), 
        Bb[a] = 0);
    }
    function i(a, b) {
        return a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
    }
    function j(a, b) {
        return a.z !== b.z ? b.z - a.z : a.id - b.id;
    }
    function k(a, b) {
        return b[0] - a[0];
    }
    function l(a) {
        if (!1 !== a.visible) {
            if (!(a instanceof THREE.Scene || a instanceof THREE.Group)) {
                void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4(), 
                a._normalMatrix = new THREE.Matrix3(), a.addEventListener("removed", cc));
                var c = a.geometry;
                if (void 0 !== c && void 0 === c.__webglInit) if (c.__webglInit = !0, c.addEventListener("dispose", dc), 
                c instanceof THREE.BufferGeometry) ab.info.memory.geometries++; else if (a instanceof THREE.Mesh) p(a, c); else if (a instanceof THREE.Line) {
                    if (void 0 === c.__webglVertexBuffer) {
                        c.__webglVertexBuffer = Eb.createBuffer(), c.__webglColorBuffer = Eb.createBuffer(), 
                        c.__webglLineDistanceBuffer = Eb.createBuffer(), ab.info.memory.geometries++;
                        var d = c.vertices.length;
                        c.__vertexArray = new Float32Array(3 * d), c.__colorArray = new Float32Array(3 * d), 
                        c.__lineDistanceArray = new Float32Array(1 * d), c.__webglLineCount = d, b(a), c.verticesNeedUpdate = !0, 
                        c.colorsNeedUpdate = !0, c.lineDistancesNeedUpdate = !0;
                    }
                } else a instanceof THREE.PointCloud && void 0 === c.__webglVertexBuffer && (c.__webglVertexBuffer = Eb.createBuffer(), 
                c.__webglColorBuffer = Eb.createBuffer(), ab.info.memory.geometries++, d = c.vertices.length, 
                c.__vertexArray = new Float32Array(3 * d), c.__colorArray = new Float32Array(3 * d), 
                c.__sortArray = [], c.__webglParticleCount = d, b(a), c.verticesNeedUpdate = !0, 
                c.colorsNeedUpdate = !0);
                if (void 0 === a.__webglActive) if (a.__webglActive = !0, a instanceof THREE.Mesh) {
                    if (c instanceof THREE.BufferGeometry) q(W, c, a); else if (c instanceof THREE.Geometry) for (var c = jc[c.id], d = 0, e = c.length; e > d; d++) q(W, c[d], a);
                } else a instanceof THREE.Line || a instanceof THREE.PointCloud ? q(W, c, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && X.push({
                    id: null,
                    object: a,
                    opaque: null,
                    transparent: null,
                    z: 0
                });
                if (a instanceof THREE.Light) V.push(a); else if (a instanceof THREE.Sprite) $.push(a); else if (a instanceof THREE.LensFlare) _.push(a); else if ((c = W[a.id]) && (!1 === a.frustumCulled || !0 === Cb.intersectsObject(a))) for (d = 0, 
                e = c.length; e > d; d++) {
                    var f = c[d], g = f, h = g.object, i = g.buffer, j = h.geometry, h = h.material;
                    h instanceof THREE.MeshFaceMaterial ? (h = h.materials[j instanceof THREE.BufferGeometry ? 0 : i.materialIndex], 
                    g.material = h, h.transparent ? Z.push(g) : Y.push(g)) : h && (g.material = h, h.transparent ? Z.push(g) : Y.push(g)), 
                    f.render = !0, !0 === ab.sortObjects && (Fb.setFromMatrixPosition(a.matrixWorld), 
                    Fb.applyProjection(Db), f.z = Fb.z);
                }
            }
            for (d = 0, e = a.children.length; e > d; d++) l(a.children[d]);
        }
    }
    function m(a, b, c, d, e, f) {
        for (var g, h = 0, i = a.length; i > h; h++) {
            g = a[h];
            var j = g.object, k = g.buffer;
            if (x(j, b), f) g = f; else {
                if (g = g.material, !g) continue;
                e && ab.setBlending(g.blending, g.blendEquation, g.blendSrc, g.blendDst), ab.setDepthTest(g.depthTest), 
                ab.setDepthWrite(g.depthWrite), B(g.polygonOffset, g.polygonOffsetFactor, g.polygonOffsetUnits);
            }
            ab.setMaterialFaces(g), k instanceof THREE.BufferGeometry ? ab.renderBufferDirect(b, c, d, g, k, j) : ab.renderBuffer(b, c, d, g, k, j);
        }
    }
    function n(a, b, c, d, e, f, g) {
        for (var h, i = 0, j = a.length; j > i; i++) {
            h = a[i];
            var k = h.object;
            if (k.visible) {
                if (g) h = g; else {
                    if (h = h[b], !h) continue;
                    f && ab.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst), ab.setDepthTest(h.depthTest), 
                    ab.setDepthWrite(h.depthWrite), B(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);
                }
                ab.renderImmediateObject(c, d, e, h, k);
            }
        }
    }
    function o(a) {
        var b = a.object.material;
        b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null);
    }
    function p(a, b) {
        var d = a.material, e = !1;
        if (void 0 === jc[b.id] || !0 === b.groupsNeedUpdate) {
            delete W[a.id];
            for (var f, g, h = jc, i = b.id, d = d instanceof THREE.MeshFaceMaterial, j = Lb.get("OES_element_index_uint") ? 4294967296 : 65535, e = {}, k = b.morphTargets.length, l = b.morphNormals.length, m = {}, n = [], o = 0, p = b.faces.length; p > o; o++) {
                f = b.faces[o];
                var r = d ? f.materialIndex : 0;
                r in e || (e[r] = {
                    hash: r,
                    counter: 0
                }), f = e[r].hash + "_" + e[r].counter, f in m || (g = {
                    id: kc++,
                    faces3: [],
                    materialIndex: r,
                    vertices: 0,
                    numMorphTargets: k,
                    numMorphNormals: l
                }, m[f] = g, n.push(g)), m[f].vertices + 3 > j && (e[r].counter += 1, f = e[r].hash + "_" + e[r].counter, 
                f in m || (g = {
                    id: kc++,
                    faces3: [],
                    materialIndex: r,
                    vertices: 0,
                    numMorphTargets: k,
                    numMorphNormals: l
                }, m[f] = g, n.push(g))), m[f].faces3.push(o), m[f].vertices += 3;
            }
            h[i] = n, b.groupsNeedUpdate = !1;
        }
        for (h = jc[b.id], i = 0, d = h.length; d > i; i++) {
            if (j = h[i], void 0 === j.__webglVertexBuffer) {
                if (e = j, e.__webglVertexBuffer = Eb.createBuffer(), e.__webglNormalBuffer = Eb.createBuffer(), 
                e.__webglTangentBuffer = Eb.createBuffer(), e.__webglColorBuffer = Eb.createBuffer(), 
                e.__webglUVBuffer = Eb.createBuffer(), e.__webglUV2Buffer = Eb.createBuffer(), e.__webglSkinIndicesBuffer = Eb.createBuffer(), 
                e.__webglSkinWeightsBuffer = Eb.createBuffer(), e.__webglFaceBuffer = Eb.createBuffer(), 
                e.__webglLineBuffer = Eb.createBuffer(), l = e.numMorphTargets) for (e.__webglMorphTargetsBuffers = [], 
                k = 0; l > k; k++) e.__webglMorphTargetsBuffers.push(Eb.createBuffer());
                if (l = e.numMorphNormals) for (e.__webglMorphNormalsBuffers = [], k = 0; l > k; k++) e.__webglMorphNormalsBuffers.push(Eb.createBuffer());
                ab.info.memory.geometries++, c(j, a), b.verticesNeedUpdate = !0, b.morphTargetsNeedUpdate = !0, 
                b.elementsNeedUpdate = !0, b.uvsNeedUpdate = !0, b.normalsNeedUpdate = !0, b.tangentsNeedUpdate = !0, 
                e = b.colorsNeedUpdate = !0;
            } else e = !1;
            (e || void 0 === a.__webglActive) && q(W, j, a);
        }
        a.__webglActive = !0;
    }
    function q(a, b, c) {
        var d = c.id;
        a[d] = a[d] || [], a[d].push({
            id: d,
            buffer: b,
            object: c,
            material: null,
            z: 0
        });
    }
    function r(a) {
        var b = a.geometry;
        if (b instanceof THREE.BufferGeometry) for (var e = b.attributes, f = b.attributesKeys, g = 0, h = f.length; h > g; g++) {
            var i = f[g], j = e[i];
            if (void 0 === j.buffer && (j.buffer = Eb.createBuffer(), j.needsUpdate = !0), !0 === j.needsUpdate) {
                var k = "index" === i ? Eb.ELEMENT_ARRAY_BUFFER : Eb.ARRAY_BUFFER;
                Eb.bindBuffer(k, j.buffer), Eb.bufferData(k, j.array, Eb.STATIC_DRAW), j.needsUpdate = !1;
            }
        } else if (a instanceof THREE.Mesh) {
            !0 === b.groupsNeedUpdate && p(a, b);
            for (var l = jc[b.id], g = 0, m = l.length; m > g; g++) {
                var n = l[g], o = d(a, n);
                !0 === b.groupsNeedUpdate && c(n, a);
                var q = o.attributes && s(o);
                if (b.verticesNeedUpdate || b.morphTargetsNeedUpdate || b.elementsNeedUpdate || b.uvsNeedUpdate || b.normalsNeedUpdate || b.colorsNeedUpdate || b.tangentsNeedUpdate || q) {
                    var r = n, u = a, v = Eb.DYNAMIC_DRAW, w = !b.dynamic, x = o;
                    if (r.__inittedArrays) {
                        var y = x && void 0 !== x.shading && x.shading === THREE.SmoothShading, z = void 0, A = void 0, B = void 0, C = void 0, D = void 0, E = void 0, F = void 0, G = void 0, H = void 0, I = void 0, J = void 0, K = void 0, L = void 0, M = void 0, N = void 0, O = void 0, P = void 0, Q = void 0, R = void 0, S = void 0, T = void 0, U = void 0, V = void 0, W = void 0, X = void 0, Y = void 0, Z = void 0, $ = void 0, _ = void 0, ab = void 0, bb = void 0, cb = void 0, db = void 0, eb = void 0, fb = void 0, gb = void 0, hb = void 0, ib = void 0, jb = void 0, kb = void 0, lb = 0, mb = 0, nb = 0, ob = 0, pb = 0, qb = 0, rb = 0, sb = 0, tb = 0, ub = 0, vb = 0, wb = 0, xb = void 0, yb = r.__vertexArray, zb = r.__uvArray, Ab = r.__uv2Array, Bb = r.__normalArray, Cb = r.__tangentArray, Db = r.__colorArray, Fb = r.__skinIndexArray, Gb = r.__skinWeightArray, Hb = r.__morphTargetsArrays, Ib = r.__morphNormalsArrays, Jb = r.__webglCustomAttributesList, Kb = void 0, Lb = r.__faceArray, Mb = r.__lineArray, Nb = u.geometry, Ob = Nb.elementsNeedUpdate, Pb = Nb.uvsNeedUpdate, Qb = Nb.normalsNeedUpdate, Rb = Nb.tangentsNeedUpdate, Sb = Nb.colorsNeedUpdate, Tb = Nb.morphTargetsNeedUpdate, Ub = Nb.vertices, Vb = r.faces3, Wb = Nb.faces, Xb = Nb.faceVertexUvs[0], Yb = Nb.faceVertexUvs[1], Zb = Nb.skinIndices, $b = Nb.skinWeights, _b = Nb.morphTargets, ac = Nb.morphNormals;
                        if (Nb.verticesNeedUpdate) {
                            for (z = 0, A = Vb.length; A > z; z++) C = Wb[Vb[z]], K = Ub[C.a], L = Ub[C.b], 
                            M = Ub[C.c], yb[mb] = K.x, yb[mb + 1] = K.y, yb[mb + 2] = K.z, yb[mb + 3] = L.x, 
                            yb[mb + 4] = L.y, yb[mb + 5] = L.z, yb[mb + 6] = M.x, yb[mb + 7] = M.y, yb[mb + 8] = M.z, 
                            mb += 9;
                            Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglVertexBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, yb, v);
                        }
                        if (Tb) for (fb = 0, gb = _b.length; gb > fb; fb++) {
                            for (z = vb = 0, A = Vb.length; A > z; z++) jb = Vb[z], C = Wb[jb], K = _b[fb].vertices[C.a], 
                            L = _b[fb].vertices[C.b], M = _b[fb].vertices[C.c], hb = Hb[fb], hb[vb] = K.x, hb[vb + 1] = K.y, 
                            hb[vb + 2] = K.z, hb[vb + 3] = L.x, hb[vb + 4] = L.y, hb[vb + 5] = L.z, hb[vb + 6] = M.x, 
                            hb[vb + 7] = M.y, hb[vb + 8] = M.z, x.morphNormals && (y ? (kb = ac[fb].vertexNormals[jb], 
                            Q = kb.a, R = kb.b, S = kb.c) : S = R = Q = ac[fb].faceNormals[jb], ib = Ib[fb], 
                            ib[vb] = Q.x, ib[vb + 1] = Q.y, ib[vb + 2] = Q.z, ib[vb + 3] = R.x, ib[vb + 4] = R.y, 
                            ib[vb + 5] = R.z, ib[vb + 6] = S.x, ib[vb + 7] = S.y, ib[vb + 8] = S.z), vb += 9;
                            Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglMorphTargetsBuffers[fb]), Eb.bufferData(Eb.ARRAY_BUFFER, Hb[fb], v), 
                            x.morphNormals && (Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglMorphNormalsBuffers[fb]), 
                            Eb.bufferData(Eb.ARRAY_BUFFER, Ib[fb], v));
                        }
                        if ($b.length) {
                            for (z = 0, A = Vb.length; A > z; z++) C = Wb[Vb[z]], W = $b[C.a], X = $b[C.b], 
                            Y = $b[C.c], Gb[ub] = W.x, Gb[ub + 1] = W.y, Gb[ub + 2] = W.z, Gb[ub + 3] = W.w, 
                            Gb[ub + 4] = X.x, Gb[ub + 5] = X.y, Gb[ub + 6] = X.z, Gb[ub + 7] = X.w, Gb[ub + 8] = Y.x, 
                            Gb[ub + 9] = Y.y, Gb[ub + 10] = Y.z, Gb[ub + 11] = Y.w, Z = Zb[C.a], $ = Zb[C.b], 
                            _ = Zb[C.c], Fb[ub] = Z.x, Fb[ub + 1] = Z.y, Fb[ub + 2] = Z.z, Fb[ub + 3] = Z.w, 
                            Fb[ub + 4] = $.x, Fb[ub + 5] = $.y, Fb[ub + 6] = $.z, Fb[ub + 7] = $.w, Fb[ub + 8] = _.x, 
                            Fb[ub + 9] = _.y, Fb[ub + 10] = _.z, Fb[ub + 11] = _.w, ub += 12;
                            ub > 0 && (Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglSkinIndicesBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, Fb, v), 
                            Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglSkinWeightsBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, Gb, v));
                        }
                        if (Sb) {
                            for (z = 0, A = Vb.length; A > z; z++) C = Wb[Vb[z]], F = C.vertexColors, G = C.color, 
                            3 === F.length && x.vertexColors === THREE.VertexColors ? (T = F[0], U = F[1], V = F[2]) : V = U = T = G, 
                            Db[tb] = T.r, Db[tb + 1] = T.g, Db[tb + 2] = T.b, Db[tb + 3] = U.r, Db[tb + 4] = U.g, 
                            Db[tb + 5] = U.b, Db[tb + 6] = V.r, Db[tb + 7] = V.g, Db[tb + 8] = V.b, tb += 9;
                            tb > 0 && (Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglColorBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, Db, v));
                        }
                        if (Rb && Nb.hasTangents) {
                            for (z = 0, A = Vb.length; A > z; z++) C = Wb[Vb[z]], H = C.vertexTangents, N = H[0], 
                            O = H[1], P = H[2], Cb[rb] = N.x, Cb[rb + 1] = N.y, Cb[rb + 2] = N.z, Cb[rb + 3] = N.w, 
                            Cb[rb + 4] = O.x, Cb[rb + 5] = O.y, Cb[rb + 6] = O.z, Cb[rb + 7] = O.w, Cb[rb + 8] = P.x, 
                            Cb[rb + 9] = P.y, Cb[rb + 10] = P.z, Cb[rb + 11] = P.w, rb += 12;
                            Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglTangentBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, Cb, v);
                        }
                        if (Qb) {
                            for (z = 0, A = Vb.length; A > z; z++) if (C = Wb[Vb[z]], D = C.vertexNormals, E = C.normal, 
                            3 === D.length && y) for (ab = 0; 3 > ab; ab++) cb = D[ab], Bb[qb] = cb.x, Bb[qb + 1] = cb.y, 
                            Bb[qb + 2] = cb.z, qb += 3; else for (ab = 0; 3 > ab; ab++) Bb[qb] = E.x, Bb[qb + 1] = E.y, 
                            Bb[qb + 2] = E.z, qb += 3;
                            Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglNormalBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, Bb, v);
                        }
                        if (Pb && Xb) {
                            for (z = 0, A = Vb.length; A > z; z++) if (B = Vb[z], I = Xb[B], void 0 !== I) for (ab = 0; 3 > ab; ab++) db = I[ab], 
                            zb[nb] = db.x, zb[nb + 1] = db.y, nb += 2;
                            nb > 0 && (Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglUVBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, zb, v));
                        }
                        if (Pb && Yb) {
                            for (z = 0, A = Vb.length; A > z; z++) if (B = Vb[z], J = Yb[B], void 0 !== J) for (ab = 0; 3 > ab; ab++) eb = J[ab], 
                            Ab[ob] = eb.x, Ab[ob + 1] = eb.y, ob += 2;
                            ob > 0 && (Eb.bindBuffer(Eb.ARRAY_BUFFER, r.__webglUV2Buffer), Eb.bufferData(Eb.ARRAY_BUFFER, Ab, v));
                        }
                        if (Ob) {
                            for (z = 0, A = Vb.length; A > z; z++) Lb[pb] = lb, Lb[pb + 1] = lb + 1, Lb[pb + 2] = lb + 2, 
                            pb += 3, Mb[sb] = lb, Mb[sb + 1] = lb + 1, Mb[sb + 2] = lb, Mb[sb + 3] = lb + 2, 
                            Mb[sb + 4] = lb + 1, Mb[sb + 5] = lb + 2, sb += 6, lb += 3;
                            Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, r.__webglFaceBuffer), Eb.bufferData(Eb.ELEMENT_ARRAY_BUFFER, Lb, v), 
                            Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, r.__webglLineBuffer), Eb.bufferData(Eb.ELEMENT_ARRAY_BUFFER, Mb, v);
                        }
                        if (Jb) for (ab = 0, bb = Jb.length; bb > ab; ab++) if (Kb = Jb[ab], Kb.__original.needsUpdate) {
                            if (wb = 0, 1 === Kb.size) {
                                if (void 0 === Kb.boundTo || "vertices" === Kb.boundTo) for (z = 0, A = Vb.length; A > z; z++) C = Wb[Vb[z]], 
                                Kb.array[wb] = Kb.value[C.a], Kb.array[wb + 1] = Kb.value[C.b], Kb.array[wb + 2] = Kb.value[C.c], 
                                wb += 3; else if ("faces" === Kb.boundTo) for (z = 0, A = Vb.length; A > z; z++) xb = Kb.value[Vb[z]], 
                                Kb.array[wb] = xb, Kb.array[wb + 1] = xb, Kb.array[wb + 2] = xb, wb += 3;
                            } else if (2 === Kb.size) {
                                if (void 0 === Kb.boundTo || "vertices" === Kb.boundTo) for (z = 0, A = Vb.length; A > z; z++) C = Wb[Vb[z]], 
                                K = Kb.value[C.a], L = Kb.value[C.b], M = Kb.value[C.c], Kb.array[wb] = K.x, Kb.array[wb + 1] = K.y, 
                                Kb.array[wb + 2] = L.x, Kb.array[wb + 3] = L.y, Kb.array[wb + 4] = M.x, Kb.array[wb + 5] = M.y, 
                                wb += 6; else if ("faces" === Kb.boundTo) for (z = 0, A = Vb.length; A > z; z++) M = L = K = xb = Kb.value[Vb[z]], 
                                Kb.array[wb] = K.x, Kb.array[wb + 1] = K.y, Kb.array[wb + 2] = L.x, Kb.array[wb + 3] = L.y, 
                                Kb.array[wb + 4] = M.x, Kb.array[wb + 5] = M.y, wb += 6;
                            } else if (3 === Kb.size) {
                                var bc;
                                if (bc = "c" === Kb.type ? [ "r", "g", "b" ] : [ "x", "y", "z" ], void 0 === Kb.boundTo || "vertices" === Kb.boundTo) for (z = 0, 
                                A = Vb.length; A > z; z++) C = Wb[Vb[z]], K = Kb.value[C.a], L = Kb.value[C.b], 
                                M = Kb.value[C.c], Kb.array[wb] = K[bc[0]], Kb.array[wb + 1] = K[bc[1]], Kb.array[wb + 2] = K[bc[2]], 
                                Kb.array[wb + 3] = L[bc[0]], Kb.array[wb + 4] = L[bc[1]], Kb.array[wb + 5] = L[bc[2]], 
                                Kb.array[wb + 6] = M[bc[0]], Kb.array[wb + 7] = M[bc[1]], Kb.array[wb + 8] = M[bc[2]], 
                                wb += 9; else if ("faces" === Kb.boundTo) for (z = 0, A = Vb.length; A > z; z++) M = L = K = xb = Kb.value[Vb[z]], 
                                Kb.array[wb] = K[bc[0]], Kb.array[wb + 1] = K[bc[1]], Kb.array[wb + 2] = K[bc[2]], 
                                Kb.array[wb + 3] = L[bc[0]], Kb.array[wb + 4] = L[bc[1]], Kb.array[wb + 5] = L[bc[2]], 
                                Kb.array[wb + 6] = M[bc[0]], Kb.array[wb + 7] = M[bc[1]], Kb.array[wb + 8] = M[bc[2]], 
                                wb += 9; else if ("faceVertices" === Kb.boundTo) for (z = 0, A = Vb.length; A > z; z++) xb = Kb.value[Vb[z]], 
                                K = xb[0], L = xb[1], M = xb[2], Kb.array[wb] = K[bc[0]], Kb.array[wb + 1] = K[bc[1]], 
                                Kb.array[wb + 2] = K[bc[2]], Kb.array[wb + 3] = L[bc[0]], Kb.array[wb + 4] = L[bc[1]], 
                                Kb.array[wb + 5] = L[bc[2]], Kb.array[wb + 6] = M[bc[0]], Kb.array[wb + 7] = M[bc[1]], 
                                Kb.array[wb + 8] = M[bc[2]], wb += 9;
                            } else if (4 === Kb.size) if (void 0 === Kb.boundTo || "vertices" === Kb.boundTo) for (z = 0, 
                            A = Vb.length; A > z; z++) C = Wb[Vb[z]], K = Kb.value[C.a], L = Kb.value[C.b], 
                            M = Kb.value[C.c], Kb.array[wb] = K.x, Kb.array[wb + 1] = K.y, Kb.array[wb + 2] = K.z, 
                            Kb.array[wb + 3] = K.w, Kb.array[wb + 4] = L.x, Kb.array[wb + 5] = L.y, Kb.array[wb + 6] = L.z, 
                            Kb.array[wb + 7] = L.w, Kb.array[wb + 8] = M.x, Kb.array[wb + 9] = M.y, Kb.array[wb + 10] = M.z, 
                            Kb.array[wb + 11] = M.w, wb += 12; else if ("faces" === Kb.boundTo) for (z = 0, 
                            A = Vb.length; A > z; z++) M = L = K = xb = Kb.value[Vb[z]], Kb.array[wb] = K.x, 
                            Kb.array[wb + 1] = K.y, Kb.array[wb + 2] = K.z, Kb.array[wb + 3] = K.w, Kb.array[wb + 4] = L.x, 
                            Kb.array[wb + 5] = L.y, Kb.array[wb + 6] = L.z, Kb.array[wb + 7] = L.w, Kb.array[wb + 8] = M.x, 
                            Kb.array[wb + 9] = M.y, Kb.array[wb + 10] = M.z, Kb.array[wb + 11] = M.w, wb += 12; else if ("faceVertices" === Kb.boundTo) for (z = 0, 
                            A = Vb.length; A > z; z++) xb = Kb.value[Vb[z]], K = xb[0], L = xb[1], M = xb[2], 
                            Kb.array[wb] = K.x, Kb.array[wb + 1] = K.y, Kb.array[wb + 2] = K.z, Kb.array[wb + 3] = K.w, 
                            Kb.array[wb + 4] = L.x, Kb.array[wb + 5] = L.y, Kb.array[wb + 6] = L.z, Kb.array[wb + 7] = L.w, 
                            Kb.array[wb + 8] = M.x, Kb.array[wb + 9] = M.y, Kb.array[wb + 10] = M.z, Kb.array[wb + 11] = M.w, 
                            wb += 12;
                            Eb.bindBuffer(Eb.ARRAY_BUFFER, Kb.buffer), Eb.bufferData(Eb.ARRAY_BUFFER, Kb.array, v);
                        }
                        w && (delete r.__inittedArrays, delete r.__colorArray, delete r.__normalArray, delete r.__tangentArray, 
                        delete r.__uvArray, delete r.__uv2Array, delete r.__faceArray, delete r.__vertexArray, 
                        delete r.__lineArray, delete r.__skinIndexArray, delete r.__skinWeightArray);
                    }
                }
            }
            b.verticesNeedUpdate = !1, b.morphTargetsNeedUpdate = !1, b.elementsNeedUpdate = !1, 
            b.uvsNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.tangentsNeedUpdate = !1, 
            o.attributes && t(o);
        } else if (a instanceof THREE.Line) {
            if (o = d(a, b), q = o.attributes && s(o), b.verticesNeedUpdate || b.colorsNeedUpdate || b.lineDistancesNeedUpdate || q) {
                var cc, dc, ec, fc, gc, hc, ic, kc, lc, mc, nc, oc, pc = Eb.DYNAMIC_DRAW, qc = b.vertices, rc = b.colors, sc = b.lineDistances, tc = qc.length, uc = rc.length, vc = sc.length, wc = b.__vertexArray, xc = b.__colorArray, yc = b.__lineDistanceArray, zc = b.colorsNeedUpdate, Ac = b.lineDistancesNeedUpdate, Bc = b.__webglCustomAttributesList;
                if (b.verticesNeedUpdate) {
                    for (cc = 0; tc > cc; cc++) fc = qc[cc], gc = 3 * cc, wc[gc] = fc.x, wc[gc + 1] = fc.y, 
                    wc[gc + 2] = fc.z;
                    Eb.bindBuffer(Eb.ARRAY_BUFFER, b.__webglVertexBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, wc, pc);
                }
                if (zc) {
                    for (dc = 0; uc > dc; dc++) hc = rc[dc], gc = 3 * dc, xc[gc] = hc.r, xc[gc + 1] = hc.g, 
                    xc[gc + 2] = hc.b;
                    Eb.bindBuffer(Eb.ARRAY_BUFFER, b.__webglColorBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, xc, pc);
                }
                if (Ac) {
                    for (ec = 0; vc > ec; ec++) yc[ec] = sc[ec];
                    Eb.bindBuffer(Eb.ARRAY_BUFFER, b.__webglLineDistanceBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, yc, pc);
                }
                if (Bc) for (ic = 0, kc = Bc.length; kc > ic; ic++) if (oc = Bc[ic], oc.needsUpdate && (void 0 === oc.boundTo || "vertices" === oc.boundTo)) {
                    if (gc = 0, mc = oc.value.length, 1 === oc.size) for (lc = 0; mc > lc; lc++) oc.array[lc] = oc.value[lc]; else if (2 === oc.size) for (lc = 0; mc > lc; lc++) nc = oc.value[lc], 
                    oc.array[gc] = nc.x, oc.array[gc + 1] = nc.y, gc += 2; else if (3 === oc.size) if ("c" === oc.type) for (lc = 0; mc > lc; lc++) nc = oc.value[lc], 
                    oc.array[gc] = nc.r, oc.array[gc + 1] = nc.g, oc.array[gc + 2] = nc.b, gc += 3; else for (lc = 0; mc > lc; lc++) nc = oc.value[lc], 
                    oc.array[gc] = nc.x, oc.array[gc + 1] = nc.y, oc.array[gc + 2] = nc.z, gc += 3; else if (4 === oc.size) for (lc = 0; mc > lc; lc++) nc = oc.value[lc], 
                    oc.array[gc] = nc.x, oc.array[gc + 1] = nc.y, oc.array[gc + 2] = nc.z, oc.array[gc + 3] = nc.w, 
                    gc += 4;
                    Eb.bindBuffer(Eb.ARRAY_BUFFER, oc.buffer), Eb.bufferData(Eb.ARRAY_BUFFER, oc.array, pc), 
                    oc.needsUpdate = !1;
                }
            }
            b.verticesNeedUpdate = !1, b.colorsNeedUpdate = !1, b.lineDistancesNeedUpdate = !1, 
            o.attributes && t(o);
        } else if (a instanceof THREE.PointCloud) {
            if (o = d(a, b), q = o.attributes && s(o), b.verticesNeedUpdate || b.colorsNeedUpdate || q) {
                var Cc, Dc, Ec, Fc, Gc, Hc, Ic, Jc, Kc, Lc, Mc, Nc = Eb.DYNAMIC_DRAW, Oc = b.vertices, Pc = Oc.length, Qc = b.colors, Rc = Qc.length, Sc = b.__vertexArray, Tc = b.__colorArray, Uc = b.colorsNeedUpdate, Vc = b.__webglCustomAttributesList;
                if (b.verticesNeedUpdate) {
                    for (Cc = 0; Pc > Cc; Cc++) Ec = Oc[Cc], Fc = 3 * Cc, Sc[Fc] = Ec.x, Sc[Fc + 1] = Ec.y, 
                    Sc[Fc + 2] = Ec.z;
                    Eb.bindBuffer(Eb.ARRAY_BUFFER, b.__webglVertexBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, Sc, Nc);
                }
                if (Uc) {
                    for (Dc = 0; Rc > Dc; Dc++) Gc = Qc[Dc], Fc = 3 * Dc, Tc[Fc] = Gc.r, Tc[Fc + 1] = Gc.g, 
                    Tc[Fc + 2] = Gc.b;
                    Eb.bindBuffer(Eb.ARRAY_BUFFER, b.__webglColorBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, Tc, Nc);
                }
                if (Vc) for (Hc = 0, Ic = Vc.length; Ic > Hc; Hc++) {
                    if (Mc = Vc[Hc], Mc.needsUpdate && (void 0 === Mc.boundTo || "vertices" === Mc.boundTo)) if (Kc = Mc.value.length, 
                    Fc = 0, 1 === Mc.size) for (Jc = 0; Kc > Jc; Jc++) Mc.array[Jc] = Mc.value[Jc]; else if (2 === Mc.size) for (Jc = 0; Kc > Jc; Jc++) Lc = Mc.value[Jc], 
                    Mc.array[Fc] = Lc.x, Mc.array[Fc + 1] = Lc.y, Fc += 2; else if (3 === Mc.size) if ("c" === Mc.type) for (Jc = 0; Kc > Jc; Jc++) Lc = Mc.value[Jc], 
                    Mc.array[Fc] = Lc.r, Mc.array[Fc + 1] = Lc.g, Mc.array[Fc + 2] = Lc.b, Fc += 3; else for (Jc = 0; Kc > Jc; Jc++) Lc = Mc.value[Jc], 
                    Mc.array[Fc] = Lc.x, Mc.array[Fc + 1] = Lc.y, Mc.array[Fc + 2] = Lc.z, Fc += 3; else if (4 === Mc.size) for (Jc = 0; Kc > Jc; Jc++) Lc = Mc.value[Jc], 
                    Mc.array[Fc] = Lc.x, Mc.array[Fc + 1] = Lc.y, Mc.array[Fc + 2] = Lc.z, Mc.array[Fc + 3] = Lc.w, 
                    Fc += 4;
                    Eb.bindBuffer(Eb.ARRAY_BUFFER, Mc.buffer), Eb.bufferData(Eb.ARRAY_BUFFER, Mc.array, Nc), 
                    Mc.needsUpdate = !1;
                }
            }
            b.verticesNeedUpdate = !1, b.colorsNeedUpdate = !1, o.attributes && t(o);
        }
    }
    function s(a) {
        for (var b in a.attributes) if (a.attributes[b].needsUpdate) return !0;
        return !1;
    }
    function t(a) {
        for (var b in a.attributes) a.attributes[b].needsUpdate = !1;
    }
    function u(a, b, c, d, e) {
        var f, g, h, i;
        if (hb = 0, d.needsUpdate) {
            d.program && ic(d), d.addEventListener("dispose", gc);
            var j = lc[d.type];
            if (j) {
                var k = THREE.ShaderLib[j];
                d.__webglShader = {
                    uniforms: THREE.UniformsUtils.clone(k.uniforms),
                    vertexShader: k.vertexShader,
                    fragmentShader: k.fragmentShader
                };
            } else d.__webglShader = {
                uniforms: d.uniforms,
                vertexShader: d.vertexShader,
                fragmentShader: d.fragmentShader
            };
            for (var l = 0, m = 0, n = 0, o = 0, p = 0, q = b.length; q > p; p++) {
                var r = b[p];
                r.onlyShadow || !1 === r.visible || (r instanceof THREE.DirectionalLight && l++, 
                r instanceof THREE.PointLight && m++, r instanceof THREE.SpotLight && n++, r instanceof THREE.HemisphereLight && o++);
            }
            f = l, g = m, h = n, i = o;
            for (var s, t = 0, u = 0, x = b.length; x > u; u++) {
                var A = b[u];
                A.castShadow && (A instanceof THREE.SpotLight && t++, A instanceof THREE.DirectionalLight && !A.shadowCascade && t++);
            }
            s = t;
            var B;
            if (Tb && e && e.skeleton && e.skeleton.useVertexTexture) B = 1024; else {
                var E = Eb.getParameter(Eb.MAX_VERTEX_UNIFORM_VECTORS), F = Math.floor((E - 20) / 4);
                void 0 !== e && e instanceof THREE.SkinnedMesh && (F = Math.min(e.skeleton.bones.length, F), 
                F < e.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + e.skeleton.bones.length + ", this GPU supports just " + F + " (try OpenGL instead of ANGLE)")), 
                B = F;
            }
            var G = {
                precision: L,
                supportsVertexTextures: Sb,
                map: !!d.map,
                envMap: !!d.envMap,
                envMapMode: d.envMap && d.envMap.mapping,
                lightMap: !!d.lightMap,
                bumpMap: !!d.bumpMap,
                normalMap: !!d.normalMap,
                specularMap: !!d.specularMap,
                alphaMap: !!d.alphaMap,
                combine: d.combine,
                vertexColors: d.vertexColors,
                fog: c,
                useFog: d.fog,
                fogExp: c instanceof THREE.FogExp2,
                sizeAttenuation: d.sizeAttenuation,
                logarithmicDepthBuffer: S,
                skinning: d.skinning,
                maxBones: B,
                useVertexTexture: Tb && e && e.skeleton && e.skeleton.useVertexTexture,
                morphTargets: d.morphTargets,
                morphNormals: d.morphNormals,
                maxMorphTargets: ab.maxMorphTargets,
                maxMorphNormals: ab.maxMorphNormals,
                maxDirLights: f,
                maxPointLights: g,
                maxSpotLights: h,
                maxHemiLights: i,
                maxShadows: s,
                shadowMapEnabled: ab.shadowMapEnabled && e.receiveShadow && s > 0,
                shadowMapType: ab.shadowMapType,
                shadowMapDebug: ab.shadowMapDebug,
                shadowMapCascade: ab.shadowMapCascade,
                alphaTest: d.alphaTest,
                metal: d.metal,
                wrapAround: d.wrapAround,
                doubleSided: d.side === THREE.DoubleSide,
                flipSided: d.side === THREE.BackSide
            }, J = [];
            if (j ? J.push(j) : (J.push(d.fragmentShader), J.push(d.vertexShader)), void 0 !== d.defines) for (var K in d.defines) J.push(K), 
            J.push(d.defines[K]);
            for (K in G) J.push(K), J.push(G[K]);
            for (var M, N = J.join(), O = 0, P = bb.length; P > O; O++) {
                var Q = bb[O];
                if (Q.code === N) {
                    M = Q, M.usedTimes++;
                    break;
                }
            }
            void 0 === M && (M = new THREE.WebGLProgram(ab, N, d, G), bb.push(M), ab.info.memory.programs = bb.length), 
            d.program = M;
            var R = M.attributes;
            if (d.morphTargets) {
                d.numSupportedMorphTargets = 0;
                for (var T, U = "morphTarget", V = 0; V < ab.maxMorphTargets; V++) T = U + V, 0 <= R[T] && d.numSupportedMorphTargets++;
            }
            if (d.morphNormals) for (d.numSupportedMorphNormals = 0, U = "morphNormal", V = 0; V < ab.maxMorphNormals; V++) T = U + V, 
            0 <= R[T] && d.numSupportedMorphNormals++;
            d.uniformsList = [];
            for (var W in d.__webglShader.uniforms) {
                var X = d.program.uniforms[W];
                X && d.uniformsList.push([ d.__webglShader.uniforms[W], X ]);
            }
            d.needsUpdate = !1;
        }
        d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(ab.maxMorphTargets));
        var Y = !1, Z = !1, $ = !1, _ = d.program, db = _.uniforms, fb = d.__webglShader.uniforms;
        if (_.id !== cb && (Eb.useProgram(_.program), cb = _.id, $ = Z = Y = !0), d.id !== eb && (-1 === eb && ($ = !0), 
        eb = d.id, Z = !0), (Y || a !== gb) && (Eb.uniformMatrix4fv(db.projectionMatrix, !1, a.projectionMatrix.elements), 
        S && Eb.uniform1f(db.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !== gb && (gb = a), 
        (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== db.cameraPosition && (Fb.setFromMatrixPosition(a.matrixWorld), 
        Eb.uniform3f(db.cameraPosition, Fb.x, Fb.y, Fb.z)), (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshBasicMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== db.viewMatrix && Eb.uniformMatrix4fv(db.viewMatrix, !1, a.matrixWorldInverse.elements)), 
        d.skinning) if (e.bindMatrix && null !== db.bindMatrix && Eb.uniformMatrix4fv(db.bindMatrix, !1, e.bindMatrix.elements), 
        e.bindMatrixInverse && null !== db.bindMatrixInverse && Eb.uniformMatrix4fv(db.bindMatrixInverse, !1, e.bindMatrixInverse.elements), 
        Tb && e.skeleton && e.skeleton.useVertexTexture) {
            if (null !== db.boneTexture) {
                var ib = w();
                Eb.uniform1i(db.boneTexture, ib), ab.setTexture(e.skeleton.boneTexture, ib);
            }
            null !== db.boneTextureWidth && Eb.uniform1i(db.boneTextureWidth, e.skeleton.boneTextureWidth), 
            null !== db.boneTextureHeight && Eb.uniform1i(db.boneTextureHeight, e.skeleton.boneTextureHeight);
        } else e.skeleton && e.skeleton.boneMatrices && null !== db.boneGlobalMatrices && Eb.uniformMatrix4fv(db.boneGlobalMatrices, !1, e.skeleton.boneMatrices);
        if (Z) {
            if (c && d.fog && (fb.fogColor.value = c.color, c instanceof THREE.Fog ? (fb.fogNear.value = c.near, 
            fb.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (fb.fogDensity.value = c.density)), 
            d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
                if (Hb) {
                    var jb, kb, lb, mb, nb, ob, pb, qb, rb, $ = !0, sb = 0, tb = 0, ub = 0, vb = Ib, wb = vb.directional.colors, xb = vb.directional.positions, yb = vb.point.colors, zb = vb.point.positions, Ab = vb.point.distances, Bb = vb.spot.colors, Cb = vb.spot.positions, Db = vb.spot.distances, Jb = vb.spot.directions, Kb = vb.spot.anglesCos, Lb = vb.spot.exponents, Mb = vb.hemi.skyColors, Nb = vb.hemi.groundColors, Ob = vb.hemi.positions, Pb = 0, Qb = 0, Ub = 0, Vb = 0, Wb = 0, Xb = 0, Zb = 0, $b = 0, _b = 0, ac = 0, bc = 0, cc = 0;
                    for (jb = 0, kb = b.length; kb > jb; jb++) lb = b[jb], lb.onlyShadow || (mb = lb.color, 
                    pb = lb.intensity, rb = lb.distance, lb instanceof THREE.AmbientLight ? lb.visible && (ab.gammaInput ? (sb += mb.r * mb.r, 
                    tb += mb.g * mb.g, ub += mb.b * mb.b) : (sb += mb.r, tb += mb.g, ub += mb.b)) : lb instanceof THREE.DirectionalLight ? (Wb += 1, 
                    lb.visible && (Gb.setFromMatrixPosition(lb.matrixWorld), Fb.setFromMatrixPosition(lb.target.matrixWorld), 
                    Gb.sub(Fb), Gb.normalize(), _b = 3 * Pb, xb[_b] = Gb.x, xb[_b + 1] = Gb.y, xb[_b + 2] = Gb.z, 
                    ab.gammaInput ? y(wb, _b, mb, pb * pb) : z(wb, _b, mb, pb), Pb += 1)) : lb instanceof THREE.PointLight ? (Xb += 1, 
                    lb.visible && (ac = 3 * Qb, ab.gammaInput ? y(yb, ac, mb, pb * pb) : z(yb, ac, mb, pb), 
                    Fb.setFromMatrixPosition(lb.matrixWorld), zb[ac] = Fb.x, zb[ac + 1] = Fb.y, zb[ac + 2] = Fb.z, 
                    Ab[Qb] = rb, Qb += 1)) : lb instanceof THREE.SpotLight ? (Zb += 1, lb.visible && (bc = 3 * Ub, 
                    ab.gammaInput ? y(Bb, bc, mb, pb * pb) : z(Bb, bc, mb, pb), Gb.setFromMatrixPosition(lb.matrixWorld), 
                    Cb[bc] = Gb.x, Cb[bc + 1] = Gb.y, Cb[bc + 2] = Gb.z, Db[Ub] = rb, Fb.setFromMatrixPosition(lb.target.matrixWorld), 
                    Gb.sub(Fb), Gb.normalize(), Jb[bc] = Gb.x, Jb[bc + 1] = Gb.y, Jb[bc + 2] = Gb.z, 
                    Kb[Ub] = Math.cos(lb.angle), Lb[Ub] = lb.exponent, Ub += 1)) : lb instanceof THREE.HemisphereLight && ($b += 1, 
                    lb.visible && (Gb.setFromMatrixPosition(lb.matrixWorld), Gb.normalize(), cc = 3 * Vb, 
                    Ob[cc] = Gb.x, Ob[cc + 1] = Gb.y, Ob[cc + 2] = Gb.z, nb = lb.color, ob = lb.groundColor, 
                    ab.gammaInput ? (qb = pb * pb, y(Mb, cc, nb, qb), y(Nb, cc, ob, qb)) : (z(Mb, cc, nb, pb), 
                    z(Nb, cc, ob, pb)), Vb += 1)));
                    for (jb = 3 * Pb, kb = Math.max(wb.length, 3 * Wb); kb > jb; jb++) wb[jb] = 0;
                    for (jb = 3 * Qb, kb = Math.max(yb.length, 3 * Xb); kb > jb; jb++) yb[jb] = 0;
                    for (jb = 3 * Ub, kb = Math.max(Bb.length, 3 * Zb); kb > jb; jb++) Bb[jb] = 0;
                    for (jb = 3 * Vb, kb = Math.max(Mb.length, 3 * $b); kb > jb; jb++) Mb[jb] = 0;
                    for (jb = 3 * Vb, kb = Math.max(Nb.length, 3 * $b); kb > jb; jb++) Nb[jb] = 0;
                    vb.directional.length = Pb, vb.point.length = Qb, vb.spot.length = Ub, vb.hemi.length = Vb, 
                    vb.ambient[0] = sb, vb.ambient[1] = tb, vb.ambient[2] = ub, Hb = !1;
                }
                if ($) {
                    var dc = Ib;
                    fb.ambientLightColor.value = dc.ambient, fb.directionalLightColor.value = dc.directional.colors, 
                    fb.directionalLightDirection.value = dc.directional.positions, fb.pointLightColor.value = dc.point.colors, 
                    fb.pointLightPosition.value = dc.point.positions, fb.pointLightDistance.value = dc.point.distances, 
                    fb.spotLightColor.value = dc.spot.colors, fb.spotLightPosition.value = dc.spot.positions, 
                    fb.spotLightDistance.value = dc.spot.distances, fb.spotLightDirection.value = dc.spot.directions, 
                    fb.spotLightAngleCos.value = dc.spot.anglesCos, fb.spotLightExponent.value = dc.spot.exponents, 
                    fb.hemisphereLightSkyColor.value = dc.hemi.skyColors, fb.hemisphereLightGroundColor.value = dc.hemi.groundColors, 
                    fb.hemisphereLightDirection.value = dc.hemi.positions, v(fb, !0);
                } else v(fb, !1);
            }
            if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
                fb.opacity.value = d.opacity, ab.gammaInput ? fb.diffuse.value.copyGammaToLinear(d.color) : fb.diffuse.value = d.color, 
                fb.map.value = d.map, fb.lightMap.value = d.lightMap, fb.specularMap.value = d.specularMap, 
                fb.alphaMap.value = d.alphaMap, d.bumpMap && (fb.bumpMap.value = d.bumpMap, fb.bumpScale.value = d.bumpScale), 
                d.normalMap && (fb.normalMap.value = d.normalMap, fb.normalScale.value.copy(d.normalScale));
                var fc;
                if (d.map ? fc = d.map : d.specularMap ? fc = d.specularMap : d.normalMap ? fc = d.normalMap : d.bumpMap ? fc = d.bumpMap : d.alphaMap && (fc = d.alphaMap), 
                void 0 !== fc) {
                    var hc = fc.offset, jc = fc.repeat;
                    fb.offsetRepeat.value.set(hc.x, hc.y, jc.x, jc.y);
                }
                fb.envMap.value = d.envMap, fb.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, 
                fb.reflectivity.value = d.reflectivity, fb.refractionRatio.value = d.refractionRatio;
            }
            if (d instanceof THREE.LineBasicMaterial ? (fb.diffuse.value = d.color, fb.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (fb.diffuse.value = d.color, 
            fb.opacity.value = d.opacity, fb.dashSize.value = d.dashSize, fb.totalSize.value = d.dashSize + d.gapSize, 
            fb.scale.value = d.scale) : d instanceof THREE.PointCloudMaterial ? (fb.psColor.value = d.color, 
            fb.opacity.value = d.opacity, fb.size.value = d.size, fb.scale.value = I.height / 2, 
            fb.map.value = d.map) : d instanceof THREE.MeshPhongMaterial ? (fb.shininess.value = d.shininess, 
            ab.gammaInput ? (fb.ambient.value.copyGammaToLinear(d.ambient), fb.emissive.value.copyGammaToLinear(d.emissive), 
            fb.specular.value.copyGammaToLinear(d.specular)) : (fb.ambient.value = d.ambient, 
            fb.emissive.value = d.emissive, fb.specular.value = d.specular), d.wrapAround && fb.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (ab.gammaInput ? (fb.ambient.value.copyGammaToLinear(d.ambient), 
            fb.emissive.value.copyGammaToLinear(d.emissive)) : (fb.ambient.value = d.ambient, 
            fb.emissive.value = d.emissive), d.wrapAround && fb.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (fb.mNear.value = a.near, 
            fb.mFar.value = a.far, fb.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (fb.opacity.value = d.opacity), 
            e.receiveShadow && !d._shadowPass && fb.shadowMatrix) for (var kc = 0, mc = 0, nc = b.length; nc > mc; mc++) {
                var oc = b[mc];
                oc.castShadow && (oc instanceof THREE.SpotLight || oc instanceof THREE.DirectionalLight && !oc.shadowCascade) && (fb.shadowMap.value[kc] = oc.shadowMap, 
                fb.shadowMapSize.value[kc] = oc.shadowMapSize, fb.shadowMatrix.value[kc] = oc.shadowMatrix, 
                fb.shadowDarkness.value[kc] = oc.shadowDarkness, fb.shadowBias.value[kc] = oc.shadowBias, 
                kc++);
            }
            for (var pc, qc, rc, sc = d.uniformsList, tc = 0, uc = sc.length; uc > tc; tc++) {
                var vc = sc[tc][0];
                if (!1 !== vc.needsUpdate) {
                    var wc = vc.type, xc = vc.value, yc = sc[tc][1];
                    switch (wc) {
                      case "1i":
                        Eb.uniform1i(yc, xc);
                        break;

                      case "1f":
                        Eb.uniform1f(yc, xc);
                        break;

                      case "2f":
                        Eb.uniform2f(yc, xc[0], xc[1]);
                        break;

                      case "3f":
                        Eb.uniform3f(yc, xc[0], xc[1], xc[2]);
                        break;

                      case "4f":
                        Eb.uniform4f(yc, xc[0], xc[1], xc[2], xc[3]);
                        break;

                      case "1iv":
                        Eb.uniform1iv(yc, xc);
                        break;

                      case "3iv":
                        Eb.uniform3iv(yc, xc);
                        break;

                      case "1fv":
                        Eb.uniform1fv(yc, xc);
                        break;

                      case "2fv":
                        Eb.uniform2fv(yc, xc);
                        break;

                      case "3fv":
                        Eb.uniform3fv(yc, xc);
                        break;

                      case "4fv":
                        Eb.uniform4fv(yc, xc);
                        break;

                      case "Matrix3fv":
                        Eb.uniformMatrix3fv(yc, !1, xc);
                        break;

                      case "Matrix4fv":
                        Eb.uniformMatrix4fv(yc, !1, xc);
                        break;

                      case "i":
                        Eb.uniform1i(yc, xc);
                        break;

                      case "f":
                        Eb.uniform1f(yc, xc);
                        break;

                      case "v2":
                        Eb.uniform2f(yc, xc.x, xc.y);
                        break;

                      case "v3":
                        Eb.uniform3f(yc, xc.x, xc.y, xc.z);
                        break;

                      case "v4":
                        Eb.uniform4f(yc, xc.x, xc.y, xc.z, xc.w);
                        break;

                      case "c":
                        Eb.uniform3f(yc, xc.r, xc.g, xc.b);
                        break;

                      case "iv1":
                        Eb.uniform1iv(yc, xc);
                        break;

                      case "iv":
                        Eb.uniform3iv(yc, xc);
                        break;

                      case "fv1":
                        Eb.uniform1fv(yc, xc);
                        break;

                      case "fv":
                        Eb.uniform3fv(yc, xc);
                        break;

                      case "v2v":
                        void 0 === vc._array && (vc._array = new Float32Array(2 * xc.length));
                        for (var zc = 0, Ac = xc.length; Ac > zc; zc++) rc = 2 * zc, vc._array[rc] = xc[zc].x, 
                        vc._array[rc + 1] = xc[zc].y;
                        Eb.uniform2fv(yc, vc._array);
                        break;

                      case "v3v":
                        for (void 0 === vc._array && (vc._array = new Float32Array(3 * xc.length)), zc = 0, 
                        Ac = xc.length; Ac > zc; zc++) rc = 3 * zc, vc._array[rc] = xc[zc].x, vc._array[rc + 1] = xc[zc].y, 
                        vc._array[rc + 2] = xc[zc].z;
                        Eb.uniform3fv(yc, vc._array);
                        break;

                      case "v4v":
                        for (void 0 === vc._array && (vc._array = new Float32Array(4 * xc.length)), zc = 0, 
                        Ac = xc.length; Ac > zc; zc++) rc = 4 * zc, vc._array[rc] = xc[zc].x, vc._array[rc + 1] = xc[zc].y, 
                        vc._array[rc + 2] = xc[zc].z, vc._array[rc + 3] = xc[zc].w;
                        Eb.uniform4fv(yc, vc._array);
                        break;

                      case "m3":
                        Eb.uniformMatrix3fv(yc, !1, xc.elements);
                        break;

                      case "m3v":
                        for (void 0 === vc._array && (vc._array = new Float32Array(9 * xc.length)), zc = 0, 
                        Ac = xc.length; Ac > zc; zc++) xc[zc].flattenToArrayOffset(vc._array, 9 * zc);
                        Eb.uniformMatrix3fv(yc, !1, vc._array);
                        break;

                      case "m4":
                        Eb.uniformMatrix4fv(yc, !1, xc.elements);
                        break;

                      case "m4v":
                        for (void 0 === vc._array && (vc._array = new Float32Array(16 * xc.length)), zc = 0, 
                        Ac = xc.length; Ac > zc; zc++) xc[zc].flattenToArrayOffset(vc._array, 16 * zc);
                        Eb.uniformMatrix4fv(yc, !1, vc._array);
                        break;

                      case "t":
                        if (pc = xc, qc = w(), Eb.uniform1i(yc, qc), !pc) continue;
                        if (pc instanceof THREE.CubeTexture || pc.image instanceof Array && 6 === pc.image.length) {
                            var Bc = pc, Cc = qc;
                            if (6 === Bc.image.length) if (Bc.needsUpdate) {
                                Bc.image.__webglTextureCube || (Bc.addEventListener("dispose", ec), Bc.image.__webglTextureCube = Eb.createTexture(), 
                                ab.info.memory.textures++), Eb.activeTexture(Eb.TEXTURE0 + Cc), Eb.bindTexture(Eb.TEXTURE_CUBE_MAP, Bc.image.__webglTextureCube), 
                                Eb.pixelStorei(Eb.UNPACK_FLIP_Y_WEBGL, Bc.flipY);
                                for (var Dc = Bc instanceof THREE.CompressedTexture, Ec = Bc.image[0] instanceof THREE.DataTexture, Fc = [], Gc = 0; 6 > Gc; Gc++) Fc[Gc] = !ab.autoScaleCubemaps || Dc || Ec ? Ec ? Bc.image[Gc].image : Bc.image[Gc] : D(Bc.image[Gc], Rb);
                                var Hc = Fc[0], Ic = THREE.Math.isPowerOfTwo(Hc.width) && THREE.Math.isPowerOfTwo(Hc.height), Jc = H(Bc.format), Kc = H(Bc.type);
                                for (C(Eb.TEXTURE_CUBE_MAP, Bc, Ic), Gc = 0; 6 > Gc; Gc++) if (Dc) for (var Lc, Mc = Fc[Gc].mipmaps, Nc = 0, Oc = Mc.length; Oc > Nc; Nc++) Lc = Mc[Nc], 
                                Bc.format !== THREE.RGBAFormat && Bc.format !== THREE.RGBFormat ? -1 < Yb().indexOf(Jc) ? Eb.compressedTexImage2D(Eb.TEXTURE_CUBE_MAP_POSITIVE_X + Gc, Nc, Jc, Lc.width, Lc.height, 0, Lc.data) : console.warn("Attempt to load unsupported compressed texture format") : Eb.texImage2D(Eb.TEXTURE_CUBE_MAP_POSITIVE_X + Gc, Nc, Jc, Lc.width, Lc.height, 0, Jc, Kc, Lc.data); else Ec ? Eb.texImage2D(Eb.TEXTURE_CUBE_MAP_POSITIVE_X + Gc, 0, Jc, Fc[Gc].width, Fc[Gc].height, 0, Jc, Kc, Fc[Gc].data) : Eb.texImage2D(Eb.TEXTURE_CUBE_MAP_POSITIVE_X + Gc, 0, Jc, Jc, Kc, Fc[Gc]);
                                Bc.generateMipmaps && Ic && Eb.generateMipmap(Eb.TEXTURE_CUBE_MAP), Bc.needsUpdate = !1, 
                                Bc.onUpdate && Bc.onUpdate();
                            } else Eb.activeTexture(Eb.TEXTURE0 + Cc), Eb.bindTexture(Eb.TEXTURE_CUBE_MAP, Bc.image.__webglTextureCube);
                        } else if (pc instanceof THREE.WebGLRenderTargetCube) {
                            var Pc = pc;
                            Eb.activeTexture(Eb.TEXTURE0 + qc), Eb.bindTexture(Eb.TEXTURE_CUBE_MAP, Pc.__webglTexture);
                        } else ab.setTexture(pc, qc);
                        break;

                      case "tv":
                        for (void 0 === vc._array && (vc._array = []), zc = 0, Ac = vc.value.length; Ac > zc; zc++) vc._array[zc] = w();
                        for (Eb.uniform1iv(yc, vc._array), zc = 0, Ac = vc.value.length; Ac > zc; zc++) pc = vc.value[zc], 
                        qc = vc._array[zc], pc && ab.setTexture(pc, qc);
                        break;

                      default:
                        console.warn("THREE.WebGLRenderer: Unknown uniform type: " + wc);
                    }
                }
            }
        }
        return Eb.uniformMatrix4fv(db.modelViewMatrix, !1, e._modelViewMatrix.elements), 
        db.normalMatrix && Eb.uniformMatrix3fv(db.normalMatrix, !1, e._normalMatrix.elements), 
        null !== db.modelMatrix && Eb.uniformMatrix4fv(db.modelMatrix, !1, e.matrixWorld.elements), 
        _;
    }
    function v(a, b) {
        a.ambientLightColor.needsUpdate = b, a.directionalLightColor.needsUpdate = b, a.directionalLightDirection.needsUpdate = b, 
        a.pointLightColor.needsUpdate = b, a.pointLightPosition.needsUpdate = b, a.pointLightDistance.needsUpdate = b, 
        a.spotLightColor.needsUpdate = b, a.spotLightPosition.needsUpdate = b, a.spotLightDistance.needsUpdate = b, 
        a.spotLightDirection.needsUpdate = b, a.spotLightAngleCos.needsUpdate = b, a.spotLightExponent.needsUpdate = b, 
        a.hemisphereLightSkyColor.needsUpdate = b, a.hemisphereLightGroundColor.needsUpdate = b, 
        a.hemisphereLightDirection.needsUpdate = b;
    }
    function w() {
        var a = hb;
        return a >= Ob && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + Ob), 
        hb += 1, a;
    }
    function x(a, b) {
        a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, a.matrixWorld), a._normalMatrix.getNormalMatrix(a._modelViewMatrix);
    }
    function y(a, b, c, d) {
        a[b] = c.r * c.r * d, a[b + 1] = c.g * c.g * d, a[b + 2] = c.b * c.b * d;
    }
    function z(a, b, c, d) {
        a[b] = c.r * d, a[b + 1] = c.g * d, a[b + 2] = c.b * d;
    }
    function A(a) {
        a *= K, a !== tb && (Eb.lineWidth(a), tb = a);
    }
    function B(a, b, c) {
        qb !== a && (a ? Eb.enable(Eb.POLYGON_OFFSET_FILL) : Eb.disable(Eb.POLYGON_OFFSET_FILL), 
        qb = a), !a || rb === b && sb === c || (Eb.polygonOffset(b, c), rb = b, sb = c);
    }
    function C(a, b, c) {
        c ? (Eb.texParameteri(a, Eb.TEXTURE_WRAP_S, H(b.wrapS)), Eb.texParameteri(a, Eb.TEXTURE_WRAP_T, H(b.wrapT)), 
        Eb.texParameteri(a, Eb.TEXTURE_MAG_FILTER, H(b.magFilter)), Eb.texParameteri(a, Eb.TEXTURE_MIN_FILTER, H(b.minFilter))) : (Eb.texParameteri(a, Eb.TEXTURE_WRAP_S, Eb.CLAMP_TO_EDGE), 
        Eb.texParameteri(a, Eb.TEXTURE_WRAP_T, Eb.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT is set to THREE.ClampToEdgeWrapping. ( " + b.sourceFile + " )"), 
        Eb.texParameteri(a, Eb.TEXTURE_MAG_FILTER, G(b.magFilter)), Eb.texParameteri(a, Eb.TEXTURE_MIN_FILTER, G(b.minFilter)), 
        b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter is set to THREE.LinearFilter or THREE.NearestFilter. ( " + b.sourceFile + " )")), 
        (c = Lb.get("EXT_texture_filter_anisotropic")) && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) && (Eb.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, ab.getMaxAnisotropy())), 
        b.__oldAnisotropy = b.anisotropy);
    }
    function D(a, b) {
        if (a.width > b || a.height > b) {
            var c = b / Math.max(a.width, a.height), d = document.createElement("canvas");
            return d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c), d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), 
            console.log("THREE.WebGLRenderer:", a, "is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height + "."), 
            d;
        }
        return a;
    }
    function E(a, b) {
        Eb.bindRenderbuffer(Eb.RENDERBUFFER, a), b.depthBuffer && !b.stencilBuffer ? (Eb.renderbufferStorage(Eb.RENDERBUFFER, Eb.DEPTH_COMPONENT16, b.width, b.height), 
        Eb.framebufferRenderbuffer(Eb.FRAMEBUFFER, Eb.DEPTH_ATTACHMENT, Eb.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (Eb.renderbufferStorage(Eb.RENDERBUFFER, Eb.DEPTH_STENCIL, b.width, b.height), 
        Eb.framebufferRenderbuffer(Eb.FRAMEBUFFER, Eb.DEPTH_STENCIL_ATTACHMENT, Eb.RENDERBUFFER, a)) : Eb.renderbufferStorage(Eb.RENDERBUFFER, Eb.RGBA4, b.width, b.height);
    }
    function F(a) {
        a instanceof THREE.WebGLRenderTargetCube ? (Eb.bindTexture(Eb.TEXTURE_CUBE_MAP, a.__webglTexture), 
        Eb.generateMipmap(Eb.TEXTURE_CUBE_MAP), Eb.bindTexture(Eb.TEXTURE_CUBE_MAP, null)) : (Eb.bindTexture(Eb.TEXTURE_2D, a.__webglTexture), 
        Eb.generateMipmap(Eb.TEXTURE_2D), Eb.bindTexture(Eb.TEXTURE_2D, null));
    }
    function G(a) {
        return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? Eb.NEAREST : Eb.LINEAR;
    }
    function H(a) {
        var b;
        if (a === THREE.RepeatWrapping) return Eb.REPEAT;
        if (a === THREE.ClampToEdgeWrapping) return Eb.CLAMP_TO_EDGE;
        if (a === THREE.MirroredRepeatWrapping) return Eb.MIRRORED_REPEAT;
        if (a === THREE.NearestFilter) return Eb.NEAREST;
        if (a === THREE.NearestMipMapNearestFilter) return Eb.NEAREST_MIPMAP_NEAREST;
        if (a === THREE.NearestMipMapLinearFilter) return Eb.NEAREST_MIPMAP_LINEAR;
        if (a === THREE.LinearFilter) return Eb.LINEAR;
        if (a === THREE.LinearMipMapNearestFilter) return Eb.LINEAR_MIPMAP_NEAREST;
        if (a === THREE.LinearMipMapLinearFilter) return Eb.LINEAR_MIPMAP_LINEAR;
        if (a === THREE.UnsignedByteType) return Eb.UNSIGNED_BYTE;
        if (a === THREE.UnsignedShort4444Type) return Eb.UNSIGNED_SHORT_4_4_4_4;
        if (a === THREE.UnsignedShort5551Type) return Eb.UNSIGNED_SHORT_5_5_5_1;
        if (a === THREE.UnsignedShort565Type) return Eb.UNSIGNED_SHORT_5_6_5;
        if (a === THREE.ByteType) return Eb.BYTE;
        if (a === THREE.ShortType) return Eb.SHORT;
        if (a === THREE.UnsignedShortType) return Eb.UNSIGNED_SHORT;
        if (a === THREE.IntType) return Eb.INT;
        if (a === THREE.UnsignedIntType) return Eb.UNSIGNED_INT;
        if (a === THREE.FloatType) return Eb.FLOAT;
        if (a === THREE.AlphaFormat) return Eb.ALPHA;
        if (a === THREE.RGBFormat) return Eb.RGB;
        if (a === THREE.RGBAFormat) return Eb.RGBA;
        if (a === THREE.LuminanceFormat) return Eb.LUMINANCE;
        if (a === THREE.LuminanceAlphaFormat) return Eb.LUMINANCE_ALPHA;
        if (a === THREE.AddEquation) return Eb.FUNC_ADD;
        if (a === THREE.SubtractEquation) return Eb.FUNC_SUBTRACT;
        if (a === THREE.ReverseSubtractEquation) return Eb.FUNC_REVERSE_SUBTRACT;
        if (a === THREE.ZeroFactor) return Eb.ZERO;
        if (a === THREE.OneFactor) return Eb.ONE;
        if (a === THREE.SrcColorFactor) return Eb.SRC_COLOR;
        if (a === THREE.OneMinusSrcColorFactor) return Eb.ONE_MINUS_SRC_COLOR;
        if (a === THREE.SrcAlphaFactor) return Eb.SRC_ALPHA;
        if (a === THREE.OneMinusSrcAlphaFactor) return Eb.ONE_MINUS_SRC_ALPHA;
        if (a === THREE.DstAlphaFactor) return Eb.DST_ALPHA;
        if (a === THREE.OneMinusDstAlphaFactor) return Eb.ONE_MINUS_DST_ALPHA;
        if (a === THREE.DstColorFactor) return Eb.DST_COLOR;
        if (a === THREE.OneMinusDstColorFactor) return Eb.ONE_MINUS_DST_COLOR;
        if (a === THREE.SrcAlphaSaturateFactor) return Eb.SRC_ALPHA_SATURATE;
        if (b = Lb.get("WEBGL_compressed_texture_s3tc"), null !== b) {
            if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (b = Lb.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
            if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (b = Lb.get("EXT_blend_minmax"), null !== b) {
            if (a === THREE.MinEquation) return b.MIN_EXT;
            if (a === THREE.MaxEquation) return b.MAX_EXT;
        }
        return 0;
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION), a = a || {};
    var I = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"), J = void 0 !== a.context ? a.context : null, K = 1, L = void 0 !== a.precision ? a.precision : "highp", M = void 0 !== a.alpha ? a.alpha : !1, N = void 0 !== a.depth ? a.depth : !0, O = void 0 !== a.stencil ? a.stencil : !0, P = void 0 !== a.antialias ? a.antialias : !1, Q = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, R = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, S = void 0 !== a.logarithmicDepthBuffer ? a.logarithmicDepthBuffer : !1, T = new THREE.Color(0), U = 0, V = [], W = {}, X = [], Y = [], Z = [], $ = [], _ = [];
    this.domElement = I, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, 
    this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1, this.shadowMapType = THREE.PCFShadowMap, 
    this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapCascade = this.shadowMapDebug = !1, 
    this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, 
    this.info = {
        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },
        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }
    };
    var ab = this, bb = [], cb = null, db = null, eb = -1, fb = "", gb = null, hb = 0, ib = -1, jb = -1, kb = -1, lb = -1, mb = -1, nb = -1, ob = -1, pb = -1, qb = null, rb = null, sb = null, tb = null, ub = 0, vb = 0, wb = I.width, xb = I.height, yb = 0, zb = 0, Ab = new Uint8Array(16), Bb = new Uint8Array(16), Cb = new THREE.Frustum(), Db = new THREE.Matrix4();
    new THREE.Matrix4();
    var Eb, Fb = new THREE.Vector3(), Gb = new THREE.Vector3(), Hb = !0, Ib = {
        ambient: [ 0, 0, 0 ],
        directional: {
            length: 0,
            colors: [],
            positions: []
        },
        point: {
            length: 0,
            colors: [],
            positions: [],
            distances: []
        },
        spot: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            directions: [],
            anglesCos: [],
            exponents: []
        },
        hemi: {
            length: 0,
            skyColors: [],
            groundColors: [],
            positions: []
        }
    };
    try {
        var Jb = {
            alpha: M,
            depth: N,
            stencil: O,
            antialias: P,
            premultipliedAlpha: Q,
            preserveDrawingBuffer: R
        };
        if (Eb = J || I.getContext("webgl", Jb) || I.getContext("experimental-webgl", Jb), 
        null === Eb) {
            if (null !== I.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
            throw "Error creating WebGL context.";
        }
        I.addEventListener("webglcontextlost", function(a) {
            a.preventDefault(), Nb(), Mb(), W = {};
        }, !1);
    } catch (Kb) {
        console.error(Kb);
    }
    void 0 === Eb.getShaderPrecisionFormat && (Eb.getShaderPrecisionFormat = function() {
        return {
            rangeMin: 1,
            rangeMax: 1,
            precision: 1
        };
    });
    var Lb = new THREE.WebGLExtensions(Eb);
    Lb.get("OES_texture_float"), Lb.get("OES_texture_float_linear"), Lb.get("OES_standard_derivatives"), 
    S && Lb.get("EXT_frag_depth");
    var Mb = function() {
        Eb.clearColor(0, 0, 0, 1), Eb.clearDepth(1), Eb.clearStencil(0), Eb.enable(Eb.DEPTH_TEST), 
        Eb.depthFunc(Eb.LEQUAL), Eb.frontFace(Eb.CCW), Eb.cullFace(Eb.BACK), Eb.enable(Eb.CULL_FACE), 
        Eb.enable(Eb.BLEND), Eb.blendEquation(Eb.FUNC_ADD), Eb.blendFunc(Eb.SRC_ALPHA, Eb.ONE_MINUS_SRC_ALPHA), 
        Eb.viewport(ub, vb, wb, xb), Eb.clearColor(T.r, T.g, T.b, U);
    }, Nb = function() {
        gb = cb = null, jb = ib = pb = ob = kb = -1, fb = "", eb = -1, Hb = !0;
        for (var a = 0; a < Bb.length; a++) Bb[a] = 0;
    };
    Mb(), this.context = Eb;
    var Ob = Eb.getParameter(Eb.MAX_TEXTURE_IMAGE_UNITS), Pb = Eb.getParameter(Eb.MAX_VERTEX_TEXTURE_IMAGE_UNITS), Qb = Eb.getParameter(Eb.MAX_TEXTURE_SIZE), Rb = Eb.getParameter(Eb.MAX_CUBE_MAP_TEXTURE_SIZE), Sb = Pb > 0, Tb = Sb && Lb.get("OES_texture_float"), Ub = Eb.getShaderPrecisionFormat(Eb.VERTEX_SHADER, Eb.HIGH_FLOAT), Vb = Eb.getShaderPrecisionFormat(Eb.VERTEX_SHADER, Eb.MEDIUM_FLOAT);
    Eb.getShaderPrecisionFormat(Eb.VERTEX_SHADER, Eb.LOW_FLOAT);
    var Wb = Eb.getShaderPrecisionFormat(Eb.FRAGMENT_SHADER, Eb.HIGH_FLOAT), Xb = Eb.getShaderPrecisionFormat(Eb.FRAGMENT_SHADER, Eb.MEDIUM_FLOAT);
    Eb.getShaderPrecisionFormat(Eb.FRAGMENT_SHADER, Eb.LOW_FLOAT);
    var Yb = function() {
        var a;
        return function() {
            if (void 0 !== a) return a;
            if (a = [], Lb.get("WEBGL_compressed_texture_pvrtc") || Lb.get("WEBGL_compressed_texture_s3tc")) for (var b = Eb.getParameter(Eb.COMPRESSED_TEXTURE_FORMATS), c = 0; c < b.length; c++) a.push(b[c]);
            return a;
        };
    }(), Zb = 0 < Ub.precision && 0 < Wb.precision, $b = 0 < Vb.precision && 0 < Xb.precision;
    "highp" !== L || Zb || ($b ? (L = "mediump", console.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (L = "lowp", 
    console.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), 
    "mediump" !== L || $b || (L = "lowp", console.warn("THREE.WebGLRenderer: mediump not supported, using lowp."));
    var _b = new THREE.ShadowMapPlugin(this, V, W, X), ac = new THREE.SpritePlugin(this, $), bc = new THREE.LensFlarePlugin(this, _);
    this.getContext = function() {
        return Eb;
    }, this.forceContextLoss = function() {
        Lb.get("WEBGL_lose_context").loseContext();
    }, this.supportsVertexTextures = function() {
        return Sb;
    }, this.supportsFloatTextures = function() {
        return Lb.get("OES_texture_float");
    }, this.supportsStandardDerivatives = function() {
        return Lb.get("OES_standard_derivatives");
    }, this.supportsCompressedTextureS3TC = function() {
        return Lb.get("WEBGL_compressed_texture_s3tc");
    }, this.supportsCompressedTexturePVRTC = function() {
        return Lb.get("WEBGL_compressed_texture_pvrtc");
    }, this.supportsBlendMinMax = function() {
        return Lb.get("EXT_blend_minmax");
    }, this.getMaxAnisotropy = function() {
        var a;
        return function() {
            if (void 0 !== a) return a;
            var b = Lb.get("EXT_texture_filter_anisotropic");
            return a = null !== b ? Eb.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        };
    }(), this.getPrecision = function() {
        return L;
    }, this.getPixelRatio = function() {
        return K;
    }, this.setPixelRatio = function(a) {
        K = a;
    }, this.setSize = function(a, b, c) {
        I.width = a * K, I.height = b * K, !1 !== c && (I.style.width = a + "px", I.style.height = b + "px"), 
        this.setViewport(0, 0, a, b);
    }, this.setViewport = function(a, b, c, d) {
        ub = a * K, vb = b * K, wb = c * K, xb = d * K, Eb.viewport(ub, vb, wb, xb);
    }, this.setScissor = function(a, b, c, d) {
        Eb.scissor(a * K, b * K, c * K, d * K);
    }, this.enableScissorTest = function(a) {
        a ? Eb.enable(Eb.SCISSOR_TEST) : Eb.disable(Eb.SCISSOR_TEST);
    }, this.getClearColor = function() {
        return T;
    }, this.setClearColor = function(a, b) {
        T.set(a), U = void 0 !== b ? b : 1, Eb.clearColor(T.r, T.g, T.b, U);
    }, this.getClearAlpha = function() {
        return U;
    }, this.setClearAlpha = function(a) {
        U = a, Eb.clearColor(T.r, T.g, T.b, U);
    }, this.clear = function(a, b, c) {
        var d = 0;
        (void 0 === a || a) && (d |= Eb.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= Eb.DEPTH_BUFFER_BIT), 
        (void 0 === c || c) && (d |= Eb.STENCIL_BUFFER_BIT), Eb.clear(d);
    }, this.clearColor = function() {
        Eb.clear(Eb.COLOR_BUFFER_BIT);
    }, this.clearDepth = function() {
        Eb.clear(Eb.DEPTH_BUFFER_BIT);
    }, this.clearStencil = function() {
        Eb.clear(Eb.STENCIL_BUFFER_BIT);
    }, this.clearTarget = function(a, b, c, d) {
        this.setRenderTarget(a), this.clear(b, c, d);
    }, this.resetGLState = Nb;
    var cc = function(a) {
        a.target.traverse(function(a) {
            if (a.removeEventListener("remove", cc), a instanceof THREE.Mesh || a instanceof THREE.PointCloud || a instanceof THREE.Line) delete W[a.id]; else if (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) for (var b = X, c = b.length - 1; c >= 0; c--) b[c].object === a && b.splice(c, 1);
            delete a.__webglInit, delete a._modelViewMatrix, delete a._normalMatrix, delete a.__webglActive;
        });
    }, dc = function(a) {
        if (a = a.target, a.removeEventListener("dispose", dc), delete a.__webglInit, a instanceof THREE.BufferGeometry) {
            for (var b in a.attributes) {
                var c = a.attributes[b];
                void 0 !== c.buffer && (Eb.deleteBuffer(c.buffer), delete c.buffer);
            }
            ab.info.memory.geometries--;
        } else if (b = jc[a.id], void 0 !== b) {
            for (var c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                if (void 0 !== e.numMorphTargets) {
                    for (var f = 0, g = e.numMorphTargets; g > f; f++) Eb.deleteBuffer(e.__webglMorphTargetsBuffers[f]);
                    delete e.__webglMorphTargetsBuffers;
                }
                if (void 0 !== e.numMorphNormals) {
                    for (f = 0, g = e.numMorphNormals; g > f; f++) Eb.deleteBuffer(e.__webglMorphNormalsBuffers[f]);
                    delete e.__webglMorphNormalsBuffers;
                }
                hc(e);
            }
            delete jc[a.id];
        } else hc(a);
        fb = "";
    }, ec = function(a) {
        a = a.target, a.removeEventListener("dispose", ec), a.image && a.image.__webglTextureCube ? (Eb.deleteTexture(a.image.__webglTextureCube), 
        delete a.image.__webglTextureCube) : void 0 !== a.__webglInit && (Eb.deleteTexture(a.__webglTexture), 
        delete a.__webglTexture, delete a.__webglInit), ab.info.memory.textures--;
    }, fc = function(a) {
        if (a = a.target, a.removeEventListener("dispose", fc), a && void 0 !== a.__webglTexture) {
            if (Eb.deleteTexture(a.__webglTexture), delete a.__webglTexture, a instanceof THREE.WebGLRenderTargetCube) for (var b = 0; 6 > b; b++) Eb.deleteFramebuffer(a.__webglFramebuffer[b]), 
            Eb.deleteRenderbuffer(a.__webglRenderbuffer[b]); else Eb.deleteFramebuffer(a.__webglFramebuffer), 
            Eb.deleteRenderbuffer(a.__webglRenderbuffer);
            delete a.__webglFramebuffer, delete a.__webglRenderbuffer;
        }
        ab.info.memory.textures--;
    }, gc = function(a) {
        a = a.target, a.removeEventListener("dispose", gc), ic(a);
    }, hc = function(a) {
        for (var b = "__webglVertexBuffer __webglNormalBuffer __webglTangentBuffer __webglColorBuffer __webglUVBuffer __webglUV2Buffer __webglSkinIndicesBuffer __webglSkinWeightsBuffer __webglFaceBuffer __webglLineBuffer __webglLineDistanceBuffer".split(" "), c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            void 0 !== a[e] && (Eb.deleteBuffer(a[e]), delete a[e]);
        }
        if (void 0 !== a.__webglCustomAttributesList) {
            for (e in a.__webglCustomAttributesList) Eb.deleteBuffer(a.__webglCustomAttributesList[e].buffer);
            delete a.__webglCustomAttributesList;
        }
        ab.info.memory.geometries--;
    }, ic = function(a) {
        var b = a.program.program;
        if (void 0 !== b) {
            a.program = void 0;
            var c, d, e = !1;
            for (a = 0, c = bb.length; c > a; a++) if (d = bb[a], d.program === b) {
                d.usedTimes--, 0 === d.usedTimes && (e = !0);
                break;
            }
            if (!0 === e) {
                for (e = [], a = 0, c = bb.length; c > a; a++) d = bb[a], d.program !== b && e.push(d);
                bb = e, Eb.deleteProgram(b), ab.info.memory.programs--;
            }
        }
    };
    this.renderBufferImmediate = function(a, b, c) {
        if (f(), a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = Eb.createBuffer()), 
        a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = Eb.createBuffer()), 
        a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = Eb.createBuffer()), a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = Eb.createBuffer()), 
        a.hasPositions && (Eb.bindBuffer(Eb.ARRAY_BUFFER, a.__webglVertexBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, a.positionArray, Eb.DYNAMIC_DRAW), 
        g(b.attributes.position), Eb.vertexAttribPointer(b.attributes.position, 3, Eb.FLOAT, !1, 0, 0)), 
        a.hasNormals) {
            if (Eb.bindBuffer(Eb.ARRAY_BUFFER, a.__webglNormalBuffer), c.shading === THREE.FlatShading) {
                var d, e, i, j, k, l, m, n, o, p, q, r = 3 * a.count;
                for (q = 0; r > q; q += 9) p = a.normalArray, d = p[q], e = p[q + 1], i = p[q + 2], 
                j = p[q + 3], l = p[q + 4], n = p[q + 5], k = p[q + 6], m = p[q + 7], o = p[q + 8], 
                d = (d + j + k) / 3, e = (e + l + m) / 3, i = (i + n + o) / 3, p[q] = d, p[q + 1] = e, 
                p[q + 2] = i, p[q + 3] = d, p[q + 4] = e, p[q + 5] = i, p[q + 6] = d, p[q + 7] = e, 
                p[q + 8] = i;
            }
            Eb.bufferData(Eb.ARRAY_BUFFER, a.normalArray, Eb.DYNAMIC_DRAW), g(b.attributes.normal), 
            Eb.vertexAttribPointer(b.attributes.normal, 3, Eb.FLOAT, !1, 0, 0);
        }
        a.hasUvs && c.map && (Eb.bindBuffer(Eb.ARRAY_BUFFER, a.__webglUvBuffer), Eb.bufferData(Eb.ARRAY_BUFFER, a.uvArray, Eb.DYNAMIC_DRAW), 
        g(b.attributes.uv), Eb.vertexAttribPointer(b.attributes.uv, 2, Eb.FLOAT, !1, 0, 0)), 
        a.hasColors && c.vertexColors !== THREE.NoColors && (Eb.bindBuffer(Eb.ARRAY_BUFFER, a.__webglColorBuffer), 
        Eb.bufferData(Eb.ARRAY_BUFFER, a.colorArray, Eb.DYNAMIC_DRAW), g(b.attributes.color), 
        Eb.vertexAttribPointer(b.attributes.color, 3, Eb.FLOAT, !1, 0, 0)), h(), Eb.drawArrays(Eb.TRIANGLES, 0, a.count), 
        a.count = 0;
    }, this.renderBufferDirect = function(a, b, c, d, g, h) {
        if (!1 !== d.visible) if (r(h), a = u(a, b, c, d, h), b = !1, c = "direct_" + g.id + "_" + a.id + "_" + (d.wireframe ? 1 : 0), 
        c !== fb && (fb = c, b = !0), b && f(), h instanceof THREE.Mesh) {
            h = !0 === d.wireframe ? Eb.LINES : Eb.TRIANGLES;
            var i = g.attributes.index;
            if (i) {
                var j, k;
                if (i.array instanceof Uint32Array && Lb.get("OES_element_index_uint") ? (j = Eb.UNSIGNED_INT, 
                k = 4) : (j = Eb.UNSIGNED_SHORT, k = 2), c = g.offsets, 0 === c.length) b && (e(d, a, g, 0), 
                Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, i.buffer)), Eb.drawElements(h, i.array.length, j, 0), 
                ab.info.render.calls++, ab.info.render.vertices += i.array.length, ab.info.render.faces += i.array.length / 3; else {
                    b = !0;
                    for (var l = 0, m = c.length; m > l; l++) {
                        var n = c[l].index;
                        b && (e(d, a, g, n), Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, i.buffer)), Eb.drawElements(h, c[l].count, j, c[l].start * k), 
                        ab.info.render.calls++, ab.info.render.vertices += c[l].count, ab.info.render.faces += c[l].count / 3;
                    }
                }
            } else b && e(d, a, g, 0), d = g.attributes.position, Eb.drawArrays(h, 0, d.array.length / 3), 
            ab.info.render.calls++, ab.info.render.vertices += d.array.length / 3, ab.info.render.faces += d.array.length / 9;
        } else if (h instanceof THREE.PointCloud) if (h = Eb.POINTS, i = g.attributes.index) if (i.array instanceof Uint32Array && Lb.get("OES_element_index_uint") ? (j = Eb.UNSIGNED_INT, 
        k = 4) : (j = Eb.UNSIGNED_SHORT, k = 2), c = g.offsets, 0 === c.length) b && (e(d, a, g, 0), 
        Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, i.buffer)), Eb.drawElements(h, i.array.length, j, 0), 
        ab.info.render.calls++, ab.info.render.points += i.array.length; else for (1 < c.length && (b = !0), 
        l = 0, m = c.length; m > l; l++) n = c[l].index, b && (e(d, a, g, n), Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, i.buffer)), 
        Eb.drawElements(h, c[l].count, j, c[l].start * k), ab.info.render.calls++, ab.info.render.points += c[l].count; else if (b && e(d, a, g, 0), 
        d = g.attributes.position, c = g.offsets, 0 === c.length) Eb.drawArrays(h, 0, d.array.length / 3), 
        ab.info.render.calls++, ab.info.render.points += d.array.length / 3; else for (l = 0, 
        m = c.length; m > l; l++) Eb.drawArrays(h, c[l].index, c[l].count), ab.info.render.calls++, 
        ab.info.render.points += c[l].count; else if (h instanceof THREE.Line) if (h = h.mode === THREE.LineStrip ? Eb.LINE_STRIP : Eb.LINES, 
        A(d.linewidth), i = g.attributes.index) if (i.array instanceof Uint32Array ? (j = Eb.UNSIGNED_INT, 
        k = 4) : (j = Eb.UNSIGNED_SHORT, k = 2), c = g.offsets, 0 === c.length) b && (e(d, a, g, 0), 
        Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, i.buffer)), Eb.drawElements(h, i.array.length, j, 0), 
        ab.info.render.calls++, ab.info.render.vertices += i.array.length; else for (1 < c.length && (b = !0), 
        l = 0, m = c.length; m > l; l++) n = c[l].index, b && (e(d, a, g, n), Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, i.buffer)), 
        Eb.drawElements(h, c[l].count, j, c[l].start * k), ab.info.render.calls++, ab.info.render.vertices += c[l].count; else if (b && e(d, a, g, 0), 
        d = g.attributes.position, c = g.offsets, 0 === c.length) Eb.drawArrays(h, 0, d.array.length / 3), 
        ab.info.render.calls++, ab.info.render.vertices += d.array.length / 3; else for (l = 0, 
        m = c.length; m > l; l++) Eb.drawArrays(h, c[l].index, c[l].count), ab.info.render.calls++, 
        ab.info.render.vertices += c[l].count;
    }, this.renderBuffer = function(a, b, c, d, e, i) {
        if (!1 !== d.visible) {
            if (r(i), c = u(a, b, c, d, i), b = c.attributes, a = !1, c = e.id + "_" + c.id + "_" + (d.wireframe ? 1 : 0), 
            c !== fb && (fb = c, a = !0), a && f(), !d.morphTargets && 0 <= b.position) a && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglVertexBuffer), 
            g(b.position), Eb.vertexAttribPointer(b.position, 3, Eb.FLOAT, !1, 0, 0)); else if (i.morphTargetBase) {
                if (c = d.program.attributes, -1 !== i.morphTargetBase && 0 <= c.position ? (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[i.morphTargetBase]), 
                g(c.position), Eb.vertexAttribPointer(c.position, 3, Eb.FLOAT, !1, 0, 0)) : 0 <= c.position && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglVertexBuffer), 
                g(c.position), Eb.vertexAttribPointer(c.position, 3, Eb.FLOAT, !1, 0, 0)), i.morphTargetForcedOrder.length) for (var j, l = 0, m = i.morphTargetForcedOrder, n = i.morphTargetInfluences; l < d.numSupportedMorphTargets && l < m.length; ) j = c["morphTarget" + l], 
                j >= 0 && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[m[l]]), g(j), 
                Eb.vertexAttribPointer(j, 3, Eb.FLOAT, !1, 0, 0)), j = c["morphNormal" + l], j >= 0 && d.morphNormals && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[m[l]]), 
                g(j), Eb.vertexAttribPointer(j, 3, Eb.FLOAT, !1, 0, 0)), i.__webglMorphTargetInfluences[l] = n[m[l]], 
                l++; else {
                    for (m = [], n = i.morphTargetInfluences, l = 0, j = n.length; j > l; l++) m.push([ n[l], l ]);
                    m.length > d.numSupportedMorphTargets ? (m.sort(k), m.length = d.numSupportedMorphTargets) : m.length > d.numSupportedMorphNormals ? m.sort(k) : 0 === m.length && m.push([ 0, 0 ]);
                    for (var l = 0, o = d.numSupportedMorphTargets; o > l; l++) if (m[l]) {
                        var p = m[l][1];
                        j = c["morphTarget" + l], j >= 0 && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[p]), 
                        g(j), Eb.vertexAttribPointer(j, 3, Eb.FLOAT, !1, 0, 0)), j = c["morphNormal" + l], 
                        j >= 0 && d.morphNormals && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[p]), 
                        g(j), Eb.vertexAttribPointer(j, 3, Eb.FLOAT, !1, 0, 0)), i.__webglMorphTargetInfluences[l] = n[p];
                    } else i.__webglMorphTargetInfluences[l] = 0;
                }
                null !== d.program.uniforms.morphTargetInfluences && Eb.uniform1fv(d.program.uniforms.morphTargetInfluences, i.__webglMorphTargetInfluences);
            }
            if (a) {
                if (e.__webglCustomAttributesList) for (c = 0, n = e.__webglCustomAttributesList.length; n > c; c++) m = e.__webglCustomAttributesList[c], 
                0 <= b[m.buffer.belongsToAttribute] && (Eb.bindBuffer(Eb.ARRAY_BUFFER, m.buffer), 
                g(b[m.buffer.belongsToAttribute]), Eb.vertexAttribPointer(b[m.buffer.belongsToAttribute], m.size, Eb.FLOAT, !1, 0, 0));
                0 <= b.color && (0 < i.geometry.colors.length || 0 < i.geometry.faces.length ? (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglColorBuffer), 
                g(b.color), Eb.vertexAttribPointer(b.color, 3, Eb.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && Eb.vertexAttrib3fv(b.color, d.defaultAttributeValues.color)), 
                0 <= b.normal && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglNormalBuffer), g(b.normal), 
                Eb.vertexAttribPointer(b.normal, 3, Eb.FLOAT, !1, 0, 0)), 0 <= b.tangent && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglTangentBuffer), 
                g(b.tangent), Eb.vertexAttribPointer(b.tangent, 4, Eb.FLOAT, !1, 0, 0)), 0 <= b.uv && (i.geometry.faceVertexUvs[0] ? (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglUVBuffer), 
                g(b.uv), Eb.vertexAttribPointer(b.uv, 2, Eb.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && Eb.vertexAttrib2fv(b.uv, d.defaultAttributeValues.uv)), 
                0 <= b.uv2 && (i.geometry.faceVertexUvs[1] ? (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglUV2Buffer), 
                g(b.uv2), Eb.vertexAttribPointer(b.uv2, 2, Eb.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && Eb.vertexAttrib2fv(b.uv2, d.defaultAttributeValues.uv2)), 
                d.skinning && 0 <= b.skinIndex && 0 <= b.skinWeight && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), 
                g(b.skinIndex), Eb.vertexAttribPointer(b.skinIndex, 4, Eb.FLOAT, !1, 0, 0), Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), 
                g(b.skinWeight), Eb.vertexAttribPointer(b.skinWeight, 4, Eb.FLOAT, !1, 0, 0)), 0 <= b.lineDistance && (Eb.bindBuffer(Eb.ARRAY_BUFFER, e.__webglLineDistanceBuffer), 
                g(b.lineDistance), Eb.vertexAttribPointer(b.lineDistance, 1, Eb.FLOAT, !1, 0, 0));
            }
            h(), i instanceof THREE.Mesh ? (i = e.__typeArray === Uint32Array ? Eb.UNSIGNED_INT : Eb.UNSIGNED_SHORT, 
            d.wireframe ? (A(d.wireframeLinewidth), a && Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), 
            Eb.drawElements(Eb.LINES, e.__webglLineCount, i, 0)) : (a && Eb.bindBuffer(Eb.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), 
            Eb.drawElements(Eb.TRIANGLES, e.__webglFaceCount, i, 0)), ab.info.render.calls++, 
            ab.info.render.vertices += e.__webglFaceCount, ab.info.render.faces += e.__webglFaceCount / 3) : i instanceof THREE.Line ? (i = i.mode === THREE.LineStrip ? Eb.LINE_STRIP : Eb.LINES, 
            A(d.linewidth), Eb.drawArrays(i, 0, e.__webglLineCount), ab.info.render.calls++) : i instanceof THREE.PointCloud && (Eb.drawArrays(Eb.POINTS, 0, e.__webglParticleCount), 
            ab.info.render.calls++, ab.info.render.points += e.__webglParticleCount);
        }
    }, this.render = function(a, b, c, d) {
        if (!1 == b instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else {
            var e = a.fog;
            fb = "", eb = -1, gb = null, Hb = !0, !0 === a.autoUpdate && a.updateMatrixWorld(), 
            void 0 === b.parent && b.updateMatrixWorld(), a.traverse(function(a) {
                a instanceof THREE.SkinnedMesh && a.skeleton.update();
            }), b.matrixWorldInverse.getInverse(b.matrixWorld), Db.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), 
            Cb.setFromMatrix(Db), V.length = 0, Y.length = 0, Z.length = 0, $.length = 0, _.length = 0, 
            l(a), !0 === ab.sortObjects && (Y.sort(i), Z.sort(j)), _b.render(a, b), ab.info.render.calls = 0, 
            ab.info.render.vertices = 0, ab.info.render.faces = 0, ab.info.render.points = 0, 
            this.setRenderTarget(c), (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), 
            d = 0;
            for (var f = X.length; f > d; d++) {
                var g = X[d], h = g.object;
                h.visible && (x(h, b), o(g));
            }
            a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst), 
            this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), B(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), 
            m(Y, b, V, e, !0, d), m(Z, b, V, e, !0, d), n(X, "", b, V, e, !1, d)) : (d = null, 
            this.setBlending(THREE.NoBlending), m(Y, b, V, e, !1, d), n(X, "opaque", b, V, e, !1, d), 
            m(Z, b, V, e, !0, d), n(X, "transparent", b, V, e, !0, d)), ac.render(a, b), bc.render(a, b, yb, zb), 
            c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && F(c), 
            this.setDepthTest(!0), this.setDepthWrite(!0);
        }
    }, this.renderImmediateObject = function(a, b, c, d, e) {
        var f = u(a, b, c, d, e);
        fb = "", ab.setMaterialFaces(d), e.immediateRenderCallback ? e.immediateRenderCallback(f, Eb, Cb) : e.render(function(a) {
            ab.renderBufferImmediate(a, f, d);
        });
    };
    var jc = {}, kc = 0, lc = {
        MeshDepthMaterial: "depth",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointCloudMaterial: "particle_basic"
    };
    this.setFaceCulling = function(a, b) {
        a === THREE.CullFaceNone ? Eb.disable(Eb.CULL_FACE) : (Eb.frontFace(b === THREE.FrontFaceDirectionCW ? Eb.CW : Eb.CCW), 
        Eb.cullFace(a === THREE.CullFaceBack ? Eb.BACK : a === THREE.CullFaceFront ? Eb.FRONT : Eb.FRONT_AND_BACK), 
        Eb.enable(Eb.CULL_FACE));
    }, this.setMaterialFaces = function(a) {
        var b = a.side === THREE.DoubleSide;
        a = a.side === THREE.BackSide, ib !== b && (b ? Eb.disable(Eb.CULL_FACE) : Eb.enable(Eb.CULL_FACE), 
        ib = b), jb !== a && (Eb.frontFace(a ? Eb.CW : Eb.CCW), jb = a);
    }, this.setDepthTest = function(a) {
        ob !== a && (a ? Eb.enable(Eb.DEPTH_TEST) : Eb.disable(Eb.DEPTH_TEST), ob = a);
    }, this.setDepthWrite = function(a) {
        pb !== a && (Eb.depthMask(a), pb = a);
    }, this.setBlending = function(a, b, c, d) {
        a !== kb && (a === THREE.NoBlending ? Eb.disable(Eb.BLEND) : a === THREE.AdditiveBlending ? (Eb.enable(Eb.BLEND), 
        Eb.blendEquation(Eb.FUNC_ADD), Eb.blendFunc(Eb.SRC_ALPHA, Eb.ONE)) : a === THREE.SubtractiveBlending ? (Eb.enable(Eb.BLEND), 
        Eb.blendEquation(Eb.FUNC_ADD), Eb.blendFunc(Eb.ZERO, Eb.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (Eb.enable(Eb.BLEND), 
        Eb.blendEquation(Eb.FUNC_ADD), Eb.blendFunc(Eb.ZERO, Eb.SRC_COLOR)) : a === THREE.CustomBlending ? Eb.enable(Eb.BLEND) : (Eb.enable(Eb.BLEND), 
        Eb.blendEquationSeparate(Eb.FUNC_ADD, Eb.FUNC_ADD), Eb.blendFuncSeparate(Eb.SRC_ALPHA, Eb.ONE_MINUS_SRC_ALPHA, Eb.ONE, Eb.ONE_MINUS_SRC_ALPHA)), 
        kb = a), a === THREE.CustomBlending ? (b !== lb && (Eb.blendEquation(H(b)), lb = b), 
        (c !== mb || d !== nb) && (Eb.blendFunc(H(c), H(d)), mb = c, nb = d)) : nb = mb = lb = null;
    }, this.uploadTexture = function(a) {
        void 0 === a.__webglInit && (a.__webglInit = !0, a.addEventListener("dispose", ec), 
        a.__webglTexture = Eb.createTexture(), ab.info.memory.textures++), Eb.bindTexture(Eb.TEXTURE_2D, a.__webglTexture), 
        Eb.pixelStorei(Eb.UNPACK_FLIP_Y_WEBGL, a.flipY), Eb.pixelStorei(Eb.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), 
        Eb.pixelStorei(Eb.UNPACK_ALIGNMENT, a.unpackAlignment), a.image = D(a.image, Qb);
        var b = a.image, c = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height), d = H(a.format), e = H(a.type);
        C(Eb.TEXTURE_2D, a, c);
        var f = a.mipmaps;
        if (a instanceof THREE.DataTexture) if (0 < f.length && c) {
            for (var g = 0, h = f.length; h > g; g++) b = f[g], Eb.texImage2D(Eb.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data);
            a.generateMipmaps = !1;
        } else Eb.texImage2D(Eb.TEXTURE_2D, 0, d, b.width, b.height, 0, d, e, b.data); else if (a instanceof THREE.CompressedTexture) for (g = 0, 
        h = f.length; h > g; g++) b = f[g], a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? -1 < Yb().indexOf(d) ? Eb.compressedTexImage2D(Eb.TEXTURE_2D, g, d, b.width, b.height, 0, b.data) : console.warn("Attempt to load unsupported compressed texture format") : Eb.texImage2D(Eb.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data); else if (0 < f.length && c) {
            for (g = 0, h = f.length; h > g; g++) b = f[g], Eb.texImage2D(Eb.TEXTURE_2D, g, d, d, e, b);
            a.generateMipmaps = !1;
        } else Eb.texImage2D(Eb.TEXTURE_2D, 0, d, d, e, a.image);
        a.generateMipmaps && c && Eb.generateMipmap(Eb.TEXTURE_2D), a.needsUpdate = !1, 
        a.onUpdate && a.onUpdate();
    }, this.setTexture = function(a, b) {
        Eb.activeTexture(Eb.TEXTURE0 + b), a.needsUpdate ? ab.uploadTexture(a) : Eb.bindTexture(Eb.TEXTURE_2D, a.__webglTexture);
    }, this.setRenderTarget = function(a) {
        var b = a instanceof THREE.WebGLRenderTargetCube;
        if (a && void 0 === a.__webglFramebuffer) {
            void 0 === a.depthBuffer && (a.depthBuffer = !0), void 0 === a.stencilBuffer && (a.stencilBuffer = !0), 
            a.addEventListener("dispose", fc), a.__webglTexture = Eb.createTexture(), ab.info.memory.textures++;
            var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height), d = H(a.format), e = H(a.type);
            if (b) {
                a.__webglFramebuffer = [], a.__webglRenderbuffer = [], Eb.bindTexture(Eb.TEXTURE_CUBE_MAP, a.__webglTexture), 
                C(Eb.TEXTURE_CUBE_MAP, a, c);
                for (var f = 0; 6 > f; f++) {
                    a.__webglFramebuffer[f] = Eb.createFramebuffer(), a.__webglRenderbuffer[f] = Eb.createRenderbuffer(), 
                    Eb.texImage2D(Eb.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);
                    var g = a, h = Eb.TEXTURE_CUBE_MAP_POSITIVE_X + f;
                    Eb.bindFramebuffer(Eb.FRAMEBUFFER, a.__webglFramebuffer[f]), Eb.framebufferTexture2D(Eb.FRAMEBUFFER, Eb.COLOR_ATTACHMENT0, h, g.__webglTexture, 0), 
                    E(a.__webglRenderbuffer[f], a);
                }
                c && Eb.generateMipmap(Eb.TEXTURE_CUBE_MAP);
            } else a.__webglFramebuffer = Eb.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : Eb.createRenderbuffer(), 
            Eb.bindTexture(Eb.TEXTURE_2D, a.__webglTexture), C(Eb.TEXTURE_2D, a, c), Eb.texImage2D(Eb.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), 
            d = Eb.TEXTURE_2D, Eb.bindFramebuffer(Eb.FRAMEBUFFER, a.__webglFramebuffer), Eb.framebufferTexture2D(Eb.FRAMEBUFFER, Eb.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), 
            a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? Eb.framebufferRenderbuffer(Eb.FRAMEBUFFER, Eb.DEPTH_ATTACHMENT, Eb.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && Eb.framebufferRenderbuffer(Eb.FRAMEBUFFER, Eb.DEPTH_STENCIL_ATTACHMENT, Eb.RENDERBUFFER, a.__webglRenderbuffer) : E(a.__webglRenderbuffer, a), 
            c && Eb.generateMipmap(Eb.TEXTURE_2D);
            b ? Eb.bindTexture(Eb.TEXTURE_CUBE_MAP, null) : Eb.bindTexture(Eb.TEXTURE_2D, null), 
            Eb.bindRenderbuffer(Eb.RENDERBUFFER, null), Eb.bindFramebuffer(Eb.FRAMEBUFFER, null);
        }
        a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, 
        a = a.height, e = d = 0) : (b = null, c = wb, a = xb, d = ub, e = vb), b !== db && (Eb.bindFramebuffer(Eb.FRAMEBUFFER, b), 
        Eb.viewport(d, e, c, a), db = b), yb = c, zb = a;
    }, this.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    }, this.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    }, this.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    }, this.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    };
}, THREE.WebGLRenderTarget = function(a, b, c) {
    this.width = a, this.height = b, c = c || {}, this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping, 
    this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter, 
    this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter, 
    this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), 
    this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat, 
    this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType, this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0, 
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0, this.generateMipmaps = !0, 
    this.shareDepthFrom = null;
}, THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    setSize: function(a, b) {
        this.width = a, this.height = b;
    },
    clone: function() {
        var a = new THREE.WebGLRenderTarget(this.width, this.height);
        return a.wrapS = this.wrapS, a.wrapT = this.wrapT, a.magFilter = this.magFilter, 
        a.minFilter = this.minFilter, a.anisotropy = this.anisotropy, a.offset.copy(this.offset), 
        a.repeat.copy(this.repeat), a.format = this.format, a.type = this.type, a.depthBuffer = this.depthBuffer, 
        a.stencilBuffer = this.stencilBuffer, a.generateMipmaps = this.generateMipmaps, 
        a.shareDepthFrom = this.shareDepthFrom, a;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function(a, b, c) {
    THREE.WebGLRenderTarget.call(this, a, b, c), this.activeCubeFace = 0;
}, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), 
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube, 
THREE.WebGLExtensions = function(a) {
    var b = {};
    this.get = function(c) {
        if (void 0 !== b[c]) return b[c];
        var d;
        switch (c) {
          case "EXT_texture_filter_anisotropic":
            d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;

          case "WEBGL_compressed_texture_s3tc":
            d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;

          case "WEBGL_compressed_texture_pvrtc":
            d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;

          default:
            d = a.getExtension(c);
        }
        return null === d && console.log("THREE.WebGLRenderer: " + c + " extension not supported."), 
        b[c] = d;
    };
}, THREE.WebGLProgram = function() {
    var a = 0;
    return function(b, c, d, e) {
        var f = b.context, g = d.defines, h = d.__webglShader.uniforms, i = d.attributes, j = d.__webglShader.vertexShader, k = d.__webglShader.fragmentShader, l = d.index0AttributeName;
        void 0 === l && !0 === e.morphTargets && (l = "position");
        var m = "SHADOWMAP_TYPE_BASIC";
        e.shadowMapType === THREE.PCFShadowMap ? m = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === THREE.PCFSoftShadowMap && (m = "SHADOWMAP_TYPE_PCF_SOFT");
        var n = "ENVMAP_TYPE_CUBE", o = "ENVMAP_MODE_REFLECTION", p = "ENVMAP_BLENDING_MULTIPLY";
        if (e.envMap) {
            switch (d.envMap.mapping) {
              case THREE.CubeReflectionMapping:
              case THREE.CubeRefractionMapping:
                n = "ENVMAP_TYPE_CUBE";
                break;

              case THREE.EquirectangularReflectionMapping:
              case THREE.EquirectangularRefractionMapping:
                n = "ENVMAP_TYPE_EQUIREC";
                break;

              case THREE.SphericalReflectionMapping:
                n = "ENVMAP_TYPE_SPHERE";
            }
            switch (d.envMap.mapping) {
              case THREE.CubeRefractionMapping:
              case THREE.EquirectangularRefractionMapping:
                o = "ENVMAP_MODE_REFRACTION";
            }
            switch (d.combine) {
              case THREE.MultiplyOperation:
                p = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case THREE.MixOperation:
                p = "ENVMAP_BLENDING_MIX";
                break;

              case THREE.AddOperation:
                p = "ENVMAP_BLENDING_ADD";
            }
        }
        var q, r;
        q = [];
        for (var s in g) r = g[s], !1 !== r && (r = "#define " + s + " " + r, q.push(r));
        q = q.join("\n"), g = f.createProgram(), d instanceof THREE.RawShaderMaterial ? b = d = "" : (d = [ "precision " + e.precision + " float;", "precision " + e.precision + " int;", q, e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, "#define MAX_BONES " + e.maxBones, e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + o : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.skinning ? "#define USE_SKINNING" : "", e.useVertexTexture ? "#define BONE_TEXTURE" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals ? "#define USE_MORPHNORMALS" : "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + m : "", e.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n	attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n	attribute vec3 morphTarget0;\n	attribute vec3 morphTarget1;\n	attribute vec3 morphTarget2;\n	attribute vec3 morphTarget3;\n	#ifdef USE_MORPHNORMALS\n		attribute vec3 morphNormal0;\n		attribute vec3 morphNormal1;\n		attribute vec3 morphNormal2;\n		attribute vec3 morphNormal3;\n	#else\n		attribute vec3 morphTarget4;\n		attribute vec3 morphTarget5;\n		attribute vec3 morphTarget6;\n		attribute vec3 morphTarget7;\n	#endif\n#endif\n#ifdef USE_SKINNING\n	attribute vec4 skinIndex;\n	attribute vec4 skinWeight;\n#endif\n" ].join("\n"), 
        b = [ "precision " + e.precision + " float;", "precision " + e.precision + " int;", e.bumpMap || e.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", q, "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, e.alphaTest ? "#define ALPHATEST " + e.alphaTest : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + n : "", e.envMap ? "#define " + o : "", e.envMap ? "#define " + p : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.metal ? "#define METAL" : "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + m : "", e.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n" ].join("\n")), 
        j = new THREE.WebGLShader(f, f.VERTEX_SHADER, d + j), k = new THREE.WebGLShader(f, f.FRAGMENT_SHADER, b + k), 
        f.attachShader(g, j), f.attachShader(g, k), void 0 !== l && f.bindAttribLocation(g, 0, l), 
        f.linkProgram(g), !1 === f.getProgramParameter(g, f.LINK_STATUS) && (console.error("THREE.WebGLProgram: Could not initialise shader."), 
        console.error("gl.VALIDATE_STATUS", f.getProgramParameter(g, f.VALIDATE_STATUS)), 
        console.error("gl.getError()", f.getError())), "" !== f.getProgramInfoLog(g) && console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f.getProgramInfoLog(g)), 
        f.deleteShader(j), f.deleteShader(k), l = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" "), 
        e.useVertexTexture ? (l.push("boneTexture"), l.push("boneTextureWidth"), l.push("boneTextureHeight")) : l.push("boneGlobalMatrices"), 
        e.logarithmicDepthBuffer && l.push("logDepthBufFC");
        for (var t in h) l.push(t);
        for (h = l, t = {}, l = 0, b = h.length; b > l; l++) m = h[l], t[m] = f.getUniformLocation(g, m);
        for (this.uniforms = t, l = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" "), 
        h = 0; h < e.maxMorphTargets; h++) l.push("morphTarget" + h);
        for (h = 0; h < e.maxMorphNormals; h++) l.push("morphNormal" + h);
        for (var u in i) l.push(u);
        for (e = l, i = {}, u = 0, h = e.length; h > u; u++) t = e[u], i[t] = f.getAttribLocation(g, t);
        return this.attributes = i, this.attributesKeys = Object.keys(this.attributes), 
        this.id = a++, this.code = c, this.usedTimes = 1, this.program = g, this.vertexShader = j, 
        this.fragmentShader = k, this;
    };
}(), THREE.WebGLShader = function() {
    var a = function(a) {
        a = a.split("\n");
        for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
        return a.join("\n");
    };
    return function(b, c, d) {
        return c = b.createShader(c), b.shaderSource(c, d), b.compileShader(c), !1 === b.getShaderParameter(c, b.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), 
        "" !== b.getShaderInfoLog(c) && (console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b.getShaderInfoLog(c)), 
        console.warn(a(d))), c;
    };
}(), THREE.LensFlarePlugin = function(a, b) {
    var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = a.context;
    this.render = function(t, u, v, w) {
        if (0 !== b.length) {
            t = new THREE.Vector3();
            var x = w / v, y = .5 * v, z = .5 * w, A = 16 / w, B = new THREE.Vector2(A * x, A), C = new THREE.Vector3(1, 1, 0), D = new THREE.Vector2(1, 1);
            if (void 0 === o) {
                var A = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]), E = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
                m = s.createBuffer(), n = s.createBuffer(), s.bindBuffer(s.ARRAY_BUFFER, m), s.bufferData(s.ARRAY_BUFFER, A, s.STATIC_DRAW), 
                s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, n), s.bufferData(s.ELEMENT_ARRAY_BUFFER, E, s.STATIC_DRAW), 
                q = s.createTexture(), r = s.createTexture(), s.bindTexture(s.TEXTURE_2D, q), s.texImage2D(s.TEXTURE_2D, 0, s.RGB, 16, 16, 0, s.RGB, s.UNSIGNED_BYTE, null), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), 
                s.bindTexture(s.TEXTURE_2D, r), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, 16, 16, 0, s.RGBA, s.UNSIGNED_BYTE, null), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST);
                var A = (p = 0 < s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                    fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                } : {
                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                    fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                }, E = s.createProgram(), F = s.createShader(s.FRAGMENT_SHADER), G = s.createShader(s.VERTEX_SHADER), H = "precision " + a.getPrecision() + " float;\n";
                s.shaderSource(F, H + A.fragmentShader), s.shaderSource(G, H + A.vertexShader), 
                s.compileShader(F), s.compileShader(G), s.attachShader(E, F), s.attachShader(E, G), 
                s.linkProgram(E), o = E, k = s.getAttribLocation(o, "position"), l = s.getAttribLocation(o, "uv"), 
                c = s.getUniformLocation(o, "renderType"), d = s.getUniformLocation(o, "map"), e = s.getUniformLocation(o, "occlusionMap"), 
                f = s.getUniformLocation(o, "opacity"), g = s.getUniformLocation(o, "color"), h = s.getUniformLocation(o, "scale"), 
                i = s.getUniformLocation(o, "rotation"), j = s.getUniformLocation(o, "screenPosition");
            }
            for (s.useProgram(o), s.enableVertexAttribArray(k), s.enableVertexAttribArray(l), 
            s.uniform1i(e, 0), s.uniform1i(d, 1), s.bindBuffer(s.ARRAY_BUFFER, m), s.vertexAttribPointer(k, 2, s.FLOAT, !1, 16, 0), 
            s.vertexAttribPointer(l, 2, s.FLOAT, !1, 16, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, n), 
            s.disable(s.CULL_FACE), s.depthMask(!1), E = 0, F = b.length; F > E; E++) if (A = 16 / w, 
            B.set(A * x, A), G = b[E], t.set(G.matrixWorld.elements[12], G.matrixWorld.elements[13], G.matrixWorld.elements[14]), 
            t.applyMatrix4(u.matrixWorldInverse), t.applyProjection(u.projectionMatrix), C.copy(t), 
            D.x = C.x * y + y, D.y = C.y * z + z, p || 0 < D.x && D.x < v && 0 < D.y && D.y < w) {
                s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, q), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGB, D.x - 8, D.y - 8, 16, 16, 0), 
                s.uniform1i(c, 0), s.uniform2f(h, B.x, B.y), s.uniform3f(j, C.x, C.y, C.z), s.disable(s.BLEND), 
                s.enable(s.DEPTH_TEST), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), s.activeTexture(s.TEXTURE0), 
                s.bindTexture(s.TEXTURE_2D, r), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGBA, D.x - 8, D.y - 8, 16, 16, 0), 
                s.uniform1i(c, 1), s.disable(s.DEPTH_TEST), s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, q), 
                s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), G.positionScreen.copy(C), G.customUpdateCallback ? G.customUpdateCallback(G) : G.updateLensFlares(), 
                s.uniform1i(c, 2), s.enable(s.BLEND);
                for (var H = 0, I = G.lensFlares.length; I > H; H++) {
                    var J = G.lensFlares[H];
                    .001 < J.opacity && .001 < J.scale && (C.x = J.x, C.y = J.y, C.z = J.z, A = J.size * J.scale / w, 
                    B.x = A * x, B.y = A, s.uniform3f(j, C.x, C.y, C.z), s.uniform2f(h, B.x, B.y), s.uniform1f(i, J.rotation), 
                    s.uniform1f(f, J.opacity), s.uniform3f(g, J.color.r, J.color.g, J.color.b), a.setBlending(J.blending, J.blendEquation, J.blendSrc, J.blendDst), 
                    a.setTexture(J.texture, 1), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0));
                }
            }
            s.enable(s.CULL_FACE), s.enable(s.DEPTH_TEST), s.depthMask(!0), a.resetGLState();
        }
    };
}, THREE.ShadowMapPlugin = function(a, b, c, d) {
    function e(a, b, d) {
        if (b.visible) {
            var f = c[b.id];
            if (f && b.castShadow && (!1 === b.frustumCulled || !0 === k.intersectsObject(b))) for (var g = 0, h = f.length; h > g; g++) {
                var i = f[g];
                b._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, b.matrixWorld), p.push(i);
            }
            for (g = 0, h = b.children.length; h > g; g++) e(a, b.children[g], d);
        }
    }
    var f, g, h, i, j = a.context, k = new THREE.Frustum(), l = new THREE.Matrix4(), m = new THREE.Vector3(), n = new THREE.Vector3(), o = new THREE.Vector3(), p = [], q = THREE.ShaderLib.depthRGBA, r = THREE.UniformsUtils.clone(q.uniforms);
    f = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader
    }), g = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader,
        morphTargets: !0
    }), h = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader,
        skinning: !0
    }), i = new THREE.ShaderMaterial({
        uniforms: r,
        vertexShader: q.vertexShader,
        fragmentShader: q.fragmentShader,
        morphTargets: !0,
        skinning: !0
    }), f._shadowPass = !0, g._shadowPass = !0, h._shadowPass = !0, i._shadowPass = !0, 
    this.render = function(c, q) {
        if (!1 !== a.shadowMapEnabled) {
            var r, s, t, u, v, w, x, y, z = [];
            for (u = 0, j.clearColor(1, 1, 1, 1), j.disable(j.BLEND), j.enable(j.CULL_FACE), 
            j.frontFace(j.CCW), j.cullFace(a.shadowMapCullFace === THREE.CullFaceFront ? j.FRONT : j.BACK), 
            a.setDepthTest(!0), r = 0, s = b.length; s > r; r++) if (t = b[r], t.castShadow) if (t instanceof THREE.DirectionalLight && t.shadowCascade) for (v = 0; v < t.shadowCascadeCount; v++) {
                var A;
                if (t.shadowCascadeArray[v]) A = t.shadowCascadeArray[v]; else {
                    x = t;
                    var B = v;
                    A = new THREE.DirectionalLight(), A.isVirtual = !0, A.onlyShadow = !0, A.castShadow = !0, 
                    A.shadowCameraNear = x.shadowCameraNear, A.shadowCameraFar = x.shadowCameraFar, 
                    A.shadowCameraLeft = x.shadowCameraLeft, A.shadowCameraRight = x.shadowCameraRight, 
                    A.shadowCameraBottom = x.shadowCameraBottom, A.shadowCameraTop = x.shadowCameraTop, 
                    A.shadowCameraVisible = x.shadowCameraVisible, A.shadowDarkness = x.shadowDarkness, 
                    A.shadowBias = x.shadowCascadeBias[B], A.shadowMapWidth = x.shadowCascadeWidth[B], 
                    A.shadowMapHeight = x.shadowCascadeHeight[B], A.pointsWorld = [], A.pointsFrustum = [], 
                    y = A.pointsWorld, w = A.pointsFrustum;
                    for (var C = 0; 8 > C; C++) y[C] = new THREE.Vector3(), w[C] = new THREE.Vector3();
                    y = x.shadowCascadeNearZ[B], x = x.shadowCascadeFarZ[B], w[0].set(-1, -1, y), w[1].set(1, -1, y), 
                    w[2].set(-1, 1, y), w[3].set(1, 1, y), w[4].set(-1, -1, x), w[5].set(1, -1, x), 
                    w[6].set(-1, 1, x), w[7].set(1, 1, x), A.originalCamera = q, w = new THREE.Gyroscope(), 
                    w.position.copy(t.shadowCascadeOffset), w.add(A), w.add(A.target), q.add(w), t.shadowCascadeArray[v] = A, 
                    console.log("Created virtualLight", A);
                }
                B = t, y = v, x = B.shadowCascadeArray[y], x.position.copy(B.position), x.target.position.copy(B.target.position), 
                x.lookAt(x.target), x.shadowCameraVisible = B.shadowCameraVisible, x.shadowDarkness = B.shadowDarkness, 
                x.shadowBias = B.shadowCascadeBias[y], w = B.shadowCascadeNearZ[y], B = B.shadowCascadeFarZ[y], 
                x = x.pointsFrustum, x[0].z = w, x[1].z = w, x[2].z = w, x[3].z = w, x[4].z = B, 
                x[5].z = B, x[6].z = B, x[7].z = B, z[u] = A, u++;
            } else z[u] = t, u++;
            for (r = 0, s = z.length; s > r; r++) {
                if (t = z[r], t.shadowMap || (v = THREE.LinearFilter, a.shadowMapType === THREE.PCFSoftShadowMap && (v = THREE.NearestFilter), 
                t.shadowMap = new THREE.WebGLRenderTarget(t.shadowMapWidth, t.shadowMapHeight, {
                    minFilter: v,
                    magFilter: v,
                    format: THREE.RGBAFormat
                }), t.shadowMapSize = new THREE.Vector2(t.shadowMapWidth, t.shadowMapHeight), t.shadowMatrix = new THREE.Matrix4()), 
                !t.shadowCamera) {
                    if (t instanceof THREE.SpotLight) t.shadowCamera = new THREE.PerspectiveCamera(t.shadowCameraFov, t.shadowMapWidth / t.shadowMapHeight, t.shadowCameraNear, t.shadowCameraFar); else {
                        if (!(t instanceof THREE.DirectionalLight)) {
                            console.error("Unsupported light type for shadow");
                            continue;
                        }
                        t.shadowCamera = new THREE.OrthographicCamera(t.shadowCameraLeft, t.shadowCameraRight, t.shadowCameraTop, t.shadowCameraBottom, t.shadowCameraNear, t.shadowCameraFar);
                    }
                    c.add(t.shadowCamera), !0 === c.autoUpdate && c.updateMatrixWorld();
                }
                if (t.shadowCameraVisible && !t.cameraHelper && (t.cameraHelper = new THREE.CameraHelper(t.shadowCamera), 
                c.add(t.cameraHelper)), t.isVirtual && A.originalCamera == q) {
                    for (v = q, u = t.shadowCamera, w = t.pointsFrustum, x = t.pointsWorld, m.set(1/0, 1/0, 1/0), 
                    n.set(-1/0, -1/0, -1/0), B = 0; 8 > B; B++) y = x[B], y.copy(w[B]), y.unproject(v), 
                    y.applyMatrix4(u.matrixWorldInverse), y.x < m.x && (m.x = y.x), y.x > n.x && (n.x = y.x), 
                    y.y < m.y && (m.y = y.y), y.y > n.y && (n.y = y.y), y.z < m.z && (m.z = y.z), y.z > n.z && (n.z = y.z);
                    u.left = m.x, u.right = n.x, u.top = n.y, u.bottom = m.y, u.updateProjectionMatrix();
                }
                for (u = t.shadowMap, w = t.shadowMatrix, v = t.shadowCamera, v.position.setFromMatrixPosition(t.matrixWorld), 
                o.setFromMatrixPosition(t.target.matrixWorld), v.lookAt(o), v.updateMatrixWorld(), 
                v.matrixWorldInverse.getInverse(v.matrixWorld), t.cameraHelper && (t.cameraHelper.visible = t.shadowCameraVisible), 
                t.shadowCameraVisible && t.cameraHelper.update(), w.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), 
                w.multiply(v.projectionMatrix), w.multiply(v.matrixWorldInverse), l.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse), 
                k.setFromMatrix(l), a.setRenderTarget(u), a.clear(), p.length = 0, e(c, c, v), t = 0, 
                u = p.length; u > t; t++) x = p[t], w = x.object, x = x.buffer, B = w.material instanceof THREE.MeshFaceMaterial ? w.material.materials[0] : w.material, 
                y = void 0 !== w.geometry.morphTargets && 0 < w.geometry.morphTargets.length && B.morphTargets, 
                C = w instanceof THREE.SkinnedMesh && B.skinning, y = w.customDepthMaterial ? w.customDepthMaterial : C ? y ? i : h : y ? g : f, 
                a.setMaterialFaces(B), x instanceof THREE.BufferGeometry ? a.renderBufferDirect(v, b, null, y, x, w) : a.renderBuffer(v, b, null, y, x, w);
                for (t = 0, u = d.length; u > t; t++) x = d[t], w = x.object, w.visible && w.castShadow && (w._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, w.matrixWorld), 
                a.renderImmediateObject(v, b, null, f, w));
            }
            r = a.getClearColor(), s = a.getClearAlpha(), j.clearColor(r.r, r.g, r.b, s), j.enable(j.BLEND), 
            a.shadowMapCullFace === THREE.CullFaceFront && j.cullFace(j.BACK), a.resetGLState();
        }
    };
}, THREE.SpritePlugin = function(a, b) {
    function c(a, b) {
        return a.z !== b.z ? b.z - a.z : b.id - a.id;
    }
    var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y = a.context, z = new THREE.Vector3(), A = new THREE.Quaternion(), B = new THREE.Vector3();
    this.render = function(C, D) {
        if (0 !== b.length) {
            if (void 0 === w) {
                var E = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]), F = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
                u = y.createBuffer(), v = y.createBuffer(), y.bindBuffer(y.ARRAY_BUFFER, u), y.bufferData(y.ARRAY_BUFFER, E, y.STATIC_DRAW), 
                y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, v), y.bufferData(y.ELEMENT_ARRAY_BUFFER, F, y.STATIC_DRAW);
                var E = y.createProgram(), F = y.createShader(y.VERTEX_SHADER), G = y.createShader(y.FRAGMENT_SHADER);
                y.shaderSource(F, [ "precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}" ].join("\n")), 
                y.shaderSource(G, [ "precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}" ].join("\n")), 
                y.compileShader(F), y.compileShader(G), y.attachShader(E, F), y.attachShader(E, G), 
                y.linkProgram(E), w = E, s = y.getAttribLocation(w, "position"), t = y.getAttribLocation(w, "uv"), 
                d = y.getUniformLocation(w, "uvOffset"), e = y.getUniformLocation(w, "uvScale"), 
                f = y.getUniformLocation(w, "rotation"), g = y.getUniformLocation(w, "scale"), h = y.getUniformLocation(w, "color"), 
                i = y.getUniformLocation(w, "map"), j = y.getUniformLocation(w, "opacity"), k = y.getUniformLocation(w, "modelViewMatrix"), 
                l = y.getUniformLocation(w, "projectionMatrix"), m = y.getUniformLocation(w, "fogType"), 
                n = y.getUniformLocation(w, "fogDensity"), o = y.getUniformLocation(w, "fogNear"), 
                p = y.getUniformLocation(w, "fogFar"), q = y.getUniformLocation(w, "fogColor"), 
                r = y.getUniformLocation(w, "alphaTest"), E = document.createElement("canvas"), 
                E.width = 8, E.height = 8, F = E.getContext("2d"), F.fillStyle = "white", F.fillRect(0, 0, 8, 8), 
                x = new THREE.Texture(E), x.needsUpdate = !0;
            }
            y.useProgram(w), y.enableVertexAttribArray(s), y.enableVertexAttribArray(t), y.disable(y.CULL_FACE), 
            y.enable(y.BLEND), y.bindBuffer(y.ARRAY_BUFFER, u), y.vertexAttribPointer(s, 2, y.FLOAT, !1, 16, 0), 
            y.vertexAttribPointer(t, 2, y.FLOAT, !1, 16, 8), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, v), 
            y.uniformMatrix4fv(l, !1, D.projectionMatrix.elements), y.activeTexture(y.TEXTURE0), 
            y.uniform1i(i, 0), F = E = 0, (G = C.fog) ? (y.uniform3f(q, G.color.r, G.color.g, G.color.b), 
            G instanceof THREE.Fog ? (y.uniform1f(o, G.near), y.uniform1f(p, G.far), y.uniform1i(m, 1), 
            F = E = 1) : G instanceof THREE.FogExp2 && (y.uniform1f(n, G.density), y.uniform1i(m, 2), 
            F = E = 2)) : (y.uniform1i(m, 0), F = E = 0);
            for (var G = 0, H = b.length; H > G; G++) {
                var I = b[G];
                I._modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, I.matrixWorld), I.z = -I._modelViewMatrix.elements[14];
            }
            b.sort(c);
            for (var J = [], G = 0, H = b.length; H > G; G++) {
                var I = b[G], K = I.material;
                y.uniform1f(r, K.alphaTest), y.uniformMatrix4fv(k, !1, I._modelViewMatrix.elements), 
                I.matrixWorld.decompose(z, A, B), J[0] = B.x, J[1] = B.y, I = 0, C.fog && K.fog && (I = F), 
                E !== I && (y.uniform1i(m, I), E = I), null !== K.map ? (y.uniform2f(d, K.map.offset.x, K.map.offset.y), 
                y.uniform2f(e, K.map.repeat.x, K.map.repeat.y)) : (y.uniform2f(d, 0, 0), y.uniform2f(e, 1, 1)), 
                y.uniform1f(j, K.opacity), y.uniform3f(h, K.color.r, K.color.g, K.color.b), y.uniform1f(f, K.rotation), 
                y.uniform2fv(g, J), a.setBlending(K.blending, K.blendEquation, K.blendSrc, K.blendDst), 
                a.setDepthTest(K.depthTest), a.setDepthWrite(K.depthWrite), K.map && K.map.image && K.map.image.width ? a.setTexture(K.map, 0) : a.setTexture(x, 0), 
                y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0);
            }
            y.enable(y.CULL_FACE), a.resetGLState();
        }
    };
}, THREE.GeometryUtils = {
    merge: function(a, b, c) {
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        var d;
        b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, 
        b = b.geometry), a.merge(b, d, c);
    },
    center: function(a) {
        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), 
        a.center();
    }
}, THREE.ImageUtils = {
    crossOrigin: void 0,
    loadTexture: function(a, b, c, d) {
        var e = new THREE.ImageLoader();
        e.crossOrigin = this.crossOrigin;
        var f = new THREE.Texture(void 0, b);
        return e.load(a, function(a) {
            f.image = a, f.needsUpdate = !0, c && c(f);
        }, void 0, function(a) {
            d && d(a);
        }), f.sourceFile = a, f;
    },
    loadTextureCube: function(a, b, c, d) {
        var e = new THREE.ImageLoader();
        e.crossOrigin = this.crossOrigin;
        var f = new THREE.CubeTexture([], b);
        f.flipY = !1;
        var g = 0;
        b = function(b) {
            e.load(a[b], function(a) {
                f.images[b] = a, g += 1, 6 === g && (f.needsUpdate = !0, c && c(f));
            }, void 0, d);
        };
        for (var h = 0, i = a.length; i > h; ++h) b(h);
        return f;
    },
    loadCompressedTexture: function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    },
    loadCompressedTextureCube: function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    },
    getNormalMap: function(a, b) {
        var c = function(a) {
            var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
            return [ a[0] / b, a[1] / b, a[2] / b ];
        };
        b |= 1;
        var d = a.width, e = a.height, f = document.createElement("canvas");
        f.width = d, f.height = e;
        var g = f.getContext("2d");
        g.drawImage(a, 0, 0);
        for (var h = g.getImageData(0, 0, d, e).data, i = g.createImageData(d, e), j = i.data, k = 0; d > k; k++) for (var l = 0; e > l; l++) {
            var m = 0 > l - 1 ? 0 : l - 1, n = l + 1 > e - 1 ? e - 1 : l + 1, o = 0 > k - 1 ? 0 : k - 1, p = k + 1 > d - 1 ? d - 1 : k + 1, q = [], r = [ 0, 0, h[4 * (l * d + k)] / 255 * b ];
            for (q.push([ -1, 0, h[4 * (l * d + o)] / 255 * b ]), q.push([ -1, -1, h[4 * (m * d + o)] / 255 * b ]), 
            q.push([ 0, -1, h[4 * (m * d + k)] / 255 * b ]), q.push([ 1, -1, h[4 * (m * d + p)] / 255 * b ]), 
            q.push([ 1, 0, h[4 * (l * d + p)] / 255 * b ]), q.push([ 1, 1, h[4 * (n * d + p)] / 255 * b ]), 
            q.push([ 0, 1, h[4 * (n * d + k)] / 255 * b ]), q.push([ -1, 1, h[4 * (n * d + o)] / 255 * b ]), 
            m = [], o = q.length, n = 0; o > n; n++) {
                var p = q[n], s = q[(n + 1) % o], p = [ p[0] - r[0], p[1] - r[1], p[2] - r[2] ], s = [ s[0] - r[0], s[1] - r[1], s[2] - r[2] ];
                m.push(c([ p[1] * s[2] - p[2] * s[1], p[2] * s[0] - p[0] * s[2], p[0] * s[1] - p[1] * s[0] ]));
            }
            for (q = [ 0, 0, 0 ], n = 0; n < m.length; n++) q[0] += m[n][0], q[1] += m[n][1], 
            q[2] += m[n][2];
            q[0] /= m.length, q[1] /= m.length, q[2] /= m.length, r = 4 * (l * d + k), j[r] = (q[0] + 1) / 2 * 255 | 0, 
            j[r + 1] = (q[1] + 1) / 2 * 255 | 0, j[r + 2] = 255 * q[2] | 0, j[r + 3] = 255;
        }
        return g.putImageData(i, 0, 0), f;
    },
    generateDataTexture: function(a, b, c) {
        var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g);
        c = Math.floor(255 * c.b);
        for (var h = 0; d > h; h++) e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
        return a = new THREE.DataTexture(e, a, b, THREE.RGBFormat), a.needsUpdate = !0, 
        a;
    }
}, THREE.SceneUtils = {
    createMultiMaterialObject: function(a, b) {
        for (var c = new THREE.Object3D(), d = 0, e = b.length; e > d; d++) c.add(new THREE.Mesh(a, b[d]));
        return c;
    },
    detach: function(a, b, c) {
        a.applyMatrix(b.matrixWorld), b.remove(a), c.add(a);
    },
    attach: function(a, b, c) {
        var d = new THREE.Matrix4();
        d.getInverse(c.matrixWorld), a.applyMatrix(d), b.remove(a), c.add(a);
    }
}, THREE.FontUtils = {
    faces: {},
    face: "helvetiker",
    weight: "normal",
    style: "normal",
    size: 150,
    divisions: 10,
    getFace: function() {
        try {
            return this.faces[this.face][this.weight][this.style];
        } catch (a) {
            throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
        }
    },
    loadFace: function(a) {
        var b = a.familyName.toLowerCase();
        return this.faces[b] = this.faces[b] || {}, this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {}, 
        this.faces[b][a.cssFontWeight][a.cssFontStyle] = a, this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
    },
    drawText: function(a) {
        var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(""), f = e.length, g = [];
        for (a = 0; f > a; a++) {
            var h = new THREE.Path(), h = this.extractGlyphPoints(e[a], b, c, d, h), d = d + h.offset;
            g.push(h.path);
        }
        return {
            paths: g,
            offset: d / 2
        };
    },
    extractGlyphPoints: function(a, b, c, d, e) {
        var f, g, h, i, j, k, l, m, n, o, p, q = [], r = b.glyphs[a] || b.glyphs["?"];
        if (r) {
            if (r.o) for (b = r._cachedOutline || (r._cachedOutline = r.o.split(" ")), i = b.length, 
            a = 0; i > a; ) switch (h = b[a++]) {
              case "m":
                h = b[a++] * c + d, j = b[a++] * c, e.moveTo(h, j);
                break;

              case "l":
                h = b[a++] * c + d, j = b[a++] * c, e.lineTo(h, j);
                break;

              case "q":
                if (h = b[a++] * c + d, j = b[a++] * c, m = b[a++] * c + d, n = b[a++] * c, e.quadraticCurveTo(m, n, h, j), 
                f = q[q.length - 1]) for (k = f.x, l = f.y, f = 1, g = this.divisions; g >= f; f++) {
                    var s = f / g;
                    THREE.Shape.Utils.b2(s, k, m, h), THREE.Shape.Utils.b2(s, l, n, j);
                }
                break;

              case "b":
                if (h = b[a++] * c + d, j = b[a++] * c, m = b[a++] * c + d, n = b[a++] * c, o = b[a++] * c + d, 
                p = b[a++] * c, e.bezierCurveTo(m, n, o, p, h, j), f = q[q.length - 1]) for (k = f.x, 
                l = f.y, f = 1, g = this.divisions; g >= f; f++) s = f / g, THREE.Shape.Utils.b3(s, k, m, o, h), 
                THREE.Shape.Utils.b3(s, l, n, p, j);
            }
            return {
                offset: r.ha * c,
                path: e
            };
        }
    }
}, THREE.FontUtils.generateShapes = function(a, b) {
    b = b || {};
    var c = void 0 !== b.curveSegments ? b.curveSegments : 4, d = void 0 !== b.font ? b.font : "helvetiker", e = void 0 !== b.weight ? b.weight : "normal", f = void 0 !== b.style ? b.style : "normal";
    for (THREE.FontUtils.size = void 0 !== b.size ? b.size : 100, THREE.FontUtils.divisions = c, 
    THREE.FontUtils.face = d, THREE.FontUtils.weight = e, THREE.FontUtils.style = f, 
    c = THREE.FontUtils.drawText(a).paths, d = [], e = 0, f = c.length; f > e; e++) Array.prototype.push.apply(d, c[e].toShapes());
    return d;
}, function(a) {
    var b = function(a) {
        for (var b = a.length, c = 0, d = b - 1, e = 0; b > e; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
        return .5 * c;
    };
    return a.Triangulate = function(a, c) {
        var d = a.length;
        if (3 > d) return null;
        var e, f, g, h = [], i = [], j = [];
        if (0 < b(a)) for (f = 0; d > f; f++) i[f] = f; else for (f = 0; d > f; f++) i[f] = d - 1 - f;
        var k = 2 * d;
        for (f = d - 1; d > 2; ) {
            if (0 >= k--) {
                console.log("Warning, unable to triangulate polygon!");
                break;
            }
            e = f, e >= d && (e = 0), f = e + 1, f >= d && (f = 0), g = f + 1, g >= d && (g = 0);
            var l;
            a: {
                var m = l = void 0, n = void 0, o = void 0, p = void 0, q = void 0, r = void 0, s = void 0, t = void 0, m = a[i[e]].x, n = a[i[e]].y, o = a[i[f]].x, p = a[i[f]].y, q = a[i[g]].x, r = a[i[g]].y;
                if (1e-10 > (o - m) * (r - n) - (p - n) * (q - m)) l = !1; else {
                    var u = void 0, v = void 0, w = void 0, x = void 0, y = void 0, z = void 0, A = void 0, B = void 0, C = void 0, D = void 0, C = B = A = t = s = void 0, u = q - o, v = r - p, w = m - q, x = n - r, y = o - m, z = p - n;
                    for (l = 0; d > l; l++) if (s = a[i[l]].x, t = a[i[l]].y, !(s === m && t === n || s === o && t === p || s === q && t === r) && (A = s - m, 
                    B = t - n, C = s - o, D = t - p, s -= q, t -= r, C = u * D - v * C, A = y * B - z * A, 
                    B = w * t - x * s, C >= -1e-10 && B >= -1e-10 && A >= -1e-10)) {
                        l = !1;
                        break a;
                    }
                    l = !0;
                }
            }
            if (l) {
                for (h.push([ a[i[e]], a[i[f]], a[i[g]] ]), j.push([ i[e], i[f], i[g] ]), e = f, 
                g = f + 1; d > g; e++, g++) i[e] = i[g];
                d--, k = 2 * d;
            }
        }
        return c ? j : h;
    }, a.Triangulate.area = b, a;
}(THREE.FontUtils), self._typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
}, THREE.typeface_js = self._typeface_js, THREE.Audio = function(a) {
    THREE.Object3D.call(this), this.type = "Audio", this.context = a.context, this.source = this.context.createBufferSource(), 
    this.gain = this.context.createGain(), this.gain.connect(this.context.destination), 
    this.panner = this.context.createPanner(), this.panner.connect(this.gain);
}, THREE.Audio.prototype = Object.create(THREE.Object3D.prototype), THREE.Audio.prototype.constructor = THREE.Audio, 
THREE.Audio.prototype.load = function(a) {
    var b = this, c = new XMLHttpRequest();
    return c.open("GET", a, !0), c.responseType = "arraybuffer", c.onload = function() {
        b.context.decodeAudioData(this.response, function(a) {
            b.source.buffer = a, b.source.connect(b.panner), b.source.start(0);
        });
    }, c.send(), this;
}, THREE.Audio.prototype.setLoop = function(a) {
    this.source.loop = a;
}, THREE.Audio.prototype.setRefDistance = function(a) {
    this.panner.refDistance = a;
}, THREE.Audio.prototype.setRolloffFactor = function(a) {
    this.panner.rolloffFactor = a;
}, THREE.Audio.prototype.updateMatrixWorld = function() {
    var a = new THREE.Vector3();
    return function(b) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, b), a.setFromMatrixPosition(this.matrixWorld), 
        this.panner.setPosition(a.x, a.y, a.z);
    };
}(), THREE.AudioListener = function() {
    THREE.Object3D.call(this), this.type = "AudioListener", this.context = new (window.AudioContext || window.webkitAudioContext)();
}, THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype), THREE.AudioListener.prototype.constructor = THREE.AudioListener, 
THREE.AudioListener.prototype.updateMatrixWorld = function() {
    var a = new THREE.Vector3(), b = new THREE.Quaternion(), c = new THREE.Vector3(), d = new THREE.Vector3(), e = new THREE.Vector3(), f = new THREE.Vector3();
    return function(g) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, g), g = this.context.listener;
        var h = this.up;
        this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), e.subVectors(a, f), 
        g.setPosition(a.x, a.y, a.z), g.setOrientation(d.x, d.y, d.z, h.x, h.y, h.z), g.setVelocity(e.x, e.y, e.z), 
        f.copy(a);
    };
}(), THREE.Curve = function() {}, THREE.Curve.prototype.getPoint = function() {
    return console.log("Warning, getPoint() not implemented!"), null;
}, THREE.Curve.prototype.getPointAt = function(a) {
    return a = this.getUtoTmapping(a), this.getPoint(a);
}, THREE.Curve.prototype.getPoints = function(a) {
    a || (a = 5);
    var b, c = [];
    for (b = 0; a >= b; b++) c.push(this.getPoint(b / a));
    return c;
}, THREE.Curve.prototype.getSpacedPoints = function(a) {
    a || (a = 5);
    var b, c = [];
    for (b = 0; a >= b; b++) c.push(this.getPointAt(b / a));
    return c;
}, THREE.Curve.prototype.getLength = function() {
    var a = this.getLengths();
    return a[a.length - 1];
}, THREE.Curve.prototype.getLengths = function(a) {
    if (a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = !1;
    var b, c, d = [], e = this.getPoint(0), f = 0;
    for (d.push(0), c = 1; a >= c; c++) b = this.getPoint(c / a), f += b.distanceTo(e), 
    d.push(f), e = b;
    return this.cacheArcLengths = d;
}, THREE.Curve.prototype.updateArcLengths = function() {
    this.needsUpdate = !0, this.getLengths();
}, THREE.Curve.prototype.getUtoTmapping = function(a, b) {
    var c, d = this.getLengths(), e = 0, f = d.length;
    c = b ? b : a * d[f - 1];
    for (var g, h = 0, i = f - 1; i >= h; ) if (e = Math.floor(h + (i - h) / 2), g = d[e] - c, 
    0 > g) h = e + 1; else {
        if (!(g > 0)) {
            i = e;
            break;
        }
        i = e - 1;
    }
    return e = i, d[e] == c ? e / (f - 1) : (h = d[e], d = (e + (c - h) / (d[e + 1] - h)) / (f - 1));
}, THREE.Curve.prototype.getTangent = function(a) {
    var b = a - 1e-4;
    return a += 1e-4, 0 > b && (b = 0), a > 1 && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize();
}, THREE.Curve.prototype.getTangentAt = function(a) {
    return a = this.getUtoTmapping(a), this.getTangent(a);
}, THREE.Curve.Utils = {
    tangentQuadraticBezier: function(a, b, c, d) {
        return 2 * (1 - a) * (c - b) + 2 * a * (d - c);
    },
    tangentCubicBezier: function(a, b, c, d, e) {
        return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;
    },
    tangentSpline: function(a) {
        return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);
    },
    interpolate: function(a, b, c, d, e) {
        a = .5 * (c - a), d = .5 * (d - b);
        var f = e * e;
        return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;
    }
}, THREE.Curve.create = function(a, b) {
    return a.prototype = Object.create(THREE.Curve.prototype), a.prototype.constructor = a, 
    a.prototype.getPoint = b, a;
}, THREE.CurvePath = function() {
    this.curves = [], this.bends = [], this.autoClose = !1;
}, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.constructor = THREE.CurvePath, 
THREE.CurvePath.prototype.add = function(a) {
    this.curves.push(a);
}, THREE.CurvePath.prototype.checkConnection = function() {}, THREE.CurvePath.prototype.closePath = function() {
    var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));
}, THREE.CurvePath.prototype.getPoint = function(a) {
    var b = a * this.getLength(), c = this.getCurveLengths();
    for (a = 0; a < c.length; ) {
        if (c[a] >= b) return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), 
        a.getPointAt(b);
        a++;
    }
    return null;
}, THREE.CurvePath.prototype.getLength = function() {
    var a = this.getCurveLengths();
    return a[a.length - 1];
}, THREE.CurvePath.prototype.getCurveLengths = function() {
    if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
    var a, b = [], c = 0, d = this.curves.length;
    for (a = 0; d > a; a++) c += this.curves[a].getLength(), b.push(c);
    return this.cacheLengths = b;
}, THREE.CurvePath.prototype.getBoundingBox = function() {
    var a, b, c, d, e, f, g = this.getPoints();
    a = b = Number.NEGATIVE_INFINITY, d = e = Number.POSITIVE_INFINITY;
    var h, i, j, k, l = g[0] instanceof THREE.Vector3;
    for (k = l ? new THREE.Vector3() : new THREE.Vector2(), i = 0, j = g.length; j > i; i++) h = g[i], 
    h.x > a ? a = h.x : h.x < d && (d = h.x), h.y > b ? b = h.y : h.y < e && (e = h.y), 
    l && (h.z > c ? c = h.z : h.z < f && (f = h.z)), k.add(h);
    return g = {
        minX: d,
        minY: e,
        maxX: a,
        maxY: b
    }, l && (g.maxZ = c, g.minZ = f), g;
}, THREE.CurvePath.prototype.createPointsGeometry = function(a) {
    return a = this.getPoints(a, !0), this.createGeometry(a);
}, THREE.CurvePath.prototype.createSpacedPointsGeometry = function(a) {
    return a = this.getSpacedPoints(a, !0), this.createGeometry(a);
}, THREE.CurvePath.prototype.createGeometry = function(a) {
    for (var b = new THREE.Geometry(), c = 0; c < a.length; c++) b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
    return b;
}, THREE.CurvePath.prototype.addWrapPath = function(a) {
    this.bends.push(a);
}, THREE.CurvePath.prototype.getTransformedPoints = function(a, b) {
    var c, d, e = this.getPoints(a);
    for (b || (b = this.bends), c = 0, d = b.length; d > c; c++) e = this.getWrapPoints(e, b[c]);
    return e;
}, THREE.CurvePath.prototype.getTransformedSpacedPoints = function(a, b) {
    var c, d, e = this.getSpacedPoints(a);
    for (b || (b = this.bends), c = 0, d = b.length; d > c; c++) e = this.getWrapPoints(e, b[c]);
    return e;
}, THREE.CurvePath.prototype.getWrapPoints = function(a, b) {
    var c, d, e, f, g, h, i = this.getBoundingBox();
    for (c = 0, d = a.length; d > c; c++) e = a[c], f = e.x, g = e.y, h = f / i.maxX, 
    h = b.getUtoTmapping(h, f), f = b.getPoint(h), h = b.getTangent(h), h.set(-h.y, h.x).multiplyScalar(g), 
    e.x = f.x + h.x, e.y = f.y + h.y;
    return a;
}, THREE.Gyroscope = function() {
    THREE.Object3D.call(this);
}, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.constructor = THREE.Gyroscope, 
THREE.Gyroscope.prototype.updateMatrixWorld = function() {
    var a = new THREE.Vector3(), b = new THREE.Quaternion(), c = new THREE.Vector3(), d = new THREE.Vector3(), e = new THREE.Quaternion(), f = new THREE.Vector3();
    return function(g) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || g) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
        this.matrixWorld.decompose(d, e, f), this.matrix.decompose(a, b, c), this.matrixWorld.compose(d, b, f)) : this.matrixWorld.copy(this.matrix), 
        this.matrixWorldNeedsUpdate = !1, g = !0);
        for (var h = 0, i = this.children.length; i > h; h++) this.children[h].updateMatrixWorld(g);
    };
}(), THREE.Path = function(a) {
    THREE.CurvePath.call(this), this.actions = [], a && this.fromPoints(a);
}, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.Path.prototype.constructor = THREE.Path, 
THREE.PathActions = {
    MOVE_TO: "moveTo",
    LINE_TO: "lineTo",
    QUADRATIC_CURVE_TO: "quadraticCurveTo",
    BEZIER_CURVE_TO: "bezierCurveTo",
    CSPLINE_THRU: "splineThru",
    ARC: "arc",
    ELLIPSE: "ellipse"
}, THREE.Path.prototype.fromPoints = function(a) {
    this.moveTo(a[0].x, a[0].y);
    for (var b = 1, c = a.length; c > b; b++) this.lineTo(a[b].x, a[b].y);
}, THREE.Path.prototype.moveTo = function() {
    var a = Array.prototype.slice.call(arguments);
    this.actions.push({
        action: THREE.PathActions.MOVE_TO,
        args: a
    });
}, THREE.Path.prototype.lineTo = function(a, b) {
    var c = Array.prototype.slice.call(arguments), d = this.actions[this.actions.length - 1].args, d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
    this.curves.push(d), this.actions.push({
        action: THREE.PathActions.LINE_TO,
        args: c
    });
}, THREE.Path.prototype.quadraticCurveTo = function(a, b, c, d) {
    var e = Array.prototype.slice.call(arguments), f = this.actions[this.actions.length - 1].args, f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
    this.curves.push(f), this.actions.push({
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: e
    });
}, THREE.Path.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
    var g = Array.prototype.slice.call(arguments), h = this.actions[this.actions.length - 1].args, h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
    this.curves.push(h), this.actions.push({
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: g
    });
}, THREE.Path.prototype.splineThru = function(a) {
    var b = Array.prototype.slice.call(arguments), c = this.actions[this.actions.length - 1].args, c = [ new THREE.Vector2(c[c.length - 2], c[c.length - 1]) ];
    Array.prototype.push.apply(c, a), c = new THREE.SplineCurve(c), this.curves.push(c), 
    this.actions.push({
        action: THREE.PathActions.CSPLINE_THRU,
        args: b
    });
}, THREE.Path.prototype.arc = function(a, b, c, d, e, f) {
    var g = this.actions[this.actions.length - 1].args;
    this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);
}, THREE.Path.prototype.absarc = function(a, b, c, d, e, f) {
    this.absellipse(a, b, c, c, d, e, f);
}, THREE.Path.prototype.ellipse = function(a, b, c, d, e, f, g) {
    var h = this.actions[this.actions.length - 1].args;
    this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g);
}, THREE.Path.prototype.absellipse = function(a, b, c, d, e, f, g) {
    var h = Array.prototype.slice.call(arguments), i = new THREE.EllipseCurve(a, b, c, d, e, f, g);
    this.curves.push(i), i = i.getPoint(1), h.push(i.x), h.push(i.y), this.actions.push({
        action: THREE.PathActions.ELLIPSE,
        args: h
    });
}, THREE.Path.prototype.getSpacedPoints = function(a) {
    a || (a = 40);
    for (var b = [], c = 0; a > c; c++) b.push(this.getPoint(c / a));
    return b;
}, THREE.Path.prototype.getPoints = function(a, b) {
    if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(a, b);
    a = a || 12;
    var c, d, e, f, g, h, i, j, k, l, m, n, o, p = [];
    for (c = 0, d = this.actions.length; d > c; c++) switch (e = this.actions[c], f = e.action, 
    e = e.args, f) {
      case THREE.PathActions.MOVE_TO:
        p.push(new THREE.Vector2(e[0], e[1]));
        break;

      case THREE.PathActions.LINE_TO:
        p.push(new THREE.Vector2(e[0], e[1]));
        break;

      case THREE.PathActions.QUADRATIC_CURVE_TO:
        for (g = e[2], h = e[3], k = e[0], l = e[1], 0 < p.length ? (f = p[p.length - 1], 
        m = f.x, n = f.y) : (f = this.actions[c - 1].args, m = f[f.length - 2], n = f[f.length - 1]), 
        e = 1; a >= e; e++) o = e / a, f = THREE.Shape.Utils.b2(o, m, k, g), o = THREE.Shape.Utils.b2(o, n, l, h), 
        p.push(new THREE.Vector2(f, o));
        break;

      case THREE.PathActions.BEZIER_CURVE_TO:
        for (g = e[4], h = e[5], k = e[0], l = e[1], i = e[2], j = e[3], 0 < p.length ? (f = p[p.length - 1], 
        m = f.x, n = f.y) : (f = this.actions[c - 1].args, m = f[f.length - 2], n = f[f.length - 1]), 
        e = 1; a >= e; e++) o = e / a, f = THREE.Shape.Utils.b3(o, m, k, i, g), o = THREE.Shape.Utils.b3(o, n, l, j, h), 
        p.push(new THREE.Vector2(f, o));
        break;

      case THREE.PathActions.CSPLINE_THRU:
        for (f = this.actions[c - 1].args, o = [ new THREE.Vector2(f[f.length - 2], f[f.length - 1]) ], 
        f = a * e[0].length, o = o.concat(e[0]), o = new THREE.SplineCurve(o), e = 1; f >= e; e++) p.push(o.getPointAt(e / f));
        break;

      case THREE.PathActions.ARC:
        for (g = e[0], h = e[1], l = e[2], i = e[3], f = e[4], k = !!e[5], m = f - i, n = 2 * a, 
        e = 1; n >= e; e++) o = e / n, k || (o = 1 - o), o = i + o * m, f = g + l * Math.cos(o), 
        o = h + l * Math.sin(o), p.push(new THREE.Vector2(f, o));
        break;

      case THREE.PathActions.ELLIPSE:
        for (g = e[0], h = e[1], l = e[2], j = e[3], i = e[4], f = e[5], k = !!e[6], m = f - i, 
        n = 2 * a, e = 1; n >= e; e++) o = e / n, k || (o = 1 - o), o = i + o * m, f = g + l * Math.cos(o), 
        o = h + j * Math.sin(o), p.push(new THREE.Vector2(f, o));
    }
    return c = p[p.length - 1], 1e-10 > Math.abs(c.x - p[0].x) && 1e-10 > Math.abs(c.y - p[0].y) && p.splice(p.length - 1, 1), 
    b && p.push(p[0]), p;
}, THREE.Path.prototype.toShapes = function(a, b) {
    function c(a) {
        for (var b = [], c = 0, d = a.length; d > c; c++) {
            var e = a[c], f = new THREE.Shape();
            f.actions = e.actions, f.curves = e.curves, b.push(f);
        }
        return b;
    }
    function d(a, b) {
        for (var c = b.length, d = !1, e = c - 1, f = 0; c > f; e = f++) {
            var g = b[e], h = b[f], i = h.x - g.x, j = h.y - g.y;
            if (1e-10 < Math.abs(j)) {
                if (0 > j && (g = b[f], i = -i, h = b[e], j = -j), !(a.y < g.y || a.y > h.y)) if (a.y == g.y) {
                    if (a.x == g.x) return !0;
                } else {
                    if (e = j * (a.x - g.x) - i * (a.y - g.y), 0 == e) return !0;
                    0 > e || (d = !d);
                }
            } else if (a.y == g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0;
        }
        return d;
    }
    var e = function(a) {
        var b, c, d, e, f = [], g = new THREE.Path();
        for (b = 0, c = a.length; c > b; b++) d = a[b], e = d.args, d = d.action, d == THREE.PathActions.MOVE_TO && 0 != g.actions.length && (f.push(g), 
        g = new THREE.Path()), g[d].apply(g, e);
        return 0 != g.actions.length && f.push(g), f;
    }(this.actions);
    if (0 == e.length) return [];
    if (!0 === b) return c(e);
    var f, g, h, i = [];
    if (1 == e.length) return g = e[0], h = new THREE.Shape(), h.actions = g.actions, 
    h.curves = g.curves, i.push(h), i;
    var j = !THREE.Shape.Utils.isClockWise(e[0].getPoints()), j = a ? !j : j;
    h = [];
    var k, l = [], m = [], n = 0;
    l[n] = void 0, m[n] = [];
    var o, p;
    for (o = 0, p = e.length; p > o; o++) g = e[o], k = g.getPoints(), f = THREE.Shape.Utils.isClockWise(k), 
    (f = a ? !f : f) ? (!j && l[n] && n++, l[n] = {
        s: new THREE.Shape(),
        p: k
    }, l[n].s.actions = g.actions, l[n].s.curves = g.curves, j && n++, m[n] = []) : m[n].push({
        h: g,
        p: k[0]
    });
    if (!l[0]) return c(e);
    if (1 < l.length) {
        for (o = !1, p = [], g = 0, e = l.length; e > g; g++) h[g] = [];
        for (g = 0, e = l.length; e > g; g++) for (f = m[g], j = 0; j < f.length; j++) {
            n = f[j], k = !0;
            for (var q = 0; q < l.length; q++) d(n.p, l[q].p) && (g != q && p.push({
                froms: g,
                tos: q,
                hole: j
            }), k ? (k = !1, h[q].push(n)) : o = !0);
            k && h[g].push(n);
        }
        0 < p.length && (o || (m = h));
    }
    for (o = 0, p = l.length; p > o; o++) for (h = l[o].s, i.push(h), g = m[o], e = 0, 
    f = g.length; f > e; e++) h.holes.push(g[e].h);
    return i;
}, THREE.Shape = function() {
    THREE.Path.apply(this, arguments), this.holes = [];
}, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.constructor = THREE.Shape, 
THREE.Shape.prototype.extrude = function(a) {
    return new THREE.ExtrudeGeometry(this, a);
}, THREE.Shape.prototype.makeGeometry = function(a) {
    return new THREE.ShapeGeometry(this, a);
}, THREE.Shape.prototype.getPointsHoles = function(a) {
    var b, c = this.holes.length, d = [];
    for (b = 0; c > b; b++) d[b] = this.holes[b].getTransformedPoints(a, this.bends);
    return d;
}, THREE.Shape.prototype.getSpacedPointsHoles = function(a) {
    var b, c = this.holes.length, d = [];
    for (b = 0; c > b; b++) d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
    return d;
}, THREE.Shape.prototype.extractAllPoints = function(a) {
    return {
        shape: this.getTransformedPoints(a),
        holes: this.getPointsHoles(a)
    };
}, THREE.Shape.prototype.extractPoints = function(a) {
    return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a);
}, THREE.Shape.prototype.extractAllSpacedPoints = function(a) {
    return {
        shape: this.getTransformedSpacedPoints(a),
        holes: this.getSpacedPointsHoles(a)
    };
}, THREE.Shape.Utils = {
    triangulateShape: function(a, b) {
        function c(a, b, c) {
            return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y;
        }
        function d(a, b, d, e, f) {
            var g = b.x - a.x, h = b.y - a.y, i = e.x - d.x, j = e.y - d.y, k = a.x - d.x, l = a.y - d.y, m = h * i - g * j, n = h * k - g * l;
            if (1e-10 < Math.abs(m)) {
                if (m > 0) {
                    if (0 > n || n > m) return [];
                    if (i = j * k - i * l, 0 > i || i > m) return [];
                } else {
                    if (n > 0 || m > n) return [];
                    if (i = j * k - i * l, i > 0 || m > i) return [];
                }
                return 0 == i ? !f || 0 != n && n != m ? [ a ] : [] : i == m ? !f || 0 != n && n != m ? [ b ] : [] : 0 == n ? [ d ] : n == m ? [ e ] : (f = i / m, 
                [ {
                    x: a.x + f * g,
                    y: a.y + f * h
                } ]);
            }
            return 0 != n || j * k != i * l ? [] : (h = 0 == g && 0 == h, i = 0 == i && 0 == j, 
            h && i ? a.x != d.x || a.y != d.y ? [] : [ a ] : h ? c(d, e, a) ? [ a ] : [] : i ? c(a, b, d) ? [ d ] : [] : (0 != g ? (a.x < b.x ? (g = a, 
            i = a.x, h = b, a = b.x) : (g = b, i = b.x, h = a, a = a.x), d.x < e.x ? (b = d, 
            m = d.x, j = e, d = e.x) : (b = e, m = e.x, j = d, d = d.x)) : (a.y < b.y ? (g = a, 
            i = a.y, h = b, a = b.y) : (g = b, i = b.y, h = a, a = a.y), d.y < e.y ? (b = d, 
            m = d.y, j = e, d = e.y) : (b = e, m = e.y, j = d, d = d.y)), m >= i ? m > a ? [] : a == m ? f ? [] : [ b ] : d >= a ? [ b, h ] : [ b, j ] : i > d ? [] : i == d ? f ? [] : [ g ] : d >= a ? [ g, h ] : [ g, j ]));
        }
        function e(a, b, c, d) {
            var e = b.x - a.x, f = b.y - a.y;
            b = c.x - a.x, c = c.y - a.y;
            var g = d.x - a.x;
            return d = d.y - a.y, a = e * c - f * b, e = e * d - f * g, 1e-10 < Math.abs(a) ? (b = g * c - d * b, 
            a > 0 ? e >= 0 && b >= 0 : e >= 0 || b >= 0) : e > 0;
        }
        var f, g, h, i, j, k = {};
        for (h = a.concat(), f = 0, g = b.length; g > f; f++) Array.prototype.push.apply(h, b[f]);
        for (f = 0, g = h.length; g > f; f++) j = h[f].x + ":" + h[f].y, void 0 !== k[j] && console.log("Duplicate point", j), 
        k[j] = f;
        f = function(a, b) {
            function c(a, b) {
                var c = q.length - 1, d = a - 1;
                0 > d && (d = c);
                var f = a + 1;
                return f > c && (f = 0), (c = e(q[a], q[d], q[f], h[b])) ? (c = h.length - 1, d = b - 1, 
                0 > d && (d = c), f = b + 1, f > c && (f = 0), (c = e(h[b], h[d], h[f], q[a])) ? !0 : !1) : !1;
            }
            function f(a, b) {
                var c, e;
                for (c = 0; c < q.length; c++) if (e = c + 1, e %= q.length, e = d(a, b, q[c], q[e], !0), 
                0 < e.length) return !0;
                return !1;
            }
            function g(a, c) {
                var e, f, g, h;
                for (e = 0; e < r.length; e++) for (f = b[r[e]], g = 0; g < f.length; g++) if (h = g + 1, 
                h %= f.length, h = d(a, c, f[g], f[h], !0), 0 < h.length) return !0;
                return !1;
            }
            var h, i, j, k, l, m, n, o, p, q = a.concat(), r = [], s = [], t = 0;
            for (i = b.length; i > t; t++) r.push(t);
            n = 0;
            for (var u = 2 * r.length; 0 < r.length; ) {
                if (u--, 0 > u) {
                    console.log("Infinite Loop! Holes left:" + r.length + ", Probably Hole outside Shape!");
                    break;
                }
                for (j = n; j < q.length; j++) {
                    for (k = q[j], i = -1, t = 0; t < r.length; t++) if (l = r[t], m = k.x + ":" + k.y + ":" + l, 
                    void 0 === s[m]) {
                        for (h = b[l], o = 0; o < h.length; o++) if (l = h[o], c(j, o) && !f(k, l) && !g(k, l)) {
                            i = o, r.splice(t, 1), n = q.slice(0, j + 1), l = q.slice(j), o = h.slice(i), p = h.slice(0, i + 1), 
                            q = n.concat(o).concat(p).concat(l), n = j;
                            break;
                        }
                        if (i >= 0) break;
                        s[m] = !0;
                    }
                    if (i >= 0) break;
                }
            }
            return q;
        }(a, b);
        var l = THREE.FontUtils.Triangulate(f, !1);
        for (f = 0, g = l.length; g > f; f++) for (i = l[f], h = 0; 3 > h; h++) j = i[h].x + ":" + i[h].y, 
        j = k[j], void 0 !== j && (i[h] = j);
        return l.concat();
    },
    isClockWise: function(a) {
        return 0 > THREE.FontUtils.Triangulate.area(a);
    },
    b2p0: function(a, b) {
        var c = 1 - a;
        return c * c * b;
    },
    b2p1: function(a, b) {
        return 2 * (1 - a) * a * b;
    },
    b2p2: function(a, b) {
        return a * a * b;
    },
    b2: function(a, b, c, d) {
        return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d);
    },
    b3p0: function(a, b) {
        var c = 1 - a;
        return c * c * c * b;
    },
    b3p1: function(a, b) {
        var c = 1 - a;
        return 3 * c * c * a * b;
    },
    b3p2: function(a, b) {
        return 3 * (1 - a) * a * a * b;
    },
    b3p3: function(a, b) {
        return a * a * a * b;
    },
    b3: function(a, b, c, d, e) {
        return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e);
    }
}, THREE.LineCurve = function(a, b) {
    this.v1 = a, this.v2 = b;
}, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.constructor = THREE.LineCurve, 
THREE.LineCurve.prototype.getPoint = function(a) {
    var b = this.v2.clone().sub(this.v1);
    return b.multiplyScalar(a).add(this.v1), b;
}, THREE.LineCurve.prototype.getPointAt = function(a) {
    return this.getPoint(a);
}, THREE.LineCurve.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize();
}, THREE.QuadraticBezierCurve = function(a, b, c) {
    this.v0 = a, this.v1 = b, this.v2 = c;
}, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), 
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve, THREE.QuadraticBezierCurve.prototype.getPoint = function(a) {
    var b = new THREE.Vector2();
    return b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x), b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y), 
    b;
}, THREE.QuadraticBezierCurve.prototype.getTangent = function(a) {
    var b = new THREE.Vector2();
    return b.x = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x), 
    b.y = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y), 
    b.normalize();
}, THREE.CubicBezierCurve = function(a, b, c, d) {
    this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d;
}, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve, 
THREE.CubicBezierCurve.prototype.getPoint = function(a) {
    var b;
    return b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), 
    a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(b, a);
}, THREE.CubicBezierCurve.prototype.getTangent = function(a) {
    var b;
    return b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), 
    a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), 
    b = new THREE.Vector2(b, a), b.normalize(), b;
}, THREE.SplineCurve = function(a) {
    this.points = void 0 == a ? [] : a;
}, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.constructor = THREE.SplineCurve, 
THREE.SplineCurve.prototype.getPoint = function(a) {
    var b = this.points;
    a *= b.length - 1;
    var c = Math.floor(a);
    a -= c;
    var d = b[0 == c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = new THREE.Vector2();
    return c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a), c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a), 
    c;
}, THREE.EllipseCurve = function(a, b, c, d, e, f, g) {
    this.aX = a, this.aY = b, this.xRadius = c, this.yRadius = d, this.aStartAngle = e, 
    this.aEndAngle = f, this.aClockwise = g;
}, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve, 
THREE.EllipseCurve.prototype.getPoint = function(a) {
    var b = this.aEndAngle - this.aStartAngle;
    return 0 > b && (b += 2 * Math.PI), b > 2 * Math.PI && (b -= 2 * Math.PI), a = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b, 
    b = new THREE.Vector2(), b.x = this.aX + this.xRadius * Math.cos(a), b.y = this.aY + this.yRadius * Math.sin(a), 
    b;
}, THREE.ArcCurve = function(a, b, c, d, e, f) {
    THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);
}, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.ArcCurve.prototype.constructor = THREE.ArcCurve, 
THREE.LineCurve3 = THREE.Curve.create(function(a, b) {
    this.v1 = a, this.v2 = b;
}, function(a) {
    var b = new THREE.Vector3();
    return b.subVectors(this.v2, this.v1), b.multiplyScalar(a), b.add(this.v1), b;
}), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(a, b, c) {
    this.v0 = a, this.v1 = b, this.v2 = c;
}, function(a) {
    var b = new THREE.Vector3();
    return b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x), b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y), 
    b.z = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z), b;
}), THREE.CubicBezierCurve3 = THREE.Curve.create(function(a, b, c, d) {
    this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d;
}, function(a) {
    var b = new THREE.Vector3();
    return b.x = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), 
    b.y = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b.z = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z), 
    b;
}), THREE.SplineCurve3 = THREE.Curve.create(function(a) {
    this.points = void 0 == a ? [] : a;
}, function(a) {
    var b = this.points;
    a *= b.length - 1;
    var c = Math.floor(a);
    a -= c;
    var d = b[0 == c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = new THREE.Vector3();
    return c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a), c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a), 
    c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a), c;
}), THREE.ClosedSplineCurve3 = THREE.Curve.create(function(a) {
    this.points = void 0 == a ? [] : a;
}, function(a) {
    var b = this.points;
    a *= b.length - 0;
    var c = Math.floor(a);
    a -= c;
    var c = c + (c > 0 ? 0 : (Math.floor(Math.abs(c) / b.length) + 1) * b.length), d = b[(c - 1) % b.length], e = b[c % b.length], f = b[(c + 1) % b.length], b = b[(c + 2) % b.length], c = new THREE.Vector3();
    return c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a), c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a), 
    c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a), c;
}), THREE.AnimationHandler = {
    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2,
    add: function() {
        console.warn("THREE.AnimationHandler.add() has been deprecated.");
    },
    get: function() {
        console.warn("THREE.AnimationHandler.get() has been deprecated.");
    },
    remove: function() {
        console.warn("THREE.AnimationHandler.remove() has been deprecated.");
    },
    animations: [],
    init: function(a) {
        if (!0 === a.initialized) return a;
        for (var b = 0; b < a.hierarchy.length; b++) {
            for (var c = 0; c < a.hierarchy[b].keys.length; c++) if (0 > a.hierarchy[b].keys[c].time && (a.hierarchy[b].keys[c].time = 0), 
            void 0 !== a.hierarchy[b].keys[c].rot && !(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)) {
                var d = a.hierarchy[b].keys[c].rot;
                a.hierarchy[b].keys[c].rot = new THREE.Quaternion().fromArray(d);
            }
            if (a.hierarchy[b].keys.length && void 0 !== a.hierarchy[b].keys[0].morphTargets) {
                for (d = {}, c = 0; c < a.hierarchy[b].keys.length; c++) for (var e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) {
                    var f = a.hierarchy[b].keys[c].morphTargets[e];
                    d[f] = -1;
                }
                for (a.hierarchy[b].usedMorphTargets = d, c = 0; c < a.hierarchy[b].keys.length; c++) {
                    var g = {};
                    for (f in d) {
                        for (e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) if (a.hierarchy[b].keys[c].morphTargets[e] === f) {
                            g[f] = a.hierarchy[b].keys[c].morphTargetsInfluences[e];
                            break;
                        }
                        e === a.hierarchy[b].keys[c].morphTargets.length && (g[f] = 0);
                    }
                    a.hierarchy[b].keys[c].morphTargetsInfluences = g;
                }
            }
            for (c = 1; c < a.hierarchy[b].keys.length; c++) a.hierarchy[b].keys[c].time === a.hierarchy[b].keys[c - 1].time && (a.hierarchy[b].keys.splice(c, 1), 
            c--);
            for (c = 0; c < a.hierarchy[b].keys.length; c++) a.hierarchy[b].keys[c].index = c;
        }
        return a.initialized = !0, a;
    },
    parse: function(a) {
        var b = function(a, c) {
            c.push(a);
            for (var d = 0; d < a.children.length; d++) b(a.children[d], c);
        }, c = [];
        if (a instanceof THREE.SkinnedMesh) for (var d = 0; d < a.skeleton.bones.length; d++) c.push(a.skeleton.bones[d]); else b(a, c);
        return c;
    },
    play: function(a) {
        -1 === this.animations.indexOf(a) && this.animations.push(a);
    },
    stop: function(a) {
        a = this.animations.indexOf(a), -1 !== a && this.animations.splice(a, 1);
    },
    update: function(a) {
        for (var b = 0; b < this.animations.length; b++) this.animations[b].resetBlendWeights();
        for (b = 0; b < this.animations.length; b++) this.animations[b].update(a);
    }
}, THREE.Animation = function(a, b) {
    this.root = a, this.data = THREE.AnimationHandler.init(b), this.hierarchy = THREE.AnimationHandler.parse(a), 
    this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, 
    this.interpolationType = THREE.AnimationHandler.LINEAR;
}, THREE.Animation.prototype.keyTypes = [ "pos", "rot", "scl" ], THREE.Animation.prototype.play = function(a, b) {
    this.currentTime = void 0 !== a ? a : 0, this.weight = void 0 !== b ? b : 1, this.isPlaying = !0, 
    this.reset(), THREE.AnimationHandler.play(this);
}, THREE.Animation.prototype.stop = function() {
    this.isPlaying = !1, THREE.AnimationHandler.stop(this);
}, THREE.Animation.prototype.reset = function() {
    for (var a = 0, b = this.hierarchy.length; b > a; a++) {
        var c = this.hierarchy[a];
        void 0 === c.animationCache && (c.animationCache = {
            animations: {},
            blending: {
                positionWeight: 0,
                quaternionWeight: 0,
                scaleWeight: 0
            }
        }), void 0 === c.animationCache.animations[this.data.name] && (c.animationCache.animations[this.data.name] = {}, 
        c.animationCache.animations[this.data.name].prevKey = {
            pos: 0,
            rot: 0,
            scl: 0
        }, c.animationCache.animations[this.data.name].nextKey = {
            pos: 0,
            rot: 0,
            scl: 0
        }, c.animationCache.animations[this.data.name].originalMatrix = c.matrix);
        for (var c = c.animationCache.animations[this.data.name], d = 0; 3 > d; d++) {
            for (var e = this.keyTypes[d], f = this.data.hierarchy[a].keys[0], g = this.getNextKeyWith(e, a, 1); g.time < this.currentTime && g.index > f.index; ) f = g, 
            g = this.getNextKeyWith(e, a, g.index + 1);
            c.prevKey[e] = f, c.nextKey[e] = g;
        }
    }
}, THREE.Animation.prototype.resetBlendWeights = function() {
    for (var a = 0, b = this.hierarchy.length; b > a; a++) {
        var c = this.hierarchy[a];
        void 0 !== c.animationCache && (c.animationCache.blending.positionWeight = 0, c.animationCache.blending.quaternionWeight = 0, 
        c.animationCache.blending.scaleWeight = 0);
    }
}, THREE.Animation.prototype.update = function() {
    var a = [], b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Quaternion(), e = function(a, b) {
        var c, d, e, g, h, i, j = [], k = [];
        return c = (a.length - 1) * b, d = Math.floor(c), c -= d, j[0] = 0 === d ? d : d - 1, 
        j[1] = d, j[2] = d > a.length - 2 ? d : d + 1, j[3] = d > a.length - 3 ? d : d + 2, 
        d = a[j[0]], g = a[j[1]], h = a[j[2]], i = a[j[3]], j = c * c, e = c * j, k[0] = f(d[0], g[0], h[0], i[0], c, j, e), 
        k[1] = f(d[1], g[1], h[1], i[1], c, j, e), k[2] = f(d[2], g[2], h[2], i[2], c, j, e), 
        k;
    }, f = function(a, b, c, d, e, f, g) {
        return a = .5 * (c - a), d = .5 * (d - b), (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
    };
    return function(f) {
        if (!1 !== this.isPlaying && (this.currentTime += f * this.timeScale, 0 !== this.weight)) {
            f = this.data.length, (this.currentTime > f || 0 > this.currentTime) && (this.loop ? (this.currentTime %= f, 
            0 > this.currentTime && (this.currentTime += f), this.reset()) : this.stop()), f = 0;
            for (var g = this.hierarchy.length; g > f; f++) for (var h = this.hierarchy[f], i = h.animationCache.animations[this.data.name], j = h.animationCache.blending, k = 0; 3 > k; k++) {
                var l = this.keyTypes[k], m = i.prevKey[l], n = i.nextKey[l];
                if (0 < this.timeScale && n.time <= this.currentTime || 0 > this.timeScale && m.time >= this.currentTime) {
                    for (m = this.data.hierarchy[f].keys[0], n = this.getNextKeyWith(l, f, 1); n.time < this.currentTime && n.index > m.index; ) m = n, 
                    n = this.getNextKeyWith(l, f, n.index + 1);
                    i.prevKey[l] = m, i.nextKey[l] = n;
                }
                var o = (this.currentTime - m.time) / (n.time - m.time), p = m[l], q = n[l];
                0 > o && (o = 0), o > 1 && (o = 1), "pos" === l ? this.interpolationType === THREE.AnimationHandler.LINEAR ? (c.x = p[0] + (q[0] - p[0]) * o, 
                c.y = p[1] + (q[1] - p[1]) * o, c.z = p[2] + (q[2] - p[2]) * o, m = this.weight / (this.weight + j.positionWeight), 
                h.position.lerp(c, m), j.positionWeight += this.weight) : (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) && (a[0] = this.getPrevKeyWith("pos", f, m.index - 1).pos, 
                a[1] = p, a[2] = q, a[3] = this.getNextKeyWith("pos", f, n.index + 1).pos, o = .33 * o + .33, 
                n = e(a, o), m = this.weight / (this.weight + j.positionWeight), j.positionWeight += this.weight, 
                l = h.position, l.x += (n[0] - l.x) * m, l.y += (n[1] - l.y) * m, l.z += (n[2] - l.z) * m, 
                this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (o = e(a, 1.01 * o), 
                b.set(o[0], o[1], o[2]), b.sub(l), b.y = 0, b.normalize(), o = Math.atan2(b.x, b.z), 
                h.rotation.set(0, o, 0))) : "rot" === l ? (THREE.Quaternion.slerp(p, q, d, o), 0 === j.quaternionWeight ? (h.quaternion.copy(d), 
                j.quaternionWeight = this.weight) : (m = this.weight / (this.weight + j.quaternionWeight), 
                THREE.Quaternion.slerp(h.quaternion, d, h.quaternion, m), j.quaternionWeight += this.weight)) : "scl" === l && (c.x = p[0] + (q[0] - p[0]) * o, 
                c.y = p[1] + (q[1] - p[1]) * o, c.z = p[2] + (q[2] - p[2]) * o, m = this.weight / (this.weight + j.scaleWeight), 
                h.scale.lerp(c, m), j.scaleWeight += this.weight);
            }
            return !0;
        }
    };
}(), THREE.Animation.prototype.getNextKeyWith = function(a, b, c) {
    var d = this.data.hierarchy[b].keys;
    for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++) if (void 0 !== d[c][a]) return d[c];
    return this.data.hierarchy[b].keys[0];
}, THREE.Animation.prototype.getPrevKeyWith = function(a, b, c) {
    var d = this.data.hierarchy[b].keys;
    for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c > 0 ? c : 0 : c >= 0 ? c : c + d.length; c >= 0; c--) if (void 0 !== d[c][a]) return d[c];
    return this.data.hierarchy[b].keys[d.length - 1];
}, THREE.KeyFrameAnimation = function(a) {
    this.root = a.node, this.data = THREE.AnimationHandler.init(a), this.hierarchy = THREE.AnimationHandler.parse(this.root), 
    this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.loop = this.isPaused = !0, 
    a = 0;
    for (var b = this.hierarchy.length; b > a; a++) {
        var c = this.data.hierarchy[a].sids, d = this.hierarchy[a];
        if (this.data.hierarchy[a].keys.length && c) {
            for (var e = 0; e < c.length; e++) {
                var f = c[e], g = this.getNextKeyWith(f, a, 0);
                g && g.apply(f);
            }
            d.matrixAutoUpdate = !1, this.data.hierarchy[a].node.updateMatrix(), d.matrixWorldNeedsUpdate = !0;
        }
    }
}, THREE.KeyFrameAnimation.prototype.play = function(a) {
    if (this.currentTime = void 0 !== a ? a : 0, !1 === this.isPlaying) {
        this.isPlaying = !0;
        var b, c, d = this.hierarchy.length;
        for (a = 0; d > a; a++) b = this.hierarchy[a], c = this.data.hierarchy[a], void 0 === c.animationCache && (c.animationCache = {}, 
        c.animationCache.prevKey = null, c.animationCache.nextKey = null, c.animationCache.originalMatrix = b.matrix), 
        b = this.data.hierarchy[a].keys, b.length && (c.animationCache.prevKey = b[0], c.animationCache.nextKey = b[1], 
        this.startTime = Math.min(b[0].time, this.startTime), this.endTime = Math.max(b[b.length - 1].time, this.endTime));
        this.update(0);
    }
    this.isPaused = !1, THREE.AnimationHandler.play(this);
}, THREE.KeyFrameAnimation.prototype.stop = function() {
    this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.stop(this);
    for (var a = 0; a < this.data.hierarchy.length; a++) {
        var b = this.hierarchy[a], c = this.data.hierarchy[a];
        if (void 0 !== c.animationCache) {
            var d = c.animationCache.originalMatrix;
            d.copy(b.matrix), b.matrix = d, delete c.animationCache;
        }
    }
}, THREE.KeyFrameAnimation.prototype.update = function(a) {
    if (!1 !== this.isPlaying) {
        this.currentTime += a * this.timeScale, a = this.data.length, !0 === this.loop && this.currentTime > a && (this.currentTime %= a), 
        this.currentTime = Math.min(this.currentTime, a), a = 0;
        for (var b = this.hierarchy.length; b > a; a++) {
            var c = this.hierarchy[a], d = this.data.hierarchy[a], e = d.keys, d = d.animationCache;
            if (e.length) {
                var f = d.prevKey, g = d.nextKey;
                if (g.time <= this.currentTime) {
                    for (;g.time < this.currentTime && g.index > f.index; ) f = g, g = e[f.index + 1];
                    d.prevKey = f, d.nextKey = g;
                }
                g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time), 
                this.data.hierarchy[a].node.updateMatrix(), c.matrixWorldNeedsUpdate = !0;
            }
        }
    }
}, THREE.KeyFrameAnimation.prototype.getNextKeyWith = function(a, b, c) {
    for (b = this.data.hierarchy[b].keys, c %= b.length; c < b.length; c++) if (b[c].hasTarget(a)) return b[c];
    return b[0];
}, THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(a, b, c) {
    for (b = this.data.hierarchy[b].keys, c = c >= 0 ? c : c + b.length; c >= 0; c--) if (b[c].hasTarget(a)) return b[c];
    return b[b.length - 1];
}, THREE.MorphAnimation = function(a) {
    this.mesh = a, this.frames = a.morphTargetInfluences.length, this.currentTime = 0, 
    this.duration = 1e3, this.loop = !0, this.currentFrame = this.lastFrame = 0, this.isPlaying = !1;
}, THREE.MorphAnimation.prototype = {
    constructor: THREE.MorphAnimation,
    play: function() {
        this.isPlaying = !0;
    },
    pause: function() {
        this.isPlaying = !1;
    },
    update: function(a) {
        if (!1 !== this.isPlaying) {
            this.currentTime += a, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), 
            this.currentTime = Math.min(this.currentTime, this.duration), a = this.duration / this.frames;
            var b = Math.floor(this.currentTime / a);
            b != this.currentFrame && (this.mesh.morphTargetInfluences[this.lastFrame] = 0, 
            this.mesh.morphTargetInfluences[this.currentFrame] = 1, this.mesh.morphTargetInfluences[b] = 0, 
            this.lastFrame = this.currentFrame, this.currentFrame = b), this.mesh.morphTargetInfluences[b] = this.currentTime % a / a, 
            this.mesh.morphTargetInfluences[this.lastFrame] = 1 - this.mesh.morphTargetInfluences[b];
        }
    }
}, THREE.BoxGeometry = function(a, b, c, d, e, f) {
    function g(a, b, c, d, e, f, g, i) {
        var j, k = h.widthSegments, l = h.heightSegments, m = e / 2, n = f / 2, o = h.vertices.length;
        "x" === a && "y" === b || "y" === a && "x" === b ? j = "z" : "x" === a && "z" === b || "z" === a && "x" === b ? (j = "y", 
        l = h.depthSegments) : ("z" === a && "y" === b || "y" === a && "z" === b) && (j = "x", 
        k = h.depthSegments);
        var p = k + 1, q = l + 1, r = e / k, s = f / l, t = new THREE.Vector3();
        for (t[j] = g > 0 ? 1 : -1, e = 0; q > e; e++) for (f = 0; p > f; f++) {
            var u = new THREE.Vector3();
            u[a] = (f * r - m) * c, u[b] = (e * s - n) * d, u[j] = g, h.vertices.push(u);
        }
        for (e = 0; l > e; e++) for (f = 0; k > f; f++) n = f + p * e, a = f + p * (e + 1), 
        b = f + 1 + p * (e + 1), c = f + 1 + p * e, d = new THREE.Vector2(f / k, 1 - e / l), 
        g = new THREE.Vector2(f / k, 1 - (e + 1) / l), j = new THREE.Vector2((f + 1) / k, 1 - (e + 1) / l), 
        m = new THREE.Vector2((f + 1) / k, 1 - e / l), n = new THREE.Face3(n + o, a + o, c + o), 
        n.normal.copy(t), n.vertexNormals.push(t.clone(), t.clone(), t.clone()), n.materialIndex = i, 
        h.faces.push(n), h.faceVertexUvs[0].push([ d, g, m ]), n = new THREE.Face3(a + o, b + o, c + o), 
        n.normal.copy(t), n.vertexNormals.push(t.clone(), t.clone(), t.clone()), n.materialIndex = i, 
        h.faces.push(n), h.faceVertexUvs[0].push([ g.clone(), j, m.clone() ]);
    }
    THREE.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
        width: a,
        height: b,
        depth: c,
        widthSegments: d,
        heightSegments: e,
        depthSegments: f
    }, this.widthSegments = d || 1, this.heightSegments = e || 1, this.depthSegments = f || 1;
    var h = this;
    d = a / 2, e = b / 2, f = c / 2, g("z", "y", -1, -1, c, b, d, 0), g("z", "y", 1, -1, c, b, -d, 1), 
    g("x", "z", 1, 1, a, c, e, 2), g("x", "z", 1, -1, a, c, -e, 3), g("x", "y", 1, -1, a, b, f, 4), 
    g("x", "y", -1, -1, a, b, -f, 5), this.mergeVertices();
}, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry, 
THREE.CircleGeometry = function(a, b, c, d) {
    THREE.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
        radius: a,
        segments: b,
        thetaStart: c,
        thetaLength: d
    }, a = a || 50, b = void 0 !== b ? Math.max(3, b) : 8, c = void 0 !== c ? c : 0, 
    d = void 0 !== d ? d : 2 * Math.PI;
    var e, f = [];
    e = new THREE.Vector3();
    var g = new THREE.Vector2(.5, .5);
    for (this.vertices.push(e), f.push(g), e = 0; b >= e; e++) {
        var h = new THREE.Vector3(), i = c + e / b * d;
        h.x = a * Math.cos(i), h.y = a * Math.sin(i), this.vertices.push(h), f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2));
    }
    for (c = new THREE.Vector3(0, 0, 1), e = 1; b >= e; e++) this.faces.push(new THREE.Face3(e, e + 1, 0, [ c.clone(), c.clone(), c.clone() ])), 
    this.faceVertexUvs[0].push([ f[e].clone(), f[e + 1].clone(), g.clone() ]);
    this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
}, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry, 
THREE.CubeGeometry = function(a, b, c, d, e, f) {
    return console.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry."), 
    new THREE.BoxGeometry(a, b, c, d, e, f);
}, THREE.CylinderGeometry = function(a, b, c, d, e, f, g, h) {
    THREE.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
        radiusTop: a,
        radiusBottom: b,
        height: c,
        radialSegments: d,
        heightSegments: e,
        openEnded: f,
        thetaStart: g,
        thetaLength: h
    }, a = void 0 !== a ? a : 20, b = void 0 !== b ? b : 20, c = void 0 !== c ? c : 100, 
    d = d || 8, e = e || 1, f = void 0 !== f ? f : !1, g = void 0 !== g ? g : 0, h = void 0 !== h ? h : 2 * Math.PI;
    var i, j, k = c / 2, l = [], m = [];
    for (j = 0; e >= j; j++) {
        var n = [], o = [], p = j / e, q = p * (b - a) + a;
        for (i = 0; d >= i; i++) {
            var r = i / d, s = new THREE.Vector3();
            s.x = q * Math.sin(r * h + g), s.y = -p * c + k, s.z = q * Math.cos(r * h + g), 
            this.vertices.push(s), n.push(this.vertices.length - 1), o.push(new THREE.Vector2(r, 1 - p));
        }
        l.push(n), m.push(o);
    }
    for (c = (b - a) / c, i = 0; d > i; i++) for (0 !== a ? (g = this.vertices[l[0][i]].clone(), 
    h = this.vertices[l[0][i + 1]].clone()) : (g = this.vertices[l[1][i]].clone(), h = this.vertices[l[1][i + 1]].clone()), 
    g.setY(Math.sqrt(g.x * g.x + g.z * g.z) * c).normalize(), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * c).normalize(), 
    j = 0; e > j; j++) {
        var n = l[j][i], o = l[j + 1][i], p = l[j + 1][i + 1], q = l[j][i + 1], r = g.clone(), s = g.clone(), t = h.clone(), u = h.clone(), v = m[j][i].clone(), w = m[j + 1][i].clone(), x = m[j + 1][i + 1].clone(), y = m[j][i + 1].clone();
        this.faces.push(new THREE.Face3(n, o, q, [ r, s, u ])), this.faceVertexUvs[0].push([ v, w, y ]), 
        this.faces.push(new THREE.Face3(o, p, q, [ s.clone(), t, u.clone() ])), this.faceVertexUvs[0].push([ w.clone(), x, y.clone() ]);
    }
    if (!1 === f && a > 0) for (this.vertices.push(new THREE.Vector3(0, k, 0)), i = 0; d > i; i++) n = l[0][i], 
    o = l[0][i + 1], p = this.vertices.length - 1, r = new THREE.Vector3(0, 1, 0), s = new THREE.Vector3(0, 1, 0), 
    t = new THREE.Vector3(0, 1, 0), v = m[0][i].clone(), w = m[0][i + 1].clone(), x = new THREE.Vector2(w.x, 0), 
    this.faces.push(new THREE.Face3(n, o, p, [ r, s, t ])), this.faceVertexUvs[0].push([ v, w, x ]);
    if (!1 === f && b > 0) for (this.vertices.push(new THREE.Vector3(0, -k, 0)), i = 0; d > i; i++) n = l[e][i + 1], 
    o = l[e][i], p = this.vertices.length - 1, r = new THREE.Vector3(0, -1, 0), s = new THREE.Vector3(0, -1, 0), 
    t = new THREE.Vector3(0, -1, 0), v = m[e][i + 1].clone(), w = m[e][i].clone(), x = new THREE.Vector2(w.x, 1), 
    this.faces.push(new THREE.Face3(n, o, p, [ r, s, t ])), this.faceVertexUvs[0].push([ v, w, x ]);
    this.computeFaceNormals();
}, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry, 
THREE.ExtrudeGeometry = function(a, b) {
    "undefined" != typeof a && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", 
    a = a instanceof Array ? a : [ a ], this.addShapeList(a, b), this.computeFaceNormals());
}, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry, 
THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = a.length, d = 0; c > d; d++) this.addShape(a[d], b);
}, THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
    function c(a, b, c) {
        return b || console.log("die"), b.clone().multiplyScalar(c).add(a);
    }
    function d(a, b, c) {
        var d = 1, d = a.x - b.x, e = a.y - b.y, f = c.x - a.x, g = c.y - a.y, h = d * d + e * e;
        if (1e-10 < Math.abs(d * g - e * f)) {
            var i = Math.sqrt(h), j = Math.sqrt(f * f + g * g), h = b.x - e / i;
            if (b = b.y + d / i, f = ((c.x - g / j - h) * g - (c.y + f / j - b) * f) / (d * g - e * f), 
            c = h + d * f - a.x, a = b + e * f - a.y, d = c * c + a * a, 2 >= d) return new THREE.Vector2(c, a);
            d = Math.sqrt(d / 2);
        } else a = !1, d > 1e-10 ? f > 1e-10 && (a = !0) : -1e-10 > d ? -1e-10 > f && (a = !0) : Math.sign(e) == Math.sign(g) && (a = !0), 
        a ? (c = -e, a = d, d = Math.sqrt(h)) : (c = d, a = e, d = Math.sqrt(h / 2));
        return new THREE.Vector2(c / d, a / d);
    }
    function e(a, b) {
        var c, d;
        for (O = a.length; 0 <= --O; ) {
            c = O, d = O - 1, 0 > d && (d = a.length - 1);
            for (var e = 0, f = s + 2 * p, e = 0; f > e; e++) {
                var g = M * e, h = M * (e + 1), i = b + c + g, g = b + d + g, j = b + d + h, h = b + c + h, i = i + C, g = g + C, j = j + C, h = h + C;
                B.faces.push(new THREE.Face3(i, g, h, null, null, w)), B.faces.push(new THREE.Face3(g, j, h, null, null, w)), 
                i = x.generateSideWallUV(B, i, g, j, h), B.faceVertexUvs[0].push([ i[0], i[1], i[3] ]), 
                B.faceVertexUvs[0].push([ i[1], i[2], i[3] ]);
            }
        }
    }
    function f(a, b, c) {
        B.vertices.push(new THREE.Vector3(a, b, c));
    }
    function g(a, b, c) {
        a += C, b += C, c += C, B.faces.push(new THREE.Face3(a, b, c, null, null, v)), a = x.generateTopUV(B, a, b, c), 
        B.faceVertexUvs[0].push(a);
    }
    var h, i, j, k, l, m = void 0 !== b.amount ? b.amount : 100, n = void 0 !== b.bevelThickness ? b.bevelThickness : 6, o = void 0 !== b.bevelSize ? b.bevelSize : n - 2, p = void 0 !== b.bevelSegments ? b.bevelSegments : 3, q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, r = void 0 !== b.curveSegments ? b.curveSegments : 12, s = void 0 !== b.steps ? b.steps : 1, t = b.extrudePath, u = !1, v = b.material, w = b.extrudeMaterial, x = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
    t && (h = t.getSpacedPoints(s), u = !0, q = !1, i = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(t, s, !1), 
    j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3()), q || (o = n = p = 0);
    var y, z, A, B = this, C = this.vertices.length, t = a.extractPoints(r), r = t.shape, D = t.holes;
    if (t = !THREE.Shape.Utils.isClockWise(r)) {
        for (r = r.reverse(), z = 0, A = D.length; A > z; z++) y = D[z], THREE.Shape.Utils.isClockWise(y) && (D[z] = y.reverse());
        t = !1;
    }
    var E = THREE.Shape.Utils.triangulateShape(r, D), F = r;
    for (z = 0, A = D.length; A > z; z++) y = D[z], r = r.concat(y);
    var G, H, I, J, K, L, M = r.length, N = E.length, t = [], O = 0;
    for (I = F.length, G = I - 1, H = O + 1; I > O; O++, G++, H++) G === I && (G = 0), 
    H === I && (H = 0), t[O] = d(F[O], F[G], F[H]);
    var P, Q = [], R = t.concat();
    for (z = 0, A = D.length; A > z; z++) {
        for (y = D[z], P = [], O = 0, I = y.length, G = I - 1, H = O + 1; I > O; O++, G++, 
        H++) G === I && (G = 0), H === I && (H = 0), P[O] = d(y[O], y[G], y[H]);
        Q.push(P), R = R.concat(P);
    }
    for (G = 0; p > G; G++) {
        for (I = G / p, J = n * (1 - I), H = o * Math.sin(I * Math.PI / 2), O = 0, I = F.length; I > O; O++) K = c(F[O], t[O], H), 
        f(K.x, K.y, -J);
        for (z = 0, A = D.length; A > z; z++) for (y = D[z], P = Q[z], O = 0, I = y.length; I > O; O++) K = c(y[O], P[O], H), 
        f(K.x, K.y, -J);
    }
    for (H = o, O = 0; M > O; O++) K = q ? c(r[O], R[O], H) : r[O], u ? (k.copy(i.normals[0]).multiplyScalar(K.x), 
    j.copy(i.binormals[0]).multiplyScalar(K.y), l.copy(h[0]).add(k).add(j), f(l.x, l.y, l.z)) : f(K.x, K.y, 0);
    for (I = 1; s >= I; I++) for (O = 0; M > O; O++) K = q ? c(r[O], R[O], H) : r[O], 
    u ? (k.copy(i.normals[I]).multiplyScalar(K.x), j.copy(i.binormals[I]).multiplyScalar(K.y), 
    l.copy(h[I]).add(k).add(j), f(l.x, l.y, l.z)) : f(K.x, K.y, m / s * I);
    for (G = p - 1; G >= 0; G--) {
        for (I = G / p, J = n * (1 - I), H = o * Math.sin(I * Math.PI / 2), O = 0, I = F.length; I > O; O++) K = c(F[O], t[O], H), 
        f(K.x, K.y, m + J);
        for (z = 0, A = D.length; A > z; z++) for (y = D[z], P = Q[z], O = 0, I = y.length; I > O; O++) K = c(y[O], P[O], H), 
        u ? f(K.x, K.y + h[s - 1].y, h[s - 1].x + J) : f(K.x, K.y, m + J);
    }
    !function() {
        if (q) {
            var a;
            for (a = 0 * M, O = 0; N > O; O++) L = E[O], g(L[2] + a, L[1] + a, L[0] + a);
            for (a = s + 2 * p, a *= M, O = 0; N > O; O++) L = E[O], g(L[0] + a, L[1] + a, L[2] + a);
        } else {
            for (O = 0; N > O; O++) L = E[O], g(L[2], L[1], L[0]);
            for (O = 0; N > O; O++) L = E[O], g(L[0] + M * s, L[1] + M * s, L[2] + M * s);
        }
    }(), function() {
        var a = 0;
        for (e(F, a), a += F.length, z = 0, A = D.length; A > z; z++) y = D[z], e(y, a), 
        a += y.length;
    }();
}, THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(a, b, c, d) {
        return a = a.vertices, b = a[b], c = a[c], d = a[d], [ new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y), new THREE.Vector2(d.x, d.y) ];
    },
    generateSideWallUV: function(a, b, c, d, e) {
        return a = a.vertices, b = a[b], c = a[c], d = a[d], e = a[e], .01 > Math.abs(b.y - c.y) ? [ new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z) ] : [ new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z), new THREE.Vector2(e.y, 1 - e.z) ];
    }
}, THREE.ShapeGeometry = function(a, b) {
    THREE.Geometry.call(this), this.type = "ShapeGeometry", !1 == a instanceof Array && (a = [ a ]), 
    this.addShapeList(a, b), this.computeFaceNormals();
}, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry, 
THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = 0, d = a.length; d > c; c++) this.addShape(a[c], b);
    return this;
}, THREE.ShapeGeometry.prototype.addShape = function(a, b) {
    void 0 === b && (b = {});
    var c, d, e, f = b.material, g = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, h = this.vertices.length;
    c = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
    var i = c.shape, j = c.holes;
    if (!THREE.Shape.Utils.isClockWise(i)) for (i = i.reverse(), c = 0, d = j.length; d > c; c++) e = j[c], 
    THREE.Shape.Utils.isClockWise(e) && (j[c] = e.reverse());
    var k = THREE.Shape.Utils.triangulateShape(i, j);
    for (c = 0, d = j.length; d > c; c++) e = j[c], i = i.concat(e);
    for (j = i.length, d = k.length, c = 0; j > c; c++) e = i[c], this.vertices.push(new THREE.Vector3(e.x, e.y, 0));
    for (c = 0; d > c; c++) j = k[c], i = j[0] + h, e = j[1] + h, j = j[2] + h, this.faces.push(new THREE.Face3(i, e, j, null, null, f)), 
    this.faceVertexUvs[0].push(g.generateTopUV(this, i, e, j));
}, THREE.LatheGeometry = function(a, b, c, d) {
    THREE.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
        points: a,
        segments: b,
        phiStart: c,
        phiLength: d
    }, b = b || 12, c = c || 0, d = d || 2 * Math.PI;
    for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; h >= g; g++) for (var i = c + g * f * d, j = Math.cos(i), k = Math.sin(i), i = 0, l = a.length; l > i; i++) {
        var m = a[i], n = new THREE.Vector3();
        n.x = j * m.x - k * m.y, n.y = k * m.x + j * m.y, n.z = m.z, this.vertices.push(n);
    }
    for (c = a.length, g = 0, h = b; h > g; g++) for (i = 0, l = a.length - 1; l > i; i++) {
        b = k = i + c * g, d = k + c;
        var j = k + 1 + c, k = k + 1, m = g * f, n = i * e, o = m + f, p = n + e;
        this.faces.push(new THREE.Face3(b, d, k)), this.faceVertexUvs[0].push([ new THREE.Vector2(m, n), new THREE.Vector2(o, n), new THREE.Vector2(m, p) ]), 
        this.faces.push(new THREE.Face3(d, j, k)), this.faceVertexUvs[0].push([ new THREE.Vector2(o, n), new THREE.Vector2(o, p), new THREE.Vector2(m, p) ]);
    }
    this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry, 
THREE.PlaneGeometry = function(a, b, c, d) {
    console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint."), 
    THREE.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    }, this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d));
}, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry, 
THREE.PlaneBufferGeometry = function(a, b, c, d) {
    THREE.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    };
    var e = a / 2, f = b / 2;
    c = c || 1, d = d || 1;
    var g = c + 1, h = d + 1, i = a / c, j = b / d;
    b = new Float32Array(g * h * 3), a = new Float32Array(g * h * 3);
    for (var k = new Float32Array(g * h * 2), l = 0, m = 0, n = 0; h > n; n++) for (var o = n * j - f, p = 0; g > p; p++) b[l] = p * i - e, 
    b[l + 1] = -o, a[l + 2] = 1, k[m] = p / c, k[m + 1] = 1 - n / d, l += 3, m += 2;
    for (l = 0, e = new (65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6), 
    n = 0; d > n; n++) for (p = 0; c > p; p++) f = p + g * (n + 1), h = p + 1 + g * (n + 1), 
    i = p + 1 + g * n, e[l] = p + g * n, e[l + 1] = f, e[l + 2] = i, e[l + 3] = f, e[l + 4] = h, 
    e[l + 5] = i, l += 6;
    this.addAttribute("index", new THREE.BufferAttribute(e, 1)), this.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    this.addAttribute("normal", new THREE.BufferAttribute(a, 3)), this.addAttribute("uv", new THREE.BufferAttribute(k, 2));
}, THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry, THREE.RingGeometry = function(a, b, c, d, e, f) {
    THREE.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
        innerRadius: a,
        outerRadius: b,
        thetaSegments: c,
        phiSegments: d,
        thetaStart: e,
        thetaLength: f
    }, a = a || 0, b = b || 50, e = void 0 !== e ? e : 0, f = void 0 !== f ? f : 2 * Math.PI, 
    c = void 0 !== c ? Math.max(3, c) : 8, d = void 0 !== d ? Math.max(1, d) : 8;
    var g, h = [], i = a, j = (b - a) / d;
    for (a = 0; d + 1 > a; a++) {
        for (g = 0; c + 1 > g; g++) {
            var k = new THREE.Vector3(), l = e + g / c * f;
            k.x = i * Math.cos(l), k.y = i * Math.sin(l), this.vertices.push(k), h.push(new THREE.Vector2((k.x / b + 1) / 2, (k.y / b + 1) / 2));
        }
        i += j;
    }
    for (b = new THREE.Vector3(0, 0, 1), a = 0; d > a; a++) for (e = a * (c + 1), g = 0; c > g; g++) f = l = g + e, 
    j = l + c + 1, k = l + c + 2, this.faces.push(new THREE.Face3(f, j, k, [ b.clone(), b.clone(), b.clone() ])), 
    this.faceVertexUvs[0].push([ h[f].clone(), h[j].clone(), h[k].clone() ]), f = l, 
    j = l + c + 2, k = l + 1, this.faces.push(new THREE.Face3(f, j, k, [ b.clone(), b.clone(), b.clone() ])), 
    this.faceVertexUvs[0].push([ h[f].clone(), h[j].clone(), h[k].clone() ]);
    this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), i);
}, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry.prototype.constructor = THREE.RingGeometry, 
THREE.SphereGeometry = function(a, b, c, d, e, f, g) {
    THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
        radius: a,
        widthSegments: b,
        heightSegments: c,
        phiStart: d,
        phiLength: e,
        thetaStart: f,
        thetaLength: g
    }, a = a || 50, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), 
    d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, 
    g = void 0 !== g ? g : Math.PI;
    var h, i, j = [], k = [];
    for (i = 0; c >= i; i++) {
        var l = [], m = [];
        for (h = 0; b >= h; h++) {
            var n = h / b, o = i / c, p = new THREE.Vector3();
            p.x = -a * Math.cos(d + n * e) * Math.sin(f + o * g), p.y = a * Math.cos(f + o * g), 
            p.z = a * Math.sin(d + n * e) * Math.sin(f + o * g), this.vertices.push(p), l.push(this.vertices.length - 1), 
            m.push(new THREE.Vector2(n, 1 - o));
        }
        j.push(l), k.push(m);
    }
    for (i = 0; c > i; i++) for (h = 0; b > h; h++) {
        d = j[i][h + 1], e = j[i][h], f = j[i + 1][h], g = j[i + 1][h + 1];
        var l = this.vertices[d].clone().normalize(), m = this.vertices[e].clone().normalize(), n = this.vertices[f].clone().normalize(), o = this.vertices[g].clone().normalize(), p = k[i][h + 1].clone(), q = k[i][h].clone(), r = k[i + 1][h].clone(), s = k[i + 1][h + 1].clone();
        Math.abs(this.vertices[d].y) === a ? (p.x = (p.x + q.x) / 2, this.faces.push(new THREE.Face3(d, f, g, [ l, n, o ])), 
        this.faceVertexUvs[0].push([ p, r, s ])) : Math.abs(this.vertices[f].y) === a ? (r.x = (r.x + s.x) / 2, 
        this.faces.push(new THREE.Face3(d, e, f, [ l, m, n ])), this.faceVertexUvs[0].push([ p, q, r ])) : (this.faces.push(new THREE.Face3(d, e, g, [ l, m, o ])), 
        this.faceVertexUvs[0].push([ p, q, s ]), this.faces.push(new THREE.Face3(e, f, g, [ m.clone(), n, o.clone() ])), 
        this.faceVertexUvs[0].push([ q.clone(), r, s.clone() ]));
    }
    this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
}, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry, 
THREE.TextGeometry = function(a, b) {
    b = b || {};
    var c = THREE.FontUtils.generateShapes(a, b);
    b.amount = void 0 !== b.height ? b.height : 50, void 0 === b.bevelThickness && (b.bevelThickness = 10), 
    void 0 === b.bevelSize && (b.bevelSize = 8), void 0 === b.bevelEnabled && (b.bevelEnabled = !1), 
    THREE.ExtrudeGeometry.call(this, c, b), this.type = "TextGeometry";
}, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), 
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry, THREE.TorusGeometry = function(a, b, c, d, e) {
    THREE.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        arc: e
    }, a = a || 100, b = b || 40, c = c || 8, d = d || 6, e = e || 2 * Math.PI;
    for (var f = new THREE.Vector3(), g = [], h = [], i = 0; c >= i; i++) for (var j = 0; d >= j; j++) {
        var k = j / d * e, l = i / c * Math.PI * 2;
        f.x = a * Math.cos(k), f.y = a * Math.sin(k);
        var m = new THREE.Vector3();
        m.x = (a + b * Math.cos(l)) * Math.cos(k), m.y = (a + b * Math.cos(l)) * Math.sin(k), 
        m.z = b * Math.sin(l), this.vertices.push(m), g.push(new THREE.Vector2(j / d, i / c)), 
        h.push(m.clone().sub(f).normalize());
    }
    for (i = 1; c >= i; i++) for (j = 1; d >= j; j++) a = (d + 1) * i + j - 1, b = (d + 1) * (i - 1) + j - 1, 
    e = (d + 1) * (i - 1) + j, f = (d + 1) * i + j, k = new THREE.Face3(a, b, f, [ h[a].clone(), h[b].clone(), h[f].clone() ]), 
    this.faces.push(k), this.faceVertexUvs[0].push([ g[a].clone(), g[b].clone(), g[f].clone() ]), 
    k = new THREE.Face3(b, e, f, [ h[b].clone(), h[e].clone(), h[f].clone() ]), this.faces.push(k), 
    this.faceVertexUvs[0].push([ g[b].clone(), g[e].clone(), g[f].clone() ]);
    this.computeFaceNormals();
}, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry, 
THREE.TorusKnotGeometry = function(a, b, c, d, e, f, g) {
    function h(a, b, c, d, e) {
        var f = Math.cos(a), g = Math.sin(a);
        return a *= b / c, b = Math.cos(a), f *= d * (2 + b) * .5, g = d * (2 + b) * g * .5, 
        d = e * d * Math.sin(a) * .5, new THREE.Vector3(f, g, d);
    }
    THREE.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        p: e,
        q: f,
        heightScale: g
    }, a = a || 100, b = b || 40, c = c || 64, d = d || 8, e = e || 2, f = f || 3, g = g || 1;
    for (var i = Array(c), j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3(), m = 0; c > m; ++m) {
        i[m] = Array(d);
        var n = m / c * 2 * e * Math.PI, o = h(n, f, e, a, g), n = h(n + .01, f, e, a, g);
        for (j.subVectors(n, o), k.addVectors(n, o), l.crossVectors(j, k), k.crossVectors(l, j), 
        l.normalize(), k.normalize(), n = 0; d > n; ++n) {
            var p = n / d * 2 * Math.PI, q = -b * Math.cos(p), p = b * Math.sin(p), r = new THREE.Vector3();
            r.x = o.x + q * k.x + p * l.x, r.y = o.y + q * k.y + p * l.y, r.z = o.z + q * k.z + p * l.z, 
            i[m][n] = this.vertices.push(r) - 1;
        }
    }
    for (m = 0; c > m; ++m) for (n = 0; d > n; ++n) e = (m + 1) % c, f = (n + 1) % d, 
    a = i[m][n], b = i[e][n], e = i[e][f], f = i[m][f], g = new THREE.Vector2(m / c, n / d), 
    j = new THREE.Vector2((m + 1) / c, n / d), k = new THREE.Vector2((m + 1) / c, (n + 1) / d), 
    l = new THREE.Vector2(m / c, (n + 1) / d), this.faces.push(new THREE.Face3(a, b, f)), 
    this.faceVertexUvs[0].push([ g, j, l ]), this.faces.push(new THREE.Face3(b, e, f)), 
    this.faceVertexUvs[0].push([ j.clone(), k, l.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry, THREE.TubeGeometry = function(a, b, c, d, e, f) {
    THREE.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
        path: a,
        segments: b,
        radius: c,
        radialSegments: d,
        closed: e
    }, b = b || 64, c = c || 1, d = d || 8, e = e || !1, f = f || THREE.TubeGeometry.NoTaper;
    var g, h, i, j, k, l, m, n, o, p, q = [], r = b + 1, s = new THREE.Vector3();
    for (n = new THREE.TubeGeometry.FrenetFrames(a, b, e), o = n.normals, p = n.binormals, 
    this.tangents = n.tangents, this.normals = o, this.binormals = p, n = 0; r > n; n++) for (q[n] = [], 
    i = n / (r - 1), m = a.getPointAt(i), g = o[n], h = p[n], k = c * f(i), i = 0; d > i; i++) j = i / d * 2 * Math.PI, 
    l = -k * Math.cos(j), j = k * Math.sin(j), s.copy(m), s.x += l * g.x + j * h.x, 
    s.y += l * g.y + j * h.y, s.z += l * g.z + j * h.z, q[n][i] = this.vertices.push(new THREE.Vector3(s.x, s.y, s.z)) - 1;
    for (n = 0; b > n; n++) for (i = 0; d > i; i++) f = e ? (n + 1) % b : n + 1, r = (i + 1) % d, 
    a = q[n][i], c = q[f][i], f = q[f][r], r = q[n][r], s = new THREE.Vector2(n / b, i / d), 
    o = new THREE.Vector2((n + 1) / b, i / d), p = new THREE.Vector2((n + 1) / b, (i + 1) / d), 
    g = new THREE.Vector2(n / b, (i + 1) / d), this.faces.push(new THREE.Face3(a, c, r)), 
    this.faceVertexUvs[0].push([ s, o, g ]), this.faces.push(new THREE.Face3(c, f, r)), 
    this.faceVertexUvs[0].push([ o.clone(), p, g.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry, 
THREE.TubeGeometry.NoTaper = function() {
    return 1;
}, THREE.TubeGeometry.SinusoidalTaper = function(a) {
    return Math.sin(Math.PI * a);
}, THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
    new THREE.Vector3();
    var d = new THREE.Vector3();
    new THREE.Vector3();
    var e = [], f = [], g = [], h = new THREE.Vector3(), i = new THREE.Matrix4();
    b += 1;
    var j, k, l;
    for (this.tangents = e, this.normals = f, this.binormals = g, j = 0; b > j; j++) k = j / (b - 1), 
    e[j] = a.getTangentAt(k), e[j].normalize();
    for (f[0] = new THREE.Vector3(), g[0] = new THREE.Vector3(), a = Number.MAX_VALUE, 
    j = Math.abs(e[0].x), k = Math.abs(e[0].y), l = Math.abs(e[0].z), a >= j && (a = j, 
    d.set(1, 0, 0)), a >= k && (a = k, d.set(0, 1, 0)), a >= l && d.set(0, 0, 1), h.crossVectors(e[0], d).normalize(), 
    f[0].crossVectors(e[0], h), g[0].crossVectors(e[0], f[0]), j = 1; b > j; j++) f[j] = f[j - 1].clone(), 
    g[j] = g[j - 1].clone(), h.crossVectors(e[j - 1], e[j]), 1e-4 < h.length() && (h.normalize(), 
    d = Math.acos(THREE.Math.clamp(e[j - 1].dot(e[j]), -1, 1)), f[j].applyMatrix4(i.makeRotationAxis(h, d))), 
    g[j].crossVectors(e[j], f[j]);
    if (c) for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 
    0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), j = 1; b > j; j++) f[j].applyMatrix4(i.makeRotationAxis(e[j], d * j)), 
    g[j].crossVectors(e[j], f[j]);
}, THREE.PolyhedronGeometry = function(a, b, c, d) {
    function e(a) {
        var b = a.normalize().clone();
        b.index = i.vertices.push(b) - 1;
        var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
        return a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5, b.uv = new THREE.Vector2(c, 1 - a), 
        b;
    }
    function f(a, b, c) {
        var d = new THREE.Face3(a.index, b.index, c.index, [ a.clone(), b.clone(), c.clone() ]);
        i.faces.push(d), q.copy(a).add(b).add(c).divideScalar(3), d = Math.atan2(q.z, -q.x), 
        i.faceVertexUvs[0].push([ h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d) ]);
    }
    function g(a, b) {
        var c = Math.pow(2, b);
        Math.pow(4, b);
        for (var d = e(i.vertices[a.a]), g = e(i.vertices[a.b]), h = e(i.vertices[a.c]), j = [], k = 0; c >= k; k++) {
            j[k] = [];
            for (var l = e(d.clone().lerp(h, k / c)), m = e(g.clone().lerp(h, k / c)), n = c - k, o = 0; n >= o; o++) j[k][o] = 0 == o && k == c ? l : e(l.clone().lerp(m, o / n));
        }
        for (k = 0; c > k; k++) for (o = 0; 2 * (c - k) - 1 > o; o++) d = Math.floor(o / 2), 
        0 == o % 2 ? f(j[k][d + 1], j[k + 1][d], j[k][d]) : f(j[k][d + 1], j[k + 1][d + 1], j[k + 1][d]);
    }
    function h(a, b, c) {
        return 0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y)), 0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y)), 
        a.clone();
    }
    THREE.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
        vertices: a,
        indices: b,
        radius: c,
        detail: d
    }, c = c || 1, d = d || 0;
    for (var i = this, j = 0, k = a.length; k > j; j += 3) e(new THREE.Vector3(a[j], a[j + 1], a[j + 2]));
    a = this.vertices;
    for (var l = [], m = j = 0, k = b.length; k > j; j += 3, m++) {
        var n = a[b[j]], o = a[b[j + 1]], p = a[b[j + 2]];
        l[m] = new THREE.Face3(n.index, o.index, p.index, [ n.clone(), o.clone(), p.clone() ]);
    }
    for (var q = new THREE.Vector3(), j = 0, k = l.length; k > j; j++) g(l[j], d);
    for (j = 0, k = this.faceVertexUvs[0].length; k > j; j++) b = this.faceVertexUvs[0][j], 
    d = b[0].x, a = b[1].x, l = b[2].x, m = Math.max(d, Math.max(a, l)), n = Math.min(d, Math.min(a, l)), 
    m > .9 && .1 > n && (.2 > d && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > l && (b[2].x += 1));
    for (j = 0, k = this.vertices.length; k > j; j++) this.vertices[j].multiplyScalar(c);
    this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);
}, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry, THREE.DodecahedronGeometry = function(a, b) {
    this.parameters = {
        radius: a,
        detail: b
    };
    var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
    THREE.PolyhedronGeometry.call(this, [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d ], [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ], a, b);
}, THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry, THREE.IcosahedronGeometry = function(a, b) {
    var c = (1 + Math.sqrt(5)) / 2;
    THREE.PolyhedronGeometry.call(this, [ -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1 ], [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ], a, b), 
    this.type = "IcosahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry, THREE.OctahedronGeometry = function(a, b) {
    this.parameters = {
        radius: a,
        detail: b
    }, THREE.PolyhedronGeometry.call(this, [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ], a, b), 
    this.type = "OctahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry, THREE.TetrahedronGeometry = function(a, b) {
    THREE.PolyhedronGeometry.call(this, [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ], a, b), 
    this.type = "TetrahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry, THREE.ParametricGeometry = function(a, b, c) {
    THREE.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
        func: a,
        slices: b,
        stacks: c
    };
    var d, e, f, g, h = this.vertices, i = this.faces, j = this.faceVertexUvs[0], k = b + 1;
    for (d = 0; c >= d; d++) for (g = d / c, e = 0; b >= e; e++) f = e / b, f = a(f, g), 
    h.push(f);
    var l, m, n, o;
    for (d = 0; c > d; d++) for (e = 0; b > e; e++) a = d * k + e, h = d * k + e + 1, 
    g = (d + 1) * k + e + 1, f = (d + 1) * k + e, l = new THREE.Vector2(e / b, d / c), 
    m = new THREE.Vector2((e + 1) / b, d / c), n = new THREE.Vector2((e + 1) / b, (d + 1) / c), 
    o = new THREE.Vector2(e / b, (d + 1) / c), i.push(new THREE.Face3(a, h, f)), j.push([ l, m, o ]), 
    i.push(new THREE.Face3(h, g, f)), j.push([ m.clone(), n, o.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry, THREE.AxisHelper = function(a) {
    a = a || 1;
    var b = new Float32Array([ 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a ]), c = new Float32Array([ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ]);
    a = new THREE.BufferGeometry(), a.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    a.addAttribute("color", new THREE.BufferAttribute(c, 3)), b = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    }), THREE.Line.call(this, a, b, THREE.LinePieces);
}, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.AxisHelper.prototype.constructor = THREE.AxisHelper, 
THREE.ArrowHelper = function() {
    var a = new THREE.Geometry();
    a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
    var b = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
    return b.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0)), function(c, d, e, f, g, h) {
        THREE.Object3D.call(this), void 0 === f && (f = 16776960), void 0 === e && (e = 1), 
        void 0 === g && (g = .2 * e), void 0 === h && (h = .2 * g), this.position.copy(d), 
        this.line = new THREE.Line(a, new THREE.LineBasicMaterial({
            color: f
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({
            color: f
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(c), 
        this.setLength(e, g, h);
    };
}(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper, 
THREE.ArrowHelper.prototype.setDirection = function() {
    var a, b = new THREE.Vector3();
    return function(c) {
        .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), 
        a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a));
    };
}(), THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, a - b, 1), 
    this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, 
    this.cone.updateMatrix();
}, THREE.ArrowHelper.prototype.setColor = function(a) {
    this.line.material.color.set(a), this.cone.material.color.set(a);
}, THREE.BoxHelper = function(a) {
    var b = new THREE.BufferGeometry();
    b.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3)), 
    THREE.Line.call(this, b, new THREE.LineBasicMaterial({
        color: 16776960
    }), THREE.LinePieces), void 0 !== a && this.update(a);
}, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.constructor = THREE.BoxHelper, 
THREE.BoxHelper.prototype.update = function(a) {
    var b = a.geometry;
    null === b.boundingBox && b.computeBoundingBox();
    var c = b.boundingBox.min, b = b.boundingBox.max, d = this.geometry.attributes.position.array;
    d[0] = b.x, d[1] = b.y, d[2] = b.z, d[3] = c.x, d[4] = b.y, d[5] = b.z, d[6] = c.x, 
    d[7] = b.y, d[8] = b.z, d[9] = c.x, d[10] = c.y, d[11] = b.z, d[12] = c.x, d[13] = c.y, 
    d[14] = b.z, d[15] = b.x, d[16] = c.y, d[17] = b.z, d[18] = b.x, d[19] = c.y, d[20] = b.z, 
    d[21] = b.x, d[22] = b.y, d[23] = b.z, d[24] = b.x, d[25] = b.y, d[26] = c.z, d[27] = c.x, 
    d[28] = b.y, d[29] = c.z, d[30] = c.x, d[31] = b.y, d[32] = c.z, d[33] = c.x, d[34] = c.y, 
    d[35] = c.z, d[36] = c.x, d[37] = c.y, d[38] = c.z, d[39] = b.x, d[40] = c.y, d[41] = c.z, 
    d[42] = b.x, d[43] = c.y, d[44] = c.z, d[45] = b.x, d[46] = b.y, d[47] = c.z, d[48] = b.x, 
    d[49] = b.y, d[50] = b.z, d[51] = b.x, d[52] = b.y, d[53] = c.z, d[54] = c.x, d[55] = b.y, 
    d[56] = b.z, d[57] = c.x, d[58] = b.y, d[59] = c.z, d[60] = c.x, d[61] = c.y, d[62] = b.z, 
    d[63] = c.x, d[64] = c.y, d[65] = c.z, d[66] = b.x, d[67] = c.y, d[68] = b.z, d[69] = b.x, 
    d[70] = c.y, d[71] = c.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), 
    this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.BoundingBoxHelper = function(a, b) {
    var c = void 0 !== b ? b : 8947848;
    this.object = a, this.box = new THREE.Box3(), THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: c,
        wireframe: !0
    }));
}, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper, 
THREE.BoundingBoxHelper.prototype.update = function() {
    this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position);
}, THREE.CameraHelper = function(a) {
    function b(a, b, d) {
        c(a, d), c(b, d);
    }
    function c(a, b) {
        d.vertices.push(new THREE.Vector3()), d.colors.push(new THREE.Color(b)), void 0 === f[a] && (f[a] = []), 
        f[a].push(d.vertices.length - 1);
    }
    var d = new THREE.Geometry(), e = new THREE.LineBasicMaterial({
        color: 16777215,
        vertexColors: THREE.FaceColors
    }), f = {};
    b("n1", "n2", 16755200), b("n2", "n4", 16755200), b("n4", "n3", 16755200), b("n3", "n1", 16755200), 
    b("f1", "f2", 16755200), b("f2", "f4", 16755200), b("f4", "f3", 16755200), b("f3", "f1", 16755200), 
    b("n1", "f1", 16755200), b("n2", "f2", 16755200), b("n3", "f3", 16755200), b("n4", "f4", 16755200), 
    b("p", "n1", 16711680), b("p", "n2", 16711680), b("p", "n3", 16711680), b("p", "n4", 16711680), 
    b("u1", "u2", 43775), b("u2", "u3", 43775), b("u3", "u1", 43775), b("c", "t", 16777215), 
    b("p", "c", 3355443), b("cn1", "cn2", 3355443), b("cn3", "cn4", 3355443), b("cf1", "cf2", 3355443), 
    b("cf3", "cf4", 3355443), THREE.Line.call(this, d, e, THREE.LinePieces), this.camera = a, 
    this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = f, this.update();
}, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.constructor = THREE.CameraHelper, 
THREE.CameraHelper.prototype.update = function() {
    var a, b, c = new THREE.Vector3(), d = new THREE.Camera(), e = function(e, f, g, h) {
        if (c.set(f, g, h).unproject(d), e = b[e], void 0 !== e) for (f = 0, g = e.length; g > f; f++) a.vertices[e[f]].copy(c);
    };
    return function() {
        a = this.geometry, b = this.pointMap, d.projectionMatrix.copy(this.camera.projectionMatrix), 
        e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), 
        e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), 
        e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), 
        e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), 
        e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), a.verticesNeedUpdate = !0;
    };
}(), THREE.DirectionalLightHelper = function(a, b) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, b = b || 1;
    var c = new THREE.Geometry();
    c.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));
    var d = new THREE.LineBasicMaterial({
        fog: !1
    });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(c, d), 
    this.add(this.lightPlane), c = new THREE.Geometry(), c.vertices.push(new THREE.Vector3(), new THREE.Vector3()), 
    d = new THREE.LineBasicMaterial({
        fog: !1
    }), d.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(c, d), 
    this.add(this.targetLine), this.update();
}, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), 
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper, 
THREE.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), 
    this.targetLine.material.dispose();
}, THREE.DirectionalLightHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function() {
        a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
        c.subVectors(b, a), this.lightPlane.lookAt(c), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), 
        this.targetLine.geometry.vertices[1].copy(c), this.targetLine.geometry.verticesNeedUpdate = !0, 
        this.targetLine.material.color.copy(this.lightPlane.material.color);
    };
}(), THREE.EdgesHelper = function(a, b) {
    var c = void 0 !== b ? b : 16777215, d = [ 0, 0 ], e = {}, f = function(a, b) {
        return a - b;
    }, g = [ "a", "b", "c" ], h = new THREE.BufferGeometry(), i = a.geometry.clone();
    i.mergeVertices(), i.computeFaceNormals();
    for (var j = i.vertices, i = i.faces, k = 0, l = 0, m = i.length; m > l; l++) for (var n = i[l], o = 0; 3 > o; o++) {
        d[0] = n[g[o]], d[1] = n[g[(o + 1) % 3]], d.sort(f);
        var p = d.toString();
        void 0 === e[p] ? (e[p] = {
            vert1: d[0],
            vert2: d[1],
            face1: l,
            face2: void 0
        }, k++) : e[p].face2 = l;
    }
    d = new Float32Array(6 * k), f = 0;
    for (p in e) g = e[p], (void 0 === g.face2 || .9999 > i[g.face1].normal.dot(i[g.face2].normal)) && (k = j[g.vert1], 
    d[f++] = k.x, d[f++] = k.y, d[f++] = k.z, k = j[g.vert2], d[f++] = k.x, d[f++] = k.y, 
    d[f++] = k.z);
    h.addAttribute("position", new THREE.BufferAttribute(d, 3)), THREE.Line.call(this, h, new THREE.LineBasicMaterial({
        color: c
    }), THREE.LinePieces), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper, 
THREE.FaceNormalsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16776960, 
    d = void 0 !== d ? d : 1, b = new THREE.Geometry(), c = 0;
    for (var e = this.object.geometry.faces.length; e > c; c++) b.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    THREE.Line.call(this, b, new THREE.LineBasicMaterial({
        color: a,
        linewidth: d
    }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3(), 
    this.update();
}, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper, 
THREE.FaceNormalsHelper.prototype.update = function() {
    var a = this.geometry.vertices, b = this.object, c = b.geometry.vertices, d = b.geometry.faces, e = b.matrixWorld;
    b.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(e);
    for (var f = b = 0, g = d.length; g > b; b++, f += 2) {
        var h = d[b];
        a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e), a[f + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f]);
    }
    return this.geometry.verticesNeedUpdate = !0, this;
}, THREE.GridHelper = function(a, b) {
    var c = new THREE.Geometry(), d = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
    for (var e = -a; a >= e; e += b) {
        c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
        var f = 0 === e ? this.color1 : this.color2;
        c.colors.push(f, f, f, f);
    }
    THREE.Line.call(this, c, d, THREE.LinePieces);
}, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.constructor = THREE.GridHelper, 
THREE.GridHelper.prototype.setColors = function(a, b) {
    this.color1.set(a), this.color2.set(b), this.geometry.colorsNeedUpdate = !0;
}, THREE.HemisphereLightHelper = function(a, b) {
    for (THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), 
    this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [ new THREE.Color(), new THREE.Color() ], 
    a = new THREE.SphereGeometry(b, 4, 2), a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2)), 
    b = 0; 8 > b; b++) a.faces[b].color = this.colors[4 > b ? 0 : 1];
    b = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    }), this.lightSphere = new THREE.Mesh(a, b), this.add(this.lightSphere), this.update();
}, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), 
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper, 
THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose();
}, THREE.HemisphereLightHelper.prototype.update = function() {
    var a = new THREE.Vector3();
    return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), 
        this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()), 
        this.lightSphere.geometry.colorsNeedUpdate = !0;
    };
}(), THREE.PointLightHelper = function(a, b) {
    this.light = a, this.light.updateMatrixWorld();
    var c = new THREE.SphereGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, c, d), 
    this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper, 
THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose();
}, THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
}, THREE.SkeletonHelper = function(a) {
    this.bones = this.getBoneList(a);
    for (var b = new THREE.Geometry(), c = 0; c < this.bones.length; c++) this.bones[c].parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3()), 
    b.vertices.push(new THREE.Vector3()), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)));
    c = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }), THREE.Line.call(this, b, c, THREE.LinePieces), this.root = a, this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, this.update();
}, THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype), THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper, 
THREE.SkeletonHelper.prototype.getBoneList = function(a) {
    var b = [];
    a instanceof THREE.Bone && b.push(a);
    for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
    return b;
}, THREE.SkeletonHelper.prototype.update = function() {
    for (var a = this.geometry, b = new THREE.Matrix4().getInverse(this.root.matrixWorld), c = new THREE.Matrix4(), d = 0, e = 0; e < this.bones.length; e++) {
        var f = this.bones[e];
        f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), 
        c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), 
        d += 2);
    }
    a.verticesNeedUpdate = !0, a.computeBoundingSphere();
}, THREE.SpotLightHelper = function(a) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0), a.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0)), 
    a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    var b = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    this.cone = new THREE.Mesh(a, b), this.add(this.cone), this.update();
}, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper, 
THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
}, THREE.SpotLightHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function() {
        var c = this.light.distance ? this.light.distance : 1e4, d = c * Math.tan(this.light.angle);
        this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
        this.cone.lookAt(b.sub(a)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
}(), THREE.VertexNormalsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, b = void 0 !== c ? c : 16711680, 
    d = void 0 !== d ? d : 1, c = new THREE.Geometry(), a = a.geometry.faces;
    for (var e = 0, f = a.length; f > e; e++) for (var g = 0, h = a[e].vertexNormals.length; h > g; g++) c.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: d
    }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3(), 
    this.update();
}, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper, 
THREE.VertexNormalsHelper.prototype.update = function() {
    var a = new THREE.Vector3();
    return function(b) {
        b = [ "a", "b", "c", "d" ], this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        for (var c = this.geometry.vertices, d = this.object.geometry.vertices, e = this.object.geometry.faces, f = this.object.matrixWorld, g = 0, h = 0, i = e.length; i > h; h++) for (var j = e[h], k = 0, l = j.vertexNormals.length; l > k; k++) {
            var m = j.vertexNormals[k];
            c[g].copy(d[j[b[k]]]).applyMatrix4(f), a.copy(m).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), 
            a.add(c[g]), g += 1, c[g].copy(a), g += 1;
        }
        return this.geometry.verticesNeedUpdate = !0, this;
    };
}(), THREE.VertexTangentsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, b = void 0 !== c ? c : 255, d = void 0 !== d ? d : 1, 
    c = new THREE.Geometry(), a = a.geometry.faces;
    for (var e = 0, f = a.length; f > e; e++) for (var g = 0, h = a[e].vertexTangents.length; h > g; g++) c.vertices.push(new THREE.Vector3()), 
    c.vertices.push(new THREE.Vector3());
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: d
    }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update();
}, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper, 
THREE.VertexTangentsHelper.prototype.update = function() {
    var a = new THREE.Vector3();
    return function(b) {
        b = [ "a", "b", "c", "d" ], this.object.updateMatrixWorld(!0);
        for (var c = this.geometry.vertices, d = this.object.geometry.vertices, e = this.object.geometry.faces, f = this.object.matrixWorld, g = 0, h = 0, i = e.length; i > h; h++) for (var j = e[h], k = 0, l = j.vertexTangents.length; l > k; k++) {
            var m = j.vertexTangents[k];
            c[g].copy(d[j[b[k]]]).applyMatrix4(f), a.copy(m).transformDirection(f).multiplyScalar(this.size), 
            a.add(c[g]), g += 1, c[g].copy(a), g += 1;
        }
        return this.geometry.verticesNeedUpdate = !0, this;
    };
}(), THREE.WireframeHelper = function(a, b) {
    var c = void 0 !== b ? b : 16777215, d = [ 0, 0 ], e = {}, f = function(a, b) {
        return a - b;
    }, g = [ "a", "b", "c" ], h = new THREE.BufferGeometry();
    if (a.geometry instanceof THREE.Geometry) {
        for (var i = a.geometry.vertices, j = a.geometry.faces, k = 0, l = new Uint32Array(6 * j.length), m = 0, n = j.length; n > m; m++) for (var o = j[m], p = 0; 3 > p; p++) {
            d[0] = o[g[p]], d[1] = o[g[(p + 1) % 3]], d.sort(f);
            var q = d.toString();
            void 0 === e[q] && (l[2 * k] = d[0], l[2 * k + 1] = d[1], e[q] = !0, k++);
        }
        for (d = new Float32Array(6 * k), m = 0, n = k; n > m; m++) for (p = 0; 2 > p; p++) k = i[l[2 * m + p]], 
        g = 6 * m + 3 * p, d[g + 0] = k.x, d[g + 1] = k.y, d[g + 2] = k.z;
        h.addAttribute("position", new THREE.BufferAttribute(d, 3));
    } else if (a.geometry instanceof THREE.BufferGeometry) {
        if (void 0 !== a.geometry.attributes.index) {
            i = a.geometry.attributes.position.array, n = a.geometry.attributes.index.array, 
            j = a.geometry.drawcalls, k = 0, 0 === j.length && (j = [ {
                count: n.length,
                index: 0,
                start: 0
            } ]);
            for (var l = new Uint32Array(2 * n.length), o = 0, r = j.length; r > o; ++o) for (var p = j[o].start, q = j[o].count, g = j[o].index, m = p, s = p + q; s > m; m += 3) for (p = 0; 3 > p; p++) d[0] = g + n[m + p], 
            d[1] = g + n[m + (p + 1) % 3], d.sort(f), q = d.toString(), void 0 === e[q] && (l[2 * k] = d[0], 
            l[2 * k + 1] = d[1], e[q] = !0, k++);
            for (d = new Float32Array(6 * k), m = 0, n = k; n > m; m++) for (p = 0; 2 > p; p++) g = 6 * m + 3 * p, 
            k = 3 * l[2 * m + p], d[g + 0] = i[k], d[g + 1] = i[k + 1], d[g + 2] = i[k + 2];
        } else for (i = a.geometry.attributes.position.array, k = i.length / 3, l = k / 3, 
        d = new Float32Array(6 * k), m = 0, n = l; n > m; m++) for (p = 0; 3 > p; p++) g = 18 * m + 6 * p, 
        l = 9 * m + 3 * p, d[g + 0] = i[l], d[g + 1] = i[l + 1], d[g + 2] = i[l + 2], k = 9 * m + (p + 1) % 3 * 3, 
        d[g + 3] = i[k], d[g + 4] = i[k + 1], d[g + 5] = i[k + 2];
        h.addAttribute("position", new THREE.BufferAttribute(d, 3));
    }
    THREE.Line.call(this, h, new THREE.LineBasicMaterial({
        color: c
    }), THREE.LinePieces), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper, 
THREE.ImmediateRenderObject = function() {
    THREE.Object3D.call(this), this.render = function() {};
}, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), 
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject, 
THREE.MorphBlendMesh = function(a, b) {
    THREE.Mesh.call(this, a, b), this.animationsMap = {}, this.animationsList = [];
    var c = this.geometry.morphTargets.length;
    this.createAnimation("__default", 0, c - 1, c / 1), this.setAnimationWeight("__default", 1);
}, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh, 
THREE.MorphBlendMesh.prototype.createAnimation = function(a, b, c, d) {
    b = {
        startFrame: b,
        endFrame: c,
        length: c - b + 1,
        fps: d,
        duration: (c - b) / d,
        lastFrame: 0,
        currentFrame: 0,
        active: !1,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: !1,
        mirroredLoop: !1
    }, this.animationsMap[a] = b, this.animationsList.push(b);
}, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(a) {
    for (var b, c = /([a-z]+)_?(\d+)/, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; g > f; f++) {
        var h = e.morphTargets[f].name.match(c);
        if (h && 1 < h.length) {
            var i = h[1];
            d[i] || (d[i] = {
                start: 1/0,
                end: -1/0
            }), h = d[i], f < h.start && (h.start = f), f > h.end && (h.end = f), b || (b = i);
        }
    }
    for (i in d) h = d[i], this.createAnimation(i, h.start, h.end, a);
    this.firstAnimation = b;
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(a) {
    (a = this.animationsMap[a]) && (a.direction = 1, a.directionBackwards = !1);
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(a) {
    (a = this.animationsMap[a]) && (a.direction = -1, a.directionBackwards = !0);
}, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);
}, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);
}, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.weight = b);
}, THREE.MorphBlendMesh.prototype.setAnimationTime = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.time = b);
}, THREE.MorphBlendMesh.prototype.getAnimationTime = function(a) {
    var b = 0;
    return (a = this.animationsMap[a]) && (b = a.time), b;
}, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(a) {
    var b = -1;
    return (a = this.animationsMap[a]) && (b = a.duration), b;
}, THREE.MorphBlendMesh.prototype.playAnimation = function(a) {
    var b = this.animationsMap[a];
    b ? (b.time = 0, b.active = !0) : console.warn("animation[" + a + "] undefined");
}, THREE.MorphBlendMesh.prototype.stopAnimation = function(a) {
    (a = this.animationsMap[a]) && (a.active = !1);
}, THREE.MorphBlendMesh.prototype.update = function(a) {
    for (var b = 0, c = this.animationsList.length; c > b; b++) {
        var d = this.animationsList[b];
        if (d.active) {
            var e = d.duration / d.length;
            d.time += d.direction * a, d.mirroredLoop ? (d.time > d.duration || 0 > d.time) && (d.direction *= -1, 
            d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, 
            d.directionBackwards = !1)) : (d.time %= d.duration, 0 > d.time && (d.time += d.duration));
            var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
            f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, 
            this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f), 
            e = d.time % e / e, d.directionBackwards && (e = 1 - e), this.morphTargetInfluences[d.currentFrame] = e * g, 
            this.morphTargetInfluences[d.lastFrame] = (1 - e) * g;
        }
    }
};

var Animyst = {};

Animyst.LOGGING = !0, Animyst.DEBUG = !0, Animyst.Application = function() {
    this._appStateList = [], this._appStateLib = {}, this._stats = null, this._startParams = null, 
    this.appScope = new Animyst.AppScope(), this.initSignal = new signals.Signal(), 
    this.config = null;
}, Animyst.Application.prototype.startup = function(a) {
    Animyst.LOG.output("==================================================="), Animyst.LOG.output("   ----- AnimystJS: (v 0.0.0) by ~Saykrd -----   "), 
    Animyst.LOG.output("==================================================="), this._startParams = a, 
    Animyst.DataLoad.startup({}), Animyst.DataLoad.loadAsset({
        id: "config",
        src: "config.json"
    }, this._load.bind(this));
}, Animyst.Application.prototype._load = function(a, b) {
    if (a == Animyst.DataLoad.FILE_LOADED) switch (b.item.id) {
      case "config":
        Animyst.LOG.output("[Application] Config json loaded"), this.config = Animyst.DataLoad.getAsset("config"), 
        this.appScope.config = this.config, Animyst.DataLoad.loadFromManifest([ {
            id: "assets",
            src: this.config.assets
        }, {
            id: "strings",
            src: this.config.strings
        } ]);
        break;

      case "assets":
        Animyst.LOG.output("[Application] Assets json loaded");
        var c = Animyst.DataLoad.getAsset("assets");
        Animyst.DataLoad.listAssets(c.manifest), Animyst.LOG.output(Animyst.DataLoad._assetList), 
        c.initialLoad && Animyst.DataLoad.loadFromManifest(c.initialLoad);
        break;

      case "strings":
        Animyst.LOG.output("[Application] Strings json loaded");
    } else a == Animyst.DataLoad.LOAD_COMPLETE && this._init();
}, Animyst.Application.prototype._init = function() {
    this._startParams;
    Animyst.LOGGING = this.config.settings.logging || !1, Animyst.DEBUG = this.config.settings.debug || !1, 
    paper.install(window), Animyst.LOG.output("[Application] Application Started"), 
    this.config.settings.debug && window.Stats && (this._stats = new Stats(), this._stats.domElement.style.position = "absolute", 
    this._stats.domElement.style.left = "0px", this._stats.domElement.style.top = "0px", 
    document.body.appendChild(this._stats.domElement), Animyst.LOG.output("[Application] Stats Enabled"));
    var a = new Animyst.CoreProcess(Animyst.CoreProcess.ID);
    this.run(a), view ? view.onFrame = this.update.bind(this) : this._initFrame(), this.initSignal.dispatch();
}, Animyst.Application.prototype.run = function(a) {
    this._appStateLib[a.id] || (this._appStateLib[a.id] = a, this._appStateList.push(a), 
    a.setScope(this.appScope), a.setup(), a.start());
}, Animyst.Application.prototype.halt = function() {
    this._appStateLib[appState.id] || this._appStateLib[appState.id].pause();
}, Animyst.Application.prototype.resume = function() {
    this._appStateLib[appState.id] || this._appStateLib[appState.id].resume();
}, Animyst.Application.prototype.end = function() {
    if (!this._appStateLib[a.id]) {
        var a = this._appStateLib[a.id];
        a.kill(), this._appStateLib[a.id] = null;
        for (var b = 0; b < this._appStateList.length; b++) {
            var c = this._appStateList[b];
            if (c.id == a.id) {
                this._appStateList.splice(b, 1);
                break;
            }
        }
    }
}, Animyst.Application.prototype.endAll = function() {
    for (var a in this._appStateLib) this.end(a);
}, Animyst.Application.prototype.update = function(a) {
    this._stats && this._stats.begin();
    for (var b = 0; b < this._appStateList.length; b++) {
        var c = this._appStateList[b];
        c.update(a.delta, a.time);
    }
    this._stats && this._stats.end();
}, Animyst.Application.prototype._initFrame = function() {
    requestAnimationFrame(this._initFrame.bind(this)), this.update();
}, Animyst.AppScope = function() {
    this.databases = {}, this.config = null;
}, Animyst.AppScope.prototype = {}, Animyst.AppScope.prototype.addDatabase = function(a, b) {
    this.databases[a] = b;
}, Animyst.AppScope.prototype.getDatabase = function(a) {
    return this.databases[a];
}, Animyst.AppState = function(a) {
    this.id = a, this._systemList = [], this._systemLib = {}, this.active = !1, this.paused = !1, 
    this.appScope = null;
}, Animyst.AppState.prototype.setScope = function(a) {
    this.appScope = a;
}, Animyst.AppState.prototype.clearScope = function() {
    this.appScope = null;
}, Animyst.AppState.prototype.setup = function() {}, Animyst.AppState.prototype.start = function() {
    this.active = !0;
}, Animyst.AppState.prototype.stop = function() {
    this.active = !1;
    for (var a = 0; a < this._systemList.length; a++) {
        var b = this._systemList[a];
        b.shutdown();
    }
}, Animyst.AppState.prototype.update = function(a) {
    if (this.active && !this.paused) for (var b = 0; b < this._systemList.length; b++) {
        var c = this._systemList[b];
        c.started && !c.paused && c.update(a);
    }
}, Animyst.AppState.prototype.pause = function() {
    this.paused = !0;
}, Animyst.AppState.prototype.resume = function() {
    this.paused = !1;
}, Animyst.AppState.prototype.kill = function() {
    this.stop(), this.clearScope(), this._systemList = null, this._systemLib = null;
}, Animyst.AppState.prototype.restart = function() {}, Animyst.AppState.prototype.addSystem = function(a, b) {
    this._systemList[a] || (this._systemLib[a] = b, this._systemList.push(b));
}, Animyst.AppState.prototype.getSystem = function(a) {
    return this._systemList[a] ? void console.error("[AppState] !! No system found with ID: " + a) : this._systemLib[a];
}, Animyst.Database = function() {
    this.signal = new signals.Signal();
}, Animyst.Database.prototype.clear = function() {}, Animyst.Database.prototype.destroy = function() {}, 
Animyst.DataLoad = {}, Animyst.DataLoad._assetList = {}, Animyst.DataLoad._weakHandlers = [], 
Animyst.DataLoad._loadQueue = null, Animyst.DataLoad._loadSignal = null, Animyst.DataLoad._fileStartedSignal = null, 
Animyst.DataLoad._fileProgressSignal = null, Animyst.DataLoad._fileLoadedSignal = null, 
Animyst.DataLoad._fileErrorSignal = null, Animyst.DataLoad._queueStartedSignal = null, 
Animyst.DataLoad._queueProgressSignal = null, Animyst.DataLoad._queueLoadedSignal = null, 
Animyst.DataLoad._queueErrorSignal = null, Animyst.DataLoad._busy = !1, Animyst.DataLoad.LOAD_INITIALIZE = 0, 
Animyst.DataLoad.LOAD_STARTED = 1, Animyst.DataLoad.LOAD_PROGRESS = 2, Animyst.DataLoad.LOAD_COMPLETE = 3, 
Animyst.DataLoad.LOAD_ERROR = 4, Animyst.DataLoad.FILE_STARTED = 5, Animyst.DataLoad.FILE_PROGRESS = 6, 
Animyst.DataLoad.FILE_LOADED = 7, Animyst.DataLoad.FILE_ERROR = 8, Animyst.DataLoad.startup = function(a) {
    Animyst.DataLoad._loadQueue = new createjs.LoadQueue(!0), Animyst.DataLoad._loadSignal = new signals.Signal();
    var b = Animyst.DataLoad._loadQueue;
    b.on("fileload", Animyst.DataLoad.handleFileLoaded), b.on("complete", Animyst.DataLoad.handleLoadComplete), 
    b.on("fileerror", Animyst.DataLoad.handleFileError), b.on("error", Animyst.DataLoad.handleLoaderError), 
    b.on("filestart", Animyst.DataLoad.handleFileStart), b.on("initialize", Animyst.DataLoad.handleLoadInitialize), 
    b.on("loadstart", Animyst.DataLoad.handleLoadStart), b.on("fileprogress", Animyst.DataLoad.handleFileProgress), 
    b.on("progress", Animyst.DataLoad.handleOverallProgress), Animyst.DataLoad._fileStartedSignal = new signals.Signal(), 
    Animyst.DataLoad._fileProgressSignal = new signals.Signal(), Animyst.DataLoad._fileLoadedSignal = new signals.Signal(), 
    Animyst.DataLoad._fileErrorSignal = new signals.Signal(), Animyst.DataLoad._queueStartedSignal = new signals.Signal(), 
    Animyst.DataLoad._queueProgressSignal = new signals.Signal(), Animyst.DataLoad._queueLoadedSignal = new signals.Signal(), 
    Animyst.DataLoad._queueErrorSignal = new signals.Signal(), null != a.manifest;
}, Animyst.DataLoad.listAssets = function(a) {
    for (var b = Animyst.DataLoad._assetList, c = 0; c < a.length; c++) {
        var d = a[c];
        b[d.id] = d;
    }
}, Animyst.DataLoad.loadFromManifest = function(a, b, c) {
    for (var d = Animyst.DataLoad._loadQueue, e = [], f = 0; f < a.length; f++) {
        var g, h = a[f];
        g = "string" == typeof h ? {
            id: h,
            src: h
        } : {
            id: h.id,
            src: h.src
        }, Animyst.DataLoad._assetList[g.id] || (Animyst.DataLoad._assetList[g.id] = g), 
        e.push(Animyst.DataLoad._assetList[g.id]);
    }
    Animyst.DataLoad.addLoadHandler(b, c), Animyst.DataLoad._busy = !0, d.loadManifest(e);
}, Animyst.DataLoad.loadAsset = function(a, b, c) {
    var d, e = Animyst.DataLoad._loadQueue;
    d = "string" == typeof a ? {
        id: a,
        src: a
    } : {
        id: a.id,
        src: a.src
    }, Animyst.DataLoad._assetList[d.id] || (Animyst.DataLoad._assetList[d.id] = d), 
    Animyst.DataLoad.addLoadHandler(b, c), Animyst.DataLoad._busy = !0, e.loadFile(Animyst.DataLoad._assetList[d.id]);
}, Animyst.DataLoad.getAsset = function(a) {
    return Animyst.DataLoad._loadQueue.getResult(a);
}, Animyst.DataLoad.getData = function(a) {
    return Animyst.DataLoad._assetList[a];
}, Animyst.DataLoad.addLoadHandler = function(a, b) {
    a && (b || Animyst.DataLoad._weakHandlers.push(a), Animyst.DataLoad._loadSignal.add(a));
}, Animyst.DataLoad.removeLoadHandler = function(a) {
    for (var b = Animyst.DataLoad._weakHandlers.length - 1; b >= 0 && Animyst.DataLoad._weakHandlers.length > 0; b--) {
        var c = Animyst.DataLoad._weakHandlers[b];
        if (c == a) {
            Animyst.DataLoad._weakHandlers.splice(b, 1);
            break;
        }
    }
    Animyst.DataLoad._loadSignal.remove(a);
}, Animyst.DataLoad.removeWeakHandlers = function(a) {
    for (Animyst.DataLoad._loadSignal; a.length > 0; ) {
        var b = a.shift();
        Animyst.DataLoad.removeLoadHandler(b);
    }
}, Animyst.DataLoad.addCommand = function(a, b, c) {
    var d;
    switch (a) {
      case Animyst.DataLoad.LOAD_STARTED:
        d = Animyst.DataLoad._queueStartedSignal;
        break;

      case Animyst.DataLoad.FILE_STARTED:
        d = Animyst.DataLoad._fileStartedSignal;
        break;

      case Animyst.DataLoad.LOAD_PROGRESS:
        d = Animyst.DataLoad._queueProgressSignal;
        break;

      case Animyst.DataLoad.FILE_PROGRESS:
        d = Animyst.DataLoad._loadProgressSignal;
        break;

      case Animyst.DataLoad.LOAD_COMPLETE:
        d = Animyst.DataLoad._queueLoadedSignal;
        break;

      case Animyst.DataLoad.FILE_LOADED:
        d = Animyst.DataLoad._fileLoadedSignal;
        break;

      case Animyst.DataLoad.LOAD_ERROR:
        d = Animyst.DataLoad._queueErrorSignal;
        break;

      case Animyst.DataLoad.FILE_ERROR:
        d = Animyst.DataLoad._fileErrorSignal;
    }
    c ? d.addOnce(b) : d.add(b);
}, Animyst.DataLoad.removeCommand = function(a, b) {
    var c;
    switch (a) {
      case Animyst.DataLoad.LOAD_STARTED:
        c = Animyst.DataLoad._queueStartedSignal;
        break;

      case Animyst.DataLoad.FILE_STARTED:
        c = Animyst.DataLoad._fileStartedSignal;
        break;

      case Animyst.DataLoad.LOAD_PROGRESS:
        c = Animyst.DataLoad._queueProgressSignal;
        break;

      case Animyst.DataLoad.FILE_PROGRESS:
        c = Animyst.DataLoad._loadProgressSignal;
        break;

      case Animyst.DataLoad.LOAD_COMPLETE:
        c = Animyst.DataLoad._queueLoadedSignal;
        break;

      case Animyst.DataLoad.FILE_LOADED:
        c = Animyst.DataLoad._fileLoadedSignal;
        break;

      case Animyst.DataLoad.LOAD_ERROR:
        c = Animyst.DataLoad._queueErrorSignal;
        break;

      case Animyst.DataLoad.FILE_ERROR:
        c = Animyst.DataLoad._fileErrorSignal;
    }
    c.remove(b);
}, Animyst.DataLoad.handleLoadInitialize = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_INITIALIZE, a);
}, Animyst.DataLoad.handleLoadStart = function(a) {
    Animyst.LOG.output("[DataLoad] Load Started!");
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_STARTED, a), Animyst.DataLoad._queueStartedSignal.dispatch(a);
}, Animyst.DataLoad.handleFileStart = function(a) {
    Animyst.LOG.output("[DataLoad] Loading File:", a.item.id, "from:", a.item.src);
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_STARTED, a), Animyst.DataLoad._fileStartedSignal.dispatch(a);
}, Animyst.DataLoad.handleFileLoaded = function(a) {
    Animyst.LOG.output("[DataLoad] File Loaded:", a.item.id, "from:", a.item.src);
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_LOADED, a), Animyst.DataLoad._fileLoadedSignal.dispatch(a);
}, Animyst.DataLoad.handleLoadComplete = function(a) {
    Animyst.LOG.output("[DataLoad] Load Completed!");
    var b = Animyst.DataLoad._loadSignal, c = Animyst.DataLoad._weakHandlers.concat();
    b.dispatch(Animyst.DataLoad.LOAD_COMPLETE, a), Animyst.DataLoad._queueLoadedSignal.dispatch(a), 
    Animyst.DataLoad.removeWeakHandlers(c);
}, Animyst.DataLoad.handleFileProgress = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_PROGRESS, a), Animyst.DataLoad._fileProgressSignal.dispatch(a);
}, Animyst.DataLoad.handleOverallProgress = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_PROGRESS, a), Animyst.DataLoad._queueProgressSignal.dispatch(a);
}, Animyst.DataLoad.handleFileError = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.FILE_ERROR, a), Animyst.DataLoad._fileErrorSignal.dispatch(a);
}, Animyst.DataLoad.handleLoaderError = function(a) {
    var b = Animyst.DataLoad._loadSignal;
    b.dispatch(Animyst.DataLoad.LOAD_ERROR, a), Animyst.DataLoad._queueErrorSignal.dispatch(a);
}, Animyst.Entity = function(a, b, c, d) {
    Animyst.Entity.instances = (Animyst.Entity.instances || 0) + 1, this.id = a || "instance" + Animyst.Entity.instances, 
    this.type = b || EntityType.ENEMY, this["class"] = c, this.position = d || new Point(), 
    this.hitBox = null, this.mVector = new Point();
}, Animyst.Entity.prototype.update = function() {
    this.position = this.position.add(this.mVector), this.render();
}, Animyst.Entity.prototype.setHitBox = function() {
    this.hitBox = hitBox;
}, Animyst.EntityType = {
    PLAYER: 0,
    ENEMY: 1,
    PROJECTILE: 2
}, Animyst.EntityClass = {
    GENERIC: 0
}, Animyst.LOG = {}, Animyst.LOG.output = function() {
    if (Animyst.LOGGING) {
        var a = [];
        a.push("::[LOG]::");
        for (var b = 0; b < arguments.length; b++) a.push(arguments[b]);
        console.log.apply(console, a);
    }
}, Animyst.System = function() {
    this.paused = !1, this.started = !1, this.startupParams = null;
}, Animyst.System.prototype.startup = function(a) {
    this.started = !0, this.startupParams = a;
}, Animyst.System.prototype.shutdown = function() {
    this.started = !1;
}, Animyst.System.prototype.update = function() {}, Animyst.Window = {}, Animyst.Window.resizeSignal = new signals.Signal(), 
Animyst.Window.width = 0, Animyst.Window.height = 0, Animyst.Window._onResize = function(a) {
    Animyst.LOG.output("[Window] onResize!"), Animyst.Window.width = document.body.clientWidth, 
    Animyst.Window.height = document.body.clientHeight, Animyst.Window.resizeSignal.dispatch(a);
}, Animyst.Window._onWindowLoad = function() {
    Animyst.LOG.output("[Window] Window loaded:", "w:", Animyst.Window.width, "h:", Animyst.Window.height), 
    Animyst.Window.width = document.body.clientWidth, Animyst.Window.height = document.body.clientHeight;
}, Animyst.Window._setup = function() {
    window.addEventListener("resize", Animyst.Window._onResize), window.addEventListener("load", Animyst.Window._onWindowLoad);
}, Animyst.Window._setup(), Animyst.Sound = function() {}, Animyst.Sound.prototype = Object.create(Animyst.System.prototype), 
Animyst.Sound.prototype.startup = function(a) {
    Animyst.DataLoad.loadAsset("music", function(a) {
        if (a == Animyst.DataLoad.FILE_LOADED) {
            var b = new Howl({
                urls: [ Animyst.DataLoad.getData("music").src ]
            });
            b.play();
        }
    }), Animyst.System.prototype.startup.call(this, a);
}, Animyst.Sound.prototype.shutdown = function() {
    Animyst.System.prototype.shutdown.call(this);
}, Animyst.Sound.prototype.update = function() {}, Animyst.Graphics = {}, Animyst.Graphics.initialize = function() {
    console.log("[Graphics] Initalizing..."), Animyst.Graphics.PLAYER = new Shape.Rectangle(new Point(), new Size(50, 50)), 
    Animyst.Graphics.PLAYER.strokeColor = "#FF0011", Animyst.Graphics.PLAYER.visible = !1, 
    Animyst.Graphics.ENEMY = new Shape.Circle(new Point(), 50), Animyst.Graphics.ENEMY.strokeColor = "00FF11", 
    Animyst.Graphics.ENEMY.visible = !1;
}, Animyst.Graphics.getGraphic = function(a, b) {
    b = null == b ? !0 : b;
    var c = Animyst.Graphics.hasOwnProperty(a) ? Animyst.Graphics[a] : null;
    return c ? (c.visible = b, c) : null;
}, Animyst.PaperDisplay = function() {
    Animyst.Database.call(this), this.canvas = null, this.layers = [];
}, Animyst.PaperDisplay.prototype = Object.create(Animyst.PaperDisplay.prototype), 
Animyst.PaperDisplay.prototype.clear = function() {
    Animyst.Database.prototype.clear.call(this);
}, Animyst.PaperDisplay.prototype.destroy = function() {
    Animyst.Database.prototype.destroy.call(this);
}, Animyst.PaperDisplay.prototype.addLayer = function() {
    var a = new Layer({
        position: new Point()
    });
    this.layers.push(a);
}, Animyst.PaperDisplay.prototype.getLayer = function(a) {
    return this.layers[a];
}, Animyst.PaperDisplay.prototype.activateLayer = function(a) {
    this.layers[a].activate();
}, Animyst.PaperEngine = function(a) {
    Animyst.System.call(this), this.canvasSettings = null, this.paperDisplay = a;
}, Animyst.PaperEngine.prototype = Object.create(Animyst.System.prototype), Animyst.PaperEngine.prototype.startup = function(a) {
    this.canvasSettings = a.canvasSettings;
    var b = document.createElement("canvas");
    b.id = this.canvasSettings.id, document.body.appendChild(b), this.paperDisplay.canvas = b, 
    this.scaleCanvas(), paper.setup(b), Animyst.Window.resizeSignal.add(this.scaleCanvas.bind(this)), 
    this.paperDisplay.addLayer(), this.paperDisplay.addLayer(), this.paperDisplay.addLayer(), 
    this.paperDisplay.addLayer(), this.paperDisplay.addLayer(), this.paperDisplay.activateLayer(1), 
    Animyst.System.prototype.startup.call(this, a);
}, Animyst.PaperEngine.prototype.shutdown = function() {
    Animyst.System.prototype.shutdown.call(this);
}, Animyst.PaperEngine.prototype.update = function(a, b) {
    Animyst.System.prototype.update.call(this, a, b);
}, Animyst.PaperEngine.prototype.scaleCanvas = function() {
    Animyst.LOG.output("[PaperEngine] Rescale Canvas!");
    var a, b, c, d;
    c = document.body.clientWidth, d = document.body.clientHeight, "noBorder" == this.canvasSettings.scaleMode ? (a = c > this.canvasSettings.minWidth ? c : this.canvasSettings.minWidth, 
    b = d > this.canvasSettings.minHeight ? d : this.canvasSettings.minHeight) : (a = this.canvasSettings.minWidth || 0, 
    b = this.canvasSettings.minHeight || 0), this.paperDisplay.canvas.width = a, this.paperDisplay.canvas.height = b;
}, Animyst.Input = function(a) {
    Animyst.System.call(this), this.inputData = a;
}, Animyst.Input.KEY_DOWN = 0, Animyst.Input.KEY_UP = 1, Animyst.Input.TOUCH_START = 0, 
Animyst.Input.TOUCH_MOVE = 1, Animyst.Input.TOUCH_RELEASE = 2, Animyst.Input.TOUCH_ENTER = 3, 
Animyst.Input.TOUCH_LEAVE = 4, Animyst.Input.MOUSE_DOWN = 5, Animyst.Input.MOUSE_UP = 6, 
Animyst.Input.MOUSE_DRAG = 7, Animyst.Input.MOUSE_MOVE = 8, Animyst.Input.MOUSE_ENTER = 9, 
Animyst.Input.MOUSE_LEAVE = 10, Animyst.Input.MOUSE_CLICK = 11, Animyst.Input.prototype = Object.create(Animyst.System.prototype), 
Animyst.Input.prototype.startup = function(a) {
    var b = a.element, c = a.tool;
    c && (c.onKeyUp = this.onKeyUp.bind(this), c.onKeyDown = this.onKeyDown.bind(this), 
    c.onMouseDown = this.onMouseDown.bind(this), c.onMouseUp = this.onMouseUp.bind(this), 
    c.onMouseDrag = this.onMouseDrag.bind(this), c.onMouseMove = this.onMouseMove.bind(this)), 
    b && (b.addEventListener("touchstart", this.onTouchStart.bind(this)), b.addEventListener("touchmove", this.onTouchMove.bind(this)), 
    b.addEventListener("touchend", this.onTouchRelease.bind(this)), b.addEventListener("touchenter", this.onTouchEnter.bind(this)), 
    b.addEventListener("touchleave", this.onTouchLeave.bind(this))), Animyst.System.prototype.startup.call(this, a);
}, Animyst.Input.prototype.shutdown = function() {
    this.inputData = null, Animyst.System.prototype.shutdown.call(this);
}, Animyst.Input.prototype.update = function(a) {
    this.inputData.onTick(a);
}, Animyst.Input.prototype.onTouchStart = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Start!"), this.handleTouchInput(Animyst.Input.TOUCH_START, a);
}, Animyst.Input.prototype.onTouchMove = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Move!"), this.handleTouchInput(Animyst.Input.TOUCH_MOVE, a);
}, Animyst.Input.prototype.onTouchRelease = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Release!"), this.handleTouchInput(Animyst.Input.TOUCH_RELEASE, a);
}, Animyst.Input.prototype.onTouchEnter = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Enter!"), this.handleTouchInput(Animyst.Input.TOUCH_ENTER, a);
}, Animyst.Input.prototype.onTouchLeave = function(a) {
    Animyst.LOGGING && console.log("[Input] Touch Leave!"), this.handleTouchInput(Animyst.Input.TOUCH_LEAVE, a);
}, Animyst.Input.prototype.onClick = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Click!"), this.handleMouseInput(Animyst.Input.MOUSE_CLICK, a);
}, Animyst.Input.prototype.onMouseDown = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Down!"), this.handleMouseInput(Animyst.Input.MOUSE_DOWN, a);
}, Animyst.Input.prototype.onMouseDrag = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Drag!"), this.handleMouseInput(Animyst.Input.MOUSE_DRAG, a);
}, Animyst.Input.prototype.onMouseMove = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Move!"), this.handleMouseInput(Animyst.Input.MOUSE_MOVE, a);
}, Animyst.Input.prototype.onMouseUp = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Up!"), this.handleMouseInput(Animyst.Input.MOUSE_UP, a);
}, Animyst.Input.prototype.onMouseEnter = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Enter!"), this.handleMouseInput(Animyst.Input.MOUSE_ENTER, a);
}, Animyst.Input.prototype.onMouseLeave = function(a) {
    Animyst.LOGGING && console.log("[Input] Mouse Leave!"), this.handleMouseInput(Animyst.Input.MOUSE_LEAVE, a);
}, Animyst.Input.prototype.onKeyUp = function(a) {
    Animyst.LOGGING && console.log("[Animyst.Input] Released Key:", a.key), a.preventDefault(), 
    this.handleKeyInput(Animyst.Input.KEY_UP, a);
}, Animyst.Input.prototype.onKeyDown = function(a) {
    Animyst.LOGGING && console.log("[Animyst.Input] Pressed Key:", a.key), a.preventDefault(), 
    this.handleKeyInput(Animyst.Input.KEY_DOWN, a);
}, Animyst.Input.prototype.handleMouseInput = function(a, b) {
    var c;
    (a == Animyst.Input.MOUSE_DOWN || a == Animyst.Input.MOUSE_DRAG) && (c = !0), (a == Animyst.Input.MOUSE_UP || a == Animyst.Input.MOUSE_LEAVE) && (c = !1), 
    this.inputData.setMouseInput(b, c);
}, Animyst.Input.prototype.handleKeyInput = function(a, b) {
    this.inputData.setKeyInput(b.key, a == Animyst.Input.KEY_DOWN);
}, Animyst.Input.prototype.handleTouchInput = function(a, b) {
    switch (a) {
      case Animyst.Input.TOUCH_START:
        this.inputData.addTouches(b.changedTouches);
        break;

      case Animyst.Input.TOUCH_MOVE:
        break;

      case Animyst.Input.TOUCH_RELEASE:
        this.inputData.removeTouches(b.touches);
        break;

      case Animyst.Input.TOUCH_ENTER:
        break;

      case Animyst.Input.TOUCH_LEAVE:    }
    this.inputData.updateTouches(b.changedTouches);
}, Animyst.InputData = function() {
    Animyst.Database.call(this), this.map = {}, this.touches = [], this.touchHistory = [], 
    this.mouse = {}, this.mouseHistory = [], this.totalTouchCount = 0, this.time = 0;
}, Animyst.InputData.TOUCH_HISTORY_LIMIT = 12, Animyst.InputData.TOUCH_PROPERTIES = [ "identifier", "screenX", "screenY", "clientX", "clientY", "pageX", "pageY", "radiusX", "radiusY", "rotationAngle", "force", "webkitForce", "target" ], 
Animyst.InputData.MOUSE_PROPERTIES = [ "clientX", "clientY", "screenX", "screenY", "type", "point", "lastPoint", "downPoint", "middlePoint", "count", "item", "modifiers" ], 
Animyst.InputData.MOUSE = 0, Animyst.InputData.TOUCH = 1, Animyst.InputData.KEY = 2, 
Animyst.InputData.TOUCH_ADDED = 0, Animyst.InputData.TOUCH_REMOVED = 1, Animyst.InputData.TOUCH_UPDATED = 2, 
Animyst.InputData.MOUSE_DOWN = 0, Animyst.InputData.MOUSE_UP = 1, Animyst.InputData.MOUSE_MOVE = 2, 
Animyst.InputData.KEY_ACTIVE = 0, Animyst.InputData.KEY_INACTIVE = 1, Animyst.InputData.prototype = Object.create(Animyst.Database.prototype), 
Animyst.InputData.prototype.clear = function() {
    this.map = {}, this.touches = [], this.touchHistory = [], this.totalTouchCount = 0, 
    Animyst.Database.prototype.clear.call(this);
}, Animyst.InputData.prototype.destroy = function() {
    this.map = null, this.touches = null, this.touchHistory = null, this.totalTouchCount = 0, 
    Animyst.Database.prototype.destroy.call(this);
}, Animyst.InputData.prototype.onTick = function(a) {
    this.time += a, this.mouse.down && (this.mouse.clickTime += a);
    for (var b in this.map) {
        var c = this.map[b];
        c.active && (c.time = (c.time || 0) + a);
    }
    for (var d = 0; d < this.touches.length; d++) {
        var e = this.touches[d];
        e.time += a;
    }
}, Animyst.InputData.prototype.isKeyDown = function(a) {
    return this.map[a] && this.map[a].active ? !0 : !1;
}, Animyst.InputData.prototype.setKeyInput = function(a, b) {
    var c, d = this.map[a] || {};
    b && !d.active && (d.time = 0, c = Animyst.InputData.KEY_ACTIVE), !b && d.active && (d.lastInput = {}, 
    d.lastInput.endTime = this.time, d.lastInput.duration = d.time, d.lastInput.startTime = this.time - d.time, 
    d.time = 0, c = Animyst.InputData.KEY_INACTIVE), d.active = b === !0, this.map[a] || (this.map[a] = d), 
    c && this.signal.dispatch(Animyst.InputData.KEY, c, d);
}, Animyst.InputData.prototype.setMouseInput = function(a, b) {
    this.touches.length > 0 && b && (b = !1), "boolean" != typeof b && (b = this.mouse.down);
    for (var c = this.mouse.down && !b ? this.mouse.lastClick || {} : null, d = !this.mouse.down && b ? {} : null, e = Animyst.InputData.MOUSE_MOVE, f = 0; f < Animyst.InputData.MOUSE_PROPERTIES.length; f++) {
        var g = Animyst.InputData.MOUSE_PROPERTIES[f];
        a[g] && (this.mouse[g] = a[g], c && (c[g] = a[g]), d && (d[g] = a[g]));
    }
    d && (Animyst.LOGGING && console.log("[InputData] Click Start!"), this.mouse.clickStart = d, 
    this.mouse.clickTime = 0, e = Animyst.InputData.MOUSE_DOWN), c && (Animyst.LOGGING && console.log("[InputData] Click Ended!", this.mouse.clickTime), 
    c.clickStart = this.mouse.clickStart, c.clickTime = this.mouse.clickTime, this.mouse.clickStart = null, 
    this.mouse.lastClick = c, e = Animyst.InputData.MOUSE_UP), this.mouse.down = b, 
    this.signal.dispatch(Animyst.InputData.MOUSE, e, this.mouse);
}, Animyst.InputData.prototype.getTouches = function() {
    return this.touches.splice();
}, Animyst.InputData.prototype.addTouches = function(a) {
    for (var b = 0; b < a.length; b++) {
        for (var c = a[b], d = !0, e = 0; e < this.touches.length; e++) if (this.touches[e].identifier == c.identifier) {
            d = !1;
            break;
        }
        if (d) {
            for (var f = {}, g = {}, e = 0; e < Animyst.InputData.TOUCH_PROPERTIES.length; e++) {
                var h = Animyst.InputData.TOUCH_PROPERTIES[e];
                f[h] = "object" != typeof c[h] || "target" == h ? c[h] : null, g[h] = "object" != typeof c[h] ? c[h] : null;
            }
            f.time = 0, f.timestamp = this.time, f.startData = g, f.uid = f.identifier + "" + this.totalTouchCount, 
            this.touches.push(f), this.totalTouchCount++, Animyst.LOGGING && console.log("[InputData] Adding Touch:", f.uid), 
            this.signal.dispatch(Animyst.InputData.TOUCH, Animyst.InputData.TOUCH_ADDED, f);
        }
    }
}, Animyst.InputData.prototype.removeTouches = function(a) {
    for (var b = this.touches.length - 1; b > -1 && this.touches.length > 0; b--) {
        for (var c = this.touches[b], d = !0, e = 0; e < a.length; e++) if (a[e].identifier == c.identifier) {
            d = !1;
            break;
        }
        d && (Animyst.LOGGING && console.log("[InputData] Removing Touch:", c.uid), this.touchHistory.shift(c), 
        this.touches.splice(b, 1), this.touchHistory.length > Animyst.InputData.TOUCH_HISTORY_LIMIT && this.touchHistory.pop(), 
        this.signal.dispatch(Animyst.InputData.TOUCH, Animyst.InputData.TOUCH_REMOVED, c));
    }
}, Animyst.InputData.prototype.updateTouches = function(a) {
    for (var b = 0; b < a.length; b++) {
        for (var c, d = a[b], e = 0; e < this.touches.length; e++) if (this.touches[e].identifier == d.identifier) {
            c = this.touches[e];
            break;
        }
        if (c) {
            for (var e = 0; e < Animyst.InputData.TOUCH_PROPERTIES.length; e++) {
                var f = Animyst.InputData.TOUCH_PROPERTIES[e];
                c[f] = d[f];
            }
            Animyst.LOGGING && console.log("[InputData] Updated Touch:", c.uid, Math.round(c.pageX), Math.round(c.pageY), Math.round(c.screenX), Math.round(c.screenY), c.force || c.webkitForce), 
            this.signal.dispatch(Animyst.InputData.TOUCH, Animyst.InputData.TOUCH_UPDATED, c);
        }
    }
}, Animyst.Physics = {}, Animyst.Physics.addVelocity = function(a, b) {
    a.mVector = a.mVector.add(b);
}, Animyst.Physics.applyFriction = function(a, b) {
    a.mVector = a.mVector.multiply(b);
}, Animyst.CoreProcess = function(a) {
    Animyst.AppState.call(this, a), this.inputData = null;
}, Animyst.CoreProcess.ID = "core", Animyst.CoreProcess.INPUT = "input", Animyst.CoreProcess.PAPER_DISPLAY = "paperDisplay", 
Animyst.CoreProcess.THREE_DISPLAY = "threeDisplay", Animyst.CoreProcess.PIXI_DISPLAY = "PIXIDisplay", 
Animyst.CoreProcess.prototype = Object.create(Animyst.AppState.prototype), Animyst.CoreProcess.prototype.setup = function() {
    Animyst.LOG.output("[CoreProcess] Core Process Initialize"), Animyst.AppState.prototype.setup.call(this), 
    this.inputData = new Animyst.InputData();
    var a = this.appScope.config, b = new Animyst.Input(this.inputData);
    if (a.settings.canvasSettings) {
        var c = a.settings.canvasSettings;
        switch (c.type) {
          case "paper":
            var d = new Animyst.PaperDisplay(), e = new Animyst.PaperEngine(d);
            e.startup({
                canvasSettings: c
            }), this.addSystem("paperEngine", e), this.appScope.addDatabase(Animyst.CoreProcess.PAPER_DISPLAY, d);
        }
    }
    b.startup({
        tool: new Tool(),
        element: document.getElementById(c.id)
    }), this.addSystem("input", b), this.appScope.addDatabase(Animyst.CoreProcess.INPUT, this.inputData);
}, Animyst.CoreProcess.prototype.start = function() {
    Animyst.LOG.output("[CoreProcess] Start"), Animyst.AppState.prototype.start.call(this);
}, Animyst.CoreProcess.prototype.update = function(a, b) {
    Animyst.AppState.prototype.update.call(this, a, b);
}, Animyst.CoreProcess.prototype.pause = function() {
    Animyst.AppState.prototype.pause.call(this);
}, Animyst.CoreProcess.prototype.resume = function() {
    Animyst.AppState.prototype.resume.call(this);
}, Animyst.CoreProcess.prototype.kill = function() {
    Animyst.AppState.prototype.kill.call(this);
}, Animyst.CoreProcess.prototype.restart = function() {
    Animyst.AppState.prototype.restart.call(this);
};